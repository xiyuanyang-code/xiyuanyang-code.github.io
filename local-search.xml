<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Tools-Tutorial</title>
    <link href="/posts/Tools-Tutorial/"/>
    <url>/posts/Tools-Tutorial/</url>
    
    <content type="html"><![CDATA[<h1 id="Tools-Tutorial-for-Computer-Science"><a href="#Tools-Tutorial-for-Computer-Science" class="headerlink" title="Tools Tutorial for Computer Science"></a>Tools Tutorial for Computer Science</h1><p><a href="https://developerguru.in/full_stack_development.php"><strong>封面出处</strong></a></p><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>In this article, you will learn a set of <strong>methodologies</strong> for using tools in computer science. It will teach you how to quickly get started and master the use of tools through <strong>practical approaches</strong>, while continuously improving your skills through ongoing practice.</p><h2 id="Table-of-contents"><a href="#Table-of-contents" class="headerlink" title="Table of contents"></a>Table of contents</h2><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>程序员之间很流行一句话，<strong>不要重复造轮子</strong>。</p><blockquote><p>造轮子其实是个很值得探讨的话题，有机会日后开一篇聊一聊~</p></blockquote><p>的确，作为轮子的<strong>使用者</strong>，我们不需要过分关注开发者所封装好的具体的实现细节，只需要掌握工具最基本的使用手段，就可以最大化地提升自己的效率。</p><p>然而，在实际的学习过程中时，笔者经常会为<strong>工具的学习</strong>而感到苦恼，比如：</p><ul><li>在<code>Github</code>上淘到一个很有意思的project，想开箱玩一玩，但是止步于<strong>读懂用户手册</strong>。</li><li>Be trapped in 各种讨人厌的配置环境和报错信息中。</li><li>尝试学习一项新技能，但发现这项技能需要许多的<strong>前置技能</strong>，导致迟迟无法获得学习的正向反馈，最后学习的热情被浇灭不了了之。</li><li>学习曲线过于陡峭，导致在使用初期开发效率<strong>不升反降</strong>。</li><li>学会了但总是没有养成经常使用的习惯，导致学了忘忘了学，每次需要一些命令还得很麻烦的问<code>GPT</code>。</li></ul><p>日后，在与其他同学的交流中，发现这样的问题并非个例，而是普遍存在的问题！在下文中，笔者将以<code>git</code>的学习历程为例，手把手搭建工具学习的高效方法论。在博客的最后，笔者将会对方法论作系统性的总结，并对上文提到的5个问题做针对性的解答。</p><h2 id="Basic-Principles"><a href="#Basic-Principles" class="headerlink" title="Basic Principles"></a>Basic Principles</h2><p>用12字概括这一套方法论，就是：</p><p><div style="width: 80%; margin: auto;"><strong style="color: red;    font-size: 30px;    "><b>提高效率，二八法则，基于实践。</b></strong></div></p><ul><li>提高效率：这是<strong>工具使用的目的</strong>。</li><li><strong>二八法则</strong>：这其实还是<strong>提高效率</strong>的另一种表达：花较短的时间学习工具20%的功能，便可以解决80%的问题。</li><li><strong>实践为王</strong>：工具使用的落脚点不是纸上谈兵而是具体落地到项目中去使用。</li></ul><h2 id="Showcasing-Usage-with-Git"><a href="#Showcasing-Usage-with-Git" class="headerlink" title="Showcasing Usage with Git"></a>Showcasing Usage with Git</h2><h3 id="Overall-Perception-of-Basic-information"><a href="#Overall-Perception-of-Basic-information" class="headerlink" title="Overall Perception of Basic information"></a>Overall Perception of Basic information</h3><p><span style="font-size: 14pt;"><strong><font  color="red">感知新内容的基本信息&amp;初步构建较为完整的知识网络</font></strong></span></p><p>学习新技能的第一步，就是<strong>很好的认识他</strong>！</p><p>这一点其实非常重要，而恰恰被网上天花乱坠的保姆级无脑手把手教程所忽略了，就是<strong>这个工具是怎么来的？为什么我们需要这一个工具？ <strong>这涉及到工具的根本属性：</strong>改善工作流，提高生产力</strong>。一切工具的使用都是基于这一点而出发的，换句话说，工具的使用都是为了<strong>解决现实生活中的实际问题</strong>。</p><p>因此，认识工具的第一步就是回答下面三个问题：</p><ul><li>这个工具是什么？用一句话概括展现其本质的属性。</li><li>这个工具是为了解决什么实际问题而存在的？</li><li>这个工具有什么用处？</li></ul><p>新的问题来了，我们该如何高效地获取上面这三个问题的答案？下文笔者将以<code>Git</code>做示范。</p><h4 id="What-is-Git"><a href="#What-is-Git" class="headerlink" title="What is Git?"></a>What is Git?</h4><p>如何迈出我们学习的第一步？那当然是从<strong>网上获取答案</strong>。在这一步，我们需要重点关注<strong><font  color="red">信息渠道来源的权威性和可解释性</font></strong>。下面分别阐述这两点。</p><h5 id="The-authority-of-information"><a href="#The-authority-of-information" class="headerlink" title="The authority of information"></a>The authority of information</h5><p> 我们上网搜索<code>Git</code>，以下三张图展示了不同搜索引擎的搜索结果：</p><p><img src="https://ooo.0x0.ooo/2025/01/11/OE9RXx.png" alt="Google Search"></p><p><img src="https://ooo.0x0.ooo/2025/01/11/OE94xj.png" alt="Bing Search"></p><p><img src="https://ooo.0x0.ooo/2025/01/11/OE9DJp.png" alt="Baidu Search"></p><p>我们发现很多全新的名词，<strong>现在看不懂没有关系</strong>，但至少我们发现了一个网站，<a href="https://git-scm.com/">https://git-scm.com</a> ，这个网站在三个搜索引擎的页面都出现了，足以证明其重要性。</p><blockquote><p>搜索引擎的选择其实也有很多学问，笔者的默认搜索引擎和浏览器是<strong>Bing</strong>浏览器，有时也会用Google浏览器（这个有时候需要一些魔法，个人感觉在日常使用上Bing已经完全足够了）。<strong>非常不建议各位使用百度或者360等软件作为主力搜索引擎去使用</strong>，广告弹窗太多并且推荐系统很垃圾。就像在上面展示的，百度的首个推送竟然是广告，并且也没有像Bing或Google这样的首页摘要供用户快速查询。</p></blockquote><p>打开这个网站，我们发现了新世界。</p><p>这就是<strong>Git</strong>的官方网站，在这里的信息代表着<strong>最新颖最权威</strong>的信息！没有经过任何转述的过程。这也是我们后续学习的<strong>主战场之一</strong>。</p><p><img src="https://ooo.0x0.ooo/2025/01/11/OE9EBY.png" alt="Git"></p><p>细看这个网站，貌似我们能够回答第一个问题了，<strong>这个工具是什么？</strong><code>Git</code>的官网给出了最权威并且也是最准确的解答：</p><blockquote><p>Git is a <a href="https://git-scm.com/about/free-and-open-source">free and open source</a> <strong>distributed version control system</strong> designed to handle everything from small to very large projects with speed and efficiency.</p><p>Git is <a href="https://git-scm.com/doc">easy to learn</a> and has a <a href="https://git-scm.com/about/small-and-fast">tiny footprint with lightning fast performance</a>. It outclasses SCM tools like Subversion, CVS, Perforce, and ClearCase with features like <a href="https://git-scm.com/about/branching-and-merging">cheap local branching</a>, convenient <a href="https://git-scm.com/about/staging-area">staging areas</a>, and <a href="https://git-scm.com/about/distributed">multiple workflows</a>.</p><p>贴心的附上中文翻译，不过学好英语还是很重要的哇！</p><p>Git 是一个<a href="https://git-scm.com/about/free-and-open-source">免费且开源</a>的<strong>分布式版本控制系统</strong>，旨在以速度和效率处理从小型到超大型的各种项目。</p><p>Git <a href="https://git-scm.com/doc">易于学习</a>，并且具有<a href="https://git-scm.com/about/small-and-fast">极小的资源占用和闪电般的性能</a>。它通过诸如<a href="https://git-scm.com/about/branching-and-merging">廉价的本地分支</a>、便捷的<a href="https://git-scm.com/about/staging-area">暂存区域</a>和<a href="https://git-scm.com/about/distributed">多种工作流程</a>等特性，超越了 Subversion、CVS、Perforce 和 ClearCase 等 SCM 工具。</p></blockquote><div class="note note-success">            <p><strong>锦囊妙计①：重视官方网站（权威性）</strong></p>          </div><h5 id="The-interpretability-of-information"><a href="#The-interpretability-of-information" class="headerlink" title="The interpretability of information"></a>The interpretability of information</h5><p>这看着很酷，不是吗？毕竟我们找到了一个“宝藏网站”，也知道了后续我们要在哪里学习。但是，<strong>Git</strong>的官方网站算是世界上写的<strong>最好的官方文档之一了</strong>，实际上很多项目的官方文档并不具备很高的<strong>可读性</strong>。</p><p>比如，下面是C++的官方文档，当时真的是对我幼小的心灵造成了降维打击。像这样的官方文档就会更加注重<strong>全面性和严谨性</strong>，受众群体是准专业开发者而非入门的新手菜鸟。而对于菜鸟来说，这个网站更多应该起到一种<strong>References</strong>的作用。</p><p><img src="https://ooo.0x0.ooo/2025/01/11/OE90Mc.png" alt="C Plus Plus"></p><blockquote><p>程序员最讨厌的四件事：写注释、写文档、别人不写注释、别人不写文档。‌</p></blockquote><p>又比如，其实你并不了解上文的<strong>distributed version control system</strong>到底是啥意思？这其实是因为我们缺乏一种<strong>可读性且直观性的解释</strong>。而<strong>生成式AI模型</strong>可以给我们带来生动形象的解释（信息的可解释性）。顺带的，我们也可以解决我们在最开始问的第二个问题，<strong>这个工具是为了解决什么实际问题而存在的？</strong></p><p>在这里各位不需要为AI工具的使用而发愁，我推荐使用GPT，Claude（这俩需要魔法），国内推荐<strong>DeepSeek，豆包，文心一言，天工AI等</strong>。笔者目前使用<code>GPT+Cursor+DeepSeek</code>的组合。下文的实例都将使用DeepSeek作为示范AI：</p><div class="note note-primary">            <p><strong>ChatBox with DeepSeek</strong></p><p><strong>Me</strong>: 请用通俗的语言解释一下Git是什么</p><hr><p><strong>DeepSeek</strong>: Git 是一个版本控制系统，简单来说，它就像是一个“时光机”，帮你记录和管理文件的变化。</p><p>举个例子：假设你在写一篇文章，每次修改后，Git 都会帮你保存一个“快照”。这样，如果你改错了内容，或者想看看之前的样子，Git 可以轻松帮你找回之前的版本。</p><p>Git 还特别适合多人协作。比如你和朋友一起写代码，Git 可以让你们同时工作，最后再把各自的修改合并到一起，避免混乱。</p><p>总结一下，Git 的主要功能就是：</p><ol><li>记录文件的变化历史。</li><li>方便多人协作。</li><li>随时回退到之前的版本。</li></ol><p>它广泛用于软件开发，但也可以用来管理任何类型的文件。</p><hr><p><strong>Me</strong>: Git在实际应用中会解决什么样的问题？</p><hr><p><strong>DeepSeek</strong>: Git 在实际应用中主要解决以下几类问题：</p><ol><li><p><strong>版本管理</strong></p><ul><li><strong>问题</strong>：在开发过程中，文件会不断修改，可能会遇到改错代码、误删文件，或者想找回之前某个版本的情况。</li><li><strong>Git 的解决方案</strong>：Git 会记录每次文件的变化，你可以随时查看历史版本，甚至回退到之前的某个状态。</li></ul><p><strong>例子</strong>：你写了一段代码，后来改坏了，可以用 Git 轻松找回之前的正确版本。</p></li><li><p><strong>多人协作</strong></p><ul><li><strong>问题</strong>：多人同时修改同一个文件时，容易产生冲突，或者不知道谁改了哪里。</li><li><strong>Git 的解决方案</strong>：Git 允许每个人在自己的分支上工作，最后将修改合并到一起。如果有冲突，Git 会提示你解决。</li></ul><p><strong>例子</strong>：你和同事同时开发一个功能，Git 可以帮助你们合并代码，避免覆盖对方的工作。</p></li><li><p><strong>代码备份</strong></p><ul><li><strong>问题</strong>：代码只存在本地电脑上，如果电脑坏了或文件丢失，工作成果就没了。</li><li><strong>Git 的解决方案</strong>：Git 可以将代码上传到远程仓库（如 GitHub、GitLab），实现备份和共享。</li></ul><p><strong>例子</strong>：你可以把代码推送到 GitHub，这样即使电脑出问题，代码也不会丢失。</p></li><li><p><strong>分支管理</strong></p><ul><li><strong>问题</strong>：在开发新功能或修复 bug 时，直接修改主代码可能会影响正在运行的程序。</li><li><strong>Git 的解决方案</strong>：Git 支持创建分支，你可以在新分支上开发，完成后再合并到主分支。</li></ul><p><strong>例子</strong>：你想开发一个新功能，可以创建一个新分支，完成后测试无误再合并到主分支。</p></li><li><p><strong>追踪改动</strong></p><ul><li><strong>问题</strong>：修改代码后，很难记住具体改了哪些地方，为什么要改。</li><li><strong>Git 的解决方案</strong>：Git 会记录每次改动的具体内容，并且你可以为每次改动添加注释（commit message），方便以后查看。</li></ul><p><strong>例子</strong>：你可以通过 Git 查看某次改动的具体内容，了解为什么修改了某段代码。</p></li><li><p><strong>代码审查</strong></p><ul><li><strong>问题</strong>：多人协作时，如何确保代码质量？</li><li><strong>Git 的解决方案</strong>：通过 Git 的 Pull Request（PR）功能，其他人可以查看你的代码改动并提出建议。</li></ul><p><strong>例子</strong>：你完成一个功能后，发起 PR，同事可以检查代码并提出改进意见。</p></li></ol><p><strong>总结</strong></p><p>Git 主要解决了以下问题：</p><ul><li>版本丢失或混乱。</li><li>多人协作时的冲突。</li><li>代码备份和共享。</li><li>开发新功能时的风险隔离。</li><li>追踪改动和代码审查。</li></ul><p>无论是个人项目还是团队协作，Git 都是提高效率、降低风险的重要工具。</p><hr><p><strong>Me</strong>: Git的官网上解释的是distributed version control system，你能用通俗的语言解释一下吗</p><hr><p><strong>DeepSeek</strong>: 当然可以！Git 官网说它是一个 <strong>“分布式版本控制系统”</strong>，听起来有点复杂，但其实很简单。我们可以拆开来看：</p><ol><li><strong>版本控制系统</strong></li></ol><p>Git 是一个用来管理文件变化的工具。比如你写代码或文档，每次修改后，Git 都会帮你保存一个“快照”。这样，你可以随时查看之前的内容，或者回退到某个历史版本。</p><ol start="2"><li><strong>分布式</strong></li></ol><p>这是 Git 最特别的地方。传统的版本控制系统（比如 SVN）是 <strong>集中式</strong> 的，所有文件的历史版本都存放在一个中央服务器上。如果服务器坏了，大家就没法工作了。</p><p>而 Git 是 <strong>分布式</strong> 的，意思是：</p><ul><li>每个人电脑上都有一个完整的仓库（包括所有文件的历史记录）。</li><li>你不需要依赖中央服务器，可以在本地完成大部分操作（比如查看历史、创建分支、提交改动等）。</li><li>你可以随时和其他人的仓库同步，交换改动。</li></ul><p>举个例子：</p><p>假设你和朋友一起写代码：</p><ol><li>你用 Git 把整个项目（包括所有历史记录）复制到自己的电脑上。</li><li>你在本地修改代码，Git 帮你记录每次改动。</li><li>你朋友也在他的电脑上修改代码，Git 也帮他记录。</li><li>你们各自完成后，可以把改动同步到一起。</li></ol><p>即使没有网络，你也可以在本地工作，等有网了再同步。如果中央服务器坏了，你们每个人的电脑上都有完整的备份，不会丢失数据。</p><p>总结</p><p>“分布式版本控制系统” 就是：</p><ul><li><strong>版本控制</strong>：帮你记录文件的变化历史。</li><li><strong>分布式</strong>：每个人电脑上都有完整的仓库，不依赖中央服务器，更灵活、更安全。</li></ul><p>Git 的这种设计让它特别适合个人开发、团队协作，甚至是开源项目的全球协作（比如 Linux 内核开发）。</p>          </div><p>我在这里问了AI三个问题，<strong>他直接解决了我的所有问题！！！</strong>可谓是强大至极。我不仅知道了Git官网中的“分布式版本控制系统”是什么意思，还知道了Git在日常用途中经常使用在哪些场景中，Git能够解决哪些生活中的实际问题。</p><div class="note note-success">            <p><strong>锦囊妙计②：善用AI工具（可解释性）</strong></p><p>当你束手无策的时候，不妨和AI聊聊天，对于入门级别的工具教程而言，AI已经能够做的比大部分人类教程要好了。</p><div class="note note-danger">            <p>注意，不要产生对<strong>AI</strong>的过度依赖心理！AI的输出并不保证绝对的正确性，尤其是在涉及更深层次问题的时候。因此，<strong>极度不推荐</strong>完全借助AI的力量来学习工具！这往往会带来很严重的隐患，作为一个学习者的身份，你根本无法判断AI生成的内容到底是正确的还是胡说八道。相反，将AI作为工具辅助学习才是最为高效且安全的选择。</p>          </div>          </div><p>至此，以下三个问题的答案，已经如何找到以下三个问题答案的答案，已经被我们找到了：</p><ul><li>这个工具是什么？用一句话概括展现其本质的属性。<ul><li>分布式版本控制系统，记录文件变化历史。</li></ul></li><li>这个工具是为了解决什么实际问题而存在的？<ul><li>管理文件版本，避免丢失，支持多人协作。</li></ul></li><li>这个工具有什么用处？<ul><li>备份代码、回退版本、分支管理、团队协作。</li></ul></li></ul><div class="note note-info">            <p><strong>Period 1:</strong> 学习最基本的框架知识，经典三连问。</p><p><strong>学习时间</strong>：&lt;1h（熟练起来20分钟足矣）</p><p><strong>关键</strong>：</p><ul><li>把握官方网站和一些权威途径（权威性）</li><li>善于使用AI工具（可解释性）</li></ul>          </div><hr><p><strong>施工区勿看！</strong></p><h3 id="Quick-Start-for-a-project"><a href="#Quick-Start-for-a-project" class="headerlink" title="Quick Start for a project"></a>Quick Start for a project</h3><ul><li><p>借助他人使用的轮子的力量</p></li><li><p>借助典型示例快速上手一个project</p></li><li><p><strong>最重要的部分</strong></p><p><span style="font-size: 18pt;"><strong><font  color="red">以实战项目为最好的教材，在实践中学习代码（知识）是怎么实现的</font></strong></span></p></li></ul><h3 id="From-imitating-to-modifying-and-enhancing"><a href="#From-imitating-to-modifying-and-enhancing" class="headerlink" title="From imitating to modifying and enhancing"></a>From imitating to modifying and enhancing</h3><ul><li>在精读完示例project后，可以尝试开始 <strong>模仿</strong></li><li><strong>模仿————修改————优化</strong></li><li>不断地发现问题，解决问题！</li></ul><h3 id="Diving-into-principles"><a href="#Diving-into-principles" class="headerlink" title="Diving into principles"></a>Diving into principles</h3><ul><li>在这个阶段，已经初步具备构建工程的基本能力，但仍需要进一步掌握<strong>底层原理和一些更高级更进阶的用法（自主性和创新性）</strong></li><li>可以在开源网站上学习他人的成果</li><li>尝试阅读官方文件或者一些底层文件</li><li>对底层原理的学习往往是枯燥的，<strong>对于工程实践来说初期永远是实践最重要，对于原理层面起到锦上添花的作用，目的在于为我们后续的个性化创新奠定基础。</strong></li></ul><h3 id="Occasional-Backtracking"><a href="#Occasional-Backtracking" class="headerlink" title="Occasional Backtracking"></a>Occasional Backtracking</h3><ul><li><strong>经典回读</strong>！！！</li><li>1-2-3-4往往是循环的过程，在哪一步都会受挫，理性分析，适当求助，疯狂拷打ChatGPT</li></ul><h3 id="Conclusion-and-Notice"><a href="#Conclusion-and-Notice" class="headerlink" title="Conclusion and Notice"></a>Conclusion and Notice</h3><ul><li>该学习方法不适应于逻辑性比较强的理科</li><li>该学习方法不适用于底层的基础学科</li><li>该学习方法适用于已经存在一定迁移基础的新学科，不适合完全未曾涉猎的学科</li></ul><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p><a href="https://git-scm.com/docs">Git documentation</a></p><p style="text-align: center;">    <span style="font-size: 30pt;">        <strong>            <font  color="red">                做一名终身的学习者            </font>        </strong>    </span></p>]]></content>
    
    
    <categories>
      
      <category>Efficient Tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tutorial</tag>
      
      <tag>Methodologies</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Jotting-References-and-Encapsulation-in-OOP</title>
    <link href="/posts/Jotting-References-and-Encapsulation-in-OOP/"/>
    <url>/posts/Jotting-References-and-Encapsulation-in-OOP/</url>
    
    <content type="html"><![CDATA[<h1 id="Jotting-References-and-Encapsulation-in-OOP"><a href="#Jotting-References-and-Encapsulation-in-OOP" class="headerlink" title="[Jotting] References and Encapsulation in OOP"></a>[Jotting] References and Encapsulation in OOP</h1><h2 id="About-Jotting"><a href="#About-Jotting" class="headerlink" title="About Jotting"></a>About Jotting</h2><div class="note note-primary">            <p>“Jotting” means quickly writing down short notes or ideas. It’s often used for informal, brief records, like reminders or thoughts.</p>          </div><p>在<strong>Jotting</strong>栏目中，我将以<strong>碎片化</strong>的方式记录我在学习过程中遇到的一个个小问题，他们之间具有独立性，各自是一个个小专题，但是<strong>有具有更深层次的共性</strong>。因此，本栏目的初衷就是在<strong>解决这一个个小专题的过程中，尝试提炼其最本质的“第一性原理”</strong>，进而有助于构建在宏观上的知识框架。</p><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>In this blog, we will start with the design of a <strong>vector</strong> class, exploring the implementation details of defining member functions as <strong>const references and non-const references</strong>, as well as their practical applications in <strong>operator overloading</strong>, <strong>setting friend functions</strong>, <strong>constructors</strong>, and more. On a deeper level, this article uses this example to discuss the trade-offs between the <strong>encapsulation philosophy and flexibility</strong> in OOP.</p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>在昨天的C++作业中，笔者做到了一道很经典的面向对象的设计题：<strong>设计向量类并实现对应的功能</strong>。下文贴出题目和已经通过测试样例的代码。</p><blockquote><p><strong>题目：</strong>本关任务：定义一个向量类MyVect，分量为整数，向量维数作为其数据成员，除了实现构造函数、析构函数、拷贝构造函数，还能够 </p><ul><li>重载加法：对应分量相加，假设总是维数相同的两个向量相加 </li><li>重载[]：取相应分量 </li><li>重载输入输出 </li><li>重载&#x3D;、&#x3D;&#x3D;、!&#x3D; </li><li>重载++、–：对所有分量做++和–</li><li>输出向量范数(L2范数) 若将向量赋值给一个double型数，则表示求其范数(L2范数) </li><li>能够知道程序目前存活的向量数 </li><li>输出向量维数</li></ul></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @Author: Xiyuan Yang   xiyuan_yang@outlook.com</span><br><span class="hljs-comment"> * @Date: 2024-11-11 21:10:22</span><br><span class="hljs-comment"> * @LastEditors: Xiyuan Yang   xiyuan_yang@outlook.com</span><br><span class="hljs-comment"> * @LastEditTime: 2024-12-30 14:56:27</span><br><span class="hljs-comment"> * @FilePath: \CODE_for_Vscode\C++_project\testcode_4.cpp</span><br><span class="hljs-comment"> * @Description: </span><br><span class="hljs-comment"> * Do you code and make progress today?</span><br><span class="hljs-comment"> * Copyright (c) 2024 by Xiyuan Yang, All Rights Reserved. </span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyVect</span>&#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> numbers;<br>    <span class="hljs-type">int</span> size;<br>    <span class="hljs-type">int</span> *array;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">MyVect</span>()&#123;<br>            numbers++;<br>        &#125;<br>        <span class="hljs-built_in">MyVect</span>(<span class="hljs-type">int</span> n):<span class="hljs-built_in">size</span>(n)&#123;<br>            array=<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[size];<br>            numbers++;<br>        &#125;<br>        <span class="hljs-built_in">MyVect</span>(<span class="hljs-type">const</span> MyVect&amp; x)&#123;<br>            size=x.size;<br>            array=<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[size];<br>            numbers++;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;<br>                array[i]=x.array[i];<br>            &#125;<br>        &#125;<br>        ~<span class="hljs-built_in">MyVect</span>()&#123;<br>            numbers--;<br>            <span class="hljs-keyword">delete</span>[] array;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getlength</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> size;&#125;<br>        <span class="hljs-function"><span class="hljs-type">int</span>* <span class="hljs-title">getarray</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<span class="hljs-keyword">return</span> array;&#125;<br>        <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">getnorm</span><span class="hljs-params">()</span></span>&#123;<br>            <span class="hljs-type">double</span> sum=<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;<br>                sum+=(array[i])*array[i];<br>            &#125;<br>            sum=<span class="hljs-built_in">sqrt</span>(sum);<br>            <span class="hljs-keyword">return</span> sum;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">getliving</span><span class="hljs-params">()</span></span>;<br>        <span class="hljs-type">int</span> <span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> x)&#123;<span class="hljs-keyword">return</span> array[x];&#125;<br>        MyVect&amp; <span class="hljs-keyword">operator</span>++()&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;<br>                array[i]++;<br>            &#125;<br>            <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>        &#125;<br>        MyVect <span class="hljs-keyword">operator</span>++(<span class="hljs-type">int</span> x)&#123;<br>            MyVect temp=*<span class="hljs-keyword">this</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;<br>                array[i]++;<br>            &#125;<br>            <span class="hljs-keyword">return</span> temp;<br>        &#125;<br>        MyVect <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> MyVect &amp;x);<br>        <span class="hljs-keyword">friend</span> istream&amp; <span class="hljs-keyword">operator</span>&gt;&gt;(istream&amp; is,MyVect&amp; x);<br>        <span class="hljs-keyword">friend</span> ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; os,<span class="hljs-type">const</span> MyVect&amp; x);<br>        <span class="hljs-keyword">friend</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(MyVect&amp;x1,MyVect&amp;x2);<br>        <span class="hljs-keyword">friend</span> MyVect <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> MyVect&amp;x1,<span class="hljs-type">const</span> MyVect&amp;x2);<br>        <span class="hljs-type">double</span> <span class="hljs-keyword">operator</span>-(<span class="hljs-type">double</span> minus)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">getnorm</span>()-minus;<br>        &#125;;<br>&#125;;<br><br><span class="hljs-type">int</span> MyVect::numbers=<span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">MyVect::getliving</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> numbers;<br>&#125;<br><br>istream&amp; <span class="hljs-keyword">operator</span>&gt;&gt;(istream&amp; is,MyVect&amp; x)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;x.size;i++)&#123;<br>        is&gt;&gt;x.array[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> is;<br>&#125;<br><br>ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; os,<span class="hljs-type">const</span> MyVect&amp; x)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;x.size;i++)&#123;<br>        os&lt;&lt;x.array[i];<br>        <span class="hljs-keyword">if</span>(i!=x.size<span class="hljs-number">-1</span>) os&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> os;<br>&#125;<br><br>MyVect <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> MyVect&amp;x1,<span class="hljs-type">const</span> MyVect&amp;x2)&#123;<br>    <span class="hljs-function">MyVect <span class="hljs-title">temp</span><span class="hljs-params">(x<span class="hljs-number">1.</span>size)</span></span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;x<span class="hljs-number">1.</span>size;i++)&#123;<br>        temp.array[i]=x<span class="hljs-number">1.</span>array[i]+x<span class="hljs-number">2.</span>array[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> temp;<br>&#125;<br><br><br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(MyVect&amp;x1,MyVect&amp;x2)&#123;<br>    <span class="hljs-keyword">if</span>(x<span class="hljs-number">1.</span>size!=x<span class="hljs-number">2.</span>size)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;x<span class="hljs-number">1.</span>size;i++)&#123;<br>        <span class="hljs-keyword">if</span>(x<span class="hljs-number">1.</span>array[i]!=x<span class="hljs-number">2.</span>array[i])&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br>MyVect MyVect::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> MyVect &amp;x)&#123;<br>            <span class="hljs-keyword">if</span>((<span class="hljs-keyword">this</span>)==&amp;x)&#123;<br>                <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">delete</span>[] array;<br>            size=x.size;<br>            array=<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[size];<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;<br>                array[i]=x.array[i];<br>            &#125;<br>            <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>        &#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-function">MyVect <span class="hljs-title">v1</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-type">double</span> x;<br>    cin &gt;&gt; v1;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Now v1 is: &quot;</span>&lt;&lt; v1 &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;The length of v1 is &quot;</span> &lt;&lt; v<span class="hljs-number">1.</span><span class="hljs-built_in">getlength</span>() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;The norm of v1 is &quot;</span> &lt;&lt; v<span class="hljs-number">1.</span><span class="hljs-built_in">getnorm</span>() &lt;&lt; endl;<br>    x = v1 - <span class="hljs-number">1.0</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;The norm of v1 minus 1 is &quot;</span> &lt;&lt; x &lt;&lt; endl;<br>    MyVect v2 = v1;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Now v2 is: &quot;</span> &lt;&lt; v2 &lt;&lt; endl;<br>    <span class="hljs-comment">//cout &lt;&lt; &quot;The number of vectors is: &quot; &lt;&lt; v1.getcount() &lt;&lt; endl;</span><br>    cout &lt;&lt; endl;<br>    &#123;<br>        <span class="hljs-function">MyVect <span class="hljs-title">v3</span><span class="hljs-params">(n)</span></span>;<br>        v3= v1 + v2;<br>        cout &lt;&lt; <span class="hljs-string">&quot;The result of v1+v2 is: &quot;</span> &lt;&lt; v3 &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">&quot;The 1st element of v3 is &quot;</span> &lt;&lt; v3[<span class="hljs-number">1</span>] &lt;&lt; endl;<br>        <span class="hljs-comment">//cout &lt;&lt; &quot;The number of vectors is: &quot; &lt;&lt; MyVect::getcount() &lt;&lt; endl;</span><br>    &#125;<br>    cout &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;The number of living vectors is: &quot;</span> &lt;&lt; v<span class="hljs-number">1.</span><span class="hljs-built_in">getliving</span>() &lt;&lt; endl;<br>    <span class="hljs-comment">//cout &lt;&lt; &quot;The number of total vector is: &quot; &lt;&lt; v1.getcount() &lt;&lt; endl;</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;The result of v1++ is: &quot;</span> &lt;&lt; v1++ &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;The result of v1==v2 is &quot;</span> &lt;&lt; (v1==v2) &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;The result of ++v2 is: &quot;</span> &lt;&lt; ++v2 &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;The result of v1==v2 is &quot;</span> &lt;&lt; (v1==v2) &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>具体的实现其实并不麻烦，只是代码的工程量很大。不过，笔者在重载++运算符的时候遇到了一些麻烦。</p><p>回顾**<a href="https://xiyuanyang-code.github.io/posts/Introduction-to-OOP/">笔者之前写的博客</a><strong>，这是</strong>重载++&#x2F;–运算符的方法**：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @Author: Xiyuan Yang   xiyuan_yang@outlook.com</span><br><span class="hljs-comment"> * @Date: 2024-11-11 21:10:21</span><br><span class="hljs-comment"> * @LastEditors: Xiyuan Yang   xiyuan_yang@outlook.com</span><br><span class="hljs-comment"> * @LastEditTime: 2024-12-30 14:04:15</span><br><span class="hljs-comment"> * @FilePath: \CODE_for_Vscode\C++_project\testcode_5.cpp</span><br><span class="hljs-comment"> * @Description: </span><br><span class="hljs-comment"> * Do you code and make progress today?</span><br><span class="hljs-comment"> * Copyright (c) 2024 by Xiyuan Yang, All Rights Reserved. </span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> value;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 构造函数</span><br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">int</span> v) : <span class="hljs-built_in">value</span>(v) &#123;&#125;<br><br>    <span class="hljs-comment">// 前缀 ++ 运算符重载</span><br>    MyClass&amp; <span class="hljs-keyword">operator</span>++() &#123;<br>        ++value;  <span class="hljs-comment">// 增加成员变量 value</span><br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;  <span class="hljs-comment">// 返回当前对象的引用</span><br>    &#125;<br><br>    <span class="hljs-comment">// 前缀 -- 运算符重载</span><br>    MyClass&amp; <span class="hljs-keyword">operator</span>--() &#123;<br>        --value;  <span class="hljs-comment">// 减少成员变量 value</span><br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;  <span class="hljs-comment">// 返回当前对象的引用</span><br>    &#125;<br><br>    <span class="hljs-comment">// 后缀 ++ 运算符重载</span><br>    MyClass <span class="hljs-keyword">operator</span>++(<span class="hljs-type">int</span>) &#123;<br>        MyClass temp = *<span class="hljs-keyword">this</span>;  <span class="hljs-comment">// 保存当前值</span><br>        ++value;  <span class="hljs-comment">// 增加成员变量 value</span><br>        <span class="hljs-keyword">return</span> temp;  <span class="hljs-comment">// 返回原对象</span><br>    &#125;<br><br>    <span class="hljs-comment">// 后缀 -- 运算符重载</span><br>    MyClass <span class="hljs-keyword">operator</span>--(<span class="hljs-type">int</span>) &#123;<br>        MyClass temp = *<span class="hljs-keyword">this</span>;  <span class="hljs-comment">// 保存当前值</span><br>        --value;  <span class="hljs-comment">// 减少成员变量 value</span><br>        <span class="hljs-keyword">return</span> temp;  <span class="hljs-comment">// 返回原对象</span><br>    &#125;<br><br>    <span class="hljs-comment">// 显示值</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Value: &quot;</span> &lt;&lt; value &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">MyClass <span class="hljs-title">obj1</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span>,<span class="hljs-title">obj2</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br>    cout&lt;&lt;<span class="hljs-string">&quot;++ in the front:&quot;</span>&lt;&lt;endl;<br>    (++obj1).<span class="hljs-built_in">display</span>();<br><br>    cout&lt;&lt;<span class="hljs-string">&quot;++ in the back:&quot;</span>&lt;&lt;endl;<br>    (obj2++).<span class="hljs-built_in">display</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">输出：</span><br><span class="hljs-comment">++ in the front:</span><br><span class="hljs-comment">Value: 11</span><br><span class="hljs-comment">++ in the back:</span><br><span class="hljs-comment">Value: 10</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>如果仔细比较<code>++/--</code>运算符的重载过程，我们会发现在函数定义的时候主要有以下几点的不同：</p><ul><li>后缀运算符重载的时候需要<code>(int)</code>作为一个参数列表，方便编译器区分。</li><li>后缀运算符返回的是一个**<code>MyClass</code>对象<strong>，而前缀运算符返回的是对一个</strong><code>MyClass</code>对象的引用**。</li></ul><p>下面我们来重点讨论第二条，即这篇博客的第一个重点内容：<strong>关于对象的引用。</strong></p><h2 id="The-References-of-an-object"><a href="#The-References-of-an-object" class="headerlink" title="The References of an object"></a>The References of an object</h2><p>为什么前缀和后缀运算符的<strong>返回值不相同</strong>？因为编译器实现这两种运算的操作不同。前缀运算是返回自增之后的</p><p>值，需要返回对对象的引用，这是为了支持<strong>链式操作</strong>和<strong>一致性</strong>。例如<code>(++(++obj));</code></p><p>那<strong>后置运算符</strong>呢？在我们重载的后置运算符中，我们先新建一个temp对象来储存原来对象的值，之后对对象做<strong>自增运算</strong>，然后返回temp对象的值，这样就实现了<strong>返回递增前对象的值</strong>。</p><p>所以，在使用<strong>后置自增运算符的过程中</strong>，我们实际上返回的是<strong>临时变量的值</strong>，因此<strong>不可以返回对对象的引用，因为对临时对象的引用会导致悬挂指针等严重的问题</strong>。（临时对象在传完值后就会被销毁，此时在对他进行引用操作是没有意义且极其危险的。）</p><p>如果读者还对这一部分有些疑惑的话，不妨看看下面的代码示例，以下的代码通过<strong>显式定义三种构造函数</strong>来监控临时对象的构造和析构。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @Author: Xiyuan Yang   xiyuan_yang@outlook.com</span><br><span class="hljs-comment"> * @Date: 2024-11-11 21:10:21</span><br><span class="hljs-comment"> * @LastEditors: Xiyuan Yang   xiyuan_yang@outlook.com</span><br><span class="hljs-comment"> * @LastEditTime: 2024-12-30 14:24:24</span><br><span class="hljs-comment"> * @FilePath: \CODE_for_Vscode\C++_project\testcode_5.cpp</span><br><span class="hljs-comment"> * @Description: </span><br><span class="hljs-comment"> * Do you code and make progress today?</span><br><span class="hljs-comment"> * Copyright (c) 2024 by Xiyuan Yang, All Rights Reserved. </span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> value;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 构造函数</span><br>    <span class="hljs-built_in">MyClass</span>()&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;Create a new object with default constructor&quot;</span>&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">int</span> v) : <span class="hljs-built_in">value</span>(v) &#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;Create a new object!&quot;</span>&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">const</span> MyClass&amp; x)&#123;<br>        value=x.value;<br>        cout&lt;&lt;<span class="hljs-string">&quot;Create a new object with copy constructor&quot;</span>&lt;&lt;endl;<br>    &#125;<br>    ~<span class="hljs-built_in">MyClass</span>()&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;The object destroyed&quot;</span>&lt;&lt;endl;<br>    &#125;<br><br>    <span class="hljs-comment">// 前缀 ++ 运算符重载</span><br>    MyClass&amp; <span class="hljs-keyword">operator</span>++() &#123;<br>        ++value;  <span class="hljs-comment">// 增加成员变量 value</span><br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;  <span class="hljs-comment">// 返回当前对象的引用</span><br>    &#125;<br><br>    <span class="hljs-comment">// 前缀 -- 运算符重载</span><br>    MyClass&amp; <span class="hljs-keyword">operator</span>--() &#123;<br>        --value;  <span class="hljs-comment">// 减少成员变量 value</span><br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;  <span class="hljs-comment">// 返回当前对象的引用</span><br>    &#125;<br><br>    <span class="hljs-comment">// 后缀 ++ 运算符重载</span><br>    MyClass <span class="hljs-keyword">operator</span>++(<span class="hljs-type">int</span>) &#123;<br>        MyClass temp = *<span class="hljs-keyword">this</span>;  <span class="hljs-comment">// 保存当前值</span><br>        ++value;  <span class="hljs-comment">// 增加成员变量 value</span><br>        <span class="hljs-keyword">return</span> temp;  <span class="hljs-comment">// 返回原对象</span><br>    &#125;<br><br>    <span class="hljs-comment">// 后缀 -- 运算符重载</span><br>    MyClass <span class="hljs-keyword">operator</span>--(<span class="hljs-type">int</span>) &#123;<br>        MyClass temp = *<span class="hljs-keyword">this</span>;  <span class="hljs-comment">// 保存当前值</span><br>        --value;  <span class="hljs-comment">// 减少成员变量 value</span><br>        <span class="hljs-keyword">return</span> temp;  <span class="hljs-comment">// 返回原对象</span><br>    &#125;<br><br>    <span class="hljs-comment">// 显示值</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Value: &quot;</span> &lt;&lt; value &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">MyClass <span class="hljs-title">obj3</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br>    obj<span class="hljs-number">3.</span><span class="hljs-built_in">display</span>();<br>    (obj3++).<span class="hljs-built_in">display</span>();<br>    ((obj3++)++).<span class="hljs-built_in">display</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">Create a new object!</span><br><span class="hljs-comment">Value: 10</span><br><span class="hljs-comment">Create a new object with copy constructor</span><br><span class="hljs-comment">Value: 10</span><br><span class="hljs-comment">The object destroyed</span><br><span class="hljs-comment">Create a new object with copy constructor</span><br><span class="hljs-comment">Create a new object with copy constructor</span><br><span class="hljs-comment">Value: 11</span><br><span class="hljs-comment">The object destroyed</span><br><span class="hljs-comment">The object destroyed</span><br><span class="hljs-comment">The object destroyed</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h3 id="Facing-the"><a href="#Facing-the" class="headerlink" title="Facing the &lt;&lt; operator"></a>Facing the <code>&lt;&lt;</code> operator</h3><p>因为临时变量对<strong>等待赋值运算符将值拷贝成功后再被销毁</strong>（如果涉及到指针对象，需要重载赋值运算符），因此仅仅在<strong>值</strong>的使用上，上文的代码能够相安无事。（输出结果的正确性也印证了这一点）。不过，只要我们对代码做一些小小的修改，我们就会发现很多有趣的bug（或者说是<strong>冲突</strong>）就出现了。</p><p>做什么修改呢？我们重载<strong>流输出运算符</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">friend</span> ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; os,MyClass&amp; x)&#123;<br>        os&lt;&lt;x.value;<br>        <span class="hljs-keyword">return</span> os;<br>    &#125;<br><span class="hljs-comment">//这是使用非 const引用</span><br></code></pre></td></tr></table></figure><p>接下来我们修改main函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">MyClass <span class="hljs-title">obj3</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br>    obj<span class="hljs-number">3.</span><span class="hljs-built_in">display</span>();<br>    (obj3++).<span class="hljs-built_in">display</span>();<br>    ((obj3++)++).<span class="hljs-built_in">display</span>();<br><br>    cout&lt;&lt;<span class="hljs-string">&quot;Now lets look at the obj4&quot;</span>&lt;&lt;endl;<br>    <span class="hljs-function">MyClass <span class="hljs-title">obj4</span><span class="hljs-params">(<span class="hljs-number">100</span>)</span></span>;<br>    cout&lt;&lt;<span class="hljs-string">&quot;Normal use &quot;</span>&lt;&lt;obj4&lt;&lt;endl;<br>    cout&lt;&lt;<span class="hljs-string">&quot;++ in the front &quot;</span>&lt;&lt;(++obj4)&lt;&lt;endl;<br>    <span class="hljs-comment">//cout&lt;&lt;&quot;++ in the back &quot;&lt;&lt;(obj4++)&lt;&lt;endl;</span><br>    <span class="hljs-comment">//上面这一行先注释掉，之后再讨论</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">Create a new object!</span><br><span class="hljs-comment">Value: 10</span><br><span class="hljs-comment">Create a new object with copy constructor</span><br><span class="hljs-comment">Value: 10</span><br><span class="hljs-comment">The object destroyed</span><br><span class="hljs-comment">Create a new object with copy constructor</span><br><span class="hljs-comment">Create a new object with copy constructor</span><br><span class="hljs-comment">Value: 11</span><br><span class="hljs-comment">The object destroyed</span><br><span class="hljs-comment">The object destroyed</span><br><span class="hljs-comment">Now lets look at the obj4</span><br><span class="hljs-comment">Create a new object!</span><br><span class="hljs-comment">Normal use 100</span><br><span class="hljs-comment">++ in the front 101</span><br><span class="hljs-comment">The object destroyed</span><br><span class="hljs-comment">The object destroyed</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>现在我们可以把<code>cout&lt;&lt;&quot;++ in the back &quot;&lt;&lt;(obj4++)&lt;&lt;endl;</code>这一行代码的注释删掉，<strong>不出意外的话，我们的代码出现了报错</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Bash">testcode_5.cpp:81:35: error: cannot <span class="hljs-built_in">bind</span> non-const lvalue reference of <span class="hljs-built_in">type</span> <span class="hljs-string">&#x27;MyClass&amp;&#x27;</span> to an rvalue of <span class="hljs-built_in">type</span> <span class="hljs-string">&#x27;MyClass&#x27;</span><br>     cout&lt;&lt;<span class="hljs-string">&quot;++ in the back &quot;</span>&lt;&lt;(obj4++)&lt;&lt;<span class="hljs-string">endl;</span><br><span class="hljs-string">                              ~~~~~^~~</span><br><span class="hljs-string">                              </span><br><span class="hljs-string">Translate:无法将类型为 MyClass&amp; 的非 const 左值引用绑定到类型为 MyClass 的右值。</span><br></code></pre></td></tr></table></figure><h3 id="Explanations"><a href="#Explanations" class="headerlink" title="Explanations"></a>Explanations</h3><p>仔细分析一下原因其实很简单：<strong>问题出现在后置++运算符的返回类型上</strong>。因为后置++运算符返回的是一个临时对象的值（<strong>MyClass 的右值</strong>），这与流输出运算符的重载参数列表（<strong>MyClass&amp; 的非 const 左值引用</strong>）不匹配。</p><p>这样就有冲突产生了，我们设计代码的初衷是希望对象能返回他在执行自增操作之前的值，如果我们修改++后置运算符的返回类型，会产生悬挂指针的严重问题：</p><p><img src="/posts/Above-All/ferences-and-Encapsulation-in-OOP/references.png" alt="Dangling pointer"></p><blockquote><p>引用找不到对应的内存地址，无法正常输出。</p></blockquote><p><strong>因此，解决这个问题的唯一途径就是修改流输出运算符的重载函数定义！</strong></p><h3 id="Use-of-const-references"><a href="#Use-of-const-references" class="headerlink" title="Use of const references"></a>Use of const references</h3><p>在这里，我们需要更改流输出运算符的引用类型：<strong>将非const引用更改为const引用</strong>。</p><p>因为<strong>const 引用有一个非常重要的特性</strong>：<strong>const 引用可以绑定右值</strong>。这是 C++ 中的一个重要特性，允许将临时对象（右值）传递给接受 <code>const</code> 引用的函数或参数。</p><p>在更改参数列表后，代码就可以正常的运行了！</p><p><strong>const vs non-const</strong></p><table><thead><tr><th align="left">特性</th><th align="left">const 引用</th><th align="left">非 const 引用</th></tr></thead><tbody><tr><td align="left"><strong>修改权限</strong></td><td align="left">不能修改对象</td><td align="left">可以修改对象</td></tr><tr><td align="left"><strong>绑定规则</strong></td><td align="left">可以绑定左值和右值</td><td align="left">只能绑定左值</td></tr><tr><td align="left"><strong>使用场景</strong></td><td align="left">只读访问，避免拷贝</td><td align="left">需要修改对象</td></tr><tr><td align="left"><strong>安全性</strong></td><td align="left">更安全，避免意外修改</td><td align="left">需要谨慎使用</td></tr><tr><td align="left"><strong>性能</strong></td><td align="left">可以优化右值处理</td><td align="left">无法直接优化右值处理</td></tr></tbody></table><div class="note note-info">            <p>笔者写到这里才发现自己的辅导书上在重载流输出运算符的时候本来就是使用const引用的 🤡💔。所以改了那么久的代码就是因为没有仔细看书。。。吃一堑长一智吧。。。</p>          </div><h2 id="Encapsulation-in-OOP"><a href="#Encapsulation-in-OOP" class="headerlink" title="Encapsulation in OOP"></a>Encapsulation in OOP</h2><p>写完上面的代码，读者的心中冒出了两个有关引用和封装的问题。</p><p><strong>Question1 <strong>回顾上面的代码，成员函数和友元函数可以</strong>直接修改引用类的私有数据成员</strong>，这样做是否有违OOP的<strong>封装</strong>的安全性精神？</p><p>封装的核心思想是<strong>隐藏对象的内部实现细节</strong>，只暴露必要的接口给外部使用。通过封装，可以确保对象的内部状态不会被外部代码随意修改，从而提高代码的安全性和可维护性。</p><p>身为<strong>成员函数</strong>或者<strong>友元函数</strong>，其本身就具有修改本对象的私有成员的权限，但是值得注意的是，这些函数在<strong>非const引用下具有访问甚至修改其他对象的私有成员的权限</strong>。</p><p>这是很危险的事情，因此，我们<strong>再次感受到了const引用的强大优势：在节省效率的同时保证了对象不被修改的安全性。</strong></p><p>因此，Question1 的问题确实是存在的，解决办法也非常的简单，将引用修改为const引用，只在需要修改的时候暴露必要的权限。同时，将修改的操作封装成函数也能一定程度上保证其安全性。</p><p><strong>Question 2</strong> 如果我希望任何外部代码都不能访问一个特地的私有成员（例如密钥），我该如何实现？</p><p><strong>这个问题比较复杂</strong>，具体而言需要使用<strong>嵌套类实现</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> value;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">PrivateValue</span>&#123;<br>        <span class="hljs-keyword">private</span>:<span class="hljs-type">int</span> privatevalue;<br>        <span class="hljs-keyword">public</span>:<br>            <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getprivatevalue</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>&#123;<span class="hljs-keyword">return</span> privatevalue;&#125;<br>            <span class="hljs-built_in">PrivateValue</span>(<span class="hljs-type">int</span> x):<span class="hljs-built_in">privatevalue</span>(x)&#123;&#125;<br>    &#125;;<br>    PrivateValue pri;<br>    <span class="hljs-comment">// 只有特定成员函数可以访问 privatevalue</span><br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">int</span> v, <span class="hljs-type">int</span> pv) : <span class="hljs-built_in">value</span>(v),<span class="hljs-built_in">pri</span>(pv)&#123;&#125;<br><br>    <span class="hljs-comment">// 公共接口</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getValue</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> pri.<span class="hljs-built_in">getprivatevalue</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>在这里，方法<code>int getprivatevalue() const&#123;return privatevalue;&#125;</code>成为了获得密钥的唯一途径，哪怕是成员函数，也不可以直接调用<code>pri.privatevalue</code>。</p><p><img src="/posts/Above-All/ferences-and-Encapsulation-in-OOP/safety.png" alt="safety"></p><div class="note note-primary">            <p><strong>封装和安全性</strong>是OOP中非常重要的一个精神，在实现公用接口的同时隐藏数据成员和具体的函数代码，提高了用户使用的安全性和便捷性。但是，在本科C++的教学中，受困于<strong>题目</strong>的限制，这一点被大大忽略了。（笔者身边甚至有同学将所有的数据成员全部设置为public，这样少写很多函数也可以通过测试样例。）</p>          </div><p>例如在下面的类设计中，<code>privatevalue</code>作为密钥，<strong>哪怕是MyClass的成员函数都不可以调用其值</strong>，只能通过唯一的接口<code>int getprivatevalue() const</code>实现。</p><blockquote><p>这样有什么好处？好处时实现了安全性的<strong>层级分离</strong>。显然value的安全等级低于<code>privatevalue</code>，开发者放开<code>MyClass</code>的权限也不会影响到<code>PrivateValue</code>类。保证了高级安全数据的安全性。</p><p>例如，任何<code>MyClass</code>的成员函数都可以访问value的值，但是只有掌握password的成员函数才能通过接口访问<code>privatevalue</code>的值。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> value;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">PrivateValue</span>&#123;<br>        <span class="hljs-keyword">private</span>:<span class="hljs-type">int</span> privatevalue;<br>        <span class="hljs-keyword">public</span>:<br>            <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getprivatevalue</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>&#123;<br>                <span class="hljs-type">int</span> password;<br>                cout&lt;&lt;<span class="hljs-string">&quot;Please enter the password: &quot;</span>;<br>                cin&gt;&gt;password;<br>                <span class="hljs-keyword">if</span>(password==<span class="hljs-number">123456</span>)&#123;<br>                    <span class="hljs-keyword">return</span> privatevalue;<br>                &#125;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            &#125;<br>            <span class="hljs-built_in">PrivateValue</span>(<span class="hljs-type">int</span> x):<span class="hljs-built_in">privatevalue</span>(x)&#123;&#125;<br>    &#125;;<br>    PrivateValue pri;<br>    <span class="hljs-comment">// 只有特定成员函数可以访问 privatevalue</span><br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">int</span> v, <span class="hljs-type">int</span> pv) : <span class="hljs-built_in">value</span>(v),<span class="hljs-built_in">pri</span>(pv)&#123;&#125;<br><br>    <span class="hljs-comment">// 公共接口</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getValue</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> pri.<span class="hljs-built_in">getprivatevalue</span>();<br>    &#125;<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">MyClass <span class="hljs-title">obj1</span><span class="hljs-params">(<span class="hljs-number">23</span>,<span class="hljs-number">3456</span>)</span></span>;<br>    cout&lt;&lt;obj<span class="hljs-number">1.</span><span class="hljs-built_in">getValue</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><ul><li>多用const引用，多多益善。</li><li>对于没有访问权的变量使用<strong>嵌套类</strong>实现。</li></ul><blockquote><p>The END</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Code</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C/C++</tag>
      
      <tag>OOP</tag>
      
      <tag>Finished</tag>
      
      <tag>Jotting</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Input-and-Output-in-C-plus-plus</title>
    <link href="/posts/Input-and-Output-in-C-plus-plus/"/>
    <url>/posts/Input-and-Output-in-C-plus-plus/</url>
    
    <content type="html"><![CDATA[<h1 id="Input-Output-and-Files-in-C"><a href="#Input-Output-and-Files-in-C" class="headerlink" title="Input, Output and Files in C++"></a>Input, Output and Files in C++</h1><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>This blog will focus on <strong>C++ stream-based input and output,</strong> including <strong>console-based, file-based, and string-based input and output</strong>. The blog will share some advanced techniques for custom input and output, including the use of the <strong>iomanip</strong> library, accessing <strong>ASCII files and binary files</strong>.</p><h2 id="Table-of-Contents"><a href="#Table-of-Contents" class="headerlink" title="Table of Contents"></a>Table of Contents</h2><ul><li><p><a href="#Introduction"><strong>Introductions</strong></a></p></li><li><p><a href="#Several-Basic-Concepts"><strong>Several Basic Concepts</strong></a></p></li><li><p><a href="#Console-based-input-and-output"><strong>Console-based input and output</strong></a></p></li></ul><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>在<strong>冯诺依曼体系结构</strong>中，计算机通过输入设备向电脑输入信息，经过运算后由输出设备输出。由此可见，输入输出是<strong>程序与外部进行数据通信的重要枢纽</strong>。在过往C++的学习中，我们已经掌握了一些有关输入输出的基本知识（<code>cin</code>和<code>cout</code>）。本章节将从更加底层的视角介绍C++中常见的三种输入输出：**基于控制台的输入输出类型<code>iostream</code>、基于文件的输入输出类型<code>fstream</code>和基于字符串的输入输出类型<code>sstream</code>**。</p><p><img src="/posts/Above-All/Output-in-C-plus-plus/fnym.png" alt="冯诺依曼体系结构"></p><h2 id="Several-Basic-Concepts"><a href="#Several-Basic-Concepts" class="headerlink" title="Several Basic Concepts"></a>Several Basic Concepts</h2><p>在正式开始我们的内容之前，我们需要做一些准备工作，下文将向读者介绍四个基本概念：<strong>流、控制台、缓冲区和IO标准库</strong>。</p><h3 id="Streams"><a href="#Streams" class="headerlink" title="Streams"></a>Streams</h3><p>在计算机编程中，<strong>流(Stream)<strong>是一种用于输入和输出（I&#x2F;O）操作的抽象。流可以看作是数据元素的序列，这些数据元素</strong>按时间顺序可供程序读取或写入</strong>，通常用于在程序与外部源（如文件、网络连接或控制台）之间传输数据。</p><p>具体到C++的输入输出中，C++的输入&#x2F;输出是以<strong>一连串字节流的方式</strong>进行的。在输入操作中，字节从<strong>设备（如键盘、磁盘）流向内存</strong>，称为<strong>输入流</strong>。在输出操作中，字节<strong>从内存流向设备（如显示器、打印机、磁盘等）</strong>，称为<strong>输出流</strong>。 C++同时提供“低层次”和“高层次”的输入&#x2F;输出。低层次的输入&#x2F;输出直接<strong>处理字节流中的一个个字节</strong>，把每个字节仅看成一个二进制比特串。高层次的输入&#x2F;输出可以将字节组合成有意义的单位，如<strong>整型数、浮点数及自定义类型的值进行操作</strong>。  </p><p>具体而言，高层次IO主要是基于<strong>流（Stream）</strong>的 I&#x2F;O，提供了更抽象、更易用的接口（<code>cin</code>和<code>cout</code>）。它隐藏了底层细节（如缓冲区管理、设备控制等）。而低层次IO基于<strong>系统调用</strong>或<strong>C 标准库函数</strong>的 I&#x2F;O，提供了更底层的控制，例如C语言中的<code>printf()</code>和<code>scanf()</code>函数。</p><table><thead><tr><th align="left">特性</th><th align="left">高层次 I&#x2F;O</th><th align="left">低层次 I&#x2F;O</th></tr></thead><tbody><tr><td align="left">抽象程度</td><td align="left">高（基于流）</td><td align="left">低（基于文件描述符或缓冲区）</td></tr><tr><td align="left">易用性</td><td align="left">高（简洁的接口，类型安全）</td><td align="left">低（需要手动管理资源）</td></tr><tr><td align="left">性能</td><td align="left">较低（有抽象层开销）</td><td align="left">较高（直接操作底层资源）</td></tr><tr><td align="left">控制粒度</td><td align="left">较粗（隐藏了底层细节）</td><td align="left">较细（可以精确控制 I&#x2F;O 细节）</td></tr><tr><td align="left">适用场景</td><td align="left">通用场景（如控制台、文件 I&#x2F;O）</td><td align="left">高性能场景或需要精细控制的场景</td></tr></tbody></table><h3 id="Console"><a href="#Console" class="headerlink" title="Console"></a>Console</h3><p><strong>控制台（Console）</strong>，也叫做<strong>命令行界面（CLI，Command Line Interface）</strong>或<strong>终端（Terminal）</strong>，是一个用于与计算机进行交互的文本界面。在控制台中，用户可以通过输入命令和接收计算机输出结果来与操作系统和应用程序进行交互。</p><p>控制台的基本概念：</p><ol><li><strong>文本交互界面</strong>： 控制台通常是一个纯文本的界面，没有图形元素，用户通过键盘输入命令，计算机通过文本输出反馈给用户。这与图形用户界面（GUI）相比，显得更加简洁、直接。</li><li><strong>命令输入和输出</strong>： 在控制台中，用户通过输入命令来执行各种任务，比如文件管理、程序启动、系统配置等。计算机则通过文本输出给出执行结果或提示信息。</li><li><strong>程序的交互式操作</strong>： 很多程序（尤其是开发工具、编译器、数据库等）都支持控制台交互，用户可以在控制台中输入指令，实时获取程序输出的结果。</li></ol><h3 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h3><p><strong>缓冲区（Buffer）</strong> 是计算机系统中的一块临时存储区域，通常用于存储数据，以便在数据处理过程中提高效率。缓冲区可以帮助程序减少频繁的I&#x2F;O操作（如磁盘读写、网络通信等），通过缓存数据来实现更高效的操作。</p><p>程序只能访问内存中的信息，而不能直接访问外部设备中的信息。当程序需要读取外部设备中的某个信息时，操作系统会将<strong>包含此信息的一批数据从外部设备读入内存，再从内存读入程序</strong>，此时发生了<strong>一次外部设备的访问</strong>。如果程序需要读取的数据已经在内存中，则不会发生外部设备的访问。输出也是如此。如果程序向外部设备输出一个信息，此信息被写在内存的某个地方，操作系统会定期将内存中的信息输出到外部设备。内存中存放这些数据的区域称为<strong>输入&#x2F;输出缓冲区</strong>。  </p><p><strong>缓冲区的工作原理：</strong></p><ol><li><strong>写缓冲区</strong>：当程序向文件或网络发送数据时，数据首先被写入缓冲区，<font color=red><strong>等缓冲区被填满或条件满足</strong></font>时，再一次性将数据写入目标设备。</li><li><strong>读缓冲区</strong>：当程序从文件或网络读取数据时，<font color=red><strong>数据首先被从目标设备加载到缓冲区，再从缓冲区读取数据到程序中</strong></font>。这样可以避免每次读取时都访问设备，提高读取速度。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 使用带缓冲的文件输入输出流</span><br>    <span class="hljs-function">std::ifstream <span class="hljs-title">inputFile</span><span class="hljs-params">(<span class="hljs-string">&quot;example.txt&quot;</span>)</span></span>;  <span class="hljs-comment">// 默认使用缓冲</span><br>    std::string line;<br>    <br>    <span class="hljs-keyword">if</span> (inputFile.<span class="hljs-built_in">is_open</span>()) &#123;<br>        <span class="hljs-keyword">while</span> (std::<span class="hljs-built_in">getline</span>(inputFile, line)) &#123;<br>            std::cout &lt;&lt; line &lt;&lt; std::endl;  <span class="hljs-comment">// 缓冲区中的数据一次性输出</span><br>        &#125;<br>        inputFile.<span class="hljs-built_in">close</span>();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;无法打开文件&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>std::ifstream</code> 默认使用缓冲区来读取文件内容。它首先从文件系统读取一些数据到缓冲区，然后一次性将这些数据提供给程序。</p><div class="note note-info">            <p>有关缓冲区的具体实现原理我们会稍后提及。（<strong>与输入输出类的实现有关</strong>）</p>          </div><h3 id="Standard-Library-for-IO"><a href="#Standard-Library-for-IO" class="headerlink" title="Standard Library for IO"></a>Standard Library for IO</h3><p>C++标准库中一个重要的组成部分就是IO流库，专门实现C++中的输入和输出。提供基于流的输入输出功能，包括控制台、文件和字符串的 I&#x2F;O。主要头文件：</p><ul><li><code>&lt;iostream&gt;</code>：标准输入输出流（如 <code>std::cin</code>、<code>std::cout</code>）。</li><li><code>&lt;fstream&gt;</code>：文件流（如 <code>std::ifstream</code>、<code>std::ofstream</code>）。</li><li><code>&lt;sstream&gt;</code>：字符串流（如 <code>std::istringstream</code>、<code>std::ostringstream</code>）。</li></ul><p><img src="/posts/Above-All/Output-in-C-plus-plus/iostream.png" alt="iostream"></p><table><thead><tr><th align="left">头文件</th><th align="left">功能描述</th><th align="left">主要类&#x2F;对象</th><th align="left">使用场景</th></tr></thead><tbody><tr><td align="left"><code>&lt;iostream&gt;</code></td><td align="left">提供标准输入输出功能，用于控制台 I&#x2F;O。</td><td align="left">- <code>std::cin</code>：标准输入流 -<code>std::cout</code>：标准输出流 - <code>std::cerr</code>：标准错误流 - <code>std::clog</code>：标准日志流</td><td align="left">控制台输入输出，如用户交互、调试信息输出等。</td></tr><tr><td align="left"><code>&lt;fstream&gt;</code></td><td align="left">提供文件输入输出功能，用于读写文件。</td><td align="left">- <code>std::ifstream</code>：文件输入流 - <code>std::ofstream</code>：文件输出流 - <code>std::fstream</code>：文件流</td><td align="left">文件读写操作，如读取配置文件、保存数据到文件等。</td></tr><tr><td align="left"><code>&lt;sstream&gt;</code></td><td align="left">提供字符串输入输出功能，用于将字符串作为流处理。</td><td align="left">- <code>std::istringstream</code>：字符串输入流 - <code>std::ostringstream</code>：字符串输出流 - <code>std::stringstream</code>：字符串流</td><td align="left">字符串格式化、解析，如将字符串转换为数字、将数据格式化为字符串等。</td></tr></tbody></table><h2 id="Console-based-input-and-output"><a href="#Console-based-input-and-output" class="headerlink" title="Console-based input and output"></a>Console-based input and output</h2><p>在<strong>运算符重载</strong>这一小节时，笔者曾经介绍了cin&#x2F;cout的真实面目是**<code>istream</code>类和<code>ostream</code>类的对象**。并讲解了如何重载流输入输出运算符。下面转载自己的部分博客内容，<a href="https://xiyuanyang-code.github.io/posts/Introduction-to-OOP/">原文点这里</a>。</p><div class="note note-info">            <h3 id="输入-输出运算符的重载"><a href="#输入-输出运算符的重载" class="headerlink" title="输入&#x2F;输出运算符的重载"></a>输入&#x2F;输出运算符的重载</h3><h4 id="重新认识运算符"><a href="#重新认识运算符" class="headerlink" title="重新认识&lt;&lt;和&gt;&gt;运算符"></a>重新认识<code>&lt;&lt;</code>和<code>&gt;&gt;</code>运算符</h4><p>在笔者的第一堂C++启蒙课上，笔者便体会到了<strong>流操作</strong>的精妙和便捷。（相比于<code>printf()</code>和<code>scanf()</code>的冗长语法）但是，当时笔者只是把<code>cin/cout</code>当做一个普通的函数来使用，并不知道其背后深层次的原理。下面，我们先来重新认识一下cin&#x2F;cout的真面目。</p><h5 id="istream和ostream"><a href="#istream和ostream" class="headerlink" title="istream和ostream"></a><code>istream</code>和<code>ostream</code></h5><p>在 C++ 中，<strong>流类（如 <code>std::istream</code> 和 <code>std::ostream</code>）是处理输入输出操作的核心类</strong>，它们为程序提供了与数据流进行交互的功能。这些类是 C++ 标准库的一部分，用于简化与文件、控制台、字符串等设备的交互。</p><ol><li><strong><code>std::istream</code> 类</strong></li></ol><p><code>std::istream</code> 类是用于处理输入操作的类，提供了从输入流中读取数据的功能。它是所有输入流类（如 <code>cin</code>）的基类。</p><ul><li><strong>构造函数</strong>：<code>std::istream</code> 的构造函数可以用来打开文件或初始化输入流。</li><li>成员函数<ul><li><code>operator&gt;&gt;</code>：流提取运算符，用于从流中提取数据。</li><li><code>get()</code>：用于读取一个字符或一行数据。</li><li><code>read()</code>：从流中读取特定数量的字符。</li><li><code>eof()</code>：检查是否到达文件结束标志。</li><li><code>fail()</code>：检查流是否进入失败状态。</li></ul></li></ul><ol start="2"><li><strong><code>std::ostream</code> 类</strong></li></ol><p><code>std::ostream</code> 类是用于处理输出操作的类，提供了将数据写入输出流的功能。它是所有输出流类（如 <code>cout</code>）的基类。</p><ul><li><p><strong>构造函数</strong>：<code>std::ostream</code> 的构造函数用于打开输出流或初始化输出流。</p></li><li><p>成员函数</p><ul><li><code>operator&lt;&lt;</code>：流插入运算符，用于将数据插入到流中。</li><li><code>put()</code>：用于向流中写入一个字符。</li><li><code>write()</code>：用于向流中写入特定数量的字符。</li><li><code>flush()</code>：强制输出缓冲区内容，确保数据立即写入流。</li><li><code>endl</code>：插入一个换行符并刷新输出流。</li></ul></li></ul><ol start="3"><li><strong>继承结构</strong></li></ol><p><code>std::istream</code> 和 <code>std::ostream</code> 类本身都继承自 <code>std::ios</code> 类，它们共享一些基本的输入输出功能。<code>std::ios</code> 类提供了管理流状态的功能，比如检查是否处于错误状态、是否已到达文件末尾等。</p><ul><li><strong><code>std::ios</code> 类</strong>：<code>std::ios</code> 是 <code>std::istream</code> 和 <code>std::ostream</code> 的基类，负责流的基本状态管理（如错误标志、格式控制等）。<ul><li><code>std::ios::good()</code>: 检查流是否处于良好状态。</li><li><code>std::ios::eof()</code>: 检查流是否到达文件末尾。</li><li><code>std::ios::fail()</code>: 检查流是否处于失败状态。</li></ul></li></ul><ol start="4"><li><strong>常见的派生类</strong></li></ol><ul><li>**<code>std::ifstream</code>**：<code>std::ifstream</code> 是 <code>std::istream</code> 的派生类，用于处理文件输入。它提供了从文件读取数据的功能。</li><li>**<code>std::ofstream</code>**：<code>std::ofstream</code> 是 <code>std::ostream</code> 的派生类，用于处理文件输出。它提供了将数据写入文件的功能。</li><li>**<code>std::stringstream</code>**：<code>std::stringstream</code> 是 <code>std::istream</code> 和 <code>std::ostream</code> 的派生类，允许在内存中处理字符串流。它既可以用于输入也可以用于输出。</li></ul><h5 id="cin和cout"><a href="#cin和cout" class="headerlink" title="cin和cout"></a><code>cin</code>和<code>cout</code></h5><p><code>cin</code> 和 <code>cout</code> 是 C++ 标准库中<strong>预定义的输入和输出流对象</strong>，它们是由流类（如 <code>istream</code> 和 <code>ostream</code>）创建的全局对象，用于进行数据的输入和输出。</p><ul><li><strong><code>cin</code>（标准输入流对象）</strong>：<code>cin</code> 是一个全局的输入流对象，属于 <code>std::istream</code> 类，通常用于从标准输入（如键盘）获取数据。</li><li><strong><code>cout</code>（标准输出流对象）</strong>：<code>cout</code> 是一个全局的输出流对象，属于 <code>std::ostream</code> 类，通常用于将数据输出到标准输出（如显示器）。</li></ul><div class="note note-danger">            <p><strong>是的，cin&#x2F;cout根本不是函数，而是对象！！！</strong></p>          </div><h5 id="运算符"><a href="#运算符" class="headerlink" title="&lt;&lt;和&gt;&gt;运算符"></a><code>&lt;&lt;</code>和<code>&gt;&gt;</code>运算符</h5><p>这些运算符实际上是被重载的，它们不是内置运算符，而是通过重载来定义流操作的行为。</p><ul><li>**流插入运算符 <code>&lt;&lt;</code>**：被 <code>std::ostream</code> 类重载，用于将数据插入到输出流中。当你写 <code>cout &lt;&lt; x;</code> 时，实际上是调用了 <code>std::ostream</code> 类的 <code>operator&lt;&lt;</code> 函数。</li><li>**流提取运算符 <code>&gt;&gt;</code>**：被 <code>std::istream</code> 类重载，用于从输入流中提取数据。当你写 <code>cin &gt;&gt; x;</code> 时，实际上是调用了 <code>std::istream</code> 类的 <code>operator&gt;&gt;</code> 函数。</li></ul><p>流插入运算符&lt;&lt;是一个二元运算符。例如，表达式 cout &lt;&lt; x 的运算符两侧分别是 cout 和 x， x 是一个整型变量， cout 是输出流类 <code>ostream</code> 的对象。 &lt;&lt;运算符将右边对象的值转换成文本形式插入左边的输出流对象， 执行结果是左边的输出流对象的引用。对于 cout &lt;&lt; x，运算结果为对象 cout。正因为&lt;&lt;运算的结果是左边对象的引用，所以允许执行 <code>cout &lt;&lt; x &lt;&lt; y</code> 等的操作。因为&lt;&lt;是左结合的，所以上述表达式先执行 <code>cout &lt;&lt; x</code>，执行的结果是对象 cout，然后执行 <code>cout &lt;&lt; y</code>。</p><h4 id="在自定义类中重载运算符"><a href="#在自定义类中重载运算符" class="headerlink" title="在自定义类中重载&lt;&lt;和&gt;&gt;运算符"></a>在自定义类中重载<code>&lt;&lt;</code>和<code>&gt;&gt;</code>运算符</h4><p>由于第一个参数是<code>ostream/istream</code> 类的对象，因此<strong>流插入运算符不能重载成成员函数，必须重载成全局函数，流输出运算符也是如此</strong>。</p><p>为什么？在 C++ 中，<strong>成员函数的第一个参数通常是隐式的 <code>this</code> 指针</strong>，指向当前对象。因此，成员函数可以通过 <code>this</code> 指针访问对象的成员变量和其他成员函数。也就是说，只有运算符的第一个参数是可以被<strong>this指针指向的，才能够被定义为类内的成员函数</strong>，否则必须被<strong>定义为友元函数</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> x, y;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 构造函数</span><br>    <span class="hljs-built_in">Point</span>(<span class="hljs-type">int</span> x = <span class="hljs-number">0</span>, <span class="hljs-type">int</span> y = <span class="hljs-number">0</span>) : <span class="hljs-built_in">x</span>(x), <span class="hljs-built_in">y</span>(y) &#123;&#125;<br><br>    <span class="hljs-comment">// 重载 &lt;&lt; 运算符</span><br>    <span class="hljs-keyword">friend</span> ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; os, <span class="hljs-type">const</span> Point&amp; p);<br>    <span class="hljs-comment">//参数中第一个对象是ostream类的对象（相当于cout）</span><br>&#125;;<br><br><span class="hljs-comment">// 重载 &lt;&lt; 运算符</span><br>ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; os, <span class="hljs-type">const</span> Point&amp; p) &#123;<br>    os &lt;&lt; <span class="hljs-string">&quot;(&quot;</span> &lt;&lt; p.x &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; p.y &lt;&lt; <span class="hljs-string">&quot;)&quot;</span>;<br>    <span class="hljs-keyword">return</span> os;  <span class="hljs-comment">// 返回 ostream 引用，以便链式调用</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">Point <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)</span></span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Point: &quot;</span> &lt;&lt; p &lt;&lt; endl;  <span class="hljs-comment">// 调用重载的 &lt;&lt; 运算符</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> x, y;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 构造函数</span><br>    <span class="hljs-built_in">Point</span>(<span class="hljs-type">int</span> x = <span class="hljs-number">0</span>, <span class="hljs-type">int</span> y = <span class="hljs-number">0</span>) : <span class="hljs-built_in">x</span>(x), <span class="hljs-built_in">y</span>(y) &#123;&#125;<br><br>    <span class="hljs-comment">// 重载 &gt;&gt; 运算符</span><br>    <span class="hljs-keyword">friend</span> istream&amp; <span class="hljs-keyword">operator</span>&gt;&gt;(istream&amp; is, Point&amp; p);<br>    <span class="hljs-comment">//参数中第一个对象是istream类的对象（相当于cin）</span><br>&#125;;<br><br><span class="hljs-comment">// 重载 &gt;&gt; 运算符</span><br>istream&amp; <span class="hljs-keyword">operator</span>&gt;&gt;(istream&amp; is, Point&amp; p) &#123;<br>    is &gt;&gt; p.x &gt;&gt; p.y;  <span class="hljs-comment">// 从输入流中读取数据到成员变量</span><br>    <span class="hljs-keyword">return</span> is;  <span class="hljs-comment">// 返回 istream 引用，以便链式调用</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">Point <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)</span></span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Enter coordinates for the point (x y): &quot;</span>;<br>    cin &gt;&gt; p;  <span class="hljs-comment">// 调用重载的 &gt;&gt; 运算符</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;You entered point: &quot;</span> &lt;&lt; p &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>相关注意点：</strong></p><ul><li>注意返回类型是对<code>istream</code>或<code>ostream</code>的引用。</li></ul>          </div><h3 id="iomanip"><a href="#iomanip" class="headerlink" title="iomanip"></a>iomanip</h3><p><code>iomanip</code> 是 C++ 标准库中的一个头文件，全称为 <strong>Input&#x2F;Output Manipulators</strong>（输入输出操纵器）。它提供了一系列用于<strong>格式化输入</strong>输出的工具函数，通常与 <code>iostream</code> 库（如 <code>cin</code> 和 <code>cout</code>）结合使用，以控制数据的显示方式。<strong>格式化输入&#x2F;输出</strong>是通过<strong>流操纵符</strong>或**<code>istream</code> 和 <code>ostream</code> 类的成员函数<strong>实现的。流操纵符是以一个流引用作为参数，并返回同一流引用的函数，因此它可以嵌入输入&#x2F;输出操作的链中。 <code>endl</code> 就是最常用的流操纵符。格式化输入&#x2F;输出的功能包括</strong>设置整型数的基数、设置浮点数的精度、设置和改变域宽、设置域的填充字符**等。  </p><p><code>iomanip</code> 中常用的函数包括：</p><ol><li><p><strong>设置字段宽度</strong><br><code>setw(n)</code>：设置下一个输出字段的宽度为 <code>n</code> 个字符。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cout &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">10</span>) &lt;&lt; <span class="hljs-string">&quot;Hello&quot;</span>; <span class="hljs-comment">// 输出 &quot;     Hello&quot;（前面有 5 个空格）</span><br></code></pre></td></tr></table></figure></li><li><p><strong>设置浮点数精度</strong><br><code>setprecision(n)</code>：设置浮点数输出的精度为 <code>n</code> 位。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cout &lt;&lt; <span class="hljs-built_in">setprecision</span>(<span class="hljs-number">3</span>) &lt;&lt; <span class="hljs-number">3.14159</span>; <span class="hljs-comment">// 输出 &quot;3.14&quot;</span><br>cout &lt;&lt; fixed &lt;&lt; <span class="hljs-built_in">setprecision</span>(<span class="hljs-number">3</span>) &lt;&lt; <span class="hljs-number">3.14159</span>; <span class="hljs-comment">//输出 &quot;3.142&quot;</span><br><br><span class="hljs-comment">// 你也可以写成 cout.precision(3);cout&lt;&lt;x;</span><br></code></pre></td></tr></table></figure><p>在默认模式下，<code>setprecision(n)</code> 控制的是<strong>有效数字位数</strong>，即从第一个非零数字开始计算的总位数。在 <code>fixed</code> 模式下，<code>setprecision(n)</code> 控制的是<strong>小数点后的位数</strong>。(<strong>是四舍五入</strong>)。在 <code>scientific</code> 模式下，<code>setprecision(n)</code> 控制的是<strong>小数点后的位数</strong>，但数字会以科学计数法显示。</p></li><li><p><strong>设置填充字符</strong><br><code>setfill(c)</code>：设置填充字符为 <code>c</code>，通常与 <code>setw</code> 一起使用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cout &lt;&lt; <span class="hljs-built_in">setfill</span>(<span class="hljs-string">&#x27;*&#x27;</span>) &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">10</span>) &lt;&lt; <span class="hljs-string">&quot;Hi&quot;</span>; <span class="hljs-comment">// 输出 &quot;********Hi&quot;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>控制布尔值输出格式</strong><br><code>boolalpha</code> &#x2F; <code>noboolalpha</code>：将布尔值输出为 <code>true</code>&#x2F;<code>false</code> 或 <code>1</code>&#x2F;<code>0</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cout &lt;&lt; boolalpha &lt;&lt; <span class="hljs-literal">true</span>; <span class="hljs-comment">// 输出 &quot;true&quot;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>控制数字的进制</strong><br><code>hex</code>、<code>dec</code>、<code>oct</code>：分别将数字输出为十六进制、十进制和八进制。</p><p>也可以使用<code>setbase()</code>进行格式化控制。（<strong>参数化的流操纵符</strong>）</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cout &lt;&lt; hex &lt;&lt; <span class="hljs-number">255</span>; <span class="hljs-comment">// 输出 &quot;ff&quot;</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iomanip&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">10</span>) &lt;&lt; <span class="hljs-built_in">setfill</span>(<span class="hljs-string">&#x27;-&#x27;</span>) &lt;&lt; <span class="hljs-string">&quot;Hello&quot;</span> &lt;&lt; endl; <span class="hljs-comment">// 输出 &quot;-----Hello&quot;</span><br>    cout &lt;&lt; <span class="hljs-built_in">setprecision</span>(<span class="hljs-number">4</span>) &lt;&lt; <span class="hljs-number">3.14159</span> &lt;&lt; endl;          <span class="hljs-comment">// 输出 &quot;3.142&quot;</span><br>    cout &lt;&lt; hex &lt;&lt; <span class="hljs-number">255</span> &lt;&lt; endl;                          <span class="hljs-comment">// 输出 &quot;ff&quot;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="6"><li><strong>自定义输出流操纵符</strong></li></ol><p>在 C++ 中，自定义流操纵符函数（Custom Stream Manipulators）允许你创建自己的流操作符，用于简化或扩展输入输出流的格式化操作。自定义流操纵符函数可以是一个无参数的函数，也可以是一个带参数的函数，它们通过操作流的内部状态或执行特定操作来实现自定义功能。</p><ol><li><strong>无参数的自定义流操纵符</strong></li></ol><p>无参数的自定义流操纵符是一个简单的函数，它接受一个流对象（<code>std::ostream&amp;</code> 或 <code>std::istream&amp;</code>）并返回该流对象。通常用于设置流的格式状态。</p><p><strong>示例：实现一个自定义操纵符，将输出流的颜色设置为红色（假设终端支持 ANSI 颜色代码）：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 自定义操纵符函数：设置为红色</span><br><span class="hljs-function">ostream&amp; <span class="hljs-title">red</span><span class="hljs-params">(ostream&amp; os)</span> </span>&#123;<br>    os &lt;&lt; <span class="hljs-string">&quot;\033[31m&quot;</span>; <span class="hljs-comment">// ANSI 颜色代码：红色</span><br>    <span class="hljs-keyword">return</span> os;<br>&#125;<br><br><span class="hljs-comment">// 自定义操纵符函数：恢复默认颜色</span><br><span class="hljs-function">ostream&amp; <span class="hljs-title">reset</span><span class="hljs-params">(ostream&amp; os)</span> </span>&#123;<br>    os &lt;&lt; <span class="hljs-string">&quot;\033[0m&quot;</span>; <span class="hljs-comment">// ANSI 重置代码</span><br>    <span class="hljs-keyword">return</span> os;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cout &lt;&lt; red &lt;&lt; <span class="hljs-string">&quot;This text is red!&quot;</span> &lt;&lt;endl&lt;&lt; reset &lt;&lt; <span class="hljs-string">&quot; This text is back to default.&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li><strong>带参数的自定义流操纵符</strong></li></ol><p>带参数的自定义流操纵符需要借助一个辅助类来实现。通过重载 <code>operator&lt;&lt;</code> 或 <code>operator&gt;&gt;</code>，可以传递参数并执行更复杂的操作。</p><p><strong>示例：实现一个自定义操纵符，重复输出指定次数的字符串：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 辅助类</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">RepeatManipulator</span> &#123;<br>    <span class="hljs-type">int</span> count;<br>    <span class="hljs-type">const</span> string&amp; str;<br><br>    <span class="hljs-built_in">RepeatManipulator</span>(<span class="hljs-type">int</span> n, <span class="hljs-type">const</span> string&amp; s) : <span class="hljs-built_in">count</span>(n), <span class="hljs-built_in">str</span>(s) &#123;&#125;<br>&#125;;<br><br><span class="hljs-comment">// 重载 operator&lt;&lt;</span><br>ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; os, <span class="hljs-type">const</span> RepeatManipulator&amp; manip) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; manip.count; ++i) &#123;<br>        os &lt;&lt; manip.str;<br>    &#125;<br>    <span class="hljs-keyword">return</span> os;<br>&#125;<br><br><span class="hljs-comment">// 自定义操纵符函数</span><br><span class="hljs-function">RepeatManipulator <span class="hljs-title">repeat</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">const</span> string&amp; s)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">RepeatManipulator</span>(n, s);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-built_in">repeat</span>(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;Hello! &quot;</span>) &lt;&lt; endl; <span class="hljs-comment">// 输出 &quot;Hello! Hello! Hello! &quot;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><ol start="3"><li><strong>结合 <code>iomanip</code> 使用</strong></li></ol><p>自定义流操纵符可以与 <code>iomanip</code> 中的标准操纵符结合使用，以实现更强大的功能。</p><p><strong>示例：实现一个自定义操纵符，将浮点数输出为百分比格式：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iomanip&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 自定义操纵符函数</span><br><span class="hljs-function">ostream&amp; <span class="hljs-title">percent</span><span class="hljs-params">(ostream&amp; os)</span> </span>&#123;<br>    os &lt;&lt; fixed &lt;&lt; <span class="hljs-built_in">setprecision</span>(<span class="hljs-number">2</span>) &lt;&lt; <span class="hljs-string">&#x27;*&#x27;</span>; <span class="hljs-comment">// 设置格式并添加百分号</span><br>    <span class="hljs-keyword">return</span> os;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">double</span> num = <span class="hljs-number">0.753</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Percentage: &quot;</span> &lt;&lt; num * <span class="hljs-number">100</span> &lt;&lt; percent &lt;&lt; endl; <span class="hljs-comment">// 输出 &quot;Percentage: 75.30%&quot;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><ol start="4"><li><strong>自定义输入流操纵符</strong></li></ol><p>自定义流操纵符也可以用于输入流（<code>std::istream</code>），用于解析或处理输入数据。</p><p><strong>示例：实现一个自定义操纵符，跳过输入流中的逗号：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 自定义操纵符函数</span><br><span class="hljs-function">istream&amp; <span class="hljs-title">skipComma</span><span class="hljs-params">(istream&amp; is)</span> </span>&#123;<br>    <span class="hljs-type">char</span> c;<br>    is &gt;&gt; c; <span class="hljs-comment">// 读取一个字符</span><br>    <span class="hljs-keyword">if</span> (c != <span class="hljs-string">&#x27;,&#x27;</span>) &#123;<br>        is.<span class="hljs-built_in">putback</span>(c); <span class="hljs-comment">// 如果不是逗号，放回流中</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> is;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> a, b;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Enter two numbers separated by a comma: &quot;</span>;<br>    cin &gt;&gt; a &gt;&gt; skipComma &gt;&gt; b;<br>    cout &lt;&lt; <span class="hljs-string">&quot;You entered: &quot;</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; and &quot;</span> &lt;&lt; b &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>自定义流操作符是C++输入输出的利器。</strong>强烈推荐大家上手实现自己的流操作符！</p></blockquote><h2 id="File-based-input-and-output"><a href="#File-based-input-and-output" class="headerlink" title="File-based input and output"></a>File-based input and output</h2><h3 id="Preliminaries"><a href="#Preliminaries" class="headerlink" title="Preliminaries"></a>Preliminaries</h3><p>在我们之前所遇到的程序中，程序的输入都指的是<strong>键盘的手动输入</strong>，这种输入方式灵活便捷但具有局限性。（例如我编写了一个程序需要统计公司所有员工的考勤记录，如果把所有数据全部手敲进终端中无疑是费时费力的。）因此，<strong>文件的输入输出</strong>在某些情况下相比于控制台的输入输出有着得天独厚的优越性。</p><p>为了展示文件输入输出的强大之处，先向笔者展示以下的程序：</p><p><img src="/posts/Above-All/Output-in-C-plus-plus/Bash.png" alt="File-based input and output"></p><blockquote><p>上图的命令行使用Bash语言，感兴趣的读者可自行学习，笔者这里使用的是GitBash（Powershell就是💩）</p></blockquote><ul><li><code>cat</code> 展示文件的内容</li><li><code>g++ testfile1.cpp =o main </code>编译<code>testfile1.cpp</code>文件，生成<code>main.exe</code>的可执行文件</li><li><code>./main.exe</code> 运行<code>main.exe</code></li><li><code>./main.exe &lt;1.txt &gt;2.txt</code><ul><li><strong>Bash语言的输入重定向和输出重定向</strong>：将<code>1.txt</code>的文件内容当做输入输入进<code>main.exe</code>中，然后将程序的输出流向<code>2.txt</code></li></ul></li></ul><p>根据结果不难发现，<code>1.txt</code>作为输入内容，成功被程序所执行并且<strong>成功将执行的结果导入到<code>2.txt</code><strong>中。</strong>泰裤辣！</strong></p><h3 id="Files-Streams-and-EOF"><a href="#Files-Streams-and-EOF" class="headerlink" title="Files, Streams, and EOF"></a>Files, Streams, and EOF</h3><h4 id="EOF"><a href="#EOF" class="headerlink" title="EOF"></a>EOF</h4><p>C++的文件没有记录的概念，它把文件看成字节序列，即由一个个字节顺序组成，每一个文件以<strong>文件结束符（ End Of File， EOF）</strong>结束，这种文件称为<strong>流式文件</strong>。我们可以将 C++的文件看成一个字符串。只不过这个字符串不是存放在内存中的，而是存放在外存中；不是用<code>&#39;\0&#39;</code>结束的，而是用 EOF 结束。</p><h4 id="Files"><a href="#Files" class="headerlink" title="Files"></a>Files</h4><p>根据不同的读写方式，<strong>文件</strong>在C++中具体被分类为<strong>ASCII文件</strong>和<strong>二进制文件</strong>。<strong>ASCII文件</strong>是指使用 ASCII 编码存储文本的文件，用来存储纯文本数据。而<strong>二进制文件</strong>储存的是<strong>数据在内存中的表示</strong>。例如我们常见的可执行文件<code>.exe</code>就是一种常见的二进制文件。</p><h4 id="Streams-1"><a href="#Streams-1" class="headerlink" title="Streams"></a>Streams</h4><p>和<code>iostream</code>类似，在数据传输过程中，文件也可以被看做是<strong>一种输入输出流</strong>。当应用程序从文件中读取数据时，将文件与一个<strong>输入文件流对象</strong> <code>ifstream</code> 相关联（<strong>这一步叫做打开文件</strong>）。当应用程序将数据写入一个文件时，将文件与一个<strong>输出文件流对象</strong> <code>ofstream</code> 相关联（<strong>这一步叫做关闭文件</strong>）。如果既要输入又要输出，则与<strong>输入&#x2F;输出文件流对象</strong> <code>fstream</code> 相关联。  文件被关闭后，该文件流对象可以与其他文件相关联。</p><p>在操作上，<code>fstream</code>是<code>iostream</code>的派生类，因此并无较大的差异。</p><h3 id="Using-fstream-for-ASCII"><a href="#Using-fstream-for-ASCII" class="headerlink" title="Using fstream for ASCII"></a>Using <code>fstream</code> for ASCII</h3><p>下面的代码给出了使用<code>fstream</code>的若干基本用法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span> <span class="hljs-comment">// 包含文件流库</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span>  <span class="hljs-comment">// 包含字符串库</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 1. 打开文件</span><br>    <span class="hljs-comment">// 使用 fstream 对象，可以同时支持读写操作</span><br>    fstream file;<br><br>    <span class="hljs-comment">// 打开文件 &quot;example.txt&quot;，模式为：</span><br>    <span class="hljs-comment">// ios::out - 写入模式（如果文件不存在则创建）</span><br>    <span class="hljs-comment">// ios::in  - 读取模式</span><br>    <span class="hljs-comment">// ios::trunc - 如果文件存在，清空文件内容</span><br>    file.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;example.txt&quot;</span>, ios::out | ios::in | ios::trunc);<br><br>    <span class="hljs-comment">// 检查文件是否成功打开</span><br>    <span class="hljs-keyword">if</span> (!file.<span class="hljs-built_in">is_open</span>()) &#123;<br>        cerr &lt;&lt; <span class="hljs-string">&quot;Error: Failed to open file!&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <span class="hljs-comment">// 返回错误码</span><br>    &#125;<br><br>    <span class="hljs-comment">// 2. 写入数据到文件</span><br>    string dataToWrite = <span class="hljs-string">&quot;Hello, this is a line of text written to the file.\n&quot;</span>;<br>    file &lt;&lt; dataToWrite; <span class="hljs-comment">// 使用流插入运算符写入数据</span><br>    file &lt;&lt; <span class="hljs-string">&quot;Another line of text.\n&quot;</span>;<br><br>    <span class="hljs-comment">// 3. 读取文件内容</span><br>    <span class="hljs-comment">// 将文件指针移动到文件开头</span><br>    file.<span class="hljs-built_in">seekg</span>(<span class="hljs-number">0</span>, ios::beg);<br><br>    string line;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Reading from file:\n&quot;</span>;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">getline</span>(file, line)) &#123; <span class="hljs-comment">// 逐行读取文件内容</span><br>        cout &lt;&lt; line &lt;&lt; endl;     <span class="hljs-comment">// 输出到控制台</span><br>    &#125;<br><br>    <span class="hljs-comment">// 4. 关闭文件</span><br>    file.<span class="hljs-built_in">close</span>();<br><br>    <span class="hljs-comment">// 5. 重新打开文件以追加数据</span><br>    file.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;example.txt&quot;</span>, ios::out | ios::app); <span class="hljs-comment">// ios::app 表示追加模式</span><br>    <span class="hljs-keyword">if</span> (!file.<span class="hljs-built_in">is_open</span>()) &#123;<br>        cerr &lt;&lt; <span class="hljs-string">&quot;Error: Failed to reopen file for appending!&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 追加数据</span><br>    file &lt;&lt; <span class="hljs-string">&quot;This line is appended to the file.\n&quot;</span>;<br><br>    <span class="hljs-comment">// 6. 再次读取文件内容</span><br>    file.<span class="hljs-built_in">close</span>();<br>    file.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;example.txt&quot;</span>, ios::in); <span class="hljs-comment">// 以只读模式打开文件</span><br>    <span class="hljs-keyword">if</span> (!file.<span class="hljs-built_in">is_open</span>()) &#123;<br>        cerr &lt;&lt; <span class="hljs-string">&quot;Error: Failed to reopen file for reading!&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;\nReading after appending:\n&quot;</span>;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">getline</span>(file, line)) &#123; <span class="hljs-comment">// 逐行读取文件内容</span><br>        cout &lt;&lt; line &lt;&lt; endl;     <span class="hljs-comment">// 输出到控制台</span><br>    &#125;<br><br>    <span class="hljs-comment">// 7. 关闭文件</span><br>    file.<span class="hljs-built_in">close</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-primary">            <p><strong>代码的相关要点解释</strong></p><h4 id="定义文件流对象"><a href="#定义文件流对象" class="headerlink" title="定义文件流对象"></a><strong>定义文件流对象</strong></h4><p><code>fstream file</code>将<strong>文件流对象</strong>和输入的数据流绑定。</p><h4 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h4><p>定义好文件流对象后，就可以使用文件流对象的<code>open()</code>成员函数实现<strong>打开文件</strong>的操作。下面是<code>open()</code>成员函数的参数列表：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">open</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* filename, ios_base::openmode mode = ios_base::in | ios_base::out)</span></span>;<br></code></pre></td></tr></table></figure><p>不难发现<code>open()</code>函数有两个参数，第一个参数接受C语言风格的字符串，第二个参数是**<code>ios_base::openmode</code>**。<code>ios_base::openmode</code> 是 C++ 标准库中定义的一个枚举类型，用于指定文件流的打开模式。它是 <code>std::ios_base</code> 类的成员类型，通常通过 <code>std::ios</code> 命名空间来访问（例如 <code>std::ios::in</code>）。<code>ios_base::openmode</code> 的主要作用是控制文件流的打开方式，例如是读取、写入、追加还是二进制模式等。这些模式可以通过位运算符 <code>|</code> 组合使用。</p><table><thead><tr><th align="left">模式</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>std::ios::in</code></td><td align="left">以读取模式打开文件。如果文件不存在，打开失败。</td></tr><tr><td align="left"><code>std::ios::out</code></td><td align="left">以写入模式打开文件。如果文件不存在，会创建文件；如果文件存在，默认覆盖内容。</td></tr><tr><td align="left"><code>std::ios::app</code></td><td align="left">以追加模式打开文件。所有写入操作都在文件末尾进行，不会覆盖原有内容。</td></tr><tr><td align="left"><code>std::ios::ate</code></td><td align="left">打开文件后，将文件指针定位到文件末尾。</td></tr><tr><td align="left"><code>std::ios::trunc</code></td><td align="left">如果文件存在，清空文件内容（截断文件）。</td></tr><tr><td align="left"><code>std::ios::binary</code></td><td align="left">以二进制模式打开文件（默认是文本模式）。</td></tr></tbody></table><p>因此，上文中<code>file.open(&quot;example.txt&quot;, ios::out | ios::in | ios::trunc);</code>的意思就是：打开<code>example.txt</code>文件，可读可写且截断文件。由默认参数可知，<code>fstream</code>类的对象默认可读也可写。</p><div class="note note-danger">            <p>在实际的应用中，程序员为了保证安全性，会<strong>实现ifstream和ofstream</strong>的分离。在<code>ifstream</code>的情况下，就不可以使用<code>out</code>模式了，反过来也同样如此。</p>          </div><h4 id="检查文件"><a href="#检查文件" class="headerlink" title="检查文件"></a>检查文件</h4><p><strong>在复杂程序中</strong>，加入适当的<strong>检查点</strong>是非常好的习惯，这也有利于我们检查代码是否有一些隐式的错误。例如在这里，我们需要<strong>检查文件是否被成功打开并且被读取</strong>。<code>file.is_open()</code>就是这样一个函数，返回一个布尔值。<code>cerr &lt;&lt; &quot;Error: Failed to open file!&quot; &lt;&lt; endl;</code> 这行代码的作用是向标准错误流（<code>cerr</code>）输出一条错误信息，表示文件打开失败。此时程序会直接结束。</p><h4 id="流输入和流输出运算符"><a href="#流输入和流输出运算符" class="headerlink" title="流输入和流输出运算符"></a>流输入和流输出运算符</h4><p><code>file &lt;&lt; dataToWrite;</code> 这行代码的作用是将数据（<code>dataToWrite</code>）写入到文件流（<code>file</code>）中。它是 C++ 中流插入运算符（<code>&lt;&lt;</code>）的典型用法，用于将数据<strong>输出</strong>到文件。</p><blockquote><p>用法和<code>cout</code>没什么区别</p></blockquote><p>同理，使用<code>&gt;&gt;</code>运算符，可以将<strong>数据输入到文件</strong>中。</p><h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><ul><li>和<code>cin/cout</code>一样，文件的输入输出流也是<strong>忽略空白字符的！</strong>如果有必要也可以向上文的程序一样使用<code>getline()</code>。</li><li>ASCII文件也可以写入各种数字和字符串。</li></ul>          </div><h3 id="Access-to-binary-files"><a href="#Access-to-binary-files" class="headerlink" title="Access to binary files"></a>Access to binary files</h3><p>在二进制文件中，所有的文件输入和读取都是以<strong>字节</strong>为基本单位，这与ASCII的读取有很大的不同。（<strong>ASCII文件可以读取各种类型，包括整型和浮点型</strong>）</p><p>由于在内存中，<code>char</code>类型的数据都只占1个字节，因此，在<strong>二进制文件</strong>中，输入输出都需要<strong>强制转换为char类型指针</strong>后进行操作。这一点会在后面的代码示例中做进一步解释。</p><h4 id="打开二进制文件"><a href="#打开二进制文件" class="headerlink" title="打开二进制文件"></a>打开二进制文件</h4><p>对于二进制文件，<code>fstream</code> 提供了 <code>read</code> 和 <code>write</code> 方法，用于直接读写二进制数据。</p><p>使用 <code>fstream</code> 打开二进制文件时，需要指定文件模式为 <code>ios::binary</code>。<strong>使用方式和ASCII文件没有区别</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 打开二进制文件用于写入</span><br>    <span class="hljs-function">fstream <span class="hljs-title">file</span><span class="hljs-params">(<span class="hljs-string">&quot;data.bin&quot;</span>, ios::out | ios::binary)</span></span>;<br><br>    <span class="hljs-keyword">if</span> (!file) &#123;<br>        cerr &lt;&lt; <span class="hljs-string">&quot;文件打开失败！&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 文件操作...</span><br><br>    file.<span class="hljs-built_in">close</span>(); <span class="hljs-comment">// 关闭文件</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="写入二进制数据"><a href="#写入二进制数据" class="headerlink" title="写入二进制数据"></a><strong>写入二进制数据</strong></h4><p>使用 <code>write</code> 方法将二进制数据写入文件。<code>write</code> 方法的原型为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">ostream&amp; <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* buffer, streamsize size)</span></span>;<br></code></pre></td></tr></table></figure><ul><li><code>buffer</code>：指向要写入的数据的指针。</li><li><code>size</code>：要写入的字节数。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">fstream <span class="hljs-title">file</span><span class="hljs-params">(<span class="hljs-string">&quot;data.bin&quot;</span>, ios::out | ios::binary)</span></span>;<br>    <span class="hljs-keyword">if</span> (!file) &#123;<br>        cerr &lt;&lt; <span class="hljs-string">&quot;文件打开失败！&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span> data[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>    file.<span class="hljs-built_in">write</span>(<span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">char</span>*&gt;(data), <span class="hljs-built_in">sizeof</span>(data)); <span class="hljs-comment">// 写入二进制数据</span><br><br>    file.<span class="hljs-built_in">close</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>reinterpret_cast</code> 是 C++ 中的一种强制类型转换操作符。它可以将任意类型的指针转换为另一种类型的指针，而不改变指针指向的实际数据。它通常用于低级别的内存操作，例如将 <code>int*</code> 转换为 <code>char*</code>。在这里， <code>data</code> 的指针类型被转换为 <code>char*</code> 类型，以便可以按字节访问数据。</p><h4 id="读取二进制数据"><a href="#读取二进制数据" class="headerlink" title="读取二进制数据"></a><strong>读取二进制数据</strong></h4><p>使用 <code>read</code> 方法从二进制文件中读取数据。<code>read</code> 方法的原型为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">istream&amp; <span class="hljs-title">read</span><span class="hljs-params">(<span class="hljs-type">char</span>* buffer, streamsize size)</span></span>;<br></code></pre></td></tr></table></figure><ul><li><code>buffer</code>：指向存储读取数据的缓冲区的指针。</li><li><code>size</code>：要读取的字节数。</li></ul><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">fstream <span class="hljs-title">file</span><span class="hljs-params">(<span class="hljs-string">&quot;data.bin&quot;</span>, ios::in | ios::binary)</span></span>;<br>    <span class="hljs-keyword">if</span> (!file) &#123;<br>        cerr &lt;&lt; <span class="hljs-string">&quot;文件打开失败！&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span> data[<span class="hljs-number">5</span>];<br>    file.<span class="hljs-built_in">read</span>(<span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">char</span>*&gt;(data), <span class="hljs-built_in">sizeof</span>(data)); <span class="hljs-comment">// 读取二进制数据</span><br><br>    <span class="hljs-comment">// 输出读取的数据</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; ++i) &#123;<br>        cout &lt;&lt; data[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout &lt;&lt; endl;<br><br>    file.<span class="hljs-built_in">close</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="File-Pointer"><a href="#File-Pointer" class="headerlink" title="File Pointer"></a>File Pointer</h3><p>在上文的两种访问方式中，无论是对ASCII文件的访问还是对二进制文件的访问，都是<strong>顺序访问</strong>，即扫描一遍文件进行写入或输出等操作。但是，在实际应用中，我们需要更加灵活且高效的文件访问操作：例如<strong>只扫描文件的特定部分</strong>或者<strong>自定义扫描文件的顺序</strong>。换句话，我们需要程序能够自主控制<strong>操作位置的移动</strong>。因此，我们需要<strong>文件指针</strong>。</p><p><strong>文件指针</strong>是用于标识文件中当前位置的一个标记，它指示了下一个读取或写入操作将从文件的哪个位置开始。文件指针的概念在文件操作中非常重要，尤其是在<strong>随机访问文件</strong>时。</p><p>在 C++ 中，文件指针的操作主要通过以下函数实现：</p><ol><li><strong>移动文件指针</strong></li></ol><ul><li><p><code>seekg</code>：用于输入流，移动读取指针。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">istream&amp; <span class="hljs-title">seekg</span> <span class="hljs-params">(streampos pos)</span></span>; <span class="hljs-comment">// 移动到绝对位置</span><br><span class="hljs-function">istream&amp; <span class="hljs-title">seekg</span> <span class="hljs-params">(streamoff off, ios_base::seekdir way)</span></span>; <span class="hljs-comment">// 移动到相对位置</span><br></code></pre></td></tr></table></figure></li><li><p><code>seekp</code>：用于输出流，移动写入指针。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">ostream&amp; <span class="hljs-title">seekp</span> <span class="hljs-params">(streampos pos)</span></span>; <span class="hljs-comment">// 移动到绝对位置</span><br><span class="hljs-function">ostream&amp; <span class="hljs-title">seekp</span> <span class="hljs-params">(streamoff off, ios_base::seekdir way)</span></span>; <span class="hljs-comment">// 移动到相对位置</span><br></code></pre></td></tr></table></figure></li></ul><ol start="2"><li><strong>获取文件指针位置</strong></li></ol><ul><li><p><code>tellg</code>：用于输入流，返回当前读取指针的位置。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">streampos <span class="hljs-title">tellg</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure></li><li><p><code>tellp</code>：用于输出流，返回当前写入指针的位置。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">streampos <span class="hljs-title">tellp</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure></li></ul><blockquote><p><code>streampos</code> 是 C++ 标准库中用于表示<strong>流位置</strong>的数据类型。它通常用于标识文件流（如 <code>ifstream</code>、<code>ofstream</code> 等）中的位置，例如文件指针的位置。<code>streampos</code> 是一个与平台相关的类型，通常是一个整数类型（如 <code>long</code> 或 <code>long long</code>），用于表示从文件开头到某个位置的字节偏移量。</p></blockquote><h4 id="seekg和seekp"><a href="#seekg和seekp" class="headerlink" title="seekg和seekp"></a><code>seekg</code>和<code>seekp</code></h4><p>使用 <code>seekg</code> 和 <code>seekp</code> 可以移动文件指针，分别用于读取和写入操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">file.<span class="hljs-built_in">seekg</span>(<span class="hljs-number">0</span>, ios::beg); <span class="hljs-comment">// 将读取指针移动到文件开头</span><br>file.<span class="hljs-built_in">seekp</span>(<span class="hljs-number">0</span>, ios::end); <span class="hljs-comment">// 将写入指针移动到文件末尾</span><br></code></pre></td></tr></table></figure><div class="note note-info">            <p><code>seekg</code> 和 <code>seekp</code> 是 C++ 中用于文件流定位的成员函数，分别用于输入流和输出流。它们允许你在文件中移动读取或写入的位置。</p><p><code>seekg</code> 用于输入流（如 <code>ifstream</code>），用于设置文件读取位置。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">istream&amp; <span class="hljs-title">seekg</span> <span class="hljs-params">(streampos pos)</span></span>;<br><span class="hljs-function">istream&amp; <span class="hljs-title">seekg</span> <span class="hljs-params">(streamoff off, ios_base::seekdir way)</span></span>;<br></code></pre></td></tr></table></figure><ul><li><code>pos</code>：绝对位置，表示从文件开头到该位置的字节数。</li><li><code>off</code>：偏移量，表示相对于 <code>way</code> 的字节数。</li><li><code>way</code>：基准位置，可以是以下值之一：<ul><li><code>ios_base::beg</code>：文件开头。</li><li><code>ios_base::cur</code>：当前位置。</li><li><code>ios_base::end</code>：文件末尾。</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::ifstream <span class="hljs-title">file</span><span class="hljs-params">(<span class="hljs-string">&quot;example.txt&quot;</span>, std::ios::in | std::ios::binary)</span></span>;<br>    <span class="hljs-keyword">if</span> (file) &#123;<br>        file.<span class="hljs-built_in">seekg</span>(<span class="hljs-number">10</span>, std::ios::beg); <span class="hljs-comment">// 从文件开头移动10个字节</span><br>        <span class="hljs-type">char</span> buffer[<span class="hljs-number">20</span>];<br>        file.<span class="hljs-built_in">read</span>(buffer, <span class="hljs-number">20</span>); <span class="hljs-comment">// 读取20个字节</span><br>        std::cout.<span class="hljs-built_in">write</span>(buffer, <span class="hljs-number">20</span>);<br>        file.<span class="hljs-built_in">close</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>seekp</code> 用于输出流（如 <code>ofstream</code>），用于设置文件写入位置。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">ostream&amp; <span class="hljs-title">seekp</span> <span class="hljs-params">(streampos pos)</span></span>;<br><span class="hljs-function">ostream&amp; <span class="hljs-title">seekp</span> <span class="hljs-params">(streamoff off, ios_base::seekdir way)</span></span>;<br></code></pre></td></tr></table></figure><ul><li><code>pos</code>：绝对位置，表示从文件开头到该位置的字节数。</li><li><code>off</code>：偏移量，表示相对于 <code>way</code> 的字节数。</li><li><code>way</code>：基准位置，可以是以下值之一：<ul><li><code>ios_base::beg</code>：文件开头。</li><li><code>ios_base::cur</code>：当前位置。</li><li><code>ios_base::end</code>：文件末尾。</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::ofstream <span class="hljs-title">file</span><span class="hljs-params">(<span class="hljs-string">&quot;example.txt&quot;</span>, std::ios::out | std::ios::binary)</span></span>;<br>    <span class="hljs-keyword">if</span> (file) &#123;<br>        file.<span class="hljs-built_in">seekp</span>(<span class="hljs-number">10</span>, std::ios::beg); <span class="hljs-comment">// 从文件开头移动10个字节</span><br>        file.<span class="hljs-built_in">write</span>(<span class="hljs-string">&quot;Hello, World!&quot;</span>, <span class="hljs-number">13</span>); <span class="hljs-comment">// 写入13个字节</span><br>        file.<span class="hljs-built_in">close</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>          </div><h4 id="tellg和tellp"><a href="#tellg和tellp" class="headerlink" title="tellg和tellp"></a><code>tellg</code>和<code>tellp</code></h4><p><code>tellp</code> 和 <code>tellg</code> 是 C++ 中用于文件流位置操作的成员函数，分别用于输出流和输入流。它们的作用是返回当前文件指针的位置（以字节为单位）。</p><p><code>tellg</code> 用于输入流（如 <code>ifstream</code>），返回当前读取位置。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">streampos <span class="hljs-title">tellg</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><ul><li>返回一个 <code>streampos</code> 类型的值，表示当前读取位置（从文件开头的字节偏移量）。</li><li>如果失败，返回 <code>-1</code>。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::ifstream <span class="hljs-title">file</span><span class="hljs-params">(<span class="hljs-string">&quot;example.txt&quot;</span>, std::ios::in | std::ios::binary)</span></span>;<br>    <span class="hljs-keyword">if</span> (file) &#123;<br>        file.<span class="hljs-built_in">seekg</span>(<span class="hljs-number">10</span>, std::ios::beg); <span class="hljs-comment">// 移动读取位置到第10字节</span><br>        std::streampos pos = file.<span class="hljs-built_in">tellg</span>(); <span class="hljs-comment">// 获取当前读取位置</span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Current read position: &quot;</span> &lt;&lt; pos &lt;&lt; std::endl;<br>        file.<span class="hljs-built_in">close</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>tellp</code> 用于输出流（如 <code>ofstream</code>），返回当前写入位置。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">streampos <span class="hljs-title">tellp</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><ul><li>返回一个 <code>streampos</code> 类型的值，表示当前写入位置（从文件开头的字节偏移量）。</li><li>如果失败，返回 <code>-1</code>。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::ofstream <span class="hljs-title">file</span><span class="hljs-params">(<span class="hljs-string">&quot;example.txt&quot;</span>, std::ios::out | std::ios::binary)</span></span>;<br>    <span class="hljs-keyword">if</span> (file) &#123;<br>        file.<span class="hljs-built_in">seekp</span>(<span class="hljs-number">20</span>, std::ios::beg); <span class="hljs-comment">// 移动写入位置到第20字节</span><br>        std::streampos pos = file.<span class="hljs-built_in">tellp</span>(); <span class="hljs-comment">// 获取当前写入位置</span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Current write position: &quot;</span> &lt;&lt; pos &lt;&lt; std::endl;<br>        file.<span class="hljs-built_in">close</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="综合示例"><a href="#综合示例" class="headerlink" title="综合示例"></a>综合示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 写入数据到文件</span><br>    <span class="hljs-function">std::ofstream <span class="hljs-title">outFile</span><span class="hljs-params">(<span class="hljs-string">&quot;example.txt&quot;</span>, std::ios::out | std::ios::binary)</span></span>;<br>    <span class="hljs-keyword">if</span> (outFile) &#123;<br>        outFile &lt;&lt; <span class="hljs-string">&quot;Hello, World!&quot;</span>; <span class="hljs-comment">// 写入字符串</span><br>        std::streampos writePos = outFile.<span class="hljs-built_in">tellp</span>(); <span class="hljs-comment">// 获取当前写入位置</span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Write position after writing: &quot;</span> &lt;&lt; writePos &lt;&lt; std::endl;<br>        outFile.<span class="hljs-built_in">close</span>();<br>    &#125;<br><br>    <span class="hljs-comment">// 读取数据从文件</span><br>    <span class="hljs-function">std::ifstream <span class="hljs-title">inFile</span><span class="hljs-params">(<span class="hljs-string">&quot;example.txt&quot;</span>, std::ios::in | std::ios::binary)</span></span>;<br>    <span class="hljs-keyword">if</span> (inFile) &#123;<br>        inFile.<span class="hljs-built_in">seekg</span>(<span class="hljs-number">0</span>, std::ios::end); <span class="hljs-comment">// 移动读取位置到文件末尾</span><br>        std::streampos endPos = inFile.<span class="hljs-built_in">tellg</span>(); <span class="hljs-comment">// 获取文件大小</span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;File size: &quot;</span> &lt;&lt; endPos &lt;&lt; <span class="hljs-string">&quot; bytes&quot;</span> &lt;&lt; std::endl;<br><br>        inFile.<span class="hljs-built_in">seekg</span>(<span class="hljs-number">0</span>, std::ios::beg); <span class="hljs-comment">// 移动读取位置到文件开头</span><br>        <span class="hljs-type">char</span> buffer[<span class="hljs-number">100</span>];<br>        inFile.<span class="hljs-built_in">read</span>(buffer, endPos); <span class="hljs-comment">// 读取整个文件</span><br>        buffer[endPos] = <span class="hljs-string">&#x27;\0&#x27;</span>; <span class="hljs-comment">// 添加字符串结束符</span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;File content: &quot;</span> &lt;&lt; buffer &lt;&lt; std::endl;<br>        inFile.<span class="hljs-built_in">close</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Stream-based-files"><a href="#Stream-based-files" class="headerlink" title="Stream-based files"></a>Stream-based files</h3><p>这一部分的内容笔者将会单独拉出来更新一期，敬请期待。</p><h2 id="String-based-input-and-output"><a href="#String-based-input-and-output" class="headerlink" title="String-based input and output"></a>String-based input and output</h2><p>在 C++ 编程中，处理字符串和数字之间的转换是一项常见的任务。</p><p><code>sstream</code> 是 C++ 标准库中的一个组件，它提供了一种方便的方式来处理字符串流（可以像处理流一样处理字符串）。<code>&lt;sstream&gt;</code> 允许你将字符串当作输入&#x2F;输出流来使用，这使得从字符串中读取数据或将数据写入字符串变得非常简单。</p><h3 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h3><p><code>sstream</code>是 C++ 标准库中的一个命名空间，它包含了几个类，用于处理字符串流，这些类包括：</p><ul><li><code>istringstream</code>：用于从字符串中读取数据。</li><li><code>ostringstream</code>：用于将数据写入字符串。</li><li><code>stringstream</code>：是<code>istringstream</code>和<code>ostringstream</code>的组合，可以同时进行读取和写入操作。</li></ul><h3 id="Grammar"><a href="#Grammar" class="headerlink" title="Grammar"></a>Grammar</h3><p>使用<code>sstream</code>的基本语法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sstream&gt;</span></span><br><br><span class="hljs-comment">// 使用istringstream</span><br><span class="hljs-function">std::istringstream <span class="hljs-title">iss</span><span class="hljs-params">(<span class="hljs-string">&quot;some data&quot;</span>)</span></span>;<br><br><span class="hljs-comment">// 使用ostringstream</span><br>std::ostringstream oss;<br><br><span class="hljs-comment">// 使用stringstream</span><br>std::stringstream ss;<br></code></pre></td></tr></table></figure><h4 id="从字符串读取数据"><a href="#从字符串读取数据" class="headerlink" title="从字符串读取数据"></a>从字符串读取数据</h4><p>下面是一个使用 <code>istringstream</code> 从字符串中读取整数和浮点数的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sstream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  std::string data = <span class="hljs-string">&quot;10 20.5&quot;</span>;<br>  <span class="hljs-function">std::istringstream <span class="hljs-title">iss</span><span class="hljs-params">(data)</span></span>;<br><br>  <span class="hljs-type">int</span> i;<br>  <span class="hljs-type">double</span> d;<br><br>  iss &gt;&gt; i &gt;&gt; d;<br><br>  std::cout &lt;&lt; <span class="hljs-string">&quot;Integer: &quot;</span> &lt;&lt; i &lt;&lt; std::endl;<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;Double: &quot;</span> &lt;&lt; d &lt;&lt; std::endl;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>输出结果：</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Integer</span>: <span class="hljs-number">10</span><br><span class="hljs-attribute">Double</span>: <span class="hljs-number">20</span>.<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><h4 id="向字符串写入数据"><a href="#向字符串写入数据" class="headerlink" title="向字符串写入数据"></a>向字符串写入数据</h4><p>下面是一个使用 <code>ostringstream</code> 将数据写入字符串的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sstream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  std::ostringstream oss;<br>  <span class="hljs-type">int</span> i = <span class="hljs-number">100</span>;<br>  <span class="hljs-type">double</span> d = <span class="hljs-number">200.5</span>;<br><br>  oss &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; d;<br><br>  std::string result = oss.<span class="hljs-built_in">str</span>();<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;Resulting string: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>输出结果：</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Resulting</span> string: <span class="hljs-number">100</span> <span class="hljs-number">200</span>.<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><h4 id="使用stringstream进行读写操作"><a href="#使用stringstream进行读写操作" class="headerlink" title="使用stringstream进行读写操作"></a>使用stringstream进行读写操作</h4><p>下面是一个使用 <code>stringstream</code> 同时进行读取和写入操作的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sstream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  std::string data = <span class="hljs-string">&quot;30 40.5&quot;</span>;<br>  <span class="hljs-function">std::stringstream <span class="hljs-title">ss</span><span class="hljs-params">(data)</span></span>;<br><br>  <span class="hljs-type">int</span> i;<br>  <span class="hljs-type">double</span> d;<br><br>  <span class="hljs-comment">// 从stringstream读取数据</span><br>  ss &gt;&gt; i &gt;&gt; d;<br><br>  std::cout &lt;&lt; <span class="hljs-string">&quot;Read Integer: &quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;, Double: &quot;</span> &lt;&lt; d &lt;&lt; std::endl;<br><br>  <span class="hljs-comment">// 向stringstream写入数据</span><br>  ss.<span class="hljs-built_in">str</span>(<span class="hljs-string">&quot;&quot;</span>); <span class="hljs-comment">// 清空stringstream</span><br>  ss &lt;&lt; <span class="hljs-string">&quot;New data: &quot;</span> &lt;&lt; <span class="hljs-number">50</span> &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; <span class="hljs-number">60.7</span>;<br><br>  std::string newData = ss.<span class="hljs-built_in">str</span>();<br>  <span class="hljs-comment">//使用str()来实现字符串的写入。</span><br>  std::cout &lt;&lt; <span class="hljs-string">&quot;New data string: &quot;</span> &lt;&lt; newData &lt;&lt; std::endl;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>输出结果：</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Read</span> Integer: <span class="hljs-number">30</span>, Double: <span class="hljs-number">40</span>.<span class="hljs-number">5</span><br><span class="hljs-attribute">New</span> data string: New data: <span class="hljs-number">50</span> <span class="hljs-number">60</span>.<span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><p>例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    stringstream input;<br>    input&lt;&lt;<span class="hljs-string">&quot;hello world&quot;</span>;<br>    string a,b;<br>    input&gt;&gt;a&gt;&gt;b;<br>    cout&lt;&lt;a&lt;&lt;endl;<br>    cout&lt;&lt;b&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="字符串中的str"><a href="#字符串中的str" class="headerlink" title="字符串中的str()"></a>字符串中的<code>str()</code></h3><p><code>std::stringstream</code> 类提供了一个名为 <code>str</code> 的成员函数，用于<strong>获取和设置流中的字符串内容</strong>。这个函数有两个重载版本，一个是无参的，用于获取流中的字符串内容；另一个是带一个 <code>std::string</code> 参数的，用于设置流中的字符串内容。</p><h5 id="获取字符串内容"><a href="#获取字符串内容" class="headerlink" title="获取字符串内容"></a>获取字符串内容</h5><p>当你调用无参的 <code>str</code> 函数时，它会返回一个 <code>std::string</code>，包含当前流中的所有内容。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sstream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::stringstream ss;<br>    ss &lt;&lt; <span class="hljs-string">&quot;Hello, &quot;</span> &lt;&lt; <span class="hljs-string">&quot;world!&quot;</span>;<br>    std::string result = ss.<span class="hljs-built_in">str</span>(); <span class="hljs-comment">// 获取流中的内容</span><br>    std::cout &lt;&lt; result &lt;&lt; std::endl; <span class="hljs-comment">// 输出: Hello, world!</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="设置字符串内容"><a href="#设置字符串内容" class="headerlink" title="设置字符串内容"></a>设置字符串内容</h5><p>当你调用带 <code>std::string</code> 参数的 <code>str</code> 函数时，它会设置流的内容为指定的字符串，并清除之前的内容。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sstream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::stringstream ss;<br>    ss &lt;&lt; <span class="hljs-string">&quot;Initial content.&quot;</span>;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Before: &quot;</span> &lt;&lt; ss.<span class="hljs-built_in">str</span>() &lt;&lt; std::endl; <span class="hljs-comment">// 输出: Before: Initial content.</span><br><br>    ss.<span class="hljs-built_in">str</span>(<span class="hljs-string">&quot;New content.&quot;</span>); <span class="hljs-comment">// 设置新的内容</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;After: &quot;</span> &lt;&lt; ss.<span class="hljs-built_in">str</span>() &lt;&lt; std::endl; <span class="hljs-comment">// 输出: After: New content.</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="结合使用-str-和-clear-方法"><a href="#结合使用-str-和-clear-方法" class="headerlink" title="结合使用 str 和 clear 方法"></a>结合使用 <code>str</code> 和 <code>clear</code> 方法</h5><p>在重用 <code>std::stringstream</code> 对象时，通常会结合使用 <code>str</code> 方法和 <code>clear</code> 方法。<code>str</code> 方法用于设置新的字符串内容，而 <code>clear</code> 方法用于重置流的状态（例如，清除错误标志）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sstream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::stringstream ss;<br>    ss &lt;&lt; <span class="hljs-string">&quot;123 456&quot;</span>;<br>    <span class="hljs-type">int</span> a, b;<br>    ss &gt;&gt; a &gt;&gt; b;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;a: &quot;</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot;, b: &quot;</span> &lt;&lt; b &lt;&lt; std::endl; <span class="hljs-comment">// 输出: a: 123, b: 456</span><br><br>    ss.<span class="hljs-built_in">clear</span>(); <span class="hljs-comment">// 重置流的状态</span><br>    <span class="hljs-comment">//重置流的状态意味着清除流的状态标志（如错误标志、结束标志等），但并不改变流的内部缓冲区的内容。换句话说，重置状态让流恢复到一个干净的状态，但原有数据仍然保留。</span><br>    ss.<span class="hljs-built_in">str</span>(<span class="hljs-string">&quot;&quot;</span>); <span class="hljs-comment">// 清空流的内容</span><br><br>    ss &lt;&lt; <span class="hljs-string">&quot;789 1011&quot;</span>;<br>    ss &gt;&gt; a &gt;&gt; b;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;a: &quot;</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot;, b: &quot;</span> &lt;&lt; b &lt;&lt; std::endl; <span class="hljs-comment">// 输出: a: 789, b: 1011</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ul><li><code>str()</code>：无参版本用于获取流中的字符串内容。</li><li><code>str(const std::string &amp;s)</code>：带参数版本用于设置流中的字符串内容，并清除之前的内容。</li></ul><p>通过使用 <code>str</code> 方法，你可以方便地获取和设置 <code>std::stringstream</code> 对象中的字符串内容，从而实现灵活的字符串操作。</p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><ul><li>基于控制台的输入输出</li><li>基于文件的输入输出</li><li>基于字符串的输入输出</li></ul><blockquote><p>这一块的知识确实是有一点冗杂的<del>学会cin&#x2F;cout其实就可以解决大部分的输入输出问题了。建议本章节可以在实践中学习，效果更佳</del></p></blockquote><div class="note note-info">            <p><strong>至此，笔者有关C++语法专题的所有内容全部更新完成啦！！！完结撒花！！！</strong></p><p>梳理一下大概更新了些啥：</p><ul><li>面向对象编程——C++ Primer Plus专题<ul><li><a href="https://xiyuanyang-code.github.io/posts/Introduction-to-OOP/">OOP入门</a></li><li><a href="https://xiyuanyang-code.github.io/posts/Dynamic-Memory-and-Classes/">类和动态内存分配</a></li><li><a href="https://xiyuanyang-code.github.io/posts/Class-Inheritance/">类的继承</a></li><li><a href="https://xiyuanyang-code.github.io/posts/Code-Reuse-in-OOP/">代码重用和高阶技巧</a></li></ul></li><li><a href="https://xiyuanyang-code.github.io/posts/Linked-List-Implementation-Based-on-Structs/">基于结构体的链表实现代码</a></li><li><a href="https://xiyuanyang-code.github.io/posts/Exception-Handling-in-C-plus-plus/">C++中的异常处理</a></li><li><a href="https://xiyuanyang-code.github.io/posts/Pointers-Arrays-and-Functions/">数组——指针——函数</a></li><li><a href="https://xiyuanyang-code.github.io/posts/Input-and-Output-in-C-plus-plus/">C++中的输入输出</a></li></ul><p><strong>后续，笔者将会把更新的重点放在数据结构和算法以及Python语法和专业基础课上，敬请期待~</strong></p>          </div><blockquote><p>THE END</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Code</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tutorial</tag>
      
      <tag>C/C++</tag>
      
      <tag>Finished</tag>
      
      <tag>IO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DataStructure-Stack</title>
    <link href="/posts/DataStructure-Stack/"/>
    <url>/posts/DataStructure-Stack/</url>
    
    <content type="html"><![CDATA[<h1 id="数据结构——栈"><a href="#数据结构——栈" class="headerlink" title="数据结构——栈"></a>数据结构——栈</h1><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><h2 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h2><p><strong>栈（Stack）</strong>是一种特殊的线性表，在这种线性表中，<strong>插入和删除运算限制在表的某一端进行</strong>。<strong>进行插入和删除 的一段叫栈顶</strong>，另一端称为<strong>栈底</strong>。</p><p><strong>栈</strong>的最重要的性质是**后进先出(Last in, first out LIFO)**，即位于栈顶的元素相当于叠叠乐中最上面的人，最后入栈但最后出栈。</p><p><img src="https://www.hello-algo.com/chapter_stack_and_queue/stack.assets/stack_operations.png" alt="栈的先入后出规则 Hello 算法"></p><p><strong>栈的基本计算如下：</strong></p><ul><li>创建一个栈</li><li>进栈 <code>push()</code></li><li>出栈 <code>pop()</code></li><li>读取栈顶元素但不弹出 <code>top()</code></li><li>判断栈空 <code>isEmpty()</code></li></ul><h2 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h2><p>首先实现栈的抽象类：</p><blockquote><p>由于线性表的抽象类设置了许多纯虚函数，并且栈的许多操作实现和一般的线性表差异较大。因此此处无法直接继承线性表的抽象基类。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ElementType&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Stack</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Stack</span>() &#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">const</span> ElementType&amp; element)</span> </span>= <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> ElementType <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> ElementType <span class="hljs-title">top</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//同样设置为纯虚函数</span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="栈的顺序实现（类似于数组）"><a href="#栈的顺序实现（类似于数组）" class="headerlink" title="栈的顺序实现（类似于数组）"></a>栈的顺序实现（类似于数组）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Exception.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Stack.h&quot;</span></span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ElementType&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SequentialStack</span> : <span class="hljs-keyword">public</span> Stack&lt;ElementType&gt;<br>&#123;<br><span class="hljs-keyword">private</span>:<br>ElementType* elementData;<br>    <span class="hljs-comment">//存储栈元素的数组名</span><br><span class="hljs-type">int</span> topPosition, totalCapacity;<br>    <span class="hljs-comment">//栈顶序列和总容量</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">expand</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">SequentialStack</span>(<span class="hljs-type">int</span> size = <span class="hljs-number">10</span>);<br>~<span class="hljs-built_in">SequentialStack</span>();<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">const</span> ElementType&amp; element)</span></span>;<br><span class="hljs-function">ElementType <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function">ElementType <span class="hljs-title">top</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ElementType&gt;<br><span class="hljs-type">void</span> SequentialStack&lt;ElementType&gt;::<span class="hljs-built_in">expand</span>()<br>    <span class="hljs-comment">//私有成员函数</span><br>&#123;<br>ElementType* TempData = elementData;<br>totalCapacity *= <span class="hljs-number">2</span>;<span class="hljs-comment">//将栈的容量扩大两倍</span><br>elementData = <span class="hljs-keyword">new</span> ElementType[totalCapacity];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= topPosition; i++)<br>elementData[i] = TempData[i];<br><span class="hljs-keyword">delete</span>[] TempData;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ElementType&gt;<br>SequentialStack&lt;ElementType&gt;::<span class="hljs-built_in">SequentialStack</span>(<span class="hljs-type">int</span> size)<span class="hljs-comment">//构造函数</span><br>&#123;<br>elementData = <span class="hljs-keyword">new</span> ElementType[size];<br>totalCapacity = size;<br>topPosition = <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ElementType&gt;<br>SequentialStack&lt;ElementType&gt;::~<span class="hljs-built_in">SequentialStack</span>()<span class="hljs-comment">//destructor</span><br>&#123;<br><span class="hljs-keyword">delete</span>[] elementData;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ElementType&gt;<br><span class="hljs-type">bool</span> SequentialStack&lt;ElementType&gt;::<span class="hljs-built_in">empty</span>() <span class="hljs-type">const</span><br>&#123;<br><span class="hljs-keyword">return</span> topPosition == <span class="hljs-number">-1</span>;<br>    <span class="hljs-comment">//清空栈顶，将栈顶序列设置为特殊的-1</span><br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ElementType&gt;<br><span class="hljs-type">void</span> SequentialStack&lt;ElementType&gt;::<span class="hljs-built_in">push</span>(<span class="hljs-type">const</span> ElementType&amp; element)<br>&#123;<br><span class="hljs-keyword">if</span> (topPosition == totalCapacity - <span class="hljs-number">1</span>)<br><span class="hljs-built_in">expand</span>();<br>    <span class="hljs-comment">//说明已经存储不下了</span><br>elementData[++topPosition] = element;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ElementType&gt;<br>ElementType SequentialStack&lt;ElementType&gt;::<span class="hljs-built_in">pop</span>()<br>&#123;<br><span class="hljs-keyword">if</span> (topPosition == <span class="hljs-number">-1</span>)<br><span class="hljs-keyword">throw</span> <span class="hljs-built_in">EmptyContainer</span>(<span class="hljs-string">&quot;Error: Stack is already empty&quot;</span>);<br><span class="hljs-keyword">return</span> elementData[topPosition--];<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ElementType&gt;<br>ElementType SequentialStack&lt;ElementType&gt;::<span class="hljs-built_in">top</span>() <span class="hljs-type">const</span><br>&#123;<br><span class="hljs-keyword">if</span> (topPosition == <span class="hljs-number">-1</span>)<br><span class="hljs-keyword">throw</span> <span class="hljs-built_in">EmptyContainer</span>(<span class="hljs-string">&quot;Error: Stack is already empty&quot;</span>);<br><span class="hljs-keyword">return</span> elementData[topPosition];<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ElementType&gt;<br><span class="hljs-type">void</span> SequentialStack&lt;ElementType&gt;::<span class="hljs-built_in">clear</span>()<br>&#123;<br>topPosition = <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><code>topPosition</code>代表栈当前的栈顶序列，如果现在栈有3个元素，这栈顶序列为2。空栈的栈顶序列为-1。</p></blockquote><p>顺序<strong>栈的运算复杂度非常低</strong>：除了进栈操作需要扩充的特殊情况（即调用<code>expand()</code>函数），其余运算的时间复杂度均为<code>O(1)</code>。</p><h3 id="栈的链接实现"><a href="#栈的链接实现" class="headerlink" title="栈的链接实现"></a>栈的链接实现</h3><p>在栈的链接实现中，栈顶元素就相当于是<strong>头结点</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Exception.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Stack.h&quot;</span></span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ElementType&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkedStack</span> : <span class="hljs-keyword">public</span> Stack&lt;ElementType&gt;<br>&#123;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">StackNode</span><br>        <span class="hljs-comment">//和链表一样定义节点</span><br>&#123;<br>ElementType data;<br>StackNode* next;<br><span class="hljs-built_in">StackNode</span>() : <span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br><span class="hljs-built_in">StackNode</span>(<span class="hljs-type">const</span> ElementType&amp; _data, StackNode* _next = <span class="hljs-literal">nullptr</span>) : <span class="hljs-built_in">data</span>(_data), <span class="hljs-built_in">next</span>(_next) &#123;&#125;<br>~<span class="hljs-built_in">StackNode</span>() &#123;&#125;<br>&#125;;<br>StackNode* head;<br>    <span class="hljs-comment">//需要维护一个指针始终指向头结点</span><br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">LinkedStack</span>();<br>~<span class="hljs-built_in">LinkedStack</span>();<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">const</span> ElementType&amp; element)</span></span>;<br><span class="hljs-function">ElementType <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function">ElementType <span class="hljs-title">top</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ElementType&gt;<br>LinkedStack&lt;ElementType&gt;::<span class="hljs-built_in">LinkedStack</span>()<br>&#123;<br>head = <span class="hljs-literal">nullptr</span>;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ElementType&gt;<br>LinkedStack&lt;ElementType&gt;::~<span class="hljs-built_in">LinkedStack</span>()<br>&#123;<br><span class="hljs-built_in">clear</span>();<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ElementType&gt;<br><span class="hljs-type">bool</span> LinkedStack&lt;ElementType&gt;::<span class="hljs-built_in">empty</span>() <span class="hljs-type">const</span><br>&#123;<br><span class="hljs-keyword">return</span> head == <span class="hljs-literal">nullptr</span>;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ElementType&gt;<br><span class="hljs-type">void</span> LinkedStack&lt;ElementType&gt;::<span class="hljs-built_in">push</span>(<span class="hljs-type">const</span> ElementType&amp; element)<br>&#123;<br>head = <span class="hljs-keyword">new</span> <span class="hljs-built_in">StackNode</span>(element, head);<br>    <span class="hljs-comment">//从右向左读，使用构造函数创建了一个临时变量，值为element，指向的节点是当前head的地址。</span><br>    <span class="hljs-comment">//现在将它对head进行赋值，则head指向的地址发生改变(指向现在新的栈顶元素)，而原来的栈顶元素变成了head-&gt;next所指向的</span><br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ElementType&gt;<br>ElementType LinkedStack&lt;ElementType&gt;::<span class="hljs-built_in">pop</span>()<br>&#123;<br><span class="hljs-keyword">if</span> (head == <span class="hljs-literal">nullptr</span>)<br><span class="hljs-keyword">throw</span> <span class="hljs-built_in">EmptyContainer</span>(<span class="hljs-string">&quot;Error: Stack is already empty&quot;</span>);<br>StackNode* temp = head;<br>ElementType value = temp-&gt;data;<br>head = head-&gt;next;<br>    <span class="hljs-comment">//此时head指向的下一个节点成为新的栈顶元素</span><br><span class="hljs-keyword">delete</span> temp;<br><span class="hljs-keyword">return</span> value;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ElementType&gt;<br>ElementType LinkedStack&lt;ElementType&gt;::<span class="hljs-built_in">top</span>() <span class="hljs-type">const</span><br>&#123;<br><span class="hljs-keyword">if</span> (head == <span class="hljs-literal">nullptr</span>)<br><span class="hljs-keyword">throw</span> <span class="hljs-built_in">EmptyContainer</span>(<span class="hljs-string">&quot;Error: Stack is already empty&quot;</span>);<br><span class="hljs-keyword">return</span> head-&gt;data;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ElementType&gt;<br><span class="hljs-type">void</span> LinkedStack&lt;ElementType&gt;::<span class="hljs-built_in">clear</span>()<br>&#123;<br>StackNode* temp;<br><span class="hljs-keyword">while</span> (head != <span class="hljs-literal">nullptr</span>)<br>&#123;<br>temp = head;<br>head = head-&gt;next;<br><span class="hljs-keyword">delete</span> temp;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>栈的链接实现</strong>在效率上优于栈的顺序实现，因为<strong>不用扩容</strong>，不用维护<code>topPosition</code>。</p><h2 id="Stack-in-STL"><a href="#Stack-in-STL" class="headerlink" title="Stack in STL"></a>Stack in STL</h2><p>STL中的栈有四个基本运算：</p><ul><li><code>push</code>（进栈）</li><li><code>pop</code>（出栈）</li><li><code>top</code>（返回首元素）</li><li><code>empty</code>（检查栈是否为空）</li></ul><p>以下是一个实例代码，展示了栈的若干基本操作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 创建一个整数栈</span><br>    std::stack&lt;<span class="hljs-type">int</span>&gt; s;<br><br>    <span class="hljs-comment">// 压入元素</span><br>    s.<span class="hljs-built_in">push</span>(<span class="hljs-number">10</span>);<br>    s.<span class="hljs-built_in">push</span>(<span class="hljs-number">20</span>);<br>    s.<span class="hljs-built_in">push</span>(<span class="hljs-number">30</span>);<br><br>    <span class="hljs-comment">// 获取栈顶元素</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;栈顶元素: &quot;</span> &lt;&lt; s.<span class="hljs-built_in">top</span>() &lt;&lt; std::endl;  <span class="hljs-comment">// 输出 30</span><br><br>    <span class="hljs-comment">// 弹出栈顶元素</span><br>    s.<span class="hljs-built_in">pop</span>();<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;弹出后栈顶元素: &quot;</span> &lt;&lt; s.<span class="hljs-built_in">top</span>() &lt;&lt; std::endl;  <span class="hljs-comment">// 输出 20</span><br><br>    <span class="hljs-comment">// 栈是否为空</span><br>    <span class="hljs-keyword">if</span> (!s.<span class="hljs-built_in">empty</span>()) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;栈不为空，元素个数: &quot;</span> &lt;&lt; s.<span class="hljs-built_in">size</span>() &lt;&lt; std::endl;  <span class="hljs-comment">// 输出 2</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><code>stack</code> 默认使用 <code>deque</code> 作为底层容器，但也可以通过模板参数指定其他容器，如 <code>vector</code> 或 <code>list</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">std::stack&lt;<span class="hljs-type">int</span>, std::vector&lt;<span class="hljs-type">int</span>&gt;&gt; s;  <span class="hljs-comment">// 使用 vector 作为底层容器</span><br>std::stack&lt;<span class="hljs-type">int</span>, std::list&lt;<span class="hljs-type">int</span>&gt;&gt; s;    <span class="hljs-comment">// 使用 list 作为底层容器（链接栈的实现）</span><br></code></pre></td></tr></table></figure><blockquote><p><code>deque</code>（双端队列）是 C++ 标准库中提供的一个容器，它可以在两端高效地插入或删除元素。它的名字 <code>deque</code> 是 “double-ended queue” 的缩写，表示它支持在队列的两端进行操作。我们在下一讲介绍队列的时候会详细介绍<code>deque</code>的用法。</p></blockquote><h2 id="Application"><a href="#Application" class="headerlink" title="Application"></a>Application</h2><h3 id="Recursive-cleaning"><a href="#Recursive-cleaning" class="headerlink" title="Recursive cleaning"></a>Recursive cleaning</h3><h4 id="Recursion"><a href="#Recursion" class="headerlink" title="Recursion"></a>Recursion</h4><p>我们常常使用<strong>递归</strong>（函数嵌套函数）的方法解决问题，但是，递归会消耗<strong>大量的时间和空间复杂度。</strong>为什么？下面我们先来详细地从内存视角解释一下递归的产生机理。</p><p>在内存管理中，所谓的“栈”内存（stack memory）就是<strong>栈</strong>的操作模式相似，按照一定的规则进行分配和回收。栈内存（stack memory）主要用于<strong>存储局部变量、函数参数、函数调用的返回地址</strong>等数据。它的分配和回收非常迅速，通常是由操作系统自动管理的。栈内存的特点如下：</p><ul><li><strong>后进先出（LIFO）</strong>：栈内存的分配和回收遵循“后进先出”的规则，最近压入栈的数据会最先被弹出，这与栈数据结构的操作模式一致。</li><li><strong>自动管理</strong>：栈内存的分配和释放由系统自动管理，通常是函数的调用和返回过程中，栈帧（stack frame）的创建和销毁。</li><li><strong>空间有限</strong>：栈的大小通常是固定的，超过限制时会发生栈溢出（stack overflow）。</li></ul><p><img src="/posts/Above-All/ure-Stack/Recursion.png" alt="Recursion"></p><p>我们先来看一种比较特殊的情况，<strong>函数的嵌套调用</strong>。在<code>main</code>函数中，函数调用<code>max</code>函数，在<code>max</code>函数中，函数调用<code>p</code>函数，形成了函数调用的一种<strong>三层嵌套</strong>。上文讲过，<strong>函数体内部的局部变量</strong>通常是存储在栈内存上的。这些局部变量在函数调用时被创建，并在函数返回时自动销毁（具体的过程如上图右侧所演示）。也就是说，当函数嵌套的层数变多时，系统执行这一个过程所需的<strong>最大栈内存</strong>会不断递增。</p><p>回到递归的例子，当递归层数增多时，在<strong>栈内存</strong>上的<strong>栈帧空间</strong>会不断变大（因为上一级的函数没有返回对应的值，函数的调用没有结束，所有栈内存上会一直保留着函数的上下文）。<strong>这会带来极大的内存消耗！！！</strong></p><blockquote><p>目前一些编译器对<strong>尾递归</strong>优化可以不保留上下文，但是对于没有尾递归的情况（例如回溯算法），则栈内存的低效使用是<strong>递归</strong>不得不面对的问题。</p></blockquote><p><img src="https://www.hello-algo.com/chapter_computational_complexity/iteration_and_recursion.assets/recursion_sum_depth.png" alt="递归调用深度 Hello 算法"></p><h4 id="Using-Stack-instead-of-Recursion"><a href="#Using-Stack-instead-of-Recursion" class="headerlink" title="Using Stack instead of Recursion"></a>Using Stack instead of Recursion</h4><p>下面看一个程序实例：我们需要打印正整数的值：</p><blockquote><p>没事找事做的程序（乐）</p></blockquote><p>如果使用递归函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(num&lt;<span class="hljs-number">10</span>)&#123;<br>        cout&lt;&lt;num;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-built_in">print</span>(num/<span class="hljs-number">10</span>);  <span class="hljs-comment">//Recursion</span><br>        cout&lt;&lt;num%<span class="hljs-number">10</span>;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> N;cin&gt;&gt;N;<br>    <span class="hljs-built_in">print</span>(N);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个递归实现本身较为简单，但是当递归深度较大时，该算法对<strong>栈内存的利用率</strong>非常低，例如，系统会在栈内存上分配<strong>栈帧</strong>，即为每一层函数存储局部变量、函数参数、返回地址等信息。但是，我们只希望存储一个值！</p><p>因此，我们可以<strong>从内存的视角优化递归算法</strong>。使用栈消除递归就是程序员<strong>自己模拟函数的调用</strong>，自己维护一个<strong>栈</strong>来存储目标值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> num)</span></span>&#123;<br>    stack&lt;<span class="hljs-type">int</span>&gt; s;<br>    <span class="hljs-type">int</span> tmp;<br>    <span class="hljs-type">int</span> maxsize=<span class="hljs-number">0</span>;<br>    s.<span class="hljs-built_in">push</span>(num);<br>    maxsize++;<br>    <span class="hljs-keyword">while</span>(!s.<span class="hljs-built_in">empty</span>())&#123;<br>        <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">top</span>()&gt;<span class="hljs-number">9</span>)&#123;<br>            tmp=s.<span class="hljs-built_in">top</span>();<br>            s.<span class="hljs-built_in">pop</span>();<br>            s.<span class="hljs-built_in">push</span>(tmp%<span class="hljs-number">10</span>);<br>            s.<span class="hljs-built_in">push</span>(tmp/<span class="hljs-number">10</span>);<br>            maxsize=<span class="hljs-built_in">max</span>(maxsize,<span class="hljs-built_in">int</span>(s.<span class="hljs-built_in">size</span>()));<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            cout&lt;&lt;s.<span class="hljs-built_in">top</span>();<br>            s.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;endl&lt;&lt;<span class="hljs-string">&quot;The maxsize of the stack: &quot;</span>&lt;&lt;maxsize&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> N;cin&gt;&gt;N;<br>    <span class="hljs-built_in">print</span>(N);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-number">1234567</span><br><span class="hljs-number">1234567</span><br>The maxsize of the stack: <span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><p><strong>从内存视角来比较两者的差异：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span></span>&#123;<br>    cout&lt;&lt;&amp;num&lt;&lt;endl;<br>    <span class="hljs-keyword">if</span>(num&lt;<span class="hljs-number">10</span>)&#123;<br>        cout&lt;&lt;num;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-built_in">print</span>(num/<span class="hljs-number">10</span>);<br>        cout&lt;&lt;num%<span class="hljs-number">10</span>;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> N;cin&gt;&gt;N;<br>    <span class="hljs-built_in">print</span>(N);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-number">1234567</span><br><span class="hljs-number">0</span>x61fdf0<br><span class="hljs-number">0</span>x61fdc0<br><span class="hljs-number">0</span>x61fd90<br><span class="hljs-number">0</span>x61fd60<br><span class="hljs-number">0</span>x61fd30<br><span class="hljs-number">0</span>x61fd00<br><span class="hljs-number">0</span>x61fcd0<br><span class="hljs-number">1234567</span><br></code></pre></td></tr></table></figure><p>可以看出，<strong>函数的递归深度为7</strong>，<strong>自定义的栈的内存最大值也为7</strong>。但是在函数调用时，仅函数调用就用了288bytes，而栈的内存仅仅只是224bytes。（估算）</p><blockquote><p>虽然相差只是几个字节的差距，但是<strong>一旦递归深度变大且数据类型本身所占内存数变多</strong>，这个开销将会大大的增长。</p></blockquote><h3 id="括号配对"><a href="#括号配对" class="headerlink" title="括号配对"></a>括号配对</h3><p>在敲代码的过程中，相信大家都会遇到过<strong>括号太多或者括号不匹配</strong>的情况。编译器需要检查<strong>括号匹配</strong>的情况，并在发现异常时及时地报错。但是，括号具有多种类型：<code>()``[]``&#123;&#125;</code>，并且有些相互匹配的括号之间的间隔非常遥远。我们能够仅在<strong>一次扫描的过程中</strong>完成对括号配对的检查？</p><p>下面为了方便，我们将<code>([&#123;</code>称为开括号，将<code>)]&#125;</code>称为闭括号。</p><p>这个问题使用<strong>栈</strong>，可以很高效地解决。基本思路是：<strong>遇到闭括号时，将与最近遇到的且尚未被匹配的开括号进行匹配。</strong></p><blockquote><p>“<strong>最近遇到的</strong>的括号”和<strong>栈</strong>的LIFO特性不谋而合！</p></blockquote><p>确定基本算法的思想后，我们来细分到每一个步骤的实现：</p><div class="note note-primary">            <ul><li>创建一个栈来维护括号的存储。（更具体来说：<strong>维护开括号的存储</strong>）</li><li>如果读取到一个开括号，进栈。<ul><li>因为<strong>匹配工作是依据闭括号来进行的，所以开括号进栈的时候不需要额外的操作。</strong></li></ul></li><li>如果读取到一个闭括号，则与栈顶的开括号进行匹配。（位于栈顶的开括号就是最近遇到的且尚未被匹配的开括号）<ul><li>如果匹配成功，那么这一对括号匹配成功，将开括号弹出栈。</li><li><strong>如果匹配失败，说明无法匹配。（例如<code>[{(}]</code>)，直接<code>return false</code>。</strong></li><li>如果此时栈已空，则说明不匹配。（闭括号的数量多于开括号的数量）</li></ul></li><li>完成所有的扫描后，若栈非空，则说明开括号的数量多于闭括号的数量。匹配失败。</li></ul>          </div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">judgethemarkers</span><span class="hljs-params">(string s)</span></span>&#123;<br>    stack&lt;<span class="hljs-type">char</span>&gt; themarker;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> ch:s)&#123;<br>        <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;(&#x27;</span>||ch==<span class="hljs-string">&#x27;[&#x27;</span>||ch==<span class="hljs-string">&#x27;&#123;&#x27;</span>)&#123;<br>            themarker.<span class="hljs-built_in">push</span>(ch);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">if</span>(themarker.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-type">char</span> check=themarker.<span class="hljs-built_in">top</span>();<br>            <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;]&#x27;</span>&amp;&amp;check==<span class="hljs-string">&#x27;[&#x27;</span>) themarker.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;)&#x27;</span>&amp;&amp;check==<span class="hljs-string">&#x27;(&#x27;</span>) themarker.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;&#125;&#x27;</span>&amp;&amp;check==<span class="hljs-string">&#x27;&#123;&#x27;</span>) themarker.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(!themarker.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    string s;<br>    cin&gt;&gt;s;<br>    cout&lt;&lt;(<span class="hljs-built_in">judgethemarkers</span>(s)?<span class="hljs-string">&quot;Successful&quot;</span>:<span class="hljs-string">&quot;Unsuccessful&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>至此，栈的扫描功能已经完全实现，但是还有很多细节需要被优化：</p><ul><li>当括号出现在<strong>字符串，字符常量，注释</strong>中时，我们不希望括号被统计。</li><li>实现更高级的功能，例如定位到具体哪个位置的括号匹配出现问题。</li></ul><p>为此，我们实现一个更加复杂的<code>balance</code>类，作为一个检查文件中代码括号匹配的工具。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span>  <span class="hljs-comment">// for file input handling</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">balance</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>    ifstream fin;      <span class="hljs-comment">// File stream to be checked</span><br>    <span class="hljs-type">int</span> currentLine;   <span class="hljs-comment">// Current line being processed</span><br>    <span class="hljs-type">int</span> Errors;        <span class="hljs-comment">// Count of errors found</span><br><br>    <span class="hljs-comment">// Structure representing a symbol and its line number</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Symbol</span> &#123;<br>        <span class="hljs-type">char</span> Token;     <span class="hljs-comment">// Character token (e.g., braces, parentheses)</span><br>        <span class="hljs-type">int</span> TheLine;    <span class="hljs-comment">// Line number where the token is found</span><br>    &#125;;<br><br>    <span class="hljs-comment">// Enum for comment types</span><br>    <span class="hljs-keyword">enum</span> <span class="hljs-title class_">CommentType</span> &#123;<br>        SlashSlash,     <span class="hljs-comment">// C++ style comment (//)</span><br>        SlashStar       <span class="hljs-comment">// C style comment (/* */)</span><br>    &#125;;<br><br>    <span class="hljs-comment">// Utility functions for CheckBalance</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">CheckMatch</span><span class="hljs-params">(<span class="hljs-type">char</span> Symb1, <span class="hljs-type">char</span> Symb2, <span class="hljs-type">int</span> Line1, <span class="hljs-type">int</span> Line2)</span></span>; <span class="hljs-comment">// Check if two symbols match (e.g., &#x27;(&#x27; and &#x27;)&#x27;)</span><br>    <span class="hljs-function"><span class="hljs-type">char</span> <span class="hljs-title">GetNextSymbol</span><span class="hljs-params">()</span></span>;          <span class="hljs-comment">// Get the next valid symbol from the input</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PutBackChar</span><span class="hljs-params">(<span class="hljs-type">char</span> ch)</span></span>;     <span class="hljs-comment">// Push back a character to the input stream</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SkipComment</span><span class="hljs-params">(<span class="hljs-keyword">enum</span> CommentType type)</span></span>; <span class="hljs-comment">// Skip over comments (C or C++ style)</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SkipQuote</span><span class="hljs-params">(<span class="hljs-type">char</span> type)</span></span>;     <span class="hljs-comment">// Skip over quoted strings or characters</span><br>    <span class="hljs-function"><span class="hljs-type">char</span> <span class="hljs-title">NextChar</span><span class="hljs-params">()</span></span>;               <span class="hljs-comment">// Get the next character from the input file</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// Constructor: Opens the file for checking</span><br>    <span class="hljs-built_in">balance</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s);<br><br>    <span class="hljs-comment">// Check if the brackets/parentheses in the file are balanced</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">CheckBalance</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">noFile</span>&#123;&#125;;<span class="hljs-comment">//for the exception</span><br>&#125;;<br><br></code></pre></td></tr></table></figure><p>除了构造函数之外，公有函数只有<code>CheckBalance</code>，其他工具函数全部为私有函数的形式，用户不需要直接调用。（<strong>对用户而言只提供唯一的接口，对程序员而言将不同的子功能在内部封装。</strong>）</p><h3 id="简单的计算器"><a href="#简单的计算器" class="headerlink" title="简单的计算器"></a>简单的计算器</h3>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tutorial</tag>
      
      <tag>C/C++</tag>
      
      <tag>Finished</tag>
      
      <tag>Data Structure</tag>
      
      <tag>Stack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DataStructure-LinearList</title>
    <link href="/posts/DataStructure-LinearList/"/>
    <url>/posts/DataStructure-LinearList/</url>
    
    <content type="html"><![CDATA[<h1 id="数据结构——线性表"><a href="#数据结构——线性表" class="headerlink" title="数据结构——线性表"></a>数据结构——线性表</h1><p><a href="https://blog.csdn.net/weixin_73616913/article/details/130185228">封面图片出处</a></p><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>This article introduces the basic data structure of linear tables, including their sequential and linked implementations. At the same time, this paper gives the definitions of the abstract base class of linear tables and the header files and member functions of the derived classes of two linear tables, and finally introduces the linear tables in STL.</p><p>接下来，我们来看数据结构中第一种数据结构，也是最简单的一种数据结构——<strong>线性结构</strong></p><div class="note note-primary">            <p><strong>前置知识回顾</strong></p><p><strong>数据结构：建模——求解（基于数据结构的算法）</strong></p><ul><li>数据元素的存储：内置类型和结构体类型</li><li>数据关系的<strong>存储</strong>：<ul><li>顺序</li><li>链接</li><li>散列</li><li>索引</li></ul></li></ul>          </div><h2 id="线性结构"><a href="#线性结构" class="headerlink" title="线性结构"></a>线性结构</h2><p>特点：一对一，有序</p><blockquote><p>Definition：<strong>具有相同特征的节点构成的有序序列</strong></p></blockquote><p>首节点，尾节点，前继节点，后继结点</p><p><strong>分类</strong>：</p><ul><li>线性表（相对位置）</li><li>时间有序表（时间先后）<ul><li>栈（3）</li><li>队列（4）</li></ul></li><li>频率有序表（频率先后）</li><li>排序表（关键字值 Key）<ul><li>排序</li></ul></li></ul><h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><p><strong>仅有节点的相互位置</strong>来确定节点的关系。0,1,2,3,4,5…，n-1,n</p><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><ul><li>创建线性表</li><li>清除线性表</li><li>求长度</li><li>插入节点，删除节点，搜索节点：O（N）</li><li>扩充数组<ul><li>申请一个更大规模的动态数组</li><li>将原数组的内容拷贝到新的动态数组上</li><li>delete掉原来的数组</li><li>将新数组作为新的存储区</li></ul></li><li>索引</li><li>按序遍历访问</li></ul><h3 id="线性表的实现"><a href="#线性表的实现" class="headerlink" title="线性表的实现"></a>线性表的实现</h3><h4 id="顺序实现（数组）"><a href="#顺序实现（数组）" class="headerlink" title="顺序实现（数组）"></a>顺序实现（数组）</h4><p><img src="https://www.hello-algo.com/chapter_array_and_linkedlist/array.assets/array_definition.png" alt="数组定义与存储方式"></p><p><strong>使用物理位置的邻接关系表示逻辑的邻接关系</strong></p><p>优点：</p><ul><li>无需增加额外的存储空间</li><li>方便访问表中的任意节点</li></ul><p>缺点：<strong>插入和删除的操作效率低，空间浪费</strong></p><ul><li>指向线性表元素类型的指针</li><li>数组规模（最大的元素个数）</li><li>数组中的元素个数</li></ul><h4 id="链接实现（链表-）"><a href="#链接实现（链表-）" class="headerlink" title="链接实现（链表 ）"></a>链接实现（链表 ）</h4><p><img src="https://www.hello-algo.com/chapter_array_and_linkedlist/linked_list.assets/linkedlist_definition.png" alt="链表定义与存储方式"></p><ul><li>单链表，双链表，循环链表</li><li><strong>头结点</strong>：保证不用对首元素进行特殊讨论</li></ul><h2 id="线性表的类的实现"><a href="#线性表的类的实现" class="headerlink" title="线性表的类的实现"></a>线性表的类的实现</h2><ul><li>线性表的抽象类</li><li><strong>顺序表类</strong></li><li><strong>链接表类</strong></li></ul><blockquote><p>小tips：为了方便管理，以下的类实现都会使用<strong>动态内存分配</strong>到<strong>堆</strong>上，但实际上，堆的内存更容易碎片化，效率没有栈高</p></blockquote><h3 id="线性表的抽象类"><a href="#线性表的抽象类" class="headerlink" title="线性表的抽象类"></a>线性表的抽象类</h3><p><strong>类模板</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ElementType&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">List</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">List</span>() &#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">length</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">const</span> ElementType&amp; element)</span> </span>= <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> </span>= <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">const</span> ElementType&amp; element)</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> ElementType <span class="hljs-title">fetch</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">traverse</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><div class="note note-primary">            <p>有关线性表抽象基类的若干说明：</p><ul><li><code>=0</code>代表在<strong>抽象基类</strong>中函数在基类中不实现，只在派生类中实现。（这也符合抽象基类的设计原理）<ul><li><code>=0</code>代表这是所有派生类的共同特征，但是在不同的派生类中又有各自不同的实现方式</li></ul></li><li><code>const</code>代表不可以修改<strong>数据成员</strong></li><li>在抽象基类中并未定义数据成员，因为不同的线性表的实现方式中，节点的定义是不同的：<ul><li>在顺序表类中，节点就是直接的数据存储</li><li>在链接表类中，节点还需要包括指针（前驱指针和后继指针）</li></ul></li></ul>          </div><h3 id="顺序表类"><a href="#顺序表类" class="headerlink" title="顺序表类"></a>顺序表类</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Exception.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;List.h&quot;</span></span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ElementType&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SequentialList</span> : <span class="hljs-keyword">public</span> List&lt;ElementType&gt;<br>&#123;<br><span class="hljs-keyword">private</span>:<br>ElementType* elementData;<br><span class="hljs-type">int</span> currentLength, totalCapacity;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">expand</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">SequentialList</span>(<span class="hljs-type">int</span> size = <span class="hljs-number">10</span>);<br>~<span class="hljs-built_in">SequentialList</span>();<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">length</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">capacity</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">const</span> ElementType&amp; element)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">const</span> ElementType&amp; element)</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-function">ElementType <span class="hljs-title">fetch</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traverse</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-function">ElementType <span class="hljs-title">back</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">append</span><span class="hljs-params">(<span class="hljs-type">const</span> ElementType&amp; element)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">cancel</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">resize</span><span class="hljs-params">(<span class="hljs-type">int</span> size)</span></span>;<br>ElementType&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> index);<br>ElementType&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> index) <span class="hljs-type">const</span>;<br>&#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ElementType&gt;<br><span class="hljs-comment">//expand the list for a larger memory</span><br><span class="hljs-type">void</span> SequentialList&lt;ElementType&gt;::<span class="hljs-built_in">expand</span>()<br>&#123;<br>ElementType* tempData = elementData;<br>totalCapacity *= <span class="hljs-number">2</span>;<br>elementData = <span class="hljs-keyword">new</span> ElementType[totalCapacity];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; currentLength; i++)<br>elementData[i] = tempData[i];<br><span class="hljs-keyword">delete</span>[] tempData;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ElementType&gt;<br><span class="hljs-comment">//constructor function</span><br>SequentialList&lt;ElementType&gt;::<span class="hljs-built_in">SequentialList</span>(<span class="hljs-type">int</span> size)<br>&#123;<br>currentLength = <span class="hljs-number">0</span>;<br>totalCapacity = size;<br>elementData = <span class="hljs-keyword">new</span> ElementType[size];<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ElementType&gt;<br><span class="hljs-comment">//destructor function</span><br>SequentialList&lt;ElementType&gt;::~<span class="hljs-built_in">SequentialList</span>()<br>&#123;<br><span class="hljs-keyword">delete</span>[] elementData;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ElementType&gt;<br><span class="hljs-comment">//clear the list</span><br><span class="hljs-type">void</span> SequentialList&lt;ElementType&gt;::<span class="hljs-built_in">clear</span>()<br>&#123;<br>currentLength = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ElementType&gt;<br><span class="hljs-comment">//the const means the function cannot modify the value of the statics of the object</span><br><span class="hljs-type">int</span> SequentialList&lt;ElementType&gt;::<span class="hljs-built_in">length</span>() <span class="hljs-type">const</span><br>&#123;<br><span class="hljs-keyword">return</span> currentLength;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ElementType&gt;<br><span class="hljs-type">int</span> SequentialList&lt;ElementType&gt;::<span class="hljs-built_in">capacity</span>() <span class="hljs-type">const</span><br>&#123;<br><span class="hljs-keyword">return</span> totalCapacity;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ElementType&gt;<br><span class="hljs-comment">//insert the value on a certain index</span><br><span class="hljs-type">void</span> SequentialList&lt;ElementType&gt;::<span class="hljs-built_in">insert</span>(<span class="hljs-type">int</span> index, <span class="hljs-type">const</span> ElementType&amp; element)<br>&#123;<br><span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt; currentLength)<span class="hljs-comment">//the index is INVALID</span><br><span class="hljs-keyword">throw</span> <span class="hljs-built_in">IndexExceed</span>();<br><span class="hljs-keyword">if</span> (currentLength == totalCapacity)<br><span class="hljs-built_in">expand</span>();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = currentLength; i &gt; index; i--)<br>elementData[i] = elementData[i - <span class="hljs-number">1</span>];<br>    <span class="hljs-comment">//move each element backwards</span><br>elementData[index] = element;<br>currentLength++;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ElementType&gt;<br><span class="hljs-comment">//delete the element on a certain index</span><br><span class="hljs-type">void</span> SequentialList&lt;ElementType&gt;::<span class="hljs-built_in">remove</span>(<span class="hljs-type">int</span> index)<br>&#123;<br><span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt;= currentLength)<br><span class="hljs-keyword">throw</span> <span class="hljs-built_in">IndexExceed</span>();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = index; i &lt; currentLength - <span class="hljs-number">1</span>; i++)<br>elementData[i] = elementData[i + <span class="hljs-number">1</span>];<br>currentLength--;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ElementType&gt;<br><span class="hljs-type">int</span> SequentialList&lt;ElementType&gt;::<span class="hljs-built_in">find</span>(<span class="hljs-type">const</span> ElementType&amp; element) <span class="hljs-type">const</span><br>&#123;<br><span class="hljs-type">int</span> i;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; currentLength &amp;&amp; elementData[i] != element; i++)<br>;<br>    <span class="hljs-comment">//the loop end if the tarverse ends or the target element has been found</span><br><span class="hljs-keyword">if</span> (i == currentLength)<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> i;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ElementType&gt;<br>ElementType SequentialList&lt;ElementType&gt;::<span class="hljs-built_in">fetch</span>(<span class="hljs-type">int</span> index) <span class="hljs-type">const</span><br>&#123;<br><span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt;= currentLength)<br><span class="hljs-keyword">throw</span> <span class="hljs-built_in">IndexExceed</span>();<br><span class="hljs-keyword">return</span> elementData[index];<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ElementType&gt;<br><span class="hljs-type">void</span> SequentialList&lt;ElementType&gt;::<span class="hljs-built_in">traverse</span>() <span class="hljs-type">const</span><br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; currentLength; i++)<br>std::cout &lt;&lt; elementData[i] &lt;&lt; <span class="hljs-string">&quot;\t&quot;</span>;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ElementType&gt;<br>ElementType SequentialList&lt;ElementType&gt;::<span class="hljs-built_in">back</span>()<br>    <span class="hljs-comment">//return the last element</span><br>&#123;<br><span class="hljs-keyword">return</span> elementData[currentLength - <span class="hljs-number">1</span>];<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ElementType&gt;<br><span class="hljs-type">void</span> SequentialList&lt;ElementType&gt;::<span class="hljs-built_in">append</span>(<span class="hljs-type">const</span> ElementType&amp; element)<br>&#123;<br><span class="hljs-built_in">insert</span>(currentLength, element);<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ElementType&gt;<br><span class="hljs-type">void</span> SequentialList&lt;ElementType&gt;::<span class="hljs-built_in">cancel</span>()<br>&#123;<br><span class="hljs-built_in">remove</span>(currentLength - <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ElementType&gt;<br><span class="hljs-type">void</span> SequentialList&lt;ElementType&gt;::<span class="hljs-built_in">resize</span>(<span class="hljs-type">int</span> size)<br>&#123;<br><span class="hljs-keyword">if</span> (size &lt;= totalCapacity)<br><span class="hljs-keyword">throw</span> <span class="hljs-built_in">InvalidModify</span>();<br>ElementType* tempData = elementData;<br>totalCapacity = size;<br>elementData = <span class="hljs-keyword">new</span> ElementType[totalCapacity];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; currentLength; i++)<br>elementData[i] = tempData[i];<br><span class="hljs-keyword">delete</span>[] tempData;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ElementType&gt;<br>ElementType&amp; SequentialList&lt;ElementType&gt;::<span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> index)<br>&#123;<br><span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt;= currentLength)<br><span class="hljs-keyword">throw</span> <span class="hljs-built_in">IndexExceed</span>();<br><span class="hljs-keyword">return</span> elementData[index];<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ElementType&gt;<br>ElementType&amp; SequentialList&lt;ElementType&gt;::<span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> index) <span class="hljs-type">const</span><br>    <span class="hljs-comment">//Operator Overloading with const</span><br>&#123;<br><span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt;= currentLength)<br><span class="hljs-keyword">throw</span> <span class="hljs-built_in">IndexExceed</span>();<br><span class="hljs-keyword">return</span> elementData[index];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="单链表类"><a href="#单链表类" class="headerlink" title="单链表类"></a>单链表类</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Exception.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;List.h&quot;</span></span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ElementType&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SingleLinkedList</span> : <span class="hljs-keyword">public</span> List&lt;ElementType&gt;<br>&#123;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ListNode</span><br>&#123;<br>ElementType data;<br>ListNode* next;<br><span class="hljs-built_in">ListNode</span>() : <span class="hljs-built_in">data</span>(), <span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br><span class="hljs-built_in">ListNode</span>(<span class="hljs-type">const</span> ElementType&amp; _data, ListNode* _next = <span class="hljs-literal">nullptr</span>) : <span class="hljs-built_in">data</span>(_data), <span class="hljs-built_in">next</span>(_next) &#123;&#125;<br>        <span class="hljs-comment">//constructor</span><br>~<span class="hljs-built_in">ListNode</span>() &#123;&#125;<br>        <span class="hljs-comment">//destructor</span><br>&#125;;<br>ListNode* head;<br><span class="hljs-type">int</span> currentLength;<br><span class="hljs-function">ListNode* <span class="hljs-title">place</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> <span class="hljs-type">const</span></span>;<br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">SingleLinkedList</span>();<br>~<span class="hljs-built_in">SingleLinkedList</span>();<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">length</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">const</span> ElementType&amp; element)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">const</span> ElementType&amp; element)</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-function">ElementType <span class="hljs-title">fetch</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traverse</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">append</span><span class="hljs-params">(<span class="hljs-type">const</span> ElementType&amp; element)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">erase</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span></span>;<br>&#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ElementType&gt;<br><span class="hljs-keyword">typename</span> SingleLinkedList&lt;ElementType&gt;::ListNode* SingleLinkedList&lt;ElementType&gt;::<span class="hljs-built_in">place</span>(<span class="hljs-type">int</span> index) <span class="hljs-type">const</span><br>&#123;<br>ListNode* p = head;<br><span class="hljs-keyword">while</span> (index &gt;= <span class="hljs-number">0</span>)<br>&#123;<br>index--;<br>p = p-&gt;next;<br>&#125;<br><span class="hljs-keyword">return</span> p;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ElementType&gt;<br>SingleLinkedList&lt;ElementType&gt;::<span class="hljs-built_in">SingleLinkedList</span>()<br>&#123;<br>head = <span class="hljs-keyword">new</span> ListNode;<br>currentLength = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ElementType&gt;<br>SingleLinkedList&lt;ElementType&gt;::~<span class="hljs-built_in">SingleLinkedList</span>()<br>&#123;<br><span class="hljs-built_in">clear</span>();<br><span class="hljs-keyword">delete</span> head;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ElementType&gt;<br><span class="hljs-type">void</span> SingleLinkedList&lt;ElementType&gt;::<span class="hljs-built_in">clear</span>()<br>&#123;<br>ListNode* p = head-&gt;next, * q;<br>head-&gt;next = <span class="hljs-literal">nullptr</span>;<br><span class="hljs-keyword">while</span> (p != <span class="hljs-literal">nullptr</span>)<br>&#123;<br>q = p-&gt;next;<br><span class="hljs-keyword">delete</span> p;<br>p = q;<br>&#125;<br>currentLength = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ElementType&gt;<br><span class="hljs-type">int</span> SingleLinkedList&lt;ElementType&gt;::<span class="hljs-built_in">length</span>() <span class="hljs-type">const</span><br>&#123;<br><span class="hljs-keyword">return</span> currentLength;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ElementType&gt;<br><span class="hljs-type">void</span> SingleLinkedList&lt;ElementType&gt;::<span class="hljs-built_in">insert</span>(<span class="hljs-type">int</span> index, <span class="hljs-type">const</span> ElementType&amp; element)<br>&#123;<br><span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt; currentLength)<br><span class="hljs-keyword">throw</span> <span class="hljs-built_in">IndexExceed</span>();<br>ListNode* p = <span class="hljs-built_in">place</span>(index - <span class="hljs-number">1</span>);<br>p-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(element, p-&gt;next);<br>currentLength++;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ElementType&gt;<br><span class="hljs-type">void</span> SingleLinkedList&lt;ElementType&gt;::<span class="hljs-built_in">remove</span>(<span class="hljs-type">int</span> index)<br>&#123;<br><span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt;= currentLength)<br><span class="hljs-keyword">throw</span> <span class="hljs-built_in">IndexExceed</span>();<br>ListNode* p = <span class="hljs-built_in">place</span>(index - <span class="hljs-number">1</span>), * q = p-&gt;next;<br>p-&gt;next = q-&gt;next;<br><span class="hljs-keyword">delete</span> q;<br>currentLength--;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ElementType&gt;<br><span class="hljs-type">int</span> SingleLinkedList&lt;ElementType&gt;::<span class="hljs-built_in">find</span>(<span class="hljs-type">const</span> ElementType&amp; element) <span class="hljs-type">const</span><br>&#123;<br>ListNode* p = head-&gt;next;<br><span class="hljs-type">int</span> index = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (p != <span class="hljs-literal">nullptr</span> &amp;&amp; p-&gt;data != element)<br>&#123;<br>p = p-&gt;next;<br>index++;<br>&#125;<br><span class="hljs-keyword">if</span> (p == <span class="hljs-literal">nullptr</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> index;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ElementType&gt;<br>ElementType SingleLinkedList&lt;ElementType&gt;::<span class="hljs-built_in">fetch</span>(<span class="hljs-type">int</span> index) <span class="hljs-type">const</span><br>&#123;<br><span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt;= currentLength)<br><span class="hljs-keyword">throw</span> <span class="hljs-built_in">IndexExceed</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">place</span>(index)-&gt;data;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ElementType&gt;<br><span class="hljs-type">void</span> SingleLinkedList&lt;ElementType&gt;::<span class="hljs-built_in">traverse</span>() <span class="hljs-type">const</span><br>&#123;<br>ListNode* p = head-&gt;next;<br><span class="hljs-keyword">while</span> (p != <span class="hljs-literal">nullptr</span>)<br>&#123;<br>std::cout &lt;&lt; p-&gt;data &lt;&lt; <span class="hljs-string">&quot;\t&quot;</span>;<br>p = p-&gt;next;<br>&#125;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ElementType&gt;<br><span class="hljs-type">void</span> SingleLinkedList&lt;ElementType&gt;::<span class="hljs-built_in">append</span>(<span class="hljs-type">const</span> ElementType&amp; element)<br>&#123;<br><span class="hljs-built_in">insert</span>(currentLength, element);<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ElementType&gt;<br><span class="hljs-type">void</span> SingleLinkedList&lt;ElementType&gt;::<span class="hljs-built_in">erase</span>(<span class="hljs-type">int</span> index)<br>&#123;<br><span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt;= currentLength)<br><span class="hljs-keyword">throw</span> <span class="hljs-built_in">IndexExceed</span>();<br>ListNode* p = <span class="hljs-built_in">place</span>(index - <span class="hljs-number">1</span>), * q = p-&gt;next;<br>ElementType target = q-&gt;data;<br>p-&gt;next = q-&gt;next;<br><span class="hljs-keyword">delete</span> q;<br><span class="hljs-type">int</span> count = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (p = head; p-&gt;next != <span class="hljs-literal">nullptr</span>;)<br>&#123;<br><span class="hljs-keyword">if</span> (p-&gt;next-&gt;data == target)<br>&#123;<br>q = p-&gt;next;<br>p-&gt;next = q-&gt;next;<br><span class="hljs-keyword">delete</span> q;<br>count++;<br>&#125;<br><span class="hljs-keyword">else</span><br>p = p-&gt;next;<br>&#125;<br>currentLength -= count;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="STL：Standard-Template-Library"><a href="#STL：Standard-Template-Library" class="headerlink" title="STL：Standard Template Library"></a>STL：Standard Template Library</h2><p><strong>泛型思想</strong>：</p><ul><li>把算法和数据类型分离：<strong>模版函数</strong></li><li>把算法和容器分离：<strong>STL和迭代器</strong></li><li>把容器和数据类型分离：<strong>模板类</strong></li></ul><p>容器，迭代器，算法</p><p><strong>迭代器</strong>：为每一种容器定义的表示其元素相对位置的类型，迭代器对象相当于指向容器中指向对象的指针，他将容器中对象的位置信息封装了起来。<strong>从使用者的角度而言，可以把迭代器当作一种抽象的指针。</strong></p><p>每个容器提供两种迭代器，<code>const</code>和非<code>const</code></p><div class="note note-info">            <p><strong>补充知识点：迭代器中重载的常见运算符</strong></p><p>在 C++ 中，迭代器通常会重载一组运算符，以便像指针一样使用它们。这些运算符使得迭代器能够在容器中进行遍历、索引以及修改数据。具体来说，常见的迭代器会重载以下运算符：</p><ol><li><strong>解引用运算符 <code>\*</code></strong></li></ol><ul><li><p><strong>作用</strong>：访问迭代器当前指向的元素。</p></li><li><p>示例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;<span class="hljs-type">int</span>&gt; v = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br><span class="hljs-keyword">auto</span> it = v.<span class="hljs-built_in">begin</span>();<br>std::cout &lt;&lt; *it;  <span class="hljs-comment">// 输出 1，指向第一个元素</span><br></code></pre></td></tr></table></figure></li></ul><ol start="2"><li><strong>箭头运算符 <code>-&gt;</code></strong></li></ol><ul><li><p><strong>作用</strong>：通过迭代器访问指向对象的成员（适用于指向对象的迭代器，如 <code>std::map</code>、<code>std::unordered_map</code> 等）。</p></li><li><p>示例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; v = &#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;&#125;;<br><span class="hljs-keyword">auto</span> it = v.<span class="hljs-built_in">begin</span>();<br>std::cout &lt;&lt; it-&gt;first &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; it-&gt;second;  <span class="hljs-comment">// 输出 1, 2</span><br></code></pre></td></tr></table></figure></li></ul><ol start="3"><li><strong>前置递增运算符 <code>++</code></strong></li></ol><ul><li><p><strong>作用</strong>：将迭代器向前移动一个位置，指向容器中的下一个元素。</p></li><li><p>示例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;<span class="hljs-type">int</span>&gt; v = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br><span class="hljs-keyword">auto</span> it = v.<span class="hljs-built_in">begin</span>();<br>++it;  <span class="hljs-comment">// 将迭代器移动到第二个元素</span><br>std::cout &lt;&lt; *it;  <span class="hljs-comment">// 输出 2</span><br></code></pre></td></tr></table></figure></li></ul><ol start="4"><li><strong>后置递增运算符 <code>++</code></strong></li></ol><ul><li><p><strong>作用</strong>：与前置递增运算符类似，但它会返回移动前的迭代器，通常用于赋值操作中。</p></li><li><p>示例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;<span class="hljs-type">int</span>&gt; v = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br><span class="hljs-keyword">auto</span> it = v.<span class="hljs-built_in">begin</span>();<br><span class="hljs-keyword">auto</span> it_copy = it++;  <span class="hljs-comment">// it_copy 是移动前的迭代器，it 会向前移动</span><br>std::cout &lt;&lt; *it_copy;  <span class="hljs-comment">// 输出 1</span><br>std::cout &lt;&lt; *it;       <span class="hljs-comment">// 输出 2</span><br></code></pre></td></tr></table></figure></li></ul><ol start="5"><li><strong>前置递减运算符 <code>--</code></strong></li></ol><ul><li><p><strong>作用</strong>：将迭代器向后移动一个位置，指向容器中的前一个元素。</p></li><li><p>示例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;<span class="hljs-type">int</span>&gt; v = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br><span class="hljs-keyword">auto</span> it = v.<span class="hljs-built_in">end</span>();<br>--it;  <span class="hljs-comment">// 将迭代器移动到最后一个元素</span><br>std::cout &lt;&lt; *it;  <span class="hljs-comment">// 输出 4</span><br></code></pre></td></tr></table></figure></li></ul><ol start="6"><li><strong>后置递减运算符 <code>--</code></strong></li></ol><ul><li><p><strong>作用</strong>：与前置递减运算符类似，但它会返回移动前的迭代器。</p></li><li><p>示例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;<span class="hljs-type">int</span>&gt; v = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br><span class="hljs-keyword">auto</span> it = v.<span class="hljs-built_in">end</span>();<br><span class="hljs-keyword">auto</span> it_copy = it--;  <span class="hljs-comment">// it_copy 是移动前的迭代器，it 会向后移动</span><br>std::cout &lt;&lt; *it_copy;  <span class="hljs-comment">// 输出 4</span><br>std::cout &lt;&lt; *it;       <span class="hljs-comment">// 输出 3</span><br></code></pre></td></tr></table></figure></li></ul><ol start="7"><li><strong>比较运算符 <code>==</code> 和 <code>!=</code></strong></li></ol><ul><li><p><strong>作用</strong>：比较两个迭代器是否相等。对于容器中的元素，迭代器 <code>==</code> 表示它们指向同一个位置，<code>!=</code> 表示它们指向不同的位置。</p></li><li><p>示例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;<span class="hljs-type">int</span>&gt; v = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br><span class="hljs-keyword">auto</span> it1 = v.<span class="hljs-built_in">begin</span>();<br><span class="hljs-keyword">auto</span> it2 = v.<span class="hljs-built_in">begin</span>();<br><span class="hljs-keyword">auto</span> it3 = v.<span class="hljs-built_in">end</span>();<br><br>std::cout &lt;&lt; (it1 == it2);  <span class="hljs-comment">// 输出 1 (true)</span><br>std::cout &lt;&lt; (it1 != it3);  <span class="hljs-comment">// 输出 1 (true)</span><br></code></pre></td></tr></table></figure></li></ul><ol start="8"><li><strong>加法运算符 <code>+</code>（某些迭代器）</strong></li></ol><ul><li><p><strong>作用</strong>：允许迭代器跳过多个元素，通常返回一个新的迭代器。</p></li><li><p>示例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;<span class="hljs-type">int</span>&gt; v = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br><span class="hljs-keyword">auto</span> it = v.<span class="hljs-built_in">begin</span>();<br>it = it + <span class="hljs-number">2</span>;  <span class="hljs-comment">// 跳过两个元素，指向第三个元素</span><br>std::cout &lt;&lt; *it;  <span class="hljs-comment">// 输出 3</span><br></code></pre></td></tr></table></figure></li></ul><ol start="9"><li><strong>减法运算符 <code>-</code>（某些迭代器）</strong></li></ol><ul><li><p><strong>作用</strong>：允许迭代器向回跳过多个元素。</p></li><li><p>示例</p><p>（对于随机访问迭代器，如 <code>std::vector</code>）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;<span class="hljs-type">int</span>&gt; v = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br><span class="hljs-keyword">auto</span> it = v.<span class="hljs-built_in">end</span>();<br>it = it - <span class="hljs-number">2</span>;  <span class="hljs-comment">// 向回跳过两个元素，指向第三个元素</span><br>std::cout &lt;&lt; *it;  <span class="hljs-comment">// 输出 3</span><br></code></pre></td></tr></table></figure></li></ul><ol start="10"><li><strong>加法赋值运算符 <code>+=</code> 和 减法赋值运算符 <code>-=</code></strong></li></ol><ul><li><p><strong>作用</strong>：使迭代器向前或向后移动指定的步数。</p></li><li><p>示例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;<span class="hljs-type">int</span>&gt; v = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br><span class="hljs-keyword">auto</span> it = v.<span class="hljs-built_in">begin</span>();<br>it += <span class="hljs-number">2</span>;  <span class="hljs-comment">// 向前移动两个位置，指向第三个元素</span><br>std::cout &lt;&lt; *it;  <span class="hljs-comment">// 输出 3</span><br>it -= <span class="hljs-number">1</span>;  <span class="hljs-comment">// 向后移动一个位置</span><br>std::cout &lt;&lt; *it;  <span class="hljs-comment">// 输出 2</span><br></code></pre></td></tr></table></figure></li></ul><ol start="11"><li><strong>下标运算符 <code>[]</code>（适用于随机访问迭代器）</strong></li></ol><ul><li><p><strong>作用</strong>：通过下标访问迭代器当前所指向的元素。</p></li><li><p>示例</p><p>（对于随机访问迭代器，如 <code>std::vector</code>）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;<span class="hljs-type">int</span>&gt; v = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br><span class="hljs-keyword">auto</span> it = v.<span class="hljs-built_in">begin</span>();<br>std::cout &lt;&lt; it[<span class="hljs-number">2</span>];  <span class="hljs-comment">// 输出 3</span><br></code></pre></td></tr></table></figure></li></ul><p><strong>注意：8,9,10,11一般适用于随机访问迭代器（支持任意位置的跳跃访问和直接跳转，因此可以实现高效的前后移动），对应的容器有线性容器，如 <code>std::vector</code>、<code>std::deque</code>、<code>std::array</code> 和 <code>std::string</code><strong>，而</strong><code>std::set</code></strong> 和 **<code>std::map</code>**（以及它们的 <code>unordered</code> 版本），这些容器的迭代器也不支持随机访问，因为它们通常是基于树或哈希表的结构。</p>          </div><h3 id="STL中的线性表"><a href="#STL中的线性表" class="headerlink" title="STL中的线性表"></a>STL中的线性表</h3><p>在 C++ 标准库中，<code>std::vector</code> 和 <code>std::list</code> 是两个常用的容器类，它们分别代表动态数组和双向链表。虽然它们都实现了 <code>std::container</code> 的接口，但它们的内部结构和适用场景不同，因此提供的库函数也有所不同。</p><h4 id="1-std-vector-类的常见库函数"><a href="#1-std-vector-类的常见库函数" class="headerlink" title="1. std::vector 类的常见库函数"></a>1. <code>std::vector</code> 类的常见库函数</h4><p><code>std::vector</code> 是一个动态数组容器，支持随机访问。它非常适合用来存储需要频繁随机访问的数据。常见的成员函数包括：</p><h5 id="1-1-构造函数和赋值操作"><a href="#1-1-构造函数和赋值操作" class="headerlink" title="1.1 构造函数和赋值操作"></a>1.1 构造函数和赋值操作</h5><ul><li>**<code>vector()</code>**：默认构造函数，创建一个空的 <code>vector</code>。</li><li>**<code>vector(n)</code>**：构造一个包含 <code>n</code> 个默认值的 <code>vector</code>。</li><li>**<code>vector(n, value)</code>**：构造一个包含 <code>n</code> 个值为 <code>value</code> 的 <code>vector</code>。</li><li>**<code>vector(begin, end)</code>**：使用范围 <code>[begin, end)</code> 的元素来构造 <code>vector</code>。</li><li>**<code>operator=</code>**：赋值操作符，用于将一个 <code>vector</code> 赋值给另一个。</li></ul><h5 id="1-2-元素访问"><a href="#1-2-元素访问" class="headerlink" title="1.2 元素访问"></a>1.2 元素访问</h5><ul><li>**<code>operator[]</code>**：通过下标访问元素。</li><li>**<code>at()</code>**：通过下标访问元素，但会进行边界检查。</li><li>**<code>front()</code>**：返回第一个元素。</li><li>**<code>back()</code>**：返回最后一个元素。</li><li>**<code>data()</code>**：返回指向第一个元素的指针。</li></ul><h5 id="1-3-容量操作"><a href="#1-3-容量操作" class="headerlink" title="1.3 容量操作"></a>1.3 容量操作</h5><ul><li>**<code>size()</code>**：返回 <code>vector</code> 中元素的个数。</li><li>**<code>capacity()</code>**：返回 <code>vector</code> 的容量（即 <code>vector</code> 可以存储的最大元素个数，不一定等于 <code>size()</code>）。</li><li>**<code>empty()</code>**：检查 <code>vector</code> 是否为空。</li><li>**<code>reserve()</code>**：预留至少可以容纳 <code>n</code> 个元素的空间。</li><li>**<code>shrink_to_fit()</code>**：请求减少 <code>vector</code> 的容量，使其尽可能接近 <code>size()</code>，但不保证立即生效。</li></ul><h5 id="1-4-修改操作"><a href="#1-4-修改操作" class="headerlink" title="1.4 修改操作"></a>1.4 修改操作</h5><ul><li>**<code>push_back()</code>**：在 <code>vector</code> 的末尾添加元素。</li><li>**<code>pop_back()</code>**：删除 <code>vector</code> 中的最后一个元素。</li><li>**<code>insert()</code>**：在指定位置插入元素。</li><li>**<code>erase()</code>**：删除指定位置的元素。</li><li>**<code>clear()</code>**：删除 <code>vector</code> 中的所有元素。</li></ul><h5 id="1-5-迭代器和算法"><a href="#1-5-迭代器和算法" class="headerlink" title="1.5 迭代器和算法"></a>1.5 迭代器和算法</h5><ul><li>**<code>begin()</code>**：返回指向 <code>vector</code> 第一个元素的迭代器。</li><li>**<code>end()</code>**：返回指向 <code>vector</code> 末尾元素之后位置的迭代器。</li><li>**<code>rbegin()</code>**：返回指向 <code>vector</code> 最后一个元素的反向迭代器。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; v = &#123;<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>&#125;;<br><br>    <span class="hljs-comment">// 使用反向迭代器进行遍历</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = v.<span class="hljs-built_in">rbegin</span>(); it != v.<span class="hljs-built_in">rend</span>(); ++it) &#123;<br>        std::cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <span class="hljs-comment">// 输出: 50 40 30 20 10</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li>**<code>rend()</code>**：返回指向 <code>vector</code> 第一个元素之前的反向迭代器。</li></ul><h5 id="1-6-其他操作"><a href="#1-6-其他操作" class="headerlink" title="1.6 其他操作"></a>1.6 其他操作</h5><ul><li>**<code>swap()</code>**：交换两个 <code>vector</code> 的内容。</li><li>**<code>resize()</code>**：改变 <code>vector</code> 的大小，如果新大小大于当前大小，新增的元素会用默认值初始化。</li><li>**<code>emplace_back()</code>**：在 <code>vector</code> 末尾构造一个元素。</li><li>**<code>emplace()</code>**：在指定位置构造一个元素。</li></ul><h3 id="2-std-list-类的常见库函数"><a href="#2-std-list-类的常见库函数" class="headerlink" title="2. std::list 类的常见库函数"></a>2. <code>std::list</code> 类的常见库函数</h3><p><code>std::list</code> 是一个双向链表容器，适合用来执行大量的插入和删除操作。由于是链表结构，<code>std::list</code> 不支持随机访问，只能进行顺序访问。常见的成员函数包括：</p><h5 id="2-1-构造函数和赋值操作"><a href="#2-1-构造函数和赋值操作" class="headerlink" title="2.1 构造函数和赋值操作"></a>2.1 构造函数和赋值操作</h5><ul><li>**<code>list()</code>**：默认构造函数，创建一个空的 <code>list</code>。</li><li>**<code>list(n)</code>**：构造一个包含 <code>n</code> 个默认值的 <code>list</code>。</li><li>**<code>list(n, value)</code>**：构造一个包含 <code>n</code> 个值为 <code>value</code> 的 <code>list</code>。</li><li>**<code>list(begin, end)</code>**：使用范围 <code>[begin, end)</code> 的元素来构造 <code>list</code>。</li><li>**<code>operator=</code>**：赋值操作符，用于将一个 <code>list</code> 赋值给另一个。</li></ul><h5 id="2-2-元素访问"><a href="#2-2-元素访问" class="headerlink" title="2.2 元素访问"></a>2.2 元素访问</h5><ul><li>**<code>front()</code>**：返回 <code>list</code> 中的第一个元素。</li><li>**<code>back()</code>**：返回 <code>list</code> 中的最后一个元素。</li></ul><h5 id="2-3-容量操作"><a href="#2-3-容量操作" class="headerlink" title="2.3 容量操作"></a>2.3 容量操作</h5><ul><li>**<code>size()</code>**：返回 <code>list</code> 中元素的个数。</li><li>**<code>empty()</code>**：检查 <code>list</code> 是否为空。</li></ul><h5 id="2-4-修改操作"><a href="#2-4-修改操作" class="headerlink" title="2.4 修改操作"></a>2.4 修改操作</h5><ul><li>**<code>push_front()</code>**：将元素添加到 <code>list</code> 的前面。</li><li>**<code>push_back()</code>**：将元素添加到 <code>list</code> 的末尾。</li><li>**<code>pop_front()</code>**：删除 <code>list</code> 中的第一个元素。</li><li>**<code>pop_back()</code>**：删除 <code>list</code> 中的最后一个元素。</li><li>**<code>insert()</code>**：在指定位置插入一个元素。</li><li>**<code>erase()</code>**：删除指定位置的元素。</li><li>**<code>remove()</code>**：删除所有等于指定值的元素。</li><li>**<code>clear()</code>**：删除 <code>list</code> 中的所有元素。</li></ul><h5 id="2-5-迭代器和算法"><a href="#2-5-迭代器和算法" class="headerlink" title="2.5 迭代器和算法"></a>2.5 迭代器和算法</h5><ul><li>**<code>begin()</code>**：返回指向 <code>list</code> 第一个元素的迭代器。</li><li>**<code>end()</code>**：返回指向 <code>list</code> 末尾元素之后位置的迭代器。</li><li>**<code>rbegin()</code>**：返回指向 <code>list</code> 最后一个元素的反向迭代器。</li><li>**<code>rend()</code>**：返回指向 <code>list</code> 第一个元素之前的反向迭代器。</li></ul><h5 id="2-6-其他操作"><a href="#2-6-其他操作" class="headerlink" title="2.6 其他操作"></a>2.6 其他操作</h5><ul><li>**<code>swap()</code>**：交换两个 <code>list</code> 的内容。</li><li>**<code>resize()</code>**：改变 <code>list</code> 的大小。如果新大小大于当前大小，新增的元素会使用默认值初始化。</li><li>**<code>unique()</code>**：删除 <code>list</code> 中相邻的重复元素。</li></ul><h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h3><table><thead><tr><th>操作</th><th><code>std::vector</code></th><th><code>std::list</code></th></tr></thead><tbody><tr><td><strong>构造函数</strong></td><td><code>vector()</code>, <code>vector(n)</code>, <code>vector(n, value)</code></td><td><code>list()</code>, <code>list(n)</code>, <code>list(n, value)</code></td></tr><tr><td><strong>访问元素</strong></td><td><code>operator[]</code>, <code>at()</code>, <code>front()</code>, <code>back()</code></td><td><code>front()</code>, <code>back()</code></td></tr><tr><td><strong>容量操作</strong></td><td><code>size()</code>, <code>capacity()</code>, <code>reserve()</code>, <code>shrink_to_fit()</code></td><td><code>size()</code>, <code>empty()</code></td></tr><tr><td><strong>修改操作</strong></td><td><code>push_back()</code>, <code>pop_back()</code>, <code>insert()</code>, <code>erase()</code>, <code>clear()</code></td><td><code>push_front()</code>, <code>push_back()</code>, <code>pop_front()</code>, <code>pop_back()</code>, <code>insert()</code>, <code>erase()</code>, <code>clear()</code></td></tr><tr><td><strong>迭代器操作</strong></td><td><code>begin()</code>, <code>end()</code>, <code>rbegin()</code>, <code>rend()</code></td><td><code>begin()</code>, <code>end()</code>, <code>rbegin()</code>, <code>rend()</code></td></tr><tr><td><strong>其他操作</strong></td><td><code>resize()</code>, <code>swap()</code>, <code>emplace_back()</code>, <code>emplace()</code></td><td><code>swap()</code>, <code>resize()</code>, <code>unique()</code>, <code>remove()</code></td></tr></tbody></table><ul><li><strong><code>std::vector</code></strong> 适合频繁的随机访问操作和需要动态扩展大小的场景，但在插入或删除操作上可能效率较低。</li><li><strong><code>std::list</code></strong> 适合需要频繁插入和删除操作的场景，尤其是在容器中间的位置，虽然其访问速度较慢。</li></ul><p>选择使用哪个容器，取决于应用场景的需求：如果需要高效的随机访问，使用 <code>std::vector</code>；如果需要频繁地在容器中间插入和删除元素，使用 <code>std::list</code>。</p><div class="note note-info">            <p><strong>补充知识：内存和缓存：从硬件视角看数据结构的选择</strong></p><blockquote><p>以下内容整理自《Hello 算法》</p></blockquote><p>首先抛出观点：<strong>物理结构在很大程度上决定了程序对内存和缓存的使用效率。</strong></p><ul><li>计算机存储设备</li></ul><p>计算机中包括三种类型的存储设备：硬盘（hard disk）、内存（random-access memory, RAM）、缓存（cache memory）。表 4-2 展示了它们在计算机系统中的不同角色和性能特点。</p><p><a href="https://www.hello-algo.com/chapter_array_and_linkedlist/ram_and_cache/">表 4-2  计算机的存储设备</a></p><table><thead><tr><th align="left"></th><th align="left">硬盘</th><th align="left">内存</th><th align="left">缓存</th></tr></thead><tbody><tr><td align="left">用途</td><td align="left">长期存储数据，包括操作系统、程序、文件等</td><td align="left"><strong>临时存储当前运行的程序和正在处理的数据</strong></td><td align="left"><strong>存储经常访问的数据和指令，减少 CPU 访问内存的次数</strong></td></tr><tr><td align="left">易失性</td><td align="left">断电后数据不会丢失</td><td align="left">断电后数据会丢失</td><td align="left">断电后数据会丢失</td></tr><tr><td align="left">容量</td><td align="left">较大，TB 级别</td><td align="left">较小，GB 级别</td><td align="left">非常小，MB 级别</td></tr><tr><td align="left">速度</td><td align="left">较慢，几百到几千 MB&#x2F;s</td><td align="left">较快，几十 GB&#x2F;s</td><td align="left">非常快，几十到几百 GB&#x2F;s</td></tr><tr><td align="left">价格</td><td align="left">较便宜，几毛到几元 &#x2F; GB</td><td align="left">较贵，几十到几百元 &#x2F; GB</td><td align="left">非常贵，随 CPU 打包计价</td></tr></tbody></table><p><img src="https://www.hello-algo.com/chapter_array_and_linkedlist/ram_and_cache.assets/storage_pyramid.png" alt="计算机存储系统 Hello算法"></p><p><strong>计算机的存储层次结构体现了在速度，容量和成本三者之间的精妙平衡</strong>。</p><ul><li>数据结构的<strong>内存效率</strong></li></ul><p>在上文我们已经比较过数组和链表在内存角度的优缺点：</p><ol><li>数组元素在内存上排列紧密，但是需要一整块内存进行存储。查找效率高但插入，删除效率低。</li><li>链表元素在内存上分散排布，但需要额外储存指针的值。插入、删除效率高但遍历效率低。<ul><li><strong>链表</strong>还有一个比较大的弊端：如果在链表中频繁的插入和删除，会导致<strong>内存的碎片化</strong>，是内存的使用效率降低。</li></ul></li></ol><ul><li>数据结构的<strong>缓存效率</strong>（Additional）</li></ul><p>缓存虽然在空间容量上远小于内存，但它比内存快得多，在程序执行速度上起着至关重要的作用。由于缓存的容量有限，只能存储一小部分频繁访问的数据，因此当 CPU 尝试访问的数据不在缓存中时，就会发生缓存未命中（cache miss），此时 CPU 不得不从速度较慢的内存中加载所需数据。</p><p>显然，<strong>“缓存未命中”越少，CPU 读写数据的效率就越高</strong>，程序性能也就越好。我们将 CPU 从缓存中成功获取数据的比例称为缓存命中率（cache hit rate），这个指标通常用来衡量缓存效率。</p><p>实际上，<strong>数组和链表对缓存的利用效率是不同的</strong>，主要体现在以下几个方面。</p><ul><li><strong>占用空间</strong>：链表元素比数组元素占用空间更多，导致缓存中容纳的有效数据量更少。</li><li><strong>缓存行</strong>：链表数据分散在内存各处，而缓存是“按行加载”的，因此加载到无效数据的比例更高。</li><li><strong>预取机制</strong>：数组比链表的数据访问模式更具“可预测性”，即系统更容易猜出即将被加载的数据。</li><li><strong>空间局部性</strong>：数组被存储在集中的内存空间中，因此被加载数据附近的数据更有可能即将被访问。</li></ul><p>总体而言，<strong>数组具有更高的缓存命中率，因此它在操作效率上通常优于链表</strong>。这使得在解决算法问题时，基于数组实现的数据结构往往更受欢迎。</p>          </div><h2 id="线性表的应用"><a href="#线性表的应用" class="headerlink" title="线性表的应用"></a>线性表的应用</h2><h3 id="大整数处理"><a href="#大整数处理" class="headerlink" title="大整数处理"></a>大整数处理</h3><h3 id="多项式求和"><a href="#多项式求和" class="headerlink" title="多项式求和"></a>多项式求和</h3><h3 id="约瑟夫环问题"><a href="#约瑟夫环问题" class="headerlink" title="约瑟夫环问题"></a>约瑟夫环问题</h3><h3 id="动态内存管理"><a href="#动态内存管理" class="headerlink" title="动态内存管理"></a>动态内存管理</h3>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tutorial</tag>
      
      <tag>C/C++</tag>
      
      <tag>Finished</tag>
      
      <tag>Data Structure</tag>
      
      <tag>Linear List</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Data-Structure-Tutorial</title>
    <link href="/posts/Data-Structure-Tutorial/"/>
    <url>/posts/Data-Structure-Tutorial/</url>
    
    <content type="html"><![CDATA[<h1 id="Data-Structure-Tutorial"><a href="#Data-Structure-Tutorial" class="headerlink" title="Data Structure Tutorial"></a>Data Structure Tutorial</h1><p>在本文将要系统梳理之后笔者将要学习的数据结构的内容，这是笔者<strong>遇到的第一门难度较大且较为重要的专业课程</strong>，将成为笔者2025年的更新重点之一。</p><h2 id="Before-Reading"><a href="#Before-Reading" class="headerlink" title="Before Reading"></a>Before Reading</h2><p>在阅读这一系列博客之前，你需要掌握以下知识：</p><ul><li>C++的基本语法（Necessary！）<ul><li><strong>面向过程</strong></li><li><strong>面向对象</strong></li></ul></li><li>Python的基本语法（Optional）</li><li>掌握一些基本的关于算法的基础知识<ul><li>递归算法</li><li>迭代算法</li><li><strong>STL的一些基本知识</strong>（会使用一些基本的接口）</li></ul></li></ul><h2 id="参考教材"><a href="#参考教材" class="headerlink" title="参考教材"></a>参考教材</h2><ul><li>入门教材：<a href="https://www.hello-algo.com/">Hello 算法</a><ul><li>非常经典且优质的一本教材，有在线学习的网站，并且开源了书中所有代码示例。</li><li>内容相对较少，但是都是基础中的基础，非常适合新手的快速入门，<strong>在一轮过后再深入学习一些更深入的知识</strong>。</li></ul></li><li>主力教材：<strong>《数据结构：思想与实现》——翁慧玉，俞勇</strong><ul><li>经典教材！</li><li>但是教材的难度较大，是笔者下学期上课的教材，也会作为更新的重点。</li></ul></li><li>其他参考教材：<ul><li>图解算法（<strong>可视化做的很好</strong>）</li><li><strong>《大话数据结构》</strong></li><li><strong>《数据结构和算法分析——C语言描述》</strong></li></ul></li></ul><blockquote><p><strong>注：示例代码主要都以C++或者Python代码给出。</strong></p></blockquote><p>更新内容</p><ul><li>导论（在本篇发表之前已经更新）<ul><li>数据结构和算法</li><li>算法的时间复杂度，空间复杂度</li></ul></li><li>线性结构<ul><li>线性表<ul><li>线性表的顺序实现（数组）</li><li>线性表的链接实现（链表）</li></ul></li><li>栈</li><li>队列</li><li>字符串</li></ul></li><li>树状结构<ul><li>二叉树</li><li>哈夫曼树</li><li>优先级队列</li></ul></li><li>集合结构<ul><li>集合与静态查找表</li><li>动态查找表<ul><li>二叉查找树</li><li>AVL树</li><li>红黑树</li><li>AA树</li><li>伸展树</li><li>散列表（哈希表）</li></ul></li><li><strong>算法应用：排序</strong><ul><li>插入排序</li><li>选择排序</li><li>交换排序</li><li>归并排序</li><li>基数排序</li><li>外部查找和排序<ul><li>B树</li><li>B+树</li></ul></li></ul></li></ul></li><li>图状结构<ul><li>图</li><li>最小生成树</li><li><strong>算法应用问题：最短路径问题</strong></li></ul></li><li>算法设计基础<ul><li>枚举法</li><li>贪婪法</li><li>分治法</li><li>动态规划</li><li>回溯法</li><li>随机算法</li></ul></li></ul><p><img src="/posts/Above-All/ture-Tutorial/1.png" alt="图片来源于网络"></p><blockquote><p>笔者在这个学期期末周会有一场<strong>下学期数据结构</strong>的拔高选拔测试😅😅😅真是无语了，希望能过吧。Anyway，与各位共勉！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tutorial</tag>
      
      <tag>C/C++</tag>
      
      <tag>Finished</tag>
      
      <tag>Data Structure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CMake-tutorial-episode2</title>
    <link href="/posts/CMake-tutorial-episode2/"/>
    <url>/posts/CMake-tutorial-episode2/</url>
    
    <content type="html"><![CDATA[<h3 id="CMake-编译多文件-C-程序：项目指南"><a href="#CMake-编译多文件-C-程序：项目指南" class="headerlink" title="CMake 编译多文件 C++ 程序：项目指南"></a>CMake 编译多文件 C++ 程序：项目指南</h3><p>本指南将帮助你使用 CMake 构建一个包含多个 <code>.cpp</code> 文件的 C++ 项目。我们将逐步介绍如何配置 <code>CMakeLists.txt</code> 文件，以及如何管理项目中的源文件和头文件。</p><hr><h3 id="1-项目结构"><a href="#1-项目结构" class="headerlink" title="1. 项目结构"></a>1. 项目结构</h3><p>假设我们有以下项目结构：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cmake">/<span class="hljs-keyword">project</span><br>  ├── CMakeLists.txt      <span class="hljs-comment"># 项目根目录的 CMake 配置文件</span><br>  ├── src/                <span class="hljs-comment"># 源代码文件夹</span><br>  │   ├── main.cpp        <span class="hljs-comment"># 主程序文件</span><br>  │   ├── foo.cpp         <span class="hljs-comment"># 其他源文件</span><br>  │   └── bar.cpp         <span class="hljs-comment"># 其他源文件</span><br>  ├── <span class="hljs-keyword">include</span>/            <span class="hljs-comment"># 头文件文件夹</span><br>  │   ├── foo.h           <span class="hljs-comment"># foo 的头文件</span><br>  │   └── bar.h           <span class="hljs-comment"># bar 的头文件</span><br>  └── CMakeLists.txt      <span class="hljs-comment"># src 子目录中的 CMake 配置文件</span><br></code></pre></td></tr></table></figure><h3 id="2-创建-CMake-配置文件"><a href="#2-创建-CMake-配置文件" class="headerlink" title="2. 创建 CMake 配置文件"></a>2. 创建 CMake 配置文件</h3><h4 id="2-1-根目录的-CMakeLists-txt"><a href="#2-1-根目录的-CMakeLists-txt" class="headerlink" title="2.1 根目录的 CMakeLists.txt"></a>2.1 根目录的 <code>CMakeLists.txt</code></h4><p>在项目的根目录下创建一个 <code>CMakeLists.txt</code> 文件，配置全局设置和添加子目录。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># 设置 CMake 最低版本要求</span><br><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.10</span>)<br><br><span class="hljs-comment"># 设置项目名称</span><br><span class="hljs-keyword">project</span>(MyMultiFileProject)<br><br><span class="hljs-comment"># 设置 C++ 标准</span><br><span class="hljs-keyword">set</span>(CMAKE_CXX_STANDARD <span class="hljs-number">11</span>)<br><br><span class="hljs-comment"># 添加 src 目录作为子目录</span><br><span class="hljs-keyword">add_subdirectory</span>(src)<br></code></pre></td></tr></table></figure><h4 id="2-2-src-CMakeLists-txt"><a href="#2-2-src-CMakeLists-txt" class="headerlink" title="2.2 src/CMakeLists.txt"></a>2.2 <code>src/CMakeLists.txt</code></h4><p>在 <code>src/</code> 目录下创建另一个 <code>CMakeLists.txt</code> 文件，用于配置源文件的编译规则。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># 查找 src 目录及其子目录中的所有 .cpp 文件</span><br><span class="hljs-keyword">file</span>(GLOB_RECURSE SOURCES <span class="hljs-string">&quot;*.cpp&quot;</span>)<br><br><span class="hljs-comment"># 创建可执行文件</span><br><span class="hljs-keyword">add_executable</span>(MyExecutable <span class="hljs-variable">$&#123;SOURCES&#125;</span>)<br><br><span class="hljs-comment"># 设置头文件搜索路径</span><br><span class="hljs-keyword">target_include_directories</span>(MyExecutable PRIVATE ../<span class="hljs-keyword">include</span>)<br></code></pre></td></tr></table></figure><ul><li><code>file(GLOB_RECURSE ...)</code>：递归查找 <code>src/</code> 目录及其子目录下的所有 <code>.cpp</code> 文件。</li><li><code>add_executable(MyExecutable $&#123;SOURCES&#125;)</code>：将所有 <code>.cpp</code> 文件编译成一个可执行文件 <code>MyExecutable</code>。</li><li><code>target_include_directories(MyExecutable PRIVATE ../include)</code>：设置 <code>MyExecutable</code> 可执行文件的头文件搜索路径，指向项目的 <code>include/</code> 目录。</li></ul><h3 id="3-自动查找源文件"><a href="#3-自动查找源文件" class="headerlink" title="3. 自动查找源文件"></a>3. 自动查找源文件</h3><p>如果源文件数量较多，手动列出每个源文件可能比较麻烦。可以使用 <code>file(GLOB ...)</code> 或 <code>file(GLOB_RECURSE ...)</code> 自动查找 <code>.cpp</code> 文件。</p><h4 id="3-1-查找当前目录下的-cpp-文件"><a href="#3-1-查找当前目录下的-cpp-文件" class="headerlink" title="3.1 查找当前目录下的 .cpp 文件"></a>3.1 查找当前目录下的 <code>.cpp</code> 文件</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">file</span>(GLOB SOURCES <span class="hljs-string">&quot;*.cpp&quot;</span>)<br></code></pre></td></tr></table></figure><p><code>file(GLOB ...)</code> 会查找当前目录下所有 <code>.cpp</code> 文件，并将它们添加到 <code>SOURCES</code> 变量中。</p><h4 id="3-2-查找子目录中的-cpp-文件"><a href="#3-2-查找子目录中的-cpp-文件" class="headerlink" title="3.2 查找子目录中的 .cpp 文件"></a>3.2 查找子目录中的 <code>.cpp</code> 文件</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">file</span>(GLOB_RECURSE SOURCES <span class="hljs-string">&quot;*.cpp&quot;</span>)<br></code></pre></td></tr></table></figure><p><code>file(GLOB_RECURSE ...)</code> 会递归地查找指定目录及其所有子目录中的 <code>.cpp</code> 文件。</p><h3 id="4-构建和编译"><a href="#4-构建和编译" class="headerlink" title="4. 构建和编译"></a>4. 构建和编译</h3><h4 id="4-1-生成构建目录"><a href="#4-1-生成构建目录" class="headerlink" title="4.1 生成构建目录"></a>4.1 生成构建目录</h4><p>在项目根目录下创建一个 <code>build</code> 目录，并进入该目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> build<br><span class="hljs-built_in">cd</span> build<br></code></pre></td></tr></table></figure><h4 id="4-2-运行-CMake-配置"><a href="#4-2-运行-CMake-配置" class="headerlink" title="4.2 运行 CMake 配置"></a>4.2 运行 CMake 配置</h4><p>在 <code>build</code> 目录中运行 CMake，指定项目的根目录作为源目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cmake ..<br></code></pre></td></tr></table></figure><p>这将配置项目并生成适合你平台的构建系统。</p><h4 id="4-3-编译项目"><a href="#4-3-编译项目" class="headerlink" title="4.3 编译项目"></a>4.3 编译项目</h4><p>使用 CMake 生成的构建系统来编译项目。如果你使用 Makefiles，可以运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">make<br></code></pre></td></tr></table></figure><p>如果使用其他构建系统（如 Visual Studio），可以直接在 IDE 中进行编译。</p><h4 id="4-4-运行程序"><a href="#4-4-运行程序" class="headerlink" title="4.4 运行程序"></a>4.4 运行程序</h4><p>编译完成后，你可以在 <code>build</code> 目录中找到生成的可执行文件 <code>MyExecutable</code>，然后运行它：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./MyExecutable<br></code></pre></td></tr></table></figure><h3 id="5-处理大型项目结构"><a href="#5-处理大型项目结构" class="headerlink" title="5. 处理大型项目结构"></a>5. 处理大型项目结构</h3><p>对于大型项目，你可能会将源文件和头文件拆分成多个子目录。在这种情况下，可以使用 <code>add_subdirectory()</code> 将各个子目录包含进来，每个子目录都可以有自己的 <code>CMakeLists.txt</code> 文件。</p><h4 id="示例：子目录结构"><a href="#示例：子目录结构" class="headerlink" title="示例：子目录结构"></a>示例：子目录结构</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs stylus">/project<br>  ├── CMakeLists<span class="hljs-selector-class">.txt</span><br>  ├── <span class="hljs-attribute">src</span>/<br>  │   ├── CMakeLists<span class="hljs-selector-class">.txt</span><br>  │   ├── <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.cpp</span><br>  │   ├── foo<span class="hljs-selector-class">.cpp</span><br>  │   └── bar<span class="hljs-selector-class">.cpp</span><br>  └── include/<br>      ├── foo<span class="hljs-selector-class">.h</span><br>      └── bar.h<br></code></pre></td></tr></table></figure><p>根目录的 <code>CMakeLists.txt</code> 文件：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.10</span>)<br><br><span class="hljs-keyword">project</span>(MyMultiFileProject)<br><br><span class="hljs-keyword">set</span>(CMAKE_CXX_STANDARD <span class="hljs-number">11</span>)<br><br><span class="hljs-comment"># 添加 src 子目录</span><br><span class="hljs-keyword">add_subdirectory</span>(src)<br></code></pre></td></tr></table></figure><p><code>src/CMakeLists.txt</code> 文件：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># 查找 src 目录及其子目录中的所有 .cpp 文件</span><br><span class="hljs-keyword">file</span>(GLOB_RECURSE SOURCES <span class="hljs-string">&quot;*.cpp&quot;</span>)<br><br><span class="hljs-comment"># 创建可执行文件</span><br><span class="hljs-keyword">add_executable</span>(MyExecutable <span class="hljs-variable">$&#123;SOURCES&#125;</span>)<br><br><span class="hljs-comment"># 设置头文件搜索路径</span><br><span class="hljs-keyword">target_include_directories</span>(MyExecutable PRIVATE ../<span class="hljs-keyword">include</span>)<br></code></pre></td></tr></table></figure><h3 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h3><p>通过以上步骤，你可以使用 CMake 管理多源文件的 C++ 项目：</p><ol><li>在项目根目录创建一个 <code>CMakeLists.txt</code> 文件，配置全局项目设置。</li><li>在 <code>src/</code> 目录创建子目录的 <code>CMakeLists.txt</code> 文件，自动查找 <code>.cpp</code> 文件。</li><li>使用 <code>file(GLOB ...)</code> 或 <code>file(GLOB_RECURSE ...)</code> 自动查找源文件。</li><li>配置头文件搜索路径，确保程序能找到必要的头文件。</li><li>使用 <code>cmake</code> 和 <code>make</code> 命令构建项目，并生成可执行文件。</li></ol><p>这样，你就能高效地管理和构建多个源文件的 C++ 项目，同时也能确保项目结构清晰，易于扩展和维护。</p>]]></content>
    
    
    <categories>
      
      <category>Efficient Tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tutorial</tag>
      
      <tag>Finished</tag>
      
      <tag>CMake</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CMake-tutorial1</title>
    <link href="/posts/CMake-tutorial1/"/>
    <url>/posts/CMake-tutorial1/</url>
    
    <content type="html"><![CDATA[<h1 id="CMake-tutorial-episode1"><a href="#CMake-tutorial-episode1" class="headerlink" title="CMake-tutorial-episode1"></a>CMake-tutorial-episode1</h1><h2 id="Building-a-cpp-project"><a href="#Building-a-cpp-project" class="headerlink" title="Building a cpp project"></a>Building a cpp project</h2><p>在之前的C++程序中，绝大部分都是以<strong>单个Cpp文件</strong>呈现的。具体到编译器，编译器对源代码（<strong>Cpp</strong>文件）进行编译，生成中间目标文件（**.obj**），再由链接器将中间目标文件与一些会使用到的库文件链接在一起，最终形成一个可执行文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Bash">g++ your_file_name.cpp -o your_executable_name.exe<br>./your_executable_name.exe<br></code></pre></td></tr></table></figure><blockquote><p>上面两行代码是在Bash（命令行）中编译C++程序的命令行代码。</p></blockquote><p>但是，随着程序体量的膨胀，我们越来越难把所有的函数放在一个cpp文件中，这样对后续代码的修改，调试等工作都增添了负担。因此，<strong>模块化开发</strong>是C++中必不可少的一个部分！</p><h3 id="模块化开发"><a href="#模块化开发" class="headerlink" title="模块化开发"></a>模块化开发</h3><p>模块化是一种将复杂系统分解为可更好管理的模块的方式</p><ul><li>模块化开发就是封装实现细节，提供模块使用接口，模块彼此之间互不影响，每个模块实现某一特定的功能</li><li>最大化代码重用，以最少的模块、零部件，更快速地满足个性化需求</li><li>原则：<strong>模块内紧耦合，模块间松耦合</strong></li></ul><p>在C++的模块化开发中，主要有两层含义：</p><ul><li>功能模块化</li><li>代码模块化</li></ul><p>对于功能模块化，<strong>程序可以拆解成若干个子功能</strong>（例如在一个学生成绩的统计表中，可以拆解为：修改、查找、排序等子功能），将每个子功能的代码实现在不同的文件中。</p><p>对于代码模块化，<strong>是指对于每一个具体的子功能</strong>，其内部有若干个自定义的函数实现，我们需要将<strong>函数的声明、函数的定义、函数的调用</strong>三者分离开来，分别放在不同的头文件或者源代码文件中。</p><h3 id="Usage："><a href="#Usage：" class="headerlink" title="Usage："></a>Usage：</h3><h4 id="①全局变量或者枚举定义"><a href="#①全局变量或者枚举定义" class="headerlink" title="①全局变量或者枚举定义"></a>①全局变量或者枚举定义</h4><p>这个部分往往是所有子功能都会使用到的，我们首先进行定义。</p><div class="note note-danger">            <p><strong>注意：谨慎使用全局变量！！！在多文件开发中，全局变量可以被任何一个文件中的任何一个函数调用并且修改！！！安全性低并且会产生很多奇怪的错误！</strong></p><p>可以在文件中使用<strong>静态全局变量</strong>，这样可以让其他文件中的函数无法使用该变量。</p><p>因此，在这个文件中，笔者推荐只定义一些枚举变量或者变量的别名，宏定义等。</p>          </div><h4 id="②子功能模块的实现"><a href="#②子功能模块的实现" class="headerlink" title="②子功能模块的实现"></a>②子功能模块的实现</h4><p>这个部分主要要解决两件事：<strong>函数的声明和函数的定义</strong>。函数的声明在<strong>头文件(.h)<strong>中实现，而函数的定义在</strong>源代码文件(.cpp)<strong>中实现，一般来说，我们要求</strong>在一个子模块就只有这两个文件，并且要求同名。</strong></p><blockquote><p>例如，一个子模块实现“输出”的子功能，内涵各种各样包含输出的函数，这头文件可以定义为<code>Output.h</code>，源代码文件可以定义为<code>Output.cpp</code>。</p></blockquote><div class="note note-info">            <p><strong>为什么要把函数的声明和调用分离开来？</strong></p><p>如果读者看过笔者对《C++ Primer Plus》的更新的话，会发现其书中面向对象编程的所有程序都是<strong>严格将函数定义，函数声明和函数的调用分离开来</strong>，这样做确实会更麻烦，但会有如下的好处：</p><ol><li><p><strong>提高代码组织性</strong></p><ul><li><p><strong>函数声明</strong>（通常在头文件中）提供了函数的接口信息，包括函数名称、参数类型和返回类型。这让其他模块可以知道如何调用该函数，但不需要了解函数的实现细节。</p></li><li><p><strong>函数定义</strong>（通常在源文件中）包含了函数的具体实现，能够避免暴露内部细节。这样其他模块只需要知道函数的声明，而不需要关心其具体实现。</p></li></ul></li><li><p><strong>加速编译过程</strong></p><ul><li><p>如果将函数声明和定义都放在同一个文件中，每次编译时都需要重新编译实现部分，而声明通常是一个接口的约定，不会发生变化。将声明和定义分离后，头文件（声明部分）可以被多个源文件共享，而源文件（定义部分）则可以独立进行编译，减少编译时间。</p></li><li><p>修改一个函数的实现时，只有源文件需要重新编译，其他依赖该函数声明的源文件不需要重新编译，提升了代码的编译效率。</p></li></ul></li><li><p><strong>代码重用</strong></p><ul><li>分离声明和定义后，可以方便地将函数声明放入一个公共的头文件，供其他项目或模块复用，而实现部分可以放在不同的源文件中。这样，开发者可以重用已有的函数实现而不需要重复编写相同的代码。</li></ul></li><li><p><strong>增强封装性</strong></p><ul><li>把函数声明放在头文件中，定义放在源文件中，可以隐藏函数的实现细节，提供更强的封装性。这样可以避免函数的实现细节泄漏给调用者，确保模块的内聚性和独立性。</li></ul></li><li><p><strong>避免重复定义</strong></p><ul><li>如果函数声明和定义混合在一个文件中，并且这个文件被多个源文件包含，那么就可能导致函数的重复定义错误。将声明和定义分离后，使用 <code>#ifndef</code>、<code>#define</code> 等预处理指令来防止头文件被多次包含，从而避免这种错误。</li></ul></li><li><p><strong>接口与实现分离</strong></p><ul><li>分离函数声明和定义符合“接口与实现分离”的设计原则。这样可以让调用者关注函数的功能（通过接口）而不需要关注具体的实现细节，提高模块的独立性和灵活性。如果接口发生改变，函数实现可以保持不变，反之亦然。</li></ul></li></ol>          </div><p><strong>注意使用预编译命令，防止同一个头文件被重复定义。</strong></p><p><img src="/posts/Above-All/rial1/multicompiling.png" alt="Several Optional Structures"></p><p>上图是三种可选的源代码放置方式。在接下来的讨论中，我们将默认选择第三种。（也是相对最复杂的一种）</p><h2 id="What-is-CMake"><a href="#What-is-CMake" class="headerlink" title="What is CMake"></a>What is CMake</h2><p>上文我们了解了C++的<strong>模块化开发</strong>的核心思想，但是有一个问题亟需被解决：</p><p><strong>如何让编译器编译那么多的文件并最后生成一个可执行文件？</strong></p><p>第一种方法是手动输入各种命令行，让程序按照顺序一个一个被编译，最后main函数被编译，生成一个可执行文件。但这种方法无疑是及其繁琐的，因为每一次编译都需要程序员手动输入，大大降低了开发的效率。</p><p>一种可行的方法就是自己写一个<strong>脚本文件</strong>，让程序<strong>自动化</strong>地按顺序编译对应的头文件和源代码文件。但是还有另外一个问题，你不想<strong>每写一个新的程序就重新先写一遍脚本</strong>，同时你希望你的脚本能够在<strong>全平台运行（Linux，Windows，macOS）</strong>。</p><p>在这样的背景下，<strong>CMake</strong>诞生了。</p><p>CMake 是个一个开源的跨平台自动化建构系统，用来管理软件建置的程序，并不依赖于某特定编译器，并可支持多层目录、多个应用程序与多个函数库。</p><p>CMake 通过使用简单的配置文件 CMakeLists.txt，自动生成不同平台的构建文件（如 Makefile、Ninja 构建文件、Visual Studio 工程文件等），简化了项目的编译和构建过程。</p><p>CMake 本身不是构建工具，而是生成构建系统的工具，它生成的构建系统可以使用不同的编译器和工具链。</p><h2 id="The-Basic-Usage-of-CMake"><a href="#The-Basic-Usage-of-CMake" class="headerlink" title="The Basic Usage of CMake"></a>The Basic Usage of CMake</h2><p><a href="https://blog.csdn.net/weiwei9363/article/details/109290252">推荐一篇写的很好的博客</a></p><p>接下来，我们以 <strong>IDE CLion</strong>为例，介绍在<strong>CLion</strong>中如何使用CMake构建工程文件。</p><blockquote><p>CLion的使用可自行查询，是一款非常好用的C++开发工具。</p></blockquote><p>在打开一个新项目的时候（C++ Executable），你应该会得到如下的界面：</p><p><img src="/posts/Above-All/rial1/1.png" alt="Opening a new project"></p><p>我们会发现系统自动生成了一个CMakeList.txt的文本文件，<strong>这就是上文提到的自动化编译的脚本</strong>。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs makefile">cmake_minimum_required(VERSION 3.30)<br><br>project(untitled)<br><br>set(CMAKE_CXX_STANDARD 20)<br><br>add_executable(untitled main.cpp)<br><br></code></pre></td></tr></table></figure><p>接下来我们来逐行解释这四行代码：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile">cmake_minimum_required(VERSION 3.30)<br></code></pre></td></tr></table></figure><p>规定了CMake的最低版本，这里CLion自动生成，无需修改。</p><blockquote><p>如果你是直接安装了CMake，则需要自己创建一个文本文件并将内容输入，还是有一点工作量的，建议新手先使用CLion熟悉CMake的基本操作。</p></blockquote><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile">project(untitled)<br></code></pre></td></tr></table></figure><p>这行代码定义了 CMake 项目的名称。在这个例子中，项目名是 <code>untitled</code>。<code>project()</code> 命令是用来初始化 CMake 项目，并为后续的构建设置一些基本的项目属性（如名称、版本等）</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile">set(CMAKE_CXX_STANDARD 20)<br></code></pre></td></tr></table></figure><p>这行代码设置了 C++ 编译标准。在这个例子中，<code>CMAKE_CXX_STANDARD 20</code> 表示将 C++ 标准设为 C++20。CMake 会确保编译器使用符合 C++20 标准的特性和语法来编译源代码。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile">add_executable(untitled main.cpp)<br></code></pre></td></tr></table></figure><p>这行代码创建了一个可执行文件。<code>add_executable()</code> 命令告诉 CMake 将源文件（此处是 <code>main.cpp</code>）编译并链接成一个可执行文件。可执行文件的名称是 <code>untitled</code>，即编译后生成的程序文件名将是 <code>untitled</code>。</p><p>在点击CLion的<code>Build</code>后，找到文件夹的根目录，在文件夹<code>cmake-build-debug</code>中应该会生成一个可执行文件，说明程序已经编译完成。</p>]]></content>
    
    
    <categories>
      
      <category>Efficient Tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tutorial</tag>
      
      <tag>CMake</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Pointers-Arrays-and-Functions</title>
    <link href="/posts/Pointers-Arrays-and-Functions/"/>
    <url>/posts/Pointers-Arrays-and-Functions/</url>
    
    <content type="html"><![CDATA[<h1 id="函数、数组和指针"><a href="#函数、数组和指针" class="headerlink" title="函数、数组和指针"></a>函数、数组和指针</h1><p>封面来源：<a href="https://knowyourmeme.com/photos/2214241-two-soyjaks-pointing">Pointers</a></p><blockquote><p>对不起真的太好笑了哈哈哈哈哈哈</p></blockquote><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>在C++中，函数，数组和指针是三个非常重要的概念，他们是C++实现许多高级功能（例如STL，OOP）的基石。同时，这三者之间又有着密不可分的联系。本文将主要从<strong>指针</strong>的角度出发，深入探究<strong>内存</strong>的本质，并在此基础之上探寻一些指针的高级功能。</p><blockquote><p>In C++, functions, arrays, and pointers are three essential concepts that serve as the cornerstone for implementing many advanced features, such as the Standard Template Library (STL) and Object-Oriented Programming (OOP). At the same time, these three elements are intricately interconnected. This article will primarily focus on <strong>pointers</strong>, delving deep into the essence of <strong>memory</strong> and, based on this foundation, exploring some advanced functionalities of pointers.</p></blockquote><h2 id="Before-the-article-begins"><a href="#Before-the-article-begins" class="headerlink" title="Before the article begins"></a>Before the article begins</h2><p>在文章开始前，请务必确保你已经掌握了<strong>指针，数组，函数三者分别的基本用法和一些初步的内存管理的知识</strong>。本文对相关基础代码不再过多赘述。</p><h2 id="Table-of-Contents"><a href="#Table-of-Contents" class="headerlink" title="Table of Contents"></a>Table of Contents</h2><ul><li>Pointers and Memories</li><li>Types of Pointers matters</li><li>Array of an Pointer and Pointer of an array</li><li>Rvalue</li><li>parameters in the main function</li><li>Lambda expression</li><li>Smart Pointer</li></ul><h2 id="Pointers-and-Memories"><a href="#Pointers-and-Memories" class="headerlink" title="Pointers and Memories"></a>Pointers and Memories</h2><p>在这一节，我们将从内存的视角重新认识指针。</p><p><strong>内存是什么？</strong>通俗来说，内存就是计算机<strong>存储数据的地方</strong>（这个定义非常的不严谨，甚至是一派胡言。但是这篇文章不会涉及硬件的太多知识，大家只要认识到这一步就行了）。第二个问题，<strong>如何存储数据？</strong>我们知道，数据存储的最小单元是<strong>位（bit）</strong>，代表一个二进制位。因此，我们会把内存进行<strong>编码</strong>，每一个bit都会拿到自己的编号，代表自己的具体位置。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> a=<span class="hljs-number">100</span>;<br>    <span class="hljs-type">int</span> *p=&amp;a;<br>    cout&lt;&lt;p;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//输出结果：0x61fe14(变量a的值，变量a的内存块第一个bit的编号，指针p所储存的值)</span><br></code></pre></td></tr></table></figure><blockquote><p>内存的硬件知识有兴趣的可以看这篇 <a href="https://blog.csdn.net/hellojoy/article/details/102933809">博客</a>，讲的比较清楚。</p></blockquote><p>接下来，回到指针。指针存储了一个<strong>变量</strong>的<strong>地址（内存）</strong>，这是指针的功能。但是，指针本身其实<strong>也是一种变量</strong>，在内存中有相对应的地址。一般来说，在64位的系统上，指针在内存中占<strong>8个字节（64bit）</strong>，在大小上和<code>unsigned long long</code>类型是一样的。（不过指针的值是十六进制的存储方式）</p><div class="note note-success">            <p><strong>因此，指针也是一种数据类型！和int，double，char等等一样，在内存中占一定空间，并且储存对应的值。（只不过指针储存的值就是内存的编号罢了）</strong></p>          </div><h2 id="Types-of-pointers-matters"><a href="#Types-of-pointers-matters" class="headerlink" title="Types of pointers matters"></a>Types of pointers matters</h2><p>指针有着<strong>解引用</strong>的操作，这是如何实现的？</p><p>我们来看下面的代码示范：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> num=<span class="hljs-number">4758843763784</span>;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span>* p1=&amp;num;<br>    <span class="hljs-type">int</span>* p2=(<span class="hljs-type">int</span>*)p1;<br>    <span class="hljs-type">double</span>* p3=(<span class="hljs-type">double</span>*)p1;<br>    <span class="hljs-type">char</span>* p4=(<span class="hljs-type">char</span>*)p2;<br>    <span class="hljs-type">float</span>* p5=(<span class="hljs-type">float</span>*)p1;<br>    <span class="hljs-comment">//对指针进行强制类型转换</span><br>    cout&lt;&lt;<span class="hljs-string">&quot;the size of each pointers:&quot;</span>&lt;&lt;endl;<br>    cout&lt;&lt;<span class="hljs-built_in">sizeof</span>(p1)&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;<span class="hljs-built_in">sizeof</span>(p2)&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;<span class="hljs-built_in">sizeof</span>(p3)&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;<span class="hljs-built_in">sizeof</span>(p4)&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;<span class="hljs-built_in">sizeof</span>(p5)&lt;&lt;endl;<br>    cout&lt;&lt;<span class="hljs-string">&quot;The memory:&quot;</span>&lt;&lt;endl;<br>    cout&lt;&lt;p1&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;p2&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;p3&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;(<span class="hljs-type">void</span>*)p4&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;p5&lt;&lt;endl;<br>    <span class="hljs-comment">//强制类型转换字符指针，否则会输出实际字符的值。</span><br>    cout&lt;&lt;<span class="hljs-string">&quot;Dereferencing Various Pointers&quot;</span>&lt;&lt;endl;<br>    cout&lt;&lt;*p1&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;*p2&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;*p3&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;*p4&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;*p5&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">the</span> size of each pointers:<br><span class="hljs-attribute">8</span> <span class="hljs-number">8</span> <span class="hljs-number">8</span> <span class="hljs-number">8</span> <span class="hljs-number">8</span><br><span class="hljs-attribute">The</span> memory:<br><span class="hljs-attribute">0x61fdf0</span> <span class="hljs-number">0</span>x61fdf0 <span class="hljs-number">0</span>x61fdf0 <span class="hljs-number">0</span>x61fdf0 <span class="hljs-number">0</span>x61fdf0<br><span class="hljs-attribute">Dereferencing</span> Various Pointers<br><span class="hljs-attribute">4758843763784</span> <span class="hljs-number">19999816</span> <span class="hljs-number">2</span>.<span class="hljs-number">35118</span>e-<span class="hljs-number">311</span> H <span class="hljs-number">3</span>.<span class="hljs-number">25415</span>e-<span class="hljs-number">38</span><br></code></pre></td></tr></table></figure><p>这个代码告诉了我们以下几点：</p><ul><li>指针在内存中存储的大小和<strong>指针指向数据类型的大小无关</strong>。（这一点很重要，稍后会解释）</li><li><strong>指向不同数据类型的指针，对于同一块内存解引用所得到的是完全不同的值</strong>！</li></ul><p>换句话说，指针的类型不会改变指针在内存中的存储和指针的值，只会影响指针在<strong>解引用时</strong>对内存的解释（即如何将0&#x2F;1的比特位转换成有效数据）。</p><p>因此，<strong>Types of pointers matters！</strong>实际上，如果不进行强制类型的转换，编译器面对不匹配的指针类型的时候也会报错。</p><p>以上两个章节是对指针和内存一些基础知识的回顾，接下来，我们将介绍<strong>数组，指针和函数</strong>三者在C++中一些高级的操作。</p><h2 id="Advanced-Technique-1-Array-of-pointers-and-Pointer-to-an-array"><a href="#Advanced-Technique-1-Array-of-pointers-and-Pointer-to-an-array" class="headerlink" title="Advanced Technique 1  Array of pointers and Pointer to an array"></a>Advanced Technique 1  Array of pointers and Pointer to an array</h2><p><strong>Definition</strong></p><p>数组指针：数组指针是<strong>指向数组的指针</strong>。</p><p>指针数组：是一个数组，数组的每个元素都是<strong>指针</strong>。</p><p>定义还是非常直白的，<strong>数组指针是指针，指针数组是数组。</strong></p><p><strong>Usage</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">int</span> (*ptr)[size];<br><span class="hljs-comment">//声明一个数组指针</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> *ptr[size];<br><span class="hljs-comment">//声明一个指针数组</span><br></code></pre></td></tr></table></figure><div class="note note-warning">            <p>在 C++ 中，<code>*</code> 运算符用于声明指针，而 <code>[]</code> 运算符用于声明数组。因为<strong>运算符的优先级不同</strong>（<code>[]</code> 运算符的优先级高于<code>*</code> 运算符），直接写 <code>*ptr[size]</code> 会让编译器理解为声明一个数组 <code>ptr</code>，每个元素是一个指向 <code>type</code> 的指针，而不是声明一个指向数组的指针。</p>          </div><p><strong>使用方法</strong></p><p>如果是数组指针：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> arr[<span class="hljs-number">3</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>    <span class="hljs-built_in">int</span> (*ptr)[<span class="hljs-number">3</span>] = &amp;arr;  <span class="hljs-comment">// ptr 是指向包含 3 个整数的数组的指针</span><br><br>    <span class="hljs-comment">// 访问数组元素</span><br>    std::cout &lt;&lt; (*ptr)[<span class="hljs-number">0</span>] &lt;&lt; std::endl;  <span class="hljs-comment">// 输出 1</span><br>    std::cout &lt;&lt; (*ptr)[<span class="hljs-number">1</span>] &lt;&lt; std::endl;  <span class="hljs-comment">// 输出 2</span><br>    std::cout &lt;&lt; (*ptr)[<span class="hljs-number">2</span>] &lt;&lt; std::endl;  <span class="hljs-comment">// 输出 3</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>ptr</code> 是指向一个包含 3 个整数的数组的指针。可以通过 <code>(*ptr)[i]</code> 的方式来访问数组元素。</p><p>如果是指针数组：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">1</span>, b = <span class="hljs-number">2</span>, c = <span class="hljs-number">3</span>;<br>    <span class="hljs-type">int</span> *ptr[<span class="hljs-number">3</span>];  <span class="hljs-comment">// ptr 是一个指针数组，包含 3 个指向整数的指针</span><br><br>    ptr[<span class="hljs-number">0</span>] = &amp;a;<br>    ptr[<span class="hljs-number">1</span>] = &amp;b;<br>    ptr[<span class="hljs-number">2</span>] = &amp;c;<br><br>    <span class="hljs-comment">// 访问数组元素</span><br>    std::cout &lt;&lt; *ptr[<span class="hljs-number">0</span>] &lt;&lt; std::endl;  <span class="hljs-comment">// 输出 1</span><br>    std::cout &lt;&lt; *ptr[<span class="hljs-number">1</span>] &lt;&lt; std::endl;  <span class="hljs-comment">// 输出 2</span><br>    std::cout &lt;&lt; *ptr[<span class="hljs-number">2</span>] &lt;&lt; std::endl;  <span class="hljs-comment">// 输出 3</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>ptr</code> 是一个包含 3 个指针的数组，每个指针指向不同的整数变量。通过 <code>*ptr[i]</code> 可以访问指针所指向的值。</p><p><strong>Applications</strong></p><p><strong>数组指针和指针数组都可以用来操作二维数组</strong>。</p><p>假设你有一个二维数组 <code>arr[3][4]</code>，它有 3 行 4 列，你可以通过以下两种方式来使用指针来访问它。</p><p>使用数组指针：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">int</span> (*ptr)[<span class="hljs-number">4</span>] = arr;  <span class="hljs-comment">// ptr 是指向数组中每一行的指针</span><br></code></pre></td></tr></table></figure><p>在这种情况下，<code>ptr</code> 是指向数组中每一行的指针。你可以通过 <code>ptr[i]</code> 来访问第 <code>i</code> 行的数据。</p><p>使用指针数组：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> *ptr[<span class="hljs-number">3</span>];  <span class="hljs-comment">// ptr 是一个指针数组，包含 3 个指向整数的指针</span><br>ptr[<span class="hljs-number">0</span>] = arr[<span class="hljs-number">0</span>];  <span class="hljs-comment">// ptr[0] 指向 arr 的第一行</span><br>ptr[<span class="hljs-number">1</span>] = arr[<span class="hljs-number">1</span>];  <span class="hljs-comment">// ptr[1] 指向 arr 的第二行</span><br>ptr[<span class="hljs-number">2</span>] = arr[<span class="hljs-number">2</span>];  <span class="hljs-comment">// ptr[2] 指向 arr 的第三行</span><br></code></pre></td></tr></table></figure><p>在这种情况下，<code>ptr</code> 是一个数组，每个元素都是一个指向数组行的指针。你可以通过 <code>ptr[i][j]</code> 来访问数组中的元素。</p><div class="note note-warning">            <p><strong>使用二级指针不可以直接指向一个二维数组！（因为类型并不匹配）</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> ** testptr=<span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-type">int</span> a[<span class="hljs-number">5</span>][<span class="hljs-number">5</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br>    testptr=a;  <span class="hljs-comment">//INVALID!</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">会报错：</span><br><span class="hljs-comment">testcode_1.cpp: In function &#x27;int main()&#x27;:</span><br><span class="hljs-comment">testcode_1.cpp:40:13: error: cannot convert &#x27;int [5][5]&#x27; to &#x27;int**&#x27; in assignment</span><br><span class="hljs-comment">     testptr=a;</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> ** testptr=<span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-built_in">int</span> (*testptr2)[<span class="hljs-number">5</span>]=<span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-type">int</span> a[<span class="hljs-number">5</span>][<span class="hljs-number">5</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br>    testptr2=a;<br>    cout&lt;&lt;*testptr2&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;**testptr2;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">程序可以正常运行：</span><br><span class="hljs-comment">输出结果：0x61fd90 0</span><br><span class="hljs-comment">解释：*testptr2代表数组指针的首元素的值，是一个指向int的指针，再解引用一次才得到a[0][0]的值。</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>但是可以使用<strong>动态内存分配</strong>的方式，也可以让一个二级指针与二维数组相关联。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> rows = <span class="hljs-number">3</span>;<br>    <span class="hljs-type">int</span> cols = <span class="hljs-number">4</span>;<br><br>    <span class="hljs-comment">// 使用 new 动态分配二维数组</span><br>    <span class="hljs-type">int</span> **arr = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>*[rows];  <span class="hljs-comment">// 创建一个指针数组，每个元素指向一行</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; rows; i++) &#123;<br>        arr[i] = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[cols];  <span class="hljs-comment">// 每一行分配 cols 个 int</span><br>    &#125;<br><br>    <span class="hljs-comment">// 给二维数组赋值</span><br>    arr[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    arr[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">2</span>;<br>    arr[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>] = <span class="hljs-number">3</span>;<br>    arr[<span class="hljs-number">0</span>][<span class="hljs-number">3</span>] = <span class="hljs-number">4</span>;<br><br>    arr[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">5</span>;<br>    arr[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">6</span>;<br>    arr[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>] = <span class="hljs-number">7</span>;<br>    arr[<span class="hljs-number">1</span>][<span class="hljs-number">3</span>] = <span class="hljs-number">8</span>;<br><br>    arr[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">9</span>;<br>    arr[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">10</span>;<br>    arr[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>] = <span class="hljs-number">11</span>;<br>    arr[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>] = <span class="hljs-number">12</span>;<br><br>    <span class="hljs-comment">// 使用二级指针访问元素</span><br>    std::cout &lt;&lt; arr[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] &lt;&lt; std::endl;  <span class="hljs-comment">// 输出 1</span><br>    std::cout &lt;&lt; arr[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>] &lt;&lt; std::endl;  <span class="hljs-comment">// 输出 7</span><br>    std::cout &lt;&lt; arr[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>] &lt;&lt; std::endl;  <span class="hljs-comment">// 输出 12</span><br><br>    <span class="hljs-comment">// 释放内存</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; rows; i++) &#123;<br>        <span class="hljs-keyword">delete</span>[] arr[i];  <span class="hljs-comment">// 释放每行的内存</span><br>    &#125;<br>    <span class="hljs-keyword">delete</span>[] arr;  <span class="hljs-comment">// 释放指针数组</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>          </div><h2 id="Advanced-Technique-2-Rvalue"><a href="#Advanced-Technique-2-Rvalue" class="headerlink" title="Advanced Technique 2 Rvalue"></a>Advanced Technique 2 Rvalue</h2><p><strong>左值（Lvalue）</strong>：可以表示一个对象的内存位置，并且可以获取其地址。通常是变量、对象或数组元素。</p><p><strong>右值（Rvalue）</strong>：通常是临时对象、字面值或表达式的结果。右值不能获取地址，代表的是一个不再需要的值。</p><p>例如在<code>x=y+z</code>这个表达式中，x,y,z都是变量（左值），在内存中有对应的空间，可以进行取址运算，但是编译器会先计算<code>y+z</code>的值（<strong>这是一个表达式是右值</strong>），将这个值赋给x后，y+z的结果就消失了。</p><p>C++3 中引用类型的变量只能是左值，除非声明的是 const 的引用，因而称之为左值引用。而C++11 引入了右值引用。右值引用以<code>&amp;&amp;</code>来表示，它的初值只能是一个将要被销毁的对象。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> x = <span class="hljs-number">10</span>; <br><span class="hljs-type">int</span> &amp;&amp;y = x + <span class="hljs-number">9</span>; <br><span class="hljs-type">int</span> &amp;&amp;z = <span class="hljs-number">8</span> * <span class="hljs-number">9</span> % <span class="hljs-number">4</span>;<br></code></pre></td></tr></table></figure><p>由于<strong>右值引用只能绑定到临时对象</strong>，即该对象将要被销毁，这意味着<strong>右值引用的变量可以接管所引用的对象的资源</strong>。定义 y 和 z 时都没有分配空间，而是接管了存储右边表达式计算结果的临时变量的空间。 y 接管了存放 x+9 结果值的临时变量的空间。 z 接管了存放 8 * 9 % 4 结果值的临时变量的空间。 </p><blockquote><p>右值引用相当于给一个即将要消亡的值续了一口命让他一直存在。</p></blockquote><p>通过右值引用，C++ 能够实现<strong>移动语义</strong>，即当对象的资源不再需要时，可以直接将资源“移动”到另一个对象中，而不是进行昂贵的拷贝操作。例如，<code>std::vector</code>和<code>std::string</code>等容器类会利用右值引用来避免不必要的内存分配和数据复制。</p><p><strong>移动语义的核心思想是避免不必要的拷贝</strong>。例如，当我们将一个临时对象传递给容器时，容器可以通过移动构造而不是拷贝构造来获取该对象的资源。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LargeObject</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span>* data;<br>    <br>    <span class="hljs-built_in">LargeObject</span>(<span class="hljs-type">int</span> value) : <span class="hljs-built_in">data</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(value)) &#123;&#125;<br>    ~<span class="hljs-built_in">LargeObject</span>() &#123; <span class="hljs-keyword">delete</span> data; &#125;<br>    <br>    <span class="hljs-comment">// 移动构造函数</span><br>    <span class="hljs-built_in">LargeObject</span>(LargeObject&amp;&amp; other) <span class="hljs-keyword">noexcept</span> : <span class="hljs-built_in">data</span>(other.data) &#123;<br>        other.data = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 移动赋值运算符</span><br>    LargeObject&amp; <span class="hljs-keyword">operator</span>=(LargeObject&amp;&amp; other) <span class="hljs-keyword">noexcept</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;other) &#123;<br>            <span class="hljs-keyword">delete</span> data;<br>            data = other.data;<br>            other.data = <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    vector&lt;LargeObject&gt; vec;<br>    vec.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">LargeObject</span>(<span class="hljs-number">42</span>));  <span class="hljs-comment">// 移动构造而非拷贝构造</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><p>简单来说，赋值构造函数是将对象的所有值拷贝一份赋给一个新的对象（无论是浅拷贝还是深拷贝），如果我只是希望实现值的移动，我还需要将原来的对象删除，这样的效率十分低下。有了移动语义（移动构造函数），我们便可以实现<strong>不拷贝直接实现值的转移</strong>。</p></blockquote><div class="note note-primary">            <h3 id="const引用和右值引用的区别"><a href="#const引用和右值引用的区别" class="headerlink" title="const引用和右值引用的区别"></a><code>const</code>引用和右值引用的区别</h3><p><strong>什么是 <code>const</code> 引用？</strong></p><p><code>const</code> 引用是一种引用类型，它允许<strong>你通过引用来访问对象，但不允许修改对象的值</strong>。通过 <code>const</code> 引用，你可以<strong>避免复制对象，同时确保引用的对象不会被修改</strong>。这通常用于传递大对象或需要确保数据不被修改的场合。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> Type&amp; ref = object;<br></code></pre></td></tr></table></figure><p>这里的 <code>const Type&amp;</code> 表示一个常量引用，<code>object</code> 可以是左值或右值。</p><blockquote><p><code>const</code>引用经常出现在函数参数的传递过程中，即保证了<strong>高效</strong>，又保证了安全性。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printValue</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; value)</span> </span>&#123;<br>    std::cout &lt;&lt; value &lt;&lt; std::endl;  <span class="hljs-comment">// 不能修改 value，因为它是 const 引用</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">10</span>;<br>    <span class="hljs-built_in">printValue</span>(x);  <span class="hljs-comment">// 传递左值</span><br>    <span class="hljs-built_in">printValue</span>(<span class="hljs-number">20</span>); <span class="hljs-comment">// 传递右值</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong><code>const</code> 引用与右值引用的区别：</strong></p><ol><li><strong><code>const</code> 引用</strong>：</li></ol><ul><li><strong>允许绑定左值和右值</strong>：<code>const</code> 引用可以<strong>绑定到左值或右值。对于右值，它的作用是将其延长生命周期，保证在函数中可以安全地使用。</strong>当我们希望通过引用传递一个右值并延长其生命周期时。通过 <code>const</code> 引用绑定到右值，可以避免不必要的拷贝，同时又不会修改该对象。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">processConstRef</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; vec)</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Size of vector (const ref): &quot;</span> &lt;&lt; vec.<span class="hljs-built_in">size</span>() &lt;&lt; std::endl;<br>    <span class="hljs-comment">// vec.push_back(4); // 错误！不能修改 const 引用绑定的对象</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 创建一个右值（临时对象）</span><br>    <span class="hljs-built_in">processConstRef</span>(std::vector&lt;<span class="hljs-type">int</span>&gt;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;);  <span class="hljs-comment">// 这里传递的是一个右值</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">输出：Size of vector (const ref): 3</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p><code>std::vector&lt;int&gt;{1, 2, 3}</code> 是一个 <strong>右值</strong>，它是一个临时对象。我们通过 <code>const std::vector&lt;int&gt;&amp;</code> 将右值传递给 <code>processConstRef</code> 函数，<code>const</code> 确保了我们在函数内部不能修改这个对象。在 <code>processConstRef</code> 中，<code>vec</code> 是一个 <strong><code>const</code> 引用</strong>，它绑定到这个临时对象上，并延长了这个临时对象的生命周期。这样，直到 <code>processConstRef</code> 函数结束，右值才会被销毁。</p><blockquote><p>如果删除const关键词，会有报错：<code>cannot bind non-const lvalue reference of type &#39;std::vector&lt;int&gt;&amp;&#39; to an rvalue of type &#39;std::vector&lt;int&gt;&#39;</code></p></blockquote><ol start="2"><li><strong>右值引用（<code>Type&amp;&amp;</code>）</strong>：</li></ol><ul><li><strong>只能绑定到右值</strong>：右值引用是 C++11 引入的，它主要用于“移动语义”，只能绑定到右值（例如临时对象、函数返回值等）。</li><li><strong>允许移动资源</strong>：右值引用允许转移对象的资源，避免不必要的复制（例如通过 <code>std::move</code>），提高性能。</li><li><strong>可以修改原对象</strong>：通过右值引用，我们可以修改被移动的对象（例如，置为空）。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">processConstRef</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; vec)</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Size of vector (const ref): &quot;</span> &lt;&lt; vec.<span class="hljs-built_in">size</span>() &lt;&lt; std::endl;<br>    <span class="hljs-comment">// vec.push_back(4); // 错误！不能修改 const 引用绑定的对象</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">processRvalueRef</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt;&amp;&amp; vec)</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Size of vector (rvalue ref): &quot;</span> &lt;&lt; vec.<span class="hljs-built_in">size</span>() &lt;&lt; std::endl;<br>    vec.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">4</span>);  <span class="hljs-comment">// 可以修改 vec，因为它是右值引用</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; vec1 = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br><br>    <span class="hljs-comment">// 使用 const 引用</span><br>    <span class="hljs-built_in">processConstRef</span>(vec1);  <span class="hljs-comment">// 传递左值</span><br><br>    <span class="hljs-comment">// 使用右值引用</span><br>    <span class="hljs-built_in">processRvalueRef</span>(std::<span class="hljs-built_in">move</span>(vec1));  <span class="hljs-comment">// 传递右值，vec1 资源被“移动”</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;vec1 size after move: &quot;</span> &lt;&lt; vec<span class="hljs-number">1.</span><span class="hljs-built_in">size</span>() &lt;&lt; std::endl;  <span class="hljs-comment">// vec1 现在为空</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">Size of vector (const ref): 3</span><br><span class="hljs-comment">Size of vector (rvalue ref): 3</span><br><span class="hljs-comment">vec1 size after move: 0</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><ol><li><strong><code>const&amp;</code> 引用</strong>：<code>processConstRef</code> 函数使用了 <code>const</code> 引用，它可以接收左值或右值，但无法修改 <code>vec</code> 的内容。</li><li><strong>右值引用（<code>&amp;&amp;</code>）</strong>：<code>processRvalueRef</code> 函数使用了右值引用，它只能接收右值，并且**可以修改 <code>vec</code>**（在本例中就是将数据“移动”到 <code>processRvalueRef</code>，并且通过 <code>push_back</code> 添加数据）。</li></ol><p><strong>总结一下，const引用和右值引用都可以绑定到右值上，但是两者的具体功能是不一样的：const引用重点在<code>const</code>上，而右值引用主要在移动语义等方面提供了更高的效率（避免了不必要的复制过程）。</strong></p>          </div><h2 id="Advanced-Technique-3-parameters-in-the-main-function"><a href="#Advanced-Technique-3-parameters-in-the-main-function" class="headerlink" title="Advanced Technique 3 parameters in the main function"></a>Advanced Technique 3 parameters in the main function</h2><p>在我们之前写的C++程序中，main函数是<strong>没有参数且返回值为0</strong>的，程序能够正常退出。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cout&lt;&lt;<span class="hljs-string">&quot;Hello world&quot;</span>&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-comment">//如果更改为return 1,那么程序仍能运行，但是会显示异常退出。</span><br></code></pre></td></tr></table></figure><p><strong>带参数的 <code>main</code> 函数</strong>：它接受命令行参数，允许程序在启动时接收外部输入。这种形式在处理用户输入或命令行参数时非常有用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span> </span>&#123;<br>    <span class="hljs-comment">// 程序代码</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><ol><li>**<code>argc</code>**：<code>argc</code> 是 <strong>argument count</strong>（参数计数）的缩写，表示传递给程序的命令行参数的个数。它的值至少为 1，因为程序名称本身也算作一个参数。</li><li>**<code>argv</code>**：<code>argv</code> 是 <strong>argument vector</strong>（参数向量）的缩写，它是一个指向字符指针数组的指针，数组的每个元素都是一个命令行参数（字符串）。<code>argv[0]</code> 通常是程序的名称，<code>argv[1]</code>、<code>argv[2]</code> 等依次是传递给程序的其他参数。</li></ol><p>例如下面的程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;程序名称: &quot;</span> &lt;&lt; argv[<span class="hljs-number">0</span>] &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;传递的参数个数: &quot;</span> &lt;&lt; argc - <span class="hljs-number">1</span> &lt;&lt; endl;  <span class="hljs-comment">// 不算程序名称</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;传递的参数: &quot;</span>;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; argc; ++i) &#123;  <span class="hljs-comment">// 从1开始，跳过程序名称</span><br>        cout &lt;&lt; argv[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li>**<code>argv[0]</code>**：程序名称，通常是执行程序时给出的文件名（例如 <code>&quot;./my_program&quot;</code>）。</li><li>**<code>argv[1]</code>、<code>argv[2]</code>**：这些是用户传递给程序的额外命令行参数。</li><li>**<code>argc</code>**：命令行参数的个数。对于上述程序，<code>argc</code> 至少为 1，因为 <code>argv[0]</code> 是程序名称。</li></ul><p><strong>编译与运行</strong>：</p><p>假设程序的文件名为 <code>program.cpp</code>，你可以按以下方式编译和运行它：</p><ol><li><p>编译程序：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">g++ program.cpp -o program<br></code></pre></td></tr></table></figure></li><li><p>运行程序，并传递一些命令行参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./program arg1 arg2 arg3<br></code></pre></td></tr></table></figure><p>输出将是：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">程序名称: ./program</span><br><span class="hljs-section">传递的参数个数: 3</span><br><span class="hljs-section">传递的参数: arg1 arg2 arg3</span><br></code></pre></td></tr></table></figure></li></ol><blockquote><p>在一些第三方库的使用中，带参数的main函数是非常强大的。</p></blockquote><h2 id="Advanced-Technique-4-Function-Pointer"><a href="#Advanced-Technique-4-Function-Pointer" class="headerlink" title="Advanced Technique 4 Function Pointer"></a>Advanced Technique 4 Function Pointer</h2><div class="note note-info">            <p><strong>问题引入：函数在内存中有自己的地址？</strong></p><p><strong>函数在内存中是有地址的</strong>。每个函数在程序加载到内存时，都会被分配一个唯一的内存地址，通常这个地址是指向函数代码开始位置的地址。在 C++ 中，我们可以通过<strong>函数指针</strong>来获取这个地址，从而间接地访问和调用函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myFunction</span><span class="hljs-params">()</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Hello, this is myFunction!&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cout &lt;&lt; (<span class="hljs-type">void</span>*)myFunction &lt;&lt; endl;  <span class="hljs-comment">// 输出函数的地址</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>函数名</strong>和数组名类似，代表了函数在内存中的地址。</p><blockquote><p>这里用到<code>(void*)</code>进行指针的强制类型转换，因为函数指针在cout中会被隐式转换成布尔值（即输出1）。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myFunction</span><span class="hljs-params">()</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Hello, this is myFunction!&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 获取函数的地址，并将其赋给一个函数指针</span><br>    <span class="hljs-built_in">void</span> (*funcPtr)() = myFunction;<br><br>    <span class="hljs-comment">// 通过函数指针调用函数</span><br>    <span class="hljs-built_in">funcPtr</span>();  <span class="hljs-comment">// 等同于 myFunction()</span><br>    <br>    <span class="hljs-comment">// 输出函数的内存地址</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;Function address: &quot;</span> &lt;&lt; (<span class="hljs-type">void</span>*)funcPtr &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">输出：</span><br><span class="hljs-comment">Hello, this is myFunction!</span><br><span class="hljs-comment">Function address: 0x401550</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>在上面的例子中，<code>funcPtr</code> 是一个指向 <code>myFunction</code> 函数的指针。<code>funcPtr</code> 存储了 <code>myFunction</code> 函数的内存地址。通过这个指针，我们可以调用函数。</p><ul><li><strong>函数名</strong>本身在 C++ 中是一个<strong>常量指针</strong>，指向函数的内存地址。例如，<code>myFunction</code> 就代表了 <code>myFunction</code> 函数的地址。</li><li>通过 <code>(void*)funcPtr</code> 可以将函数指针转为 <code>void*</code> 类型，进而打印出函数的内存地址。</li></ul>          </div><p>在 C++ 中，<strong>函数指针</strong>（Function Pointer）是一个指向函数的指针变量，类似于指向普通数据类型的指针。通过函数指针，我们可以动态地调用函数，而不需要直接调用它们的名称。函数指针在实现回调机制、事件驱动编程、以及某些设计模式（如策略模式）时非常有用。</p><ol><li><strong>函数指针的声明</strong></li></ol><p>函数指针的声明需要指定函数的返回类型、参数类型以及指针本身的类型。声明的形式与函数的声明很相似，关键在于指针的符号 <code>*</code> 和 <code>&amp;</code> 的使用。</p><p>假设有一个返回 <code>int</code> 类型，参数为 <code>int</code> 和 <code>float</code> 的函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">my_function</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">float</span>)</span></span>;<br></code></pre></td></tr></table></figure><p>那么，指向该函数的函数指针应该这样声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">int</span> (*func_ptr)(<span class="hljs-type">int</span>, <span class="hljs-type">float</span>);<br></code></pre></td></tr></table></figure><ul><li><code>int (*func_ptr)(int, float)</code>：表示 <code>func_ptr</code> 是一个指向函数的指针，函数的返回类型是 <code>int</code>，参数类型是 <code>int</code> 和 <code>float</code>。</li><li><code>(*func_ptr)</code> 表示 <code>func_ptr</code> 是一个指针，指向的内容是一个函数。</li></ul><ol start="2"><li><strong>函数指针的初始化</strong></li></ol><p>函数指针可以通过将它指向某个具体的函数来初始化。你可以将函数名赋给函数指针，因为函数名本身就是指向函数的指针。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">my_function</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">float</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">int</span> (*func_ptr)(<span class="hljs-type">int</span>, <span class="hljs-type">float</span>);  <span class="hljs-comment">// 函数指针声明</span><br>    func_ptr = my_function;       <span class="hljs-comment">// 初始化指针，指向 my_function</span><br><br>    <span class="hljs-comment">// 通过函数指针调用函数</span><br>    <span class="hljs-type">int</span> result = <span class="hljs-built_in">func_ptr</span>(<span class="hljs-number">5</span>, <span class="hljs-number">3.2</span>); <span class="hljs-comment">// 等价于 my_function(5, 3.2)</span><br>    std::cout &lt;&lt; result &lt;&lt; std::endl;  <span class="hljs-comment">// 输出 8</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的代码中，<code>func_ptr</code> 是一个指向 <code>my_function</code> 函数的指针。通过 <code>func_ptr</code> 调用函数，功能与直接调用 <code>my_function</code> 一样。</p><ol start="3"><li><strong>通过函数指针调用函数</strong></li></ol><p>一旦函数指针被正确初始化，你可以使用该指针来调用函数。通过 <code>*</code> 解引用函数指针，然后传递参数来调用目标函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">int</span> (*func_ptr)(<span class="hljs-type">int</span>, <span class="hljs-type">float</span>);  <span class="hljs-comment">// 函数指针声明</span><br>func_ptr = my_function;       <span class="hljs-comment">// 函数指针初始化</span><br><br><span class="hljs-comment">// 使用函数指针调用函数</span><br><span class="hljs-type">int</span> result = (*func_ptr)(<span class="hljs-number">10</span>, <span class="hljs-number">5.5</span>);  <span class="hljs-comment">// 等同于 my_function(10, 5.5)</span><br>std::cout &lt;&lt; <span class="hljs-string">&quot;Result: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;<br></code></pre></td></tr></table></figure><p>你也可以直接用 <code>func_ptr(10, 5.5)</code> 来调用函数，因为 <code>func_ptr</code> 本身就代表了一个函数。</p><ol start="4"><li><strong>函数指针数组</strong></li></ol><p>你可以创建一个指向多个函数的数组。这样的数组允许你根据索引动态选择不同的函数进行调用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123; <span class="hljs-keyword">return</span> a + b; &#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">subtract</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123; <span class="hljs-keyword">return</span> a - b; &#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">multiply</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123; <span class="hljs-keyword">return</span> a * b; &#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 创建函数指针数组，数组元素是指向函数的指针</span><br>    <span class="hljs-built_in">int</span> (*operations[<span class="hljs-number">3</span>])(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>) = &#123;add, subtract, multiply&#125;;<br><br>    <span class="hljs-comment">// 动态调用不同的操作</span><br>    <span class="hljs-type">int</span> x = <span class="hljs-number">5</span>, y = <span class="hljs-number">3</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Add: &quot;</span> &lt;&lt; operations[<span class="hljs-number">0</span>](x, y) &lt;&lt; endl;        <span class="hljs-comment">// add(5, 3)</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;Subtract: &quot;</span> &lt;&lt; operations[<span class="hljs-number">1</span>](x, y) &lt;&lt; endl;   <span class="hljs-comment">// subtract(5, 3)</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;Multiply: &quot;</span> &lt;&lt; operations[<span class="hljs-number">2</span>](x, y) &lt;&lt; endl;   <span class="hljs-comment">// multiply(5, 3)</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>operations</code> 是一个函数指针数组，其中每个元素都指向一个函数。你可以使用数组的索引来选择要调用的函数。</p><blockquote><p>可以用于菜单选择。</p></blockquote><div class="note note-warning">            <p>注意，函数指针数组要求<strong>数组中的每一个函数的返回值和特征表都要相同！</strong></p><ul><li>例如，如果修改add函数为<code>int add(int a, double b) { return a + b; }</code>，会产生报错：<code>invalid conversion from &#39;int (*)(int, double)&#39; to &#39;int (*)(int, int)&#39; [-fpermissive]</code></li><li>修改<code>int add(int a) { return a; }</code>，会产生报错：<code>invalid conversion from &#39;int (*)(int)&#39; to &#39;int (*)(int, int)&#39; [-fpermissive]</code></li><li>修改<code>double add(int a ,int b) { return a+b; }</code>，会产生报错：<code>invalid conversion from &#39;double (*)(int, int)&#39; to &#39;int (*)(int, int)&#39; [-fpermissive]</code><ul><li>你当然可以用指针的<strong>强制类型转换</strong>来实现这一点，但是这又会带来更大的隐患。</li></ul></li></ul>          </div><ol start="5"><li><strong>作为函数参数的函数指针</strong></li></ol><p>函数指针常常作为参数传递给其他函数，允许在运行时选择不同的函数进行调用。这是一种典型的<strong>回调机制</strong>。</p><p>示例：<strong>回调函数</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 定义一个函数类型</span><br><span class="hljs-keyword">using</span> FuncPtr = <span class="hljs-built_in">void</span>(*)(<span class="hljs-type">int</span>);  <span class="hljs-comment">// 函数指针类型，指向接受 int 参数并返回 void 的函数</span><br><br><span class="hljs-comment">// 函数 1</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print_square</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Square: &quot;</span> &lt;&lt; x * x &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">// 函数 2</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print_cube</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Cube: &quot;</span> &lt;&lt; x * x * x &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">// 一个函数，它接受一个函数指针作为参数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">process_number</span><span class="hljs-params">(<span class="hljs-type">int</span> num, FuncPtr callback)</span> </span>&#123;<br>    <span class="hljs-built_in">callback</span>(num);  <span class="hljs-comment">// 调用回调函数</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> num = <span class="hljs-number">5</span>;<br>    <br>    <span class="hljs-comment">// 使用不同的回调函数</span><br>    <span class="hljs-built_in">process_number</span>(num, print_square);  <span class="hljs-comment">// 调用 print_square</span><br>    <span class="hljs-built_in">process_number</span>(num, print_cube);    <span class="hljs-comment">// 调用 print_cube</span><br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>process_number</code> 函数接收一个函数指针 <code>callback</code>，它指向一个接受 <code>int</code> 参数并返回 <code>void</code> 的函数。你可以传递不同的函数来处理同一个数字，这样就实现了动态的行为。</p><p>举个实际的例子：<strong>函数指针和冒泡排序</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(T a[],<span class="hljs-type">int</span> size,<span class="hljs-type">bool</span>(*f)(T,T))</span> </span>&#123;<br>    <span class="hljs-type">bool</span> flag;<br>    <span class="hljs-type">int</span> i,j;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;size;++i) &#123;<br>        flag=<span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;size-i<span class="hljs-number">-1</span>;++j) &#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">f</span>(a[j],a[j<span class="hljs-number">+1</span>])) &#123;<br>                T temp=a[j];<br>                a[j]=a[j<span class="hljs-number">+1</span>];<br>                a[j<span class="hljs-number">+1</span>]=temp;<br>                flag=<span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(!flag)<span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">increaseInt</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<span class="hljs-keyword">return</span> x&gt;y;&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">decreaseInt</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<span class="hljs-keyword">return</span> x&lt;y;&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">increaseString</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* x,<span class="hljs-type">const</span> <span class="hljs-type">char</span>* y)</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">strcmp</span>(x,y)&gt;<span class="hljs-number">0</span>;&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">decreaseString</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* x,<span class="hljs-type">const</span> <span class="hljs-type">char</span>* y)</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">strcmp</span>(x,y)&lt;<span class="hljs-number">0</span>;&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> a[]=&#123;<span class="hljs-number">92</span>,<span class="hljs-number">73</span>,<span class="hljs-number">36</span>,<span class="hljs-number">63</span>,<span class="hljs-number">13</span>&#125;;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>*b[]=&#123;<span class="hljs-string">&quot;hsc&quot;</span>,<span class="hljs-string">&quot;cbs&quot;</span>,<span class="hljs-string">&quot;abx&quot;</span>,<span class="hljs-string">&quot;bcj&quot;</span>&#125;;<br>    <span class="hljs-comment">//cout&lt;&lt;strcmp(b[1],b[2]);</span><br>    <span class="hljs-built_in">sort</span>&lt;<span class="hljs-type">int</span>&gt;(a,<span class="hljs-number">5</span>,increaseInt);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++) cout&lt;&lt;a[i]&lt;&lt;<span class="hljs-string">&quot;\t&quot;</span>;<br>    cout&lt;&lt;endl;<br>    <span class="hljs-built_in">sort</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">char</span>*&gt;(b,<span class="hljs-number">4</span>,decreaseString);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++) cout&lt;&lt;b[i]&lt;&lt;<span class="hljs-string">&quot;\t&quot;</span>;<br>    cout&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">输出结果:</span><br><span class="hljs-comment">13      36      63      73      92</span><br><span class="hljs-comment">hsc     cbs     bcj     abx</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p><code>bool(*f)(T,T))</code>就是函数指针作为函数参数的用法（<strong>回调函数</strong>）。类似于<code>sort</code>函数的<code>compare</code>函数一样，在冒泡排序算法中，搭配不同的<code>bool(*f)(T,T))</code>可以实现自定义的排序顺序。</p><ol start="6"><li><strong>函数指针和 <code>const</code> 修饰符</strong></li></ol><p>如果你想确保函数指针指向的函数不被修改，可以使用 <code>const</code> 修饰符。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123; <span class="hljs-keyword">return</span> a + b; &#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">subtract</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123; <span class="hljs-keyword">return</span> a - b; &#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 定义一个常量函数指针，指向不修改函数的函数</span><br>    <span class="hljs-built_in">int</span> (*<span class="hljs-type">const</span> func_ptr)(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>) = add;<br>    <br>    <span class="hljs-comment">// func_ptr = subtract;  // 错误，不能改变指针的值</span><br>    <span class="hljs-type">int</span> result = <span class="hljs-built_in">func_ptr</span>(<span class="hljs-number">10</span>, <span class="hljs-number">5</span>);  <span class="hljs-comment">// 正确，调用 add</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;Result: &quot;</span> &lt;&lt; result &lt;&lt; endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这里，<code>func_ptr</code> 是一个常量函数指针，意味着它一旦指向 <code>add</code> 函数，就不能再改变指向其他函数。</p><h2 id="Advanced-Technique-5-Lambda-expression"><a href="#Advanced-Technique-5-Lambda-expression" class="headerlink" title="Advanced Technique 5 Lambda expression"></a>Advanced Technique 5 Lambda expression</h2><p>C++ 中的 <strong>Lambda 表达式</strong> 是一种轻量级的匿名函数，它允许在代码中定义和使用一个函数对象，而不需要事先为其命名。Lambda 表达式使得 C++ 代码更加简洁和灵活，特别是在需要临时传递函数作为参数时非常有用。</p><p>C++11 引入了 Lambda 表达式，基本语法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">[捕获列表](参数列表) -&gt; 返回类型 &#123; 函数体 &#125;<br></code></pre></td></tr></table></figure><p>其中各部分的含义如下：</p><ul><li><strong>捕获列表</strong>（Capture list）：指定 Lambda 表达式访问外部变量的方式。捕获列表允许 Lambda 表达式“捕获”<strong>外部作用域中的变量</strong>，并可以在函数体内使用这些变量。</li><li><strong>参数列表</strong>（Parameter list）：指定 Lambda 表达式的输入参数，类似于普通函数的参数。</li><li><strong>返回类型</strong>（Return type）：指定 Lambda 表达式的返回类型，可以省略，编译器会根据返回值推导类型。</li><li><strong>函数体</strong>（Function body）：Lambda 表达式的实际代码，包含执行的语句。</li></ul><ol><li><strong>捕获列表（Capture List）</strong></li></ol><p>捕获列表定义了 Lambda 表达式如何访问外部作用域的变量。捕获方式有以下几种：</p><ul><li><p>按值捕获：捕获外部变量的副本</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">[x] &#123; std::cout &lt;&lt; x; &#125;  <span class="hljs-comment">// 捕获 x 的副本</span><br></code></pre></td></tr></table></figure></li><li><p>按引用捕获：捕获外部变量的引用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">[&amp;x] &#123; x = <span class="hljs-number">10</span>; &#125;  <span class="hljs-comment">// 捕获 x 的引用，允许修改 x</span><br></code></pre></td></tr></table></figure></li><li><p>捕获所有变量按值：捕获所有外部变量的副本</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">[=] &#123; std::cout &lt;&lt; x &lt;&lt; y; &#125;  <span class="hljs-comment">// 捕获所有外部变量的副本</span><br></code></pre></td></tr></table></figure></li><li><p>捕获所有变量按引用：捕获所有外部变量的引用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">[&amp;] &#123; x = <span class="hljs-number">10</span>; y = <span class="hljs-number">20</span>; &#125;  <span class="hljs-comment">// 捕获所有外部变量的引用</span><br></code></pre></td></tr></table></figure></li><li><p>按值和引用混合捕获：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">[=, &amp;x] &#123; x = <span class="hljs-number">10</span>; &#125;  <span class="hljs-comment">// 捕获所有外部变量按值，x 按引用</span><br></code></pre></td></tr></table></figure></li></ul><ol start="2"><li><strong>参数列表</strong></li></ol><p>Lambda 表达式的参数列表与普通函数类似，可以定义输入参数。如果没有参数，参数列表可以省略。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">[]() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Hello, World!&quot;</span> &lt;&lt; std::endl; &#125;<br></code></pre></td></tr></table></figure><ol start="3"><li><strong>返回类型</strong></li></ol><p><strong>Lambda 表达式的返回类型通常可以省略</strong>，编译器会根据函数体中的返回语句推导出返回类型。如果需要显式指定返回类型，可以使用 <code>-&gt;</code> 语法。</p><blockquote><p>这怎么那么像python的语法？？？</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> lambda = []() -&gt; <span class="hljs-type">int</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>; &#125;;<br>std::cout &lt;&lt; <span class="hljs-built_in">lambda</span>() &lt;&lt; std::endl;  <span class="hljs-comment">// 输出 42</span><br></code></pre></td></tr></table></figure><ol start="4"><li><strong>Lambda 表达式的实际例子</strong></li></ol><ul><li>按值捕获</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">auto</span> lambda = [x]() &#123; cout &lt;&lt; <span class="hljs-string">&quot;x = &quot;</span> &lt;&lt; x &lt;&lt; endl; &#125;;<br>    <span class="hljs-built_in">lambda</span>();  <span class="hljs-comment">// 输出: x = 5</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的 Lambda 捕获了变量 <code>x</code> 的值，并输出它。</p><ul><li>按引用捕获</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">auto</span> lambda = [&amp;x]() &#123; x = <span class="hljs-number">10</span>; &#125;;  <span class="hljs-comment">// 捕获 x 的引用</span><br>    <span class="hljs-built_in">lambda</span>();<br>    cout &lt;&lt; <span class="hljs-string">&quot;x = &quot;</span> &lt;&lt; x &lt;&lt; endl;  <span class="hljs-comment">// 输出: x = 10</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码通过按引用捕获，Lambda 表达式能够修改外部变量 <code>x</code>。</p><ul><li>带参数的 Lambda</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> add = [](<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b) &#123; <span class="hljs-keyword">return</span> a + b; &#125;;<br>    cout &lt;&lt; <span class="hljs-built_in">add</span>(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>) &lt;&lt; endl;  <span class="hljs-comment">// 输出: 8</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这是一个带有两个整型参数的 Lambda 表达式，用于计算两个数的和。</p><ol start="5"><li><strong>Lambda 表达式的高级用法</strong></li></ol><ul><li>Lambda <strong>表达式作为参数</strong></li></ul><p>Lambda 表达式常用于 STL 算法中作为参数，尤其是像 <code>std::sort</code> 这样的函数，它允许你提供自定义的排序规则。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; vec = &#123;<span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>&#125;;<br>    <br>    <span class="hljs-comment">// 使用 Lambda 表达式自定义排序规则</span><br>    <span class="hljs-built_in">sort</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b) &#123; <span class="hljs-keyword">return</span> a &gt; b; &#125;);<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> val : vec) &#123;<br>        cout &lt;&lt; val &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <span class="hljs-comment">// 输出: 5 4 3 2 1</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，Lambda 表达式 <code>[ ]</code> 用于指定排序的比较规则。</p><ul><li><strong>使用 <code>mutable</code> 修改捕获变量</strong></li></ul><p>默认情况下，捕获的变量在 Lambda 中是 <strong>常量</strong>，不能修改。如果你需要在 Lambda 内部修改捕获的变量，可以使用 <code>mutable</code> 关键字。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">auto</span> lambda = [x]() <span class="hljs-keyword">mutable</span> &#123; x = <span class="hljs-number">10</span>; cout &lt;&lt; <span class="hljs-string">&quot;x inside lambda: &quot;</span> &lt;&lt; x &lt;&lt; endl; &#125;;<br>    <span class="hljs-built_in">lambda</span>();<br>    cout &lt;&lt; <span class="hljs-string">&quot;x outside lambda: &quot;</span> &lt;&lt; x &lt;&lt; endl;  <span class="hljs-comment">// 输出: x outside lambda: 5</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用 <code>mutable</code> 后，捕获的变量 <code>x</code> 在 Lambda 内部变成可修改的副本，但是外部的 <code>x</code> 不会受到影响。</p><ul><li><strong>返回 Lambda 表达式</strong></li></ul><p><strong>Lambda 表达式也可以返回 Lambda</strong>。例如，返回一个根据输入参数变化的 Lambda：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">createAdder</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> [x](<span class="hljs-type">int</span> y) &#123; <span class="hljs-keyword">return</span> x + y; &#125;;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> add5 = <span class="hljs-built_in">createAdder</span>(<span class="hljs-number">5</span>);<br>    <span class="hljs-comment">//在这里add5是一个函数指针，相当于createAdder的返回值，可以继续进行操作。</span><br>    cout &lt;&lt; <span class="hljs-built_in">add5</span>(<span class="hljs-number">10</span>) &lt;&lt; endl;  <span class="hljs-comment">// 输出: 15</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>createAdder</code> 返回一个 Lambda 表达式，它会将传入的 <code>x</code> 与每次调用时传入的 <code>y</code> 相加。</p><ol start="6"><li><strong>总结</strong></li></ol><ul><li><strong>Lambda 表达式</strong> 是 C++ 中一种轻量级的匿名函数，可以捕获外部变量并在局部上下文中使用。</li><li>捕获方式有按值捕获、按引用捕获、按值或按引用混合捕获等。</li><li>Lambda 表达式可以带有参数和返回类型，可以通过 <code>mutable</code> 关键字修改捕获的外部变量。</li><li>Lambda 表达式常用于 STL 算法、回调函数、事件处理等场景，提供了更高的灵活性和代码简洁性。</li></ul><h2 id="Advanced-Technique-6-Smart-Pointer"><a href="#Advanced-Technique-6-Smart-Pointer" class="headerlink" title="Advanced Technique 6 Smart Pointer"></a>Advanced Technique 6 Smart Pointer</h2><p>在之前的学习过程中我们知道，使用<code>new</code>命令动态分配内存，需要手动<code>delete</code>来释放分配在<strong>堆</strong>的内存，否则会发生严重的内存泄漏，导致程序崩溃。在C++98中，**引入了<code>auto_ptr</code>，来自动实现内存回收的功能（所以被称作智能指针）。但是，在C++11的新标准中，<code>auto_ptr</code>被摒弃，取而代之的是三种新的智能指针：<code>unique_ptr</code>,<code>shared_ptr</code>,<code>weak_ptr</code>**。</p><h3 id="为什么需要智能指针"><a href="#为什么需要智能指针" class="headerlink" title="为什么需要智能指针"></a>为什么需要智能指针</h3><p>​我们希望智能指针能够在程序终止时<strong>自动回收为指针所分配的内存而非手动删除</strong>，看下面的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cassert&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">testfunction</span><span class="hljs-params">(string &amp;str,<span class="hljs-type">int</span> n)</span></span>&#123;<br>    str=<span class="hljs-string">&quot;Hello world&quot;</span>;<br>    string *pd=<span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>(str);<br>    <span class="hljs-built_in">assert</span>(n==<span class="hljs-number">0</span>);<br>    pd=&amp;str;<br>    cout&lt;&lt;pd&lt;&lt;endl;<br>    cout&lt;&lt;*pd&lt;&lt;endl;<br>    cout&lt;&lt;&amp;str&lt;&lt;endl&lt;&lt;str&lt;&lt;endl;<br>    <span class="hljs-keyword">delete</span> pd;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    string str;<br>    <span class="hljs-built_in">testfunction</span>(str,<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-number">0x61fd20</span><br>Hello world<br><span class="hljs-number">0x61fd20</span><br>Hello world<br></code></pre></td></tr></table></figure><p>​我们不难发现<strong>手动删除内存是一件效率十分低下的事情！</strong>，如果我没有正确的通过<code>assert</code>断言，我就不会执行<code>delete</code>语句实现内存的回收。因此，<strong>我们希望pd指针有着更强大的功能——在程序终止时自动回收</strong>。如何在类中实现对象的回收与销毁？<strong>析构函数！</strong></p><blockquote><p><code>auto_ptr</code>的类定义(确实是有析构函数的！)</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Tp&gt;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">auto_ptr</span><br>    &#123;<br>    <span class="hljs-keyword">private</span>:<br>      _Tp* _M_ptr;<br>        <span class="hljs-comment">//声明了一个私有成员变量 _M_ptr，它是一个指向模板类型 _Tp 的指针，用于存储 auto_ptr 管理的对象的地址</span><br>    <span class="hljs-keyword">public</span>:<br>      <span class="hljs-comment">/// The pointed-to type.</span><br>      <span class="hljs-keyword">typedef</span> _Tp element_type;<br>      <span class="hljs-comment">//定义了一个类型别名 element_type，它是 _Tp 的同义词，用于表示 auto_ptr 所管理的对象类型。</span><br>      <span class="hljs-function"><span class="hljs-keyword">explicit</span></span><br><span class="hljs-function">      <span class="hljs-title">auto_ptr</span><span class="hljs-params">(element_type* __p = <span class="hljs-number">0</span>)</span> <span class="hljs-title">throw</span><span class="hljs-params">()</span> : _M_ptr(__p) &#123;</span> &#125;<br>      <span class="hljs-comment">/*</span><br><span class="hljs-comment">        这是 auto_ptr 的构造函数：</span><br><span class="hljs-comment">          explicit 关键字意味着这个构造函数不能用于隐式类型转换。</span><br><span class="hljs-comment">          构造函数接受一个指向 element_type 类型的指针  __p 作为参数，默认值为 0（即 NULL）。</span><br><span class="hljs-comment">          throw() 表示这个构造函数不会抛出异常（在C++98中，异常规范已弃用）。</span><br><span class="hljs-comment">          构造函数体通过初始化列表将传入的指针赋值给 _M_ptr</span><br><span class="hljs-comment">          </span><br><span class="hljs-comment">      */</span><br>      ~<span class="hljs-built_in">auto_ptr</span>() &#123; <span class="hljs-keyword">delete</span> _M_ptr; &#125;<br>        <span class="hljs-comment">//当 auto_ptr 对象被销毁时，析构函数被调用。</span><br>        <span class="hljs-comment">//它使用 delete 来释放 _M_ptr 所指向的内存，从而自动管理资源。</span><br>      <span class="hljs-comment">//other members.............</span><br>    &#125;;<br></code></pre></td></tr></table></figure><h3 id="auto-ptr"><a href="#auto-ptr" class="headerlink" title="auto_ptr"></a><code>auto_ptr</code></h3><p>​这就是<code>auto_ptr</code>的基本思想，<strong>通过析构函数在指针结束其生命周期的时候自动释放内存</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">auto_ptr&lt;<span class="hljs-type">double</span>&gt; <span class="hljs-title">pd</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">double</span>)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>智能指针和普通的动态内存分配在使用上还有哪些差异？</strong>请看下面的两组程序的对比：在程序中实现了相同的<code>MyClass</code>类，包含数据成员<code>value</code>以及对应的构造函数，析构函数和<code>showMessage()</code>函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs Cpp"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span>  <span class="hljs-comment">// 引入 auto_ptr 需要的头文件</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>    <span class="hljs-type">int</span> value;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">int</span> n):<span class="hljs-built_in">value</span>(n)&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;MyClass constructor&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    ~<span class="hljs-built_in">MyClass</span>() &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;MyClass destructor&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showMessage</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Hello from MyClass!&quot;</span> &lt;&lt; std::endl;<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;The value is&quot;</span>&lt;&lt;value&lt;&lt;std::endl;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demonotAutoPtr</span><span class="hljs-params">()</span> </span>&#123;<br>    MyClass* ptr1=<span class="hljs-keyword">new</span> <span class="hljs-built_in">MyClass</span>(<span class="hljs-number">4</span>);<br>    ptr1-&gt;<span class="hljs-built_in">showMessage</span>();<br>    MyClass *ptr2;<br>    ptr2=ptr1;<br>    ptr2-&gt;<span class="hljs-built_in">showMessage</span>();<br>    ptr1-&gt;<span class="hljs-built_in">showMessage</span>();<br>    <span class="hljs-keyword">delete</span> ptr1;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">demonotAutoPtr</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">MyClass constructor</span><br><span class="hljs-comment">Hello from MyClass!</span><br><span class="hljs-comment">The value is4</span><br><span class="hljs-comment">Hello from MyClass!</span><br><span class="hljs-comment">The value is4</span><br><span class="hljs-comment">Hello from MyClass!</span><br><span class="hljs-comment">The value is4</span><br><span class="hljs-comment">MyClass destructor</span><br><span class="hljs-comment">(这里程序正常运行并且正常退出)</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span>  <span class="hljs-comment">// 引入 auto_ptr 需要的头文件</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>    <span class="hljs-type">int</span> value;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">int</span> n):<span class="hljs-built_in">value</span>(n)&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;MyClass constructor&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    ~<span class="hljs-built_in">MyClass</span>() &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;MyClass destructor&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showMessage</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Hello from MyClass!&quot;</span> &lt;&lt; std::endl;<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;The value is&quot;</span>&lt;&lt;value&lt;&lt;std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demoAutoPtr</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 创建一个 auto_ptr，并初始化为指向动态分配的 MyClass 对象</span><br>    <span class="hljs-function">std::auto_ptr&lt;MyClass&gt; <span class="hljs-title">ptr1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> MyClass(<span class="hljs-number">4</span>))</span></span>;<br>    ptr1-&gt;<span class="hljs-built_in">showMessage</span>();  <span class="hljs-comment">// 使用 auto_ptr 指向的对象</span><br><br>    <span class="hljs-comment">// 将 ptr1 转移给 ptr2，这样 ptr1 变为空，ptr2 拥有 MyClass 的所有权</span><br>    std::auto_ptr&lt;MyClass&gt; ptr2 = ptr1;<br>    <span class="hljs-comment">// 此时 ptr1 不再持有对象，只有 ptr2 拥有 MyClass 对象</span><br>    ptr2-&gt;<span class="hljs-built_in">showMessage</span>();<br>    ptr1-&gt;<span class="hljs-built_in">showMessage</span>();<br>    <span class="hljs-comment">// ptr2 会在超出作用域时自动销毁，并调用 MyClass 的析构函数</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">demoAutoPtr</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">MyClass constructor</span><br><span class="hljs-comment">Hello from MyClass!</span><br><span class="hljs-comment">The value is 4</span><br><span class="hljs-comment">Hello from MyClass!</span><br><span class="hljs-comment">The value is 4</span><br><span class="hljs-comment">Hello from MyClass!</span><br><span class="hljs-comment">The value is</span><br><span class="hljs-comment">(最后程序会异常退出)</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>通过对比可以发现，两者唯一的不同是在函数<code>demoAutoPtr()</code>中一个使用<strong>动态内存</strong>，另一个使用<strong>智能指针</strong>。两者实现的操作都是一样的，创建<code>ptr1</code>后将<code>ptr1</code>的值转移给<code>ptr2</code>。但是程序在最后调用<code>ptr1-&gt;showMessage();</code>这条语句的时候出现了差异：<strong>基于动态内存实现的指针保留的原来的value值，但是基于智能指针实现的指针在此处value值丢失了，导致程序的异常终止。</strong></p><p>在 <code>auto_ptr</code> 的赋值操作中，资源的所有权被转移给了目标 <code>auto_ptr</code>，而源 <code>auto_ptr</code> 被置为空。具体来说，这种行为是通过以下方式实现的：</p><ol><li>当你将一个 <code>auto_ptr</code> 赋值给另一个 <code>auto_ptr</code> 时，源对象的指针会被转移到目标对象，而源对象的指针则被置为 <code>nullptr</code>。这种行为是通过“<strong>转移所有权</strong>”来避免多次删除相同的资源。</li><li>这种转移的目的是确保动态分配的内存在程序结束时被释放，但是如果没有进行所有权转移，可能会发生<strong>双重删除</strong>的错误。</li></ol><p>因此，我们可以发现，在智能指针的使用上，仅仅依靠<code>auto_ptr</code>似乎是不够的：上文的<strong>转移所有权</strong>的特性确实能够避免内存泄漏的问题出现，但是我们有时也需要进行<strong>指针拷贝</strong>的操作。实际上，在C++的新标准中，**<code>auto_ptr</code>已经被弃用**，主要有以下原因：</p><ol><li><p><strong>不安全的转移语义</strong>： <code>auto_ptr</code> 在赋值或传递给另一个 <code>auto_ptr</code> 时，进行的是“<strong>浅拷贝</strong>”，即将指针转移到另一个 <code>auto_ptr</code>，并将原来的 <code>auto_ptr</code> 设置为 <code>nullptr</code>。这种行为会导致潜在的资源管理问题，尤其是多个 <code>auto_ptr</code> 管理同一内存时，容易发生重复释放内存。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">auto_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">10</span>))</span></span>;<br>auto_ptr&lt;<span class="hljs-type">int</span>&gt; p2 = p1;  <span class="hljs-comment">// 现在 p1 为空，p2 拥有该内存</span><br>std::cout &lt;&lt; *p2 &lt;&lt; std::endl;  <span class="hljs-comment">// p2 仍然有效，但 p1 不再持有该内存</span><br></code></pre></td></tr></table></figure></li><li><p><strong>不一致的所有权语义</strong>： <code>auto_ptr</code> 的所有权语义比较模糊。它使得传递和返回指针时，所有权的转移比较不直观，容易造成内存管理的混乱。</p></li><li><p><strong>不支持移动语义</strong>： <code>auto_ptr</code> 不支持现代 C++ 中引入的“移动语义”。C++11 引入了 <code>std::move</code> 和 <code>std::unique_ptr</code>，使得可以安全高效地转移所有权，而无需担心意外的复制和删除。</p></li></ol><h3 id="other-smart-pointers"><a href="#other-smart-pointers" class="headerlink" title="other smart pointers"></a>other smart pointers</h3><p>现代 C++ 中有<strong>三种常见的智能指针</strong>，它们分别是：</p><ol><li><strong><code>std::unique_ptr</code><strong>：用于表示</strong>独占所有权</strong>。每个 <code>unique_ptr</code> 只能有一个所有者，当它超出作用域时会自动释放资源。</li><li><strong><code>std::shared_ptr</code><strong>：用于表示</strong>共享所有权</strong>。多个 <code>shared_ptr</code> 可以共享同一块资源，当所有指向该资源的 <code>shared_ptr</code> 都被销毁时，资源才会被释放。</li><li>**<code>std::weak_ptr</code>**：用于表示对某个资源的“非拥有”引用。它不会影响资源的生命周期，但可以用来观察 <code>shared_ptr</code> 所管理的对象，避免循环引用。</li></ol><blockquote><p>智能指针的关键在于对<strong>内存地址的所有权</strong>进行自动管理。</p></blockquote><h4 id="1-std-unique-ptr"><a href="#1-std-unique-ptr" class="headerlink" title="1. std::unique_ptr"></a>1. <strong><code>std::unique_ptr</code></strong></h4><p><code>std::unique_ptr</code> 是 C++11 引入的，适用于确保资源的独占所有权。<strong>一个 <code>unique_ptr</code> 不能被复制，只能被移动</strong>。</p><div class="note note-info">            <p><strong>就相当于原来的<code>auto_ptr</code>一样。</strong></p>          </div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyClass</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;MyClass constructor&quot;</span> &lt;&lt; std::endl; &#125;<br>    ~<span class="hljs-built_in">MyClass</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;MyClass destructor&quot;</span> &lt;&lt; std::endl; &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showMessage</span><span class="hljs-params">()</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Hello from MyClass!&quot;</span> &lt;&lt; std::endl; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demoUniquePtr</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 创建一个 unique_ptr，指向 MyClass 对象</span><br>    std::unique_ptr&lt;MyClass&gt; ptr1 = std::<span class="hljs-built_in">make_unique</span>&lt;MyClass&gt;();<br>    ptr1-&gt;<span class="hljs-built_in">showMessage</span>();<br><br>    <span class="hljs-comment">// 转移所有权</span><br>    std::unique_ptr&lt;MyClass&gt; ptr2 = std::<span class="hljs-built_in">move</span>(ptr1);  <span class="hljs-comment">// 这里发生了所有权的转移</span><br>    <span class="hljs-keyword">if</span> (!ptr1) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;ptr1 is now empty (nullptr)&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    ptr2-&gt;<span class="hljs-built_in">showMessage</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">demoUniquePtr</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs delphi">MyClass <span class="hljs-function"><span class="hljs-keyword">constructor</span></span><br><span class="hljs-function"><span class="hljs-title">Hello</span> <span class="hljs-title">from</span> <span class="hljs-title">MyClass</span>!</span><br><span class="hljs-function"><span class="hljs-title">ptr1</span> <span class="hljs-title">is</span> <span class="hljs-title">now</span> <span class="hljs-title">empty</span> <span class="hljs-params">(nullptr)</span></span><br><span class="hljs-function"><span class="hljs-title">Hello</span> <span class="hljs-title">from</span> <span class="hljs-title">MyClass</span>!</span><br><span class="hljs-function"><span class="hljs-title">MyClass</span> <span class="hljs-title">destructor</span></span><br></code></pre></td></tr></table></figure><h4 id="2-std-shared-ptr"><a href="#2-std-shared-ptr" class="headerlink" title="2. std::shared_ptr"></a>2. <strong><code>std::shared_ptr</code></strong></h4><p><code>std::shared_ptr</code> 是 C++11 引入的，用于表示共享所有权。<strong>多个 <code>shared_ptr</code> 可以同时管理一个资源</strong>，资源只有在所有 <code>shared_ptr</code> 被销毁时才会释放。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>    <span class="hljs-type">int</span> value;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">int</span> n):<span class="hljs-built_in">value</span>(n) &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;MyClass constructor&quot;</span> &lt;&lt; std::endl; &#125;<br>    ~<span class="hljs-built_in">MyClass</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;MyClass destructor&quot;</span> &lt;&lt; std::endl; &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showMessage</span><span class="hljs-params">()</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Hello from MyClass!&quot;</span> &lt;&lt; std::endl; &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showValue</span><span class="hljs-params">()</span></span>&#123; std::cout&lt;&lt;<span class="hljs-string">&quot;the value: &quot;</span>&lt;&lt;value&lt;&lt;std::endl;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modifyValue</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123; value=n;&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demoSharedPtr</span><span class="hljs-params">()</span> </span>&#123;<br>    std::shared_ptr&lt;MyClass&gt; ptr1 = std::<span class="hljs-built_in">make_shared</span>&lt;MyClass&gt;(<span class="hljs-number">4</span>);<br>    ptr1-&gt;<span class="hljs-built_in">showMessage</span>();<br><br>    <span class="hljs-comment">// 创建第二个 shared_ptr，指向同一资源</span><br>    std::shared_ptr&lt;MyClass&gt; ptr2 = ptr1;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Use count: &quot;</span> &lt;&lt; ptr<span class="hljs-number">1.</span><span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl;  <span class="hljs-comment">// 输出共享计数</span><br><br>    ptr1-&gt;<span class="hljs-built_in">showValue</span>();<br>    ptr2-&gt;<span class="hljs-built_in">showValue</span>();<br>    <br>    ptr1-&gt;<span class="hljs-built_in">modifyValue</span>(<span class="hljs-number">3</span>);<br>    ptr2-&gt;<span class="hljs-built_in">showValue</span>();<br><br>    ptr2-&gt;<span class="hljs-built_in">modifyValue</span>(<span class="hljs-number">2</span>);<br>    ptr1-&gt;<span class="hljs-built_in">showValue</span>();<br>    <span class="hljs-comment">// ptr2 和 ptr1 都指向同一对象，资源不会被释放直到两个都超出作用域</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">demoSharedPtr</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs powershell">MyClass constructor<br>Hello from MyClass!<br>Use count: <span class="hljs-number">2</span><br>the value: <span class="hljs-number">4</span><br>the value: <span class="hljs-number">4</span><br>the value: <span class="hljs-number">3</span><br>the value: <span class="hljs-number">2</span><br>MyClass destructor<br></code></pre></td></tr></table></figure><h4 id="3-std-weak-ptr"><a href="#3-std-weak-ptr" class="headerlink" title="3. std::weak_ptr"></a>3. <strong><code>std::weak_ptr</code></strong></h4><p><code>std::weak_ptr</code> 是 C++11 引入的，通常与 <code>shared_ptr</code> 配合使用，用来观察由 <code>shared_ptr</code> 管理的对象。<code>weak_ptr</code> 不增加对象的引用计数，因此<strong>它不会影响对象的生命周期</strong>。</p><blockquote><p>在某些场景下，<code>shared_ptr</code> 之间可能会相互引用，导致引用计数永远不为零，从而导致内存泄漏。这时可以使用 <code>weak_ptr</code> 来避免这种循环引用的问题。</p></blockquote><p>想象你有一个 <code>shared_ptr</code> 管理的对象 <code>A</code>，同时，你有另一个对象 <code>B</code>，它想引用 <code>A</code>，但不想干扰 <code>A</code> 的生命周期。你就可以用 <code>weak_ptr</code> 来观察 <code>A</code> 是否存在。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span>  <span class="hljs-comment">// 引入 shared_ptr 和 weak_ptr</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyClass</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;MyClass constructor&quot;</span> &lt;&lt; std::endl; &#125;<br>    ~<span class="hljs-built_in">MyClass</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;MyClass destructor&quot;</span> &lt;&lt; std::endl; &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showMessage</span><span class="hljs-params">()</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Hello from MyClass!&quot;</span> &lt;&lt; std::endl; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demoWeakPtr</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 创建一个 shared_ptr，指向 MyClass 对象</span><br>    std::shared_ptr&lt;MyClass&gt; ptr1 = std::<span class="hljs-built_in">make_shared</span>&lt;MyClass&gt;();<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Use count before weak_ptr: &quot;</span> &lt;&lt; ptr<span class="hljs-number">1.</span><span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 创建一个 weak_ptr，指向同一个对象，但不增加引用计数</span><br>    std::weak_ptr&lt;MyClass&gt; weakPtr = ptr1;<br><br>    <span class="hljs-comment">// 使用 weak_ptr 时，我们需要“锁定”它，检查它是否仍然有效</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">auto</span> sharedPtr = weakPtr.<span class="hljs-built_in">lock</span>()) &#123;  <span class="hljs-comment">// lock() 方法返回一个 shared_ptr，如果对象仍然存在</span><br>        sharedPtr-&gt;<span class="hljs-built_in">showMessage</span>();  <span class="hljs-comment">// 如果 weak_ptr 指向的对象仍然存在，就可以使用它</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Object is no longer available&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-comment">// 释放 ptr1，MyClass 对象的引用计数变为 0，对象会被销毁</span><br>    ptr<span class="hljs-number">1.</span><span class="hljs-built_in">reset</span>();  <span class="hljs-comment">// 释放 ptr1 指向的对象</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Use count after reset: &quot;</span> &lt;&lt; weakPtr.<span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 尝试再次锁定 weak_ptr</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">auto</span> sharedPtr = weakPtr.<span class="hljs-built_in">lock</span>()) &#123;<br>        sharedPtr-&gt;<span class="hljs-built_in">showMessage</span>();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Object is no longer available&quot;</span> &lt;&lt; std::endl;  <span class="hljs-comment">// 此时对象已经被销毁</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">demoWeakPtr</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs delphi">MyClass <span class="hljs-function"><span class="hljs-keyword">constructor</span></span><br><span class="hljs-function"><span class="hljs-title">Use</span> <span class="hljs-title">count</span> <span class="hljs-title">before</span> <span class="hljs-title">weak_ptr</span>:</span> <span class="hljs-number">1</span><br>Hello from MyClass!<br>Use count after reset: <span class="hljs-number">0</span><br><span class="hljs-keyword">Object</span> <span class="hljs-keyword">is</span> no longer available<br>MyClass <span class="hljs-function"><span class="hljs-keyword">destructor</span></span><br></code></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>**<code>std::unique_ptr</code>**：表示独占所有权，只能转移所有权，不支持拷贝。常用于资源的独占管理。</li><li>**<code>std::shared_ptr</code>**：表示共享所有权，多个 <code>shared_ptr</code> 可以共同拥有一个资源，直到最后一个 <code>shared_ptr</code> 被销毁，资源才会被释放。</li><li>**<code>std::weak_ptr</code>**：不增加引用计数，仅用于观察由 <code>shared_ptr</code> 管理的对象，防止出现循环引用的问题。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Code</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tutorial</tag>
      
      <tag>C/C++</tag>
      
      <tag>Finished</tag>
      
      <tag>pointers</tag>
      
      <tag>functions</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Exception-Handling-in-C-plus-plus</title>
    <link href="/posts/Exception-Handling-in-C-plus-plus/"/>
    <url>/posts/Exception-Handling-in-C-plus-plus/</url>
    
    <content type="html"><![CDATA[<h1 id="C-Primer-Plus-Tutorial-15"><a href="#C-Primer-Plus-Tutorial-15" class="headerlink" title="C++ Primer Plus Tutorial-15"></a>C++ Primer Plus Tutorial-15</h1><center><p style="color: red;"><b><font size=6.5>Chapter 15 Exception Handling</font></b></p></center><center><p style="color: red;"><b><font size=6.5>C++中的异常处理</font></b></p></center><p>【写在前面的话】</p><p><a href="https://xiyuanyang-code.github.io/posts/C-Primer-Plus-tutorial/">C++ Primer Plus Tutorial</a></p><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><blockquote><p>在原书的15.1节介绍了友元类函数的高阶用法，包括其他友元关系和共同友元。</p><p>在原书的15.2节介绍了嵌套类的高级用法。</p><p>对于刚刚入门C++的本科生而言，这两部分内容笔者在此不展开叙述。下面，我们将重点放在C++的一个功能强大的模块，也是“++”的部分——<strong>C++的异常处理机制</strong>。</p></blockquote><p>This article mainly introduces the exception handling mechanism introduced in C++, which includes <code>throw</code> (throwing exceptions), <code>try</code> (exception handling), and <code>catch</code> (catching exceptions), as well as some advanced techniques for exception handling.</p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>在程序设计中，有时会遇到<strong>程序异常终止</strong>的情景，例如用户进行了非法输入导致数据无法正常读取，尝试打开一个不可用的文件，对内存管理不当（申请过多的内存，内存泄漏）等等。而C++中的异常处理（Exception Handling）提供了一种机制，使程序在运行时能够<strong>优雅</strong>地处理错误。通过异常处理，程序可以检测并响应不同类型的运行时错误，而<strong>无需中断正常的程序流程</strong>。C++中的异常处理包括三个基本部分：<strong>throw</strong>、<strong>try</strong> 和 <strong>catch</strong>。</p><blockquote><p>何为<strong>优雅</strong>？异常处理使程序能够在遇到错误时跳转到适当的错误处理代码，程序的控制流不会直接终止而是转移到专门用来处理异常的地方。但是如果不使用异常处理，程序会直接崩溃或者挂起。</p></blockquote><p>请看下面的示例程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> a=<span class="hljs-number">2</span>;<br>    <span class="hljs-type">int</span> b[]=&#123;<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> num:b)&#123;<br>        cout&lt;&lt;<span class="hljs-built_in">double</span>(a)/num&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出示例：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">0</span>.<span class="hljs-number">4</span><br><span class="hljs-attribute">0</span>.<span class="hljs-number">5</span><br><span class="hljs-attribute">0</span>.<span class="hljs-number">666667</span><br><span class="hljs-attribute">1</span><br><span class="hljs-attribute">2</span><br><span class="hljs-attribute">inf</span><br></code></pre></td></tr></table></figure><p>程序在num的值（分母）为0是输出了<code>inf</code>，这是一个表示无穷大的特殊浮点数值。</p><p>幸运的是，在此处程序不会异常终止，但是一旦<code>inf</code>会被用在后续的复杂的程序计算中，便会产生非常严重的后果，也为后续的Debug过程增加了负担。因此，我们不得不引入一种<strong>异常处理的机制</strong>，来专门用来处理给种各样的异常情况，使我们的程序更加的鲁棒。</p><h2 id="If-No-Exception-Handling？"><a href="#If-No-Exception-Handling？" class="headerlink" title="If No Exception Handling？"></a>If No Exception Handling？</h2><p>接下来我们来介绍两种<strong>不需要使用异常处理机制的方法来终止程序</strong>。</p><h3 id="Abort"><a href="#Abort" class="headerlink" title="Abort"></a>Abort</h3><p><code>abort()</code> 函数是 C&#x2F;C++ 中用于终止程序执行的一个标准库函数。它通常用于程序遇到严重错误时，强制终止程序并产生异常的退出状态。该函数会立即停止程序的执行，并且不会进行任何清理操作（如调用析构函数或执行 <code>atexit()</code> 注册的函数等）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span>  <span class="hljs-comment">// 包含 abort 函数</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Program started.&quot;</span> &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 由于某种条件不满足，调用 abort 终止程序</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;An error occurred, aborting program.&quot;</span> &lt;&lt; std::endl;<br>    <span class="hljs-built_in">abort</span>();  <span class="hljs-comment">// 强制终止程序</span><br><br>    <span class="hljs-comment">// 这行代码不会被执行</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;This will not be printed.&quot;</span> &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>严格来说，这并不能能算一种异常处理的机制，毕竟没有人想通过<strong>强制退出</strong>的方法终止自己的程序。（而且这会带来非常多的隐患，例如<strong>动态分配的内存没有被清除等</strong>）</p><p><img src="/posts/Above-All/Handling-in-C-plus-plus/abort.png" alt="在IDE中，这仍被视为程序的异常退出"></p><h3 id="使用函数的返回值"><a href="#使用函数的返回值" class="headerlink" title="使用函数的返回值"></a>使用函数的返回值</h3><p>一种比异常终止更灵活的方法是，使用函数的返回值来指出问题。例如， <code>ostream</code> 类的 get（ void）成员通常返回下一个输入字符的 ASCII 码，但到达文件尾时，将返回特殊值 EOF。对 hmean( )来说，这种方法不管用。任何数值都是有效的返回值，因此不存在可用于指出问题的特殊值。在这种情况下，可使用指针参数或引用参数来将值返回给调用程序，并使用函数的返回值来指出成功还是失败。<strong>istream 族重载&gt;&gt;运算符使用了这种技术的变体。通过告知调用程序是成功了还是失败了</strong>，使得程序可以采取除异常终止程序之外的其他措施。程序清单 15.8 是一个采用这种方式的示例，它将 hmean( )的返回值重新定义为 bool，让返回值指出成功了还是失败了，另外还给该函数增加了第三个参数，用于提供答案。  </p><blockquote><p>通俗来说，在流输入的时候，如果进行非法输入会直接告知调用程序是否调用成功，这也就是为什么我们可以使用<code>while(cin&gt;&gt;a)</code>的结构。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//error2.cpp -- returning an error code</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cfloat&gt;</span>  <span class="hljs-comment">// (or float.h) for DBL_MAX</span></span><br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hmean</span><span class="hljs-params">(<span class="hljs-type">double</span> a, <span class="hljs-type">double</span> b, <span class="hljs-type">double</span> * ans)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">double</span> x, y, z;<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Enter two numbers: &quot;</span>;<br>    <span class="hljs-keyword">while</span> (std::cin &gt;&gt; x &gt;&gt; y)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">hmean</span>(x,y,&amp;z))<br>            <span class="hljs-comment">//这里将函数的返回值设置为布尔值，用来判断条件是否成立，而将运算的结果通过指针的方式储存。</span><br>            std::cout &lt;&lt; <span class="hljs-string">&quot;Harmonic mean of &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; and &quot;</span> &lt;&lt; y<br>                &lt;&lt; <span class="hljs-string">&quot; is &quot;</span> &lt;&lt; z &lt;&lt; std::endl;<br>        <span class="hljs-keyword">else</span><br>            std::cout &lt;&lt; <span class="hljs-string">&quot;One value should not be the negative &quot;</span><br>                &lt;&lt; <span class="hljs-string">&quot;of the other - try again.\n&quot;</span>;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Enter next set of numbers &lt;q to quit&gt;: &quot;</span>;<br>    &#125;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Bye!\n&quot;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hmean</span><span class="hljs-params">(<span class="hljs-type">double</span> a, <span class="hljs-type">double</span> b, <span class="hljs-type">double</span> * ans)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (a == -b)<br>    &#123;<br>        *ans = DBL_MAX;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        *ans = <span class="hljs-number">2.0</span> * a * b / (a + b);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="Exception-Handling"><a href="#Exception-Handling" class="headerlink" title="Exception Handling"></a>Exception Handling</h2><p>首先解决第一个问题，上文两种异常处理的方法有什么局限性？</p><p><code>Abort()</code>不必多说，没有程序员希望在程序中使用这个丑陋的东西，那<code>返回值</code>呢？这确实是一种方法，但这种方法的本质还是<strong>if-else大法进行分类讨论</strong>，如果判断错误的情况就进行特殊的处理，会增加程序的复杂性。（你也不希望自己的程序满眼望过去全是用来if-else处理异常情况的代码块吧）</p><p>不过值得庆幸的时，第二种方法给了我们一种思路，即<strong>异常处理可以跳转程序的控制流到一个特殊的地方，在那个地方我们专门来处理错误</strong>，这样即可以保证程序的控制流不会<strong>异常中断（像<code>abort()</code>一样）</strong>，也无需使用if-else大法，是程序更加的简洁。</p><p>这就是异常处理的最基本思路：<strong>提供了一种将程序的控制权从一个部分传递到另一个部分的途径</strong>。</p><div class="note note-primary">            <p>从另一个角度来说，异常处理就像是一个<strong>踢皮球</strong>的过程，矛盾上交，让函数在发现自己无法处理的错误时<strong>抛出一个异常</strong>，希望他的调用者能够处理这个问题，<strong>将异常检测和异常处理分开，将异常处理和解决问题的主逻辑分开，更加的清晰</strong>。</p>          </div><p>C++中的异常处理包括三个基本部分：<strong>throw</strong>、<strong>try</strong> 和 <strong>catch</strong>。</p><h3 id="示例程序"><a href="#示例程序" class="headerlink" title="示例程序"></a>示例程序</h3><ol><li><strong>throw</strong>：用于<strong>抛出异常</strong>。可以抛出任何类型的对象，通常是类的实例，但也可以是原始数据类型。</li><li><strong>try</strong>：用来定义异常检测的代码块。try块中的代码会被执行，若出现异常，程序会跳转到相应的catch块处理异常。</li><li><strong>catch</strong>：用于捕获和处理异常。每个catch块对应一个特定类型的异常，可以根据异常类型进行不同的处理。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdexcept&gt;</span> <span class="hljs-comment">// 引入标准异常头文件</span></span><br><br><span class="hljs-comment">// 一个简单的函数，用来演示异常处理</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">divide</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (b == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 抛出异常</span><br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">invalid_argument</span>(<span class="hljs-string">&quot;Division by zero is not allowed&quot;</span>);<br>    &#125;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Result: &quot;</span> &lt;&lt; a / b &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-built_in">divide</span>(<span class="hljs-number">10</span>, <span class="hljs-number">0</span>);  <span class="hljs-comment">// 这里会抛出异常</span><br>    &#125; <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::invalid_argument&amp; e) &#123;<br>        <span class="hljs-comment">// 捕获并处理异常</span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Error: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：<code>Division by zero is not allowed</code></p><blockquote><p>如果将第15行代码修改为：<code>divide(10, 1);</code>输出：<code>Result: 10</code></p></blockquote><h4 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h4><ol><li>**throw std::invalid_argument(“…”)**：如果除数为0，抛出一个<code>std::invalid_argument</code>类型的异常，带有错误信息。</li><li><strong>try-catch</strong>：在<code>main()</code>函数中，调用<code>divide()</code>时使用了<code>try</code>块，如果发生异常（例如除数为0），会跳转到相应的<code>catch</code>块处理异常。</li><li>**catch (const std::invalid_argument&amp; e)**：捕获异常并处理，<code>e.what()</code>返回异常的详细信息。</li></ol><h2 id="Throw-异常抛出"><a href="#Throw-异常抛出" class="headerlink" title="Throw 异常抛出"></a>Throw 异常抛出</h2><p>如果程序发生了异常，程序希望将错误信息发送到更大的环境中。（转移程序的控制权）这就是<strong>throw</strong>语句（异常抛出语句），它的功能将一个<strong>操作数</strong>抛出到“更大的环境”（即<strong>跳出当前的程序块</strong>）</p><p>还是以除数不可以为0为例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">divv</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(y==<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">throw</span>(y);<br>    &#125;<br>    <span class="hljs-keyword">return</span> x/y;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cout&lt;&lt;<span class="hljs-built_in">divv</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)&lt;&lt;endl;<br>    cout&lt;&lt;<span class="hljs-built_in">divv</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<br>    cout&lt;&lt;<span class="hljs-built_in">divv</span>(<span class="hljs-number">0</span>,<span class="hljs-number">3</span>)&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><p><img src="/posts/Above-All/Handling-in-C-plus-plus/throw.png" alt="Throw"></p><p>很不幸的是，这里程序仍然是异常终止的，程序的控制流被直接切断，我们想要程序执行的第三条语句 <code>cout&lt;&lt;divv(0,3)&lt;&lt;endl</code>并没有执行。因为throw只是<strong>抛出了一个异常</strong>，我们并没有定义对所抛出异常的后续处理方法。Anyway，我们成功迈出了异常处理的第一步！</p><p>在这个程序中，<strong>操作数</strong>就是被抛出的int值<code>y</code>。异常抛出语句的一般形式为<code>throw &lt;操作数&gt;</code>。<strong>throw对应的操作数可以是任何类型，可以是基本的数据类型，也可以是自定义的类和对象（异常对象）</strong>。下面我们来看一个如何自定义一个异常类和异常对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Divide_by_zero</span>&#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">Divide_by_zero</span>():<span class="hljs-built_in">message</span>(<span class="hljs-string">&quot;attempted to divide by zero&quot;</span>)&#123;<br>            cout&lt;&lt;message&lt;&lt;endl;<br>        &#125;<br>        <span class="hljs-comment">//构造函数</span><br>        <span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title">what</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> message;<br>        &#125;<br>        <span class="hljs-comment">//what方法来调用私有数据成员message</span><br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-type">const</span> <span class="hljs-type">char</span>* message;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">divv</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(y==<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Divide_by_zero</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> x/y;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cout&lt;&lt;<span class="hljs-built_in">divv</span>(<span class="hljs-number">14</span>,<span class="hljs-number">2</span>)&lt;&lt;endl;<br>    cout&lt;&lt;<span class="hljs-built_in">divv</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<br>    cout&lt;&lt;<span class="hljs-built_in">divv</span>(<span class="hljs-number">6</span>,<span class="hljs-number">3</span>)&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs smali">输出示例：<br>7<br>attempted to divide by zero<br>terminate called after throwing an<span class="hljs-built_in"> instance </span>of &#x27;Divide_by_zero&#x27;<br></code></pre></td></tr></table></figure><p>在输出中，出现了<code>message</code>的内容，说明语句 <code>throw Divide_by_zero()</code>首先创建了一个<code>throw Divide_by_zero()</code>类的临时对象，调用了其构造函数，然后抛出这个临时对象（输出的第三行）。</p><blockquote><p>这里没有构造显式的析构函数，因为默认的析构函数就会销毁成员message。</p></blockquote><h2 id="Try-Catch-异常捕获"><a href="#Try-Catch-异常捕获" class="headerlink" title="Try-Catch 异常捕获"></a>Try-Catch 异常捕获</h2><h3 id="异常抛出后的控制权问题"><a href="#异常抛出后的控制权问题" class="headerlink" title="异常抛出后的控制权问题"></a>异常抛出后的控制权问题</h3><p>在上文我们知道，<strong>程序在异常处理后需要被捕获</strong>。何为捕获？在开始这一部分内容之前，我们首先介绍一下<strong>在抛出异常的时候，程序的控制权发生了什么。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdexcept&gt;</span> <span class="hljs-comment">// std::runtime_error</span></span><br><br><span class="hljs-comment">// 函数A抛出异常</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">functionA</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Inside functionA\n&quot;</span>;<br>    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;An error occurred in functionA&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// 函数B调用函数A</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">functionB</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Inside functionB\n&quot;</span>;<br>    <span class="hljs-built_in">functionA</span>(); <span class="hljs-comment">// 调用抛出异常的函数</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;FunctionB ends normally\n&quot;</span>;  <span class="hljs-comment">// 这行不会执行</span><br>&#125;<br><br><span class="hljs-comment">// main函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Inside main\n&quot;</span>;<br>        <span class="hljs-built_in">functionB</span>(); <span class="hljs-comment">// 调用functionB</span><br>    &#125;<br>    <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::runtime_error&amp; e) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Caught exception: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    &#125;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Program ends\n&quot;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs inform7"><span class="hljs-keyword">Inside</span> main<br><span class="hljs-keyword">Inside</span> functionB<br><span class="hljs-keyword">Inside</span> functionA<br>Caught exception: An error occurred in functionA<br>Program ends<br></code></pre></td></tr></table></figure><p>相信读者应该从名字就能猜出来，<code>try</code>和<code>catch</code>块就是用来<strong>捕获throw抛出的异常的</strong>，在上文程序中，他们被设置在了main函数中，也就是说，相当于在main函数里面<strong>设下了一张网</strong>，用来捕获上游函数抛出的异常。</p><p>接下来我们来重点关注上游函数，读者应该不难看出，函数的调用权转移是如下的顺序（在遇到异常情况前）：<strong>main函数→functionB→functionA</strong>，在functionA中，遇到异常情况被抛出，此时，<strong>异常将会跳出当前的程序块（functionA），而跳转到外部，即调用该函数的函数functionB</strong>。接下来，functionB没有捕获异常，因此，<strong>程序跳出functionB，异常继续传播</strong>，终于在main函数被捕获。</p><blockquote><p>这就是为什么程序没有输出<code>FunctionB ends normally</code>，因为异常的传播导致functionB的执行被异常终止了。</p></blockquote><p>也就是说，<strong>被抛出的异常需要被捕获</strong>，否则异常会切断在其被捕获的路上的函数的正常执行。</p><p>举一反三，如果我们修改了try-catch的位置：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdexcept&gt;</span> <span class="hljs-comment">// std::runtime_error</span></span><br><br><span class="hljs-comment">// 函数A抛出异常</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">functionA</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">try</span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Inside functionA\n&quot;</span>;<br>    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;An error occurred in functionA&quot;</span>);<br>&#125;<br>    <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::runtime_error&amp; e) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Caught exception2: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 函数B调用函数A</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">functionB</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Inside functionB\n&quot;</span>;<br>    <span class="hljs-built_in">functionA</span>(); <span class="hljs-comment">// 调用抛出异常的函数</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;FunctionB ends normally\n&quot;</span>;  <span class="hljs-comment">// 这行不会执行</span><br>&#125;<br><br><span class="hljs-comment">// main函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Inside main\n&quot;</span>;<br>        <span class="hljs-built_in">functionB</span>(); <span class="hljs-comment">// 调用functionB</span><br>    &#125;<br>    <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::runtime_error&amp; e) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Caught exception1: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    &#125;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Program ends\n&quot;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">Inside </span>main<br><span class="hljs-keyword">Inside </span>functionB<br><span class="hljs-keyword">Inside </span>functionA<br>Caught exception2: An error occurred in functionA<br>FunctionB ends <span class="hljs-keyword">normally</span><br><span class="hljs-keyword"></span>Program ends<br></code></pre></td></tr></table></figure><p>我们会发现，异常在被函数A抛出后直接被函数A中的<code>try-catch</code>捕获，没有打扰到后续functionB和main函数的正常执行。</p><h3 id="try-catch基本语法"><a href="#try-catch基本语法" class="headerlink" title="try-catch基本语法"></a>try-catch基本语法</h3><p><code>try</code>的作用是通知系统启动异常处理机制，这样可以使在try代码块中的所有抛出异常都能够被捕获。一旦捕获，<strong>则退出try块，跳过tey块后面的语句，进入try后面的异常处理部分</strong>。<code>catch</code>块的作用是<strong>处理某种类型异常的异常处理器</strong>。它们俩常常搭配使用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">try</span>&#123;<br>    <span class="hljs-comment">//可能抛出的异常代码</span><br>&#125;<br><span class="hljs-built_in">catch</span>(类型<span class="hljs-number">1</span> 参数<span class="hljs-number">1</span>)&#123;<br>    <span class="hljs-comment">//处理异常的代码1;</span><br>&#125;<br><span class="hljs-built_in">catch</span>(类型<span class="hljs-number">2</span> 参数<span class="hljs-number">2</span>)&#123;<br>    <span class="hljs-comment">//处理异常的代码2;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>值得注意的是，如果try没有捕获异常，<strong>不会执行任何一条跟在其后面的catch语句</strong>。也就是说，异常处理建立在异常抛出和异常捕获的基础之上。</p><p><code>catch</code> 处理器定义了自己处理的异常范围。<strong>异常范围是按类型区分的</strong>。 <code>catch</code> 在小括号中指定要<strong>捕获的异常类型以及参数</strong>。参数是所捕获的异常类型的一个<strong>对象</strong>，即 try 块中的某个语句抛出的<strong>对象</strong>。catch 处理器中的参数名是可选的。 如果给出了参数名， 则可以在异常处理代码中引用这个异常对象。如果没有指定参数名，只指定匹配抛出对象的类型，则信息不从抛出点传递到处理器中，只是把控制从抛出点转到处理器中。</p><p>如果 try 块中的某个语句抛出了异常，则跳出 <code>try</code> 块，开始异常捕获。先将抛出的异常类型与第一个异常处理器捕获的类型相比较，如果可以匹配，则执行异常处理代码，然后转到所有 catch 后的语句继续执行。如果不匹配，则与下一个异常处理器比较，直到找到一个匹配的异常处理器。如果找遍了所有的异常处理器，都不匹配，则函数执行结束，并将该<strong>异常抛给调用它的函数，由调用它的函数来处理该异常</strong>（异常继续向下传播）。  </p><p>回到那个除数不能为0的例子，如果我们使用try-catch块：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @Author: Xiyuan Yang   xiyuan_yang@outlook.com</span><br><span class="hljs-comment"> * @Date: 2024-10-13 11:06:15</span><br><span class="hljs-comment"> * @LastEditors: Xiyuan Yang   xiyuan_yang@outlook.com</span><br><span class="hljs-comment"> * @LastEditTime: 2024-12-15 14:53:59</span><br><span class="hljs-comment"> * @FilePath: \CODE_for_Vscode\C++_project\testcode_1.cpp</span><br><span class="hljs-comment"> * @Description: </span><br><span class="hljs-comment"> * Do you code and make progress today?</span><br><span class="hljs-comment"> * Copyright (c) 2024 by Xiyuan Yang, All Rights Reserved. </span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Divide_by_zero</span>&#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">Divide_by_zero</span>():<span class="hljs-built_in">message</span>(<span class="hljs-string">&quot;attempted to divide by zero&quot;</span>)&#123;<br>            cout&lt;&lt;message&lt;&lt;endl;<br>        &#125;<br>        <span class="hljs-comment">//构造函数</span><br>        <span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title">what</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> message;<br>        &#125;<br>        <span class="hljs-comment">//what方法来调用私有数据成员message</span><br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-type">const</span> <span class="hljs-type">char</span>* message;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">divv</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br>    <span class="hljs-keyword">try</span>&#123;<br>        <span class="hljs-keyword">if</span>(y==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Divide_by_zero</span>();<br>        &#125;<br>        cout&lt;&lt;x/y&lt;&lt;endl;<br>    &#125;<span class="hljs-built_in">catch</span>(Divide_by_zero ex)&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;Excpetion occured: &quot;</span>&lt;&lt;ex.<span class="hljs-built_in">what</span>()&lt;&lt;endl;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">divv</span>(<span class="hljs-number">14</span>,<span class="hljs-number">2</span>);<br>    <span class="hljs-built_in">divv</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">divv</span>(<span class="hljs-number">6</span>,<span class="hljs-number">3</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>终于成功了！程序成功捕获了<code>divv(1,0)</code>所抛出的异常，并正常执行了第三条语句 <code>divv(6,3)</code>并正常退出。</p><h2 id="Advanced-Usage"><a href="#Advanced-Usage" class="headerlink" title="Advanced Usage"></a>Advanced Usage</h2><h3 id="Periodic-Reflection"><a href="#Periodic-Reflection" class="headerlink" title="Periodic Reflection"></a>Periodic Reflection</h3><p>我们已经学习了异常处理的三种最基本的处理工具：</p><p><strong>throw（抛出异常）——try（捕获异常）——catch（处理异常）</strong></p><p>接下来，我们将从应用的角度出发，介绍异常处理的一些高级用法。</p><h3 id="标准库中的异常类"><a href="#标准库中的异常类" class="headerlink" title="标准库中的异常类"></a>标准库中的异常类</h3><p>C++标准库提供了多种异常类，如<code>std::out_of_range</code>、<code>std::invalid_argument</code>、<code>std::runtime_error</code>等。</p><h4 id="1-标准库中的异常类"><a href="#1-标准库中的异常类" class="headerlink" title="1. 标准库中的异常类"></a>1. <strong>标准库中的异常类</strong></h4><h5 id="std-exception"><a href="#std-exception" class="headerlink" title="std::exception"></a><strong><code>std::exception</code></strong></h5><p><code>std::exception</code> 是所有标准异常类的基类。它提供了一个虚函数 <code>what()</code>，用于获取异常的描述信息。用户通常会继承它并重写 <code>what()</code> 来创建自定义的异常类。</p><ul><li>**<code>what()</code>**：返回一个描述异常原因的 C 风格字符串。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;An error occurred&quot;</span>);<br>&#125; <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::exception&amp; e) &#123;<br>    std::cout &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="std-logic-error"><a href="#std-logic-error" class="headerlink" title="std::logic_error"></a><strong><code>std::logic_error</code></strong></h5><p><code>std::logic_error</code> 用于表示程序的逻辑错误。它是继承自 <code>std::exception</code> 的派生类，表示程序运行时存在设计缺陷。以下是其常见的子类：</p><ul><li>**<code>std::invalid_argument</code>**：表示函数接收到无效的参数，通常用于输入参数检查。</li><li>**<code>std::domain_error</code>**：表示数学函数的参数不在有效的数学域内。</li><li>**<code>std::length_error</code>**：表示容器的大小超过了容器的最大限制（例如 <code>std::vector</code>）。</li><li>**<code>std::out_of_range</code>**：表示访问超出了容器或数组的有效范围。</li></ul><h5 id="std-runtime-error"><a href="#std-runtime-error" class="headerlink" title="std::runtime_error"></a><strong><code>std::runtime_error</code></strong></h5><p><code>std::runtime_error</code> 用于表示程序在运行过程中遇到的错误，通常是由于不可预料的问题或外部条件造成的。以下是其常见的子类：</p><ul><li>**<code>std::overflow_error</code>**：表示数值计算中的溢出错误（例如，整数溢出）。</li><li>**<code>std::underflow_error</code>**：表示数值计算中的下溢错误（例如，浮点数精度问题）。</li><li>**<code>std::range_error</code>**：表示某些计算超出了有效的数值范围。</li></ul><h5 id="std-bad-alloc"><a href="#std-bad-alloc" class="headerlink" title="std::bad_alloc"></a><strong><code>std::bad_alloc</code></strong></h5><p><code>std::bad_alloc</code> 是在内存分配失败时抛出的异常。当使用 <code>new</code> 或 <code>std::vector</code> 等容器分配内存时，若内存不足，通常会抛出该异常。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-type">int</span>* arr = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">1000000000</span>];  <span class="hljs-comment">// 可能抛出 std::bad_alloc</span><br>&#125; <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::bad_alloc&amp; e) &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Memory allocation failed: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="std-bad-cast"><a href="#std-bad-cast" class="headerlink" title="std::bad_cast"></a><strong><code>std::bad_cast</code></strong></h5><p><code>std::bad_cast</code> 在使用 <code>dynamic_cast</code> 进行类型转换失败时抛出，通常用于不合法的指针类型转换。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">try</span> &#123;<br>    Base* base = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Derived</span>();<br>    Derived* derived = <span class="hljs-built_in">dynamic_cast</span>&lt;Derived*&gt;(base);  <span class="hljs-comment">// 如果转换失败，将抛出 std::bad_cast</span><br>&#125; <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::bad_cast&amp; e) &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Bad cast: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="std-bad-typeid"><a href="#std-bad-typeid" class="headerlink" title="std::bad_typeid"></a><strong><code>std::bad_typeid</code></strong></h5><p><code>std::bad_typeid</code> 在 <code>typeid</code> 运算符用于空指针时抛出。这常发生在运行时类型识别（RTTI）中，尤其是在多态类型系统中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">try</span> &#123;<br>    Base* base = <span class="hljs-literal">nullptr</span>;<br>    std::cout &lt;&lt; <span class="hljs-built_in">typeid</span>(*base).<span class="hljs-built_in">name</span>();  <span class="hljs-comment">// 如果 base 是 nullptr，将抛出 std::bad_typeid</span><br>&#125; <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::bad_typeid&amp; e) &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Bad typeid: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="2-用户自定义异常类"><a href="#2-用户自定义异常类" class="headerlink" title="2. 用户自定义异常类"></a>2. <strong>用户自定义异常类</strong></h4><p>除了标准库提供的异常类，用户可以根据程序的需要自定义异常类。这些异常类可以从 <code>std::exception</code> 或其他标准异常类继承，并根据具体需求实现错误处理和信息传递。</p><h5 id="自定义异常类示例"><a href="#自定义异常类示例" class="headerlink" title="自定义异常类示例"></a><strong>自定义异常类示例</strong></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;exception&gt;</span></span><br><br><span class="hljs-comment">// 自定义异常类继承自 std::exception</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyException</span> : <span class="hljs-keyword">public</span> std::exception &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 重写 what() 方法，返回自定义的错误信息</span><br>    <span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title">what</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;My custom exception occurred!&quot;</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-built_in">MyException</span>();  <span class="hljs-comment">// 抛出自定义异常</span><br>    &#125; <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> MyException&amp; e) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Caught exception: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="自定义异常类传递额外信息"><a href="#自定义异常类传递额外信息" class="headerlink" title="自定义异常类传递额外信息"></a><strong>自定义异常类传递额外信息</strong></h5><p>有时需要在异常类中存储附加信息，比如错误代码或上下文信息。可以通过构造函数传递这些信息，并在 <code>what()</code> 中返回它们。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;exception&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DetailedException</span> : <span class="hljs-keyword">public</span> std::exception &#123;<br><span class="hljs-keyword">private</span>:<br>    std::string message;<br>    <span class="hljs-type">int</span> errorCode;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">DetailedException</span>(<span class="hljs-type">const</span> std::string&amp; msg, <span class="hljs-type">int</span> code)<br>        : <span class="hljs-built_in">message</span>(msg), <span class="hljs-built_in">errorCode</span>(code) &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title">what</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> message.<span class="hljs-built_in">c_str</span>();  <span class="hljs-comment">// 返回错误信息</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getErrorCode</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> errorCode;  <span class="hljs-comment">// 返回错误码</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-built_in">DetailedException</span>(<span class="hljs-string">&quot;Something went wrong&quot;</span>, <span class="hljs-number">42</span>);<br>    &#125; <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> DetailedException&amp; e) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Error: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; <span class="hljs-string">&quot;, Code: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">getErrorCode</span>() &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="catch-的用法"><a href="#catch-的用法" class="headerlink" title="catch(...)的用法"></a><code>catch(...)</code>的用法</h3><p>C++ 的异常处理通常通过 <code>try-catch</code> 语句块来实现，<code>try</code> 块包含可能引发异常的代码，而 <code>catch</code> 块处理异常。可以捕获指定类型的异常，也可以捕获所有类型的异常。</p><ul><li><p><strong>捕获特定异常类型</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;Runtime error&quot;</span>);<br>&#125; <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::runtime_error&amp; e) &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Caught runtime error: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>捕获所有异常</strong>（<strong>必须作为最后一个异常处理器</strong>）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;Runtime error&quot;</span>);<br>&#125; <span class="hljs-built_in">catch</span> (...) &#123;  <span class="hljs-comment">// 捕获所有类型的异常</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Caught an unknown exception&quot;</span> &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><blockquote><p><code>catch (...) </code>诚然是一种很强大的处理异常的工具，他相当于一张密不透风的超强大网可以兜住所有的错误类型，但是在一定程度上牺牲了个性化。（他即使抛出了错误，你也不知道抛出的错误是什么类型）</p></blockquote><ul><li><strong>只捕获类型，不指明对象</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">try</span> &#123;<br>cout &lt;&lt; <span class="hljs-built_in">div</span>(<span class="hljs-number">6</span>, <span class="hljs-number">3</span>) &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-built_in">div</span>(<span class="hljs-number">10</span>, <span class="hljs-number">0</span>) &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-built_in">div</span>(<span class="hljs-number">5</span>, <span class="hljs-number">2</span>) &lt;&lt; endl;<br>&#125;<br><span class="hljs-built_in">catch</span> (<span class="hljs-type">int</span>) &#123; cout &lt;&lt; <span class="hljs-string">&quot;divide by zero&quot;</span> &lt;&lt; endl; &#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;It&#x27;s Over&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>That‘s it! 这就是C++中异常处理的基本知识点，你可以在自己的程序中尝试使用这一种异常处理的机制了。不过切记来时的路：<strong>异常处理机制是让程序在不中止的情况下对异常情况通过“跳出—捕获—处理”的过程异常处理。</strong>所以，不要让你的程序到处都是Try-Catch！这一点可以在后续的编程实践中逐步巩固。</p><blockquote><p>The END 2024&#x2F;12&#x2F;15</p></blockquote><div class="note note-info">            <p>笔者接下来将会将重点放在STL和数据结构的系统化更新中~有关Cpp的语法博客可能就暂时告一段落啦，不过之后会专门更新Cmake的使用，敬请期待！</p>          </div>]]></content>
    
    
    <categories>
      
      <category>Code</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tutorial</tag>
      
      <tag>C/C++</tag>
      
      <tag>C++ Primer Plus</tag>
      
      <tag>Finished</tag>
      
      <tag>Exception Handling</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Code-Reuse-in-OOP</title>
    <link href="/posts/Code-Reuse-in-OOP/"/>
    <url>/posts/Code-Reuse-in-OOP/</url>
    
    <content type="html"><![CDATA[<h1 id="Code-Reuse-in-OOP"><a href="#Code-Reuse-in-OOP" class="headerlink" title="Code Reuse in OOP"></a>Code Reuse in OOP</h1><h1 id="C-Primer-Plus-Tutorial-15"><a href="#C-Primer-Plus-Tutorial-15" class="headerlink" title="C++ Primer Plus Tutorial-15"></a>C++ Primer Plus Tutorial-15</h1><h1 id="面向对象编程教程——Section④"><a href="#面向对象编程教程——Section④" class="headerlink" title="面向对象编程教程——Section④"></a>面向对象编程教程——Section④</h1><center><p style="color: red;"><b><font size=6.5>Chapter 15 Code Reuse in OOP</font></b></p></center><center><p style="color: red;"><b><font size=6.5>面向对象编程中的代码重用</font></b></p></center><p>【写在前面的话】</p><p><a href="https://xiyuanyang-code.github.io/posts/C-plus-plus-Primer-Plus-tutorial/">C++ Primer Plus Tutorial</a></p><p><a href="https://xiyuanyang-code.github.io/tags/OOP/">系列文章</a></p><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>C++的一个主要目标是促进代码重用。公有继承是实现这种目标的机制之一，但并不是唯一的机制。本章将介绍其他方法，其中之一是使用这样的类成员：本身是另一个类的对象。这种方法称为<strong>包含（containment）、组合（composition）或层次化（layering）</strong>。另一种方法是使用私有或保护继承。通常，<strong>包含、私有继承和保护继承</strong>用于实现 <strong>has-a</strong> 关系，即新的类将包含另一个类的对象。多重继承使得能够使用两个或更多的基类派生出新的类，将基类的功能组合在一起。</p><p>同时，本章将介绍<strong>类模板</strong>——另一种重用代码的方法。类模板使我们能够使用通用术语定义类，然后使用模板来创建针对特定类型定义的特殊类。</p><blockquote><p>One of the main goals of C++ is to promote code reuse. Public inheritance is one of the mechanisms to achieve this goal, but not the only one. This chapter will introduce other methods, one of which is to use class members that are themselves objects of another class. This method is called containment, composition, or layering. Another method is to use private or protected inheritance. Generally, containment, private inheritance, and protected inheritance are used to implement the has - a relationship, that is, the new class will contain an object of another class. Multiple inheritance enables new classes to be derived from two or more base classes, combining the functionality of the base classes.</p><p>At the same time, this chapter will introduce class templates - another method of reusing code. Class templates enable us to define classes in general terms and then use the templates to create special classes defined for specific types.</p></blockquote><h2 id="Table-of-Contents"><a href="#Table-of-Contents" class="headerlink" title="Table of Contents"></a>Table of Contents</h2><ul><li>Containment Composition Layering</li><li>Multiple Inheritance</li><li>Class Template</li><li>Friend Class and Friend Functions</li></ul><h2 id="Containment-Composition-Layering"><a href="#Containment-Composition-Layering" class="headerlink" title="Containment Composition Layering"></a>Containment Composition Layering</h2><h3 id="valarray"><a href="#valarray" class="headerlink" title="valarray"></a><code>valarray</code></h3><p><code>valarray</code>被定义为一个模板类，能够处理不同的数据类型。</p><p>下面来看<code>valarray</code>的基本操作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;valarray&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">valarray&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">list</span><span class="hljs-params">(<span class="hljs-number">10</span>,<span class="hljs-number">8</span>)</span></span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> num:list)&#123;<br>        cout&lt;&lt;num&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：8个10</p><p><code>valarray</code>的基本使用和数组完全一样，但是<code>valarray</code>在数值计算方面具有更大的优势。</p><div class="note note-info">            <ol><li>构造函数<ul><li><strong>默认构造函数</strong>：可以创建一个空的<code>valarray</code>。例如<code>std::valarray&lt;int&gt; va;</code>，这样就创建了一个空的<code>valarray</code>，其中元素类型为<code>int</code>。</li><li><strong>大小指定构造函数</strong>：可以指定<code>valarray</code>的大小和初始值。例如<code>std::valarray&lt;double&gt; va1(10, 3.14);</code>，这个构造函数创建了一个包含 10 个元素的<code>valarray</code>，每个元素初始值为 3.14。</li><li><strong>拷贝构造函数</strong>：用于从另一个<code>valarray</code>创建一个新的<code>valarray</code>。例如<code>std::valarray&lt;int&gt; va2(va1);</code>，这里<code>va2</code>是<code>va1</code>的一个拷贝，它们具有相同的元素个数和对应位置相同的元素。</li><li><strong>初始化列表构造函数</strong>：可以使用花括号初始化列表来创建<code>valarray</code>。例如<code>std::valarray&lt;int&gt; va3 = {1, 2, 3, 4, 5};</code>，这种方式方便快捷地创建并初始化一个<code>valarray</code>。</li></ul></li><li>元素访问方法<ul><li><strong><code>[]</code>操作符</strong>：用于访问<code>valarray</code>中的单个元素。例如：</li></ul></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::valarray&lt;<span class="hljs-type">int</span>&gt; va = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><span class="hljs-type">int</span> element = va[<span class="hljs-number">2</span>];  <span class="hljs-comment">// 访问第三个元素，element的值为3</span><br></code></pre></td></tr></table></figure><ul><li><strong><code>size()</code>方法</strong>：返回<code>valarray</code>中元素的个数。例如：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::valarray&lt;<span class="hljs-type">double</span>&gt; <span class="hljs-title">va1</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">3.14</span>)</span></span>;<br>std::cout &lt;&lt; va<span class="hljs-number">1.</span><span class="hljs-built_in">size</span>() &lt;&lt; std::endl;  <span class="hljs-comment">// 输出10</span><br></code></pre></td></tr></table></figure><ol><li>数学运算方法<ul><li>算术运算符重载<ul><li><strong>加法</strong>：可以将两个<code>valarray</code>相加，或者将一个<code>valarray</code>与一个标量相加。例如：</li></ul></li></ul></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::valarray&lt;<span class="hljs-type">int</span>&gt; va1 = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>std::valarray&lt;<span class="hljs-type">int</span>&gt; va2 = &#123;<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;;<br>std::valarray&lt;<span class="hljs-type">int</span>&gt; result1 = va1 + va2;  <span class="hljs-comment">// 对应元素相加，result1为&#123;5, 7, 9&#125;</span><br>std::valarray&lt;<span class="hljs-type">int</span>&gt; result2 = va1 + <span class="hljs-number">2</span>;    <span class="hljs-comment">// 每个元素加2，result2为&#123;3, 4, 5&#125;</span><br></code></pre></td></tr></table></figure><ul><li>减法、乘法、除法等运算与之类似<ul><li>减法：<code>std::valarray&lt;int&gt; result3 = va2 - va1;</code>（对应元素相减）</li><li>乘法：<code>std::valarray&lt;int&gt; result4 = va1 * 3;</code>（每个元素乘以 3）</li><li>除法：<code>std::valarray&lt;double&gt; va3 = {4.0, 8.0, 12.0};</code>，<code>std::valarray&lt;double&gt; result5 = va3 / 2.0;</code>（每个元素除以 2.0）</li></ul></li><li>数学函数应用<ul><li><strong><code>std::pow</code>函数</strong>：用于计算<code>valarray</code>中每个元素的幂。例如</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::valarray&lt;<span class="hljs-type">int</span>&gt; va = &#123;<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br>std::valarray&lt;<span class="hljs-type">int</span>&gt; result = std::<span class="hljs-built_in">pow</span>(va, <span class="hljs-number">2</span>);  <span class="hljs-comment">// 计算每个元素的平方，result为&#123;4, 9, 16&#125;</span><br></code></pre></td></tr></table></figure><ul><li><code>std::sin</code>、<code>std::cos</code>等三角函数也可以应用于<code>valarray</code>元素<ul><li>例如<code>std::valarray&lt;double&gt; va1 = {0.0, 3.14159 / 2.0, 3.14159};</code>，<code>std::valarray&lt;double&gt; sin_result = std::sin(va1);</code>，会分别计算<code>va1</code>中每个元素的正弦值。</li></ul></li></ul><ol><li>切片操作（<code>slice</code>）相关方法<ul><li><strong><code>valarray</code>支持切片操作</strong>：可以通过定义<code>slice</code>对象来提取<code>valarray</code>中的一部分元素。例如：</li></ul></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::valarray&lt;<span class="hljs-type">int</span>&gt; va = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>&#125;;<br><span class="hljs-function">std::slice <span class="hljs-title">s</span><span class="hljs-params">(<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>)</span></span>;  <span class="hljs-comment">// 从索引2开始，长度为4，步长为2的切片</span><br>std::valarray&lt;<span class="hljs-type">int</span>&gt; sliced_va = va[s];  <span class="hljs-comment">// sliced_va为&#123;3, 5, 7, 9&#125;</span><br></code></pre></td></tr></table></figure><ul><li><strong><code>cshift</code>方法（循环移位）</strong>：可以对<code>valarray</code>中的元素进行循环移位操作。例如：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::valarray&lt;<span class="hljs-type">int</span>&gt; va = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>std::valarray&lt;<span class="hljs-type">int</span>&gt; shifted_va = va.<span class="hljs-built_in">cshift</span>(<span class="hljs-number">2</span>);  <span class="hljs-comment">// 元素向右循环移2位，shifted_va为&#123;4, 5, 1, 2, 3&#125;</span><br></code></pre></td></tr></table></figure>          </div><h3 id="如何操作has-a关系？"><a href="#如何操作has-a关系？" class="headerlink" title="如何操作has-a关系？"></a>如何操作<code>has-a</code>关系？</h3><p>公有继承比较适合的是<code>is-a-king-of</code>关系的建立，即构建一种<strong>种类上子集</strong>的关系。那如果是是一种<strong>has-a</strong>关系呢？举个简单的例子，我们现在又<strong>string</strong>类（姓名）和<strong>valarry</strong>类（分数）两个底层的基类，我想从这两个基类派生出我的<strong>student类</strong>（每个学生都有自己的姓名和分数）。</p><p>如果使用<strong>公有继承</strong>（在这里是多重公有继承），显然不合适。因为学生和姓名不属于同类事物。通常，我们使用<strong>包含（containment）</strong>的技术来构建一种<strong>has-a</strong>关系，即<strong>创建一个包含其他类对象的类</strong>。</p><p>下文给出<code>student</code>类的代码示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// studentc.h -- defining a Student class using containment</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> STUDENTC_H_</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> STUDENTC_H_</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span>   </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;valarray&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span><br>&#123;   <br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">typedef</span> std::valarray&lt;<span class="hljs-type">double</span>&gt; ArrayDb;<br>    std::string name;       <span class="hljs-comment">// contained object</span><br>    ArrayDb scores;         <span class="hljs-comment">// contained object</span><br>    <span class="hljs-comment">// private method for scores output</span><br>    <span class="hljs-function">std::ostream &amp; <span class="hljs-title">arr_out</span><span class="hljs-params">(std::ostream &amp; os)</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Student</span>() : <span class="hljs-built_in">name</span>(<span class="hljs-string">&quot;Null Student&quot;</span>), <span class="hljs-built_in">scores</span>() &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Student</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp; s)</span></span><br><span class="hljs-function">        : name(s), scores() &#123;</span>&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Student</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> : name(<span class="hljs-string">&quot;Nully&quot;</span>), scores(n) &#123;</span>&#125;<br>    <span class="hljs-built_in">Student</span>(<span class="hljs-type">const</span> std::string &amp; s, <span class="hljs-type">int</span> n)<br>        : <span class="hljs-built_in">name</span>(s), <span class="hljs-built_in">scores</span>(n) &#123;&#125;<br>    <span class="hljs-built_in">Student</span>(<span class="hljs-type">const</span> std::string &amp; s, <span class="hljs-type">const</span> ArrayDb &amp; a)<br>        : <span class="hljs-built_in">name</span>(s), <span class="hljs-built_in">scores</span>(a) &#123;&#125;<br>    <span class="hljs-built_in">Student</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> * str, <span class="hljs-type">const</span> <span class="hljs-type">double</span> * pd, <span class="hljs-type">int</span> n)<br>        : <span class="hljs-built_in">name</span>(str), <span class="hljs-built_in">scores</span>(pd, n) &#123;&#125;<br>    ~<span class="hljs-built_in">Student</span>() &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">Average</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">const</span> std::string &amp; <span class="hljs-title">Name</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-type">double</span> &amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> i);<br>    <span class="hljs-type">double</span> <span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> i) <span class="hljs-type">const</span>;<br><span class="hljs-comment">// friends</span><br>    <span class="hljs-comment">// input</span><br>    <span class="hljs-keyword">friend</span> std::istream &amp; <span class="hljs-keyword">operator</span>&gt;&gt;(std::istream &amp; is,<br>                                     Student &amp; stu);  <span class="hljs-comment">// 1 word</span><br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> std::istream &amp; <span class="hljs-title">getline</span><span class="hljs-params">(std::istream &amp; is,</span></span><br><span class="hljs-params"><span class="hljs-function">                                  Student &amp; stu)</span></span>;     <span class="hljs-comment">// 1 line</span><br>    <span class="hljs-comment">// output</span><br>    <span class="hljs-keyword">friend</span> std::ostream &amp; <span class="hljs-keyword">operator</span>&lt;&lt;(std::ostream &amp; os,<br>                                     <span class="hljs-type">const</span> Student &amp; stu);<br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br></code></pre></td></tr></table></figure><blockquote><p>复习一下：<code>explicit</code>关键词可以避免编译器进行隐式类型转换。</p><p>在这种情况下，Student类的成员函可以使用string类的共用接口来修改和访问name对象，但是在类的外部只能通过Student类的成员函数对私有数据进行访问。</p><p>换句话说，在has-a关系的继承中，<strong>类对象不能自动获得被包含对象的接口，而应该通过定义成员函数来实现。</strong>举个例子，在string类中重载了加法运算符用于字符串的拼接，但是student类继承这种方法是没有任何意义的（你不可以把两个学生拼在一起）。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// studentc.cpp -- Student class using containment</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;studentc.h&quot;</span></span><br><span class="hljs-keyword">using</span> std::ostream;<br><span class="hljs-keyword">using</span> std::endl;<br><span class="hljs-keyword">using</span> std::istream;<br><span class="hljs-keyword">using</span> std::string;<br><br><span class="hljs-comment">//public methods</span><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">Student::Average</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (scores.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> scores.<span class="hljs-built_in">sum</span>()/scores.<span class="hljs-built_in">size</span>();  <br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">const</span> string &amp; <span class="hljs-title">Student::Name</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> name;<br>&#125;<br><br><span class="hljs-type">double</span> &amp; Student::<span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> i)<br>&#123;<br>    <span class="hljs-keyword">return</span> scores[i];         <span class="hljs-comment">// use valarray&lt;double&gt;::operator[]()</span><br>&#125;<br><br><span class="hljs-type">double</span> Student::<span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> i) <span class="hljs-type">const</span><br>&#123;<br>    <span class="hljs-keyword">return</span> scores[i];<br>&#125;<br><br><span class="hljs-comment">// private method</span><br><span class="hljs-function">ostream &amp; <span class="hljs-title">Student::arr_out</span><span class="hljs-params">(ostream &amp; os)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-type">int</span> lim = scores.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">if</span> (lim &gt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; lim; i++)<br>        &#123;<br>            os &lt;&lt; scores[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>            <span class="hljs-keyword">if</span> (i % <span class="hljs-number">5</span> == <span class="hljs-number">4</span>)<br>                os &lt;&lt; endl;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (i % <span class="hljs-number">5</span> != <span class="hljs-number">0</span>)<br>            os &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>        os &lt;&lt; <span class="hljs-string">&quot; empty array &quot;</span>;<br>    <span class="hljs-keyword">return</span> os; <br>&#125;<br><br><span class="hljs-comment">// friends</span><br><br><span class="hljs-comment">// use string version of operator&gt;&gt;()</span><br>istream &amp; <span class="hljs-keyword">operator</span>&gt;&gt;(istream &amp; is, Student &amp; stu)<br>&#123;<br>    is &gt;&gt; stu.name;<br>    <span class="hljs-keyword">return</span> is; <br>&#125;<br><br><span class="hljs-comment">// use string friend getline(ostream &amp;, const string &amp;)</span><br><span class="hljs-function">istream &amp; <span class="hljs-title">getline</span><span class="hljs-params">(istream &amp; is, Student &amp; stu)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">getline</span>(is, stu.name);<br>    <span class="hljs-keyword">return</span> is;<br>&#125;<br><br><span class="hljs-comment">// use string version of operator&lt;&lt;()</span><br>ostream &amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp; os, <span class="hljs-type">const</span> Student &amp; stu)<br>&#123;<br>    os &lt;&lt; <span class="hljs-string">&quot;Scores for &quot;</span> &lt;&lt; stu.name &lt;&lt; <span class="hljs-string">&quot;:\n&quot;</span>;<br>    stu.<span class="hljs-built_in">arr_out</span>(os);  <span class="hljs-comment">// use private method for scores</span><br>    <span class="hljs-keyword">return</span> os;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="私有继承与保护继承（Additional）"><a href="#私有继承与保护继承（Additional）" class="headerlink" title="私有继承与保护继承（Additional）"></a>私有继承与保护继承（Additional）</h3><p>在C++中，<strong>私有继承</strong>也是实现<strong>has-a</strong>关系的重要实现方式之一，在这里不再展开涉及具体的细节（毕竟第一种方法已经够用了，不是吗），只给出头文件的语法规范示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// studenti.h -- defining a Student class using private inheritance</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> STUDENTC_H_</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> STUDENTC_H_</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;valarray&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span>   </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> : <span class="hljs-keyword">private</span> std::string, <span class="hljs-keyword">private</span> std::valarray&lt;<span class="hljs-type">double</span>&gt;<br>&#123;   <br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">typedef</span> std::valarray&lt;<span class="hljs-type">double</span>&gt; ArrayDb;<br>    <span class="hljs-comment">// private method for scores output</span><br>    <span class="hljs-function">std::ostream &amp; <span class="hljs-title">arr_out</span><span class="hljs-params">(std::ostream &amp; os)</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Student</span>() : std::<span class="hljs-built_in">string</span>(<span class="hljs-string">&quot;Null Student&quot;</span>), <span class="hljs-built_in">ArrayDb</span>() &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Student</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp; s)</span></span><br><span class="hljs-function">            : std::string(s), ArrayDb() &#123;</span>&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Student</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> : std::string(<span class="hljs-string">&quot;Nully&quot;</span>), ArrayDb(n) &#123;</span>&#125;<br>    <span class="hljs-built_in">Student</span>(<span class="hljs-type">const</span> std::string &amp; s, <span class="hljs-type">int</span> n)<br>            : std::<span class="hljs-built_in">string</span>(s), <span class="hljs-built_in">ArrayDb</span>(n) &#123;&#125;<br>    <span class="hljs-built_in">Student</span>(<span class="hljs-type">const</span> std::string &amp; s, <span class="hljs-type">const</span> ArrayDb &amp; a)<br>            : std::<span class="hljs-built_in">string</span>(s), <span class="hljs-built_in">ArrayDb</span>(a) &#123;&#125;<br>    <span class="hljs-built_in">Student</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> * str, <span class="hljs-type">const</span> <span class="hljs-type">double</span> * pd, <span class="hljs-type">int</span> n)<br>            : std::<span class="hljs-built_in">string</span>(str), <span class="hljs-built_in">ArrayDb</span>(pd, n) &#123;&#125;<br>    ~<span class="hljs-built_in">Student</span>() &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">Average</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-type">double</span> &amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> i);<br>    <span class="hljs-type">double</span> <span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> i) <span class="hljs-type">const</span>;<br>    <span class="hljs-function"><span class="hljs-type">const</span> std::string &amp; <span class="hljs-title">Name</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-comment">// friends</span><br>    <span class="hljs-comment">// input</span><br>    <span class="hljs-keyword">friend</span> std::istream &amp; <span class="hljs-keyword">operator</span>&gt;&gt;(std::istream &amp; is,<br>                                     Student &amp; stu);  <span class="hljs-comment">// 1 word</span><br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> std::istream &amp; <span class="hljs-title">getline</span><span class="hljs-params">(std::istream &amp; is,</span></span><br><span class="hljs-params"><span class="hljs-function">                                  Student &amp; stu)</span></span>;     <span class="hljs-comment">// 1 line</span><br>    <span class="hljs-comment">// output</span><br>    <span class="hljs-keyword">friend</span> std::ostream &amp; <span class="hljs-keyword">operator</span>&lt;&lt;(std::ostream &amp; os,<br>                                     <span class="hljs-type">const</span> Student &amp; stu);<br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br></code></pre></td></tr></table></figure><h2 id="Multiple-Inheritance"><a href="#Multiple-Inheritance" class="headerlink" title="Multiple Inheritance"></a>Multiple Inheritance</h2><p>从单继承，我们很容易的推理出多重继承（Multiple Inheritance），简称MI。</p><p><img src="/posts/Above-All/-in-OOP/MI.png" alt="Multiple Inheritance"></p><div class="note note-danger">            <p><strong>注意！！！多重继承在一定程度上大大提高了继承的复杂性！一定要慎用！（笔者建议能使用单继承就使用单继承）</strong></p>          </div><div class="note note-info">            <h3 id="小故事：钻石问题"><a href="#小故事：钻石问题" class="headerlink" title="小故事：钻石问题"></a>小故事：钻石问题</h3><p>钻石问题（Diamond Problem）是多重继承中的一个经典问题，特别是在面向对象编程语言中。这个问题发生在一个类继承自两个或更多有共同父类的类时，导致继承结构中产生二义性和不明确的继承路径。它的名字来源于继承关系图形的形状，通常呈现一个钻石形状。</p><p><strong>钻石问题的例子</strong>：</p><p>假设有一个类 <code>A</code>，它是两个类 <code>B</code> 和 <code>C</code> 的父类，而 <code>B</code> 和 <code>C</code> 又被一个类 <code>D</code> 继承。继承关系可以表示为一个钻石形状：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Css">  <span class="hljs-selector-tag">A</span><br> / \<br><span class="hljs-selector-tag">B</span>   C<br> \ /<br>  D<br></code></pre></td></tr></table></figure><p><strong>问题的具体情况</strong>：</p><p>在这个继承关系中，类 <code>B</code> 和类 <code>C</code> 都继承了类 <code>A</code>，并且类 <code>D</code> 同时继承了 <code>B</code> 和 <code>C</code>。假设类 <code>A</code> 中有一个成员函数 <code>foo()</code>，而类 <code>B</code> 和类 <code>C</code> 都没有覆盖（override）该函数。那么，类 <code>D</code> 在继承时会遇到以下问题：</p><ul><li><strong>二义性</strong>：类 <code>D</code> 继承了 <code>B</code> 和 <code>C</code>，它同时会继承来自 <code>A</code> 的 <code>foo()</code> 函数。但是，当你尝试调用 <code>foo()</code> 时，编译器无法确定应该调用 <code>B</code> 中的 <code>foo()</code>，还是 <code>C</code> 中的 <code>foo()</code>（假设 <code>B</code> 和 <code>C</code> 都没有覆盖这个函数）。如果 <code>B</code> 和 <code>C</code> 都没有 <code>foo()</code>，那么 <code>D</code> 也会得到二义性错误。</li><li><strong>重复继承</strong>：由于 <code>B</code> 和 <code>C</code> 都继承自 <code>A</code>，在类 <code>D</code> 中可能会包含 <code>A</code> 的多个副本，导致同一个基类成员被多次继承，这种冗余的继承可能会导致不必要的资源浪费和代码混乱。</li></ul><blockquote><p>实际上，C++ 引入了 <strong>虚拟继承（Virtual Inheritance）</strong> 来解决钻石问题。虚拟继承可以确保在多重继承时，<code>A</code> 类的子对象只会被继承一次。</p></blockquote>          </div><h2 id="Class-Template"><a href="#Class-Template" class="headerlink" title="Class Template"></a>Class Template</h2><p>面向对象的程序设计提供了一种称为<strong>泛型程序设计</strong>的机制，即允许将类中成员的类型设置为一个可变的参数，使多个类变成一个类。泛型程序设计可以以独立于任何特定类型的方式编写代码。使用泛型程序时，必须提供具体所操作的类型或值。第 5 章介绍的<strong>函数模板</strong>就是泛型机制的一种实现方法，本章将介绍<strong>类模板</strong>，即<strong>用泛型机制设计的类</strong>。  </p><p>在函数章节，我们学习了模版函数，实现了一个模版在多个不同数据类型之间的通用，大大提高了代码重用的效率。在类的定义中同样也是如此，模板提供<strong>参数化（parameterized）类型</strong>，即能够将类型名作为参数传递给接收方来建立类或函数。例如，将类型名 <code>int</code> 传递给 <code>Queue</code> 模板，可以让编译器构造一个对 int 进行排队的 <code>Queue</code> 类。  </p><p>在接下来的内容中，我们将以非常重要的数据结构——<strong>栈（Stack）</strong>为示例，向读者演示模板类的强大之处。</p><h3 id="The-Implementation-of-Stack"><a href="#The-Implementation-of-Stack" class="headerlink" title="The Implementation of Stack"></a>The Implementation of Stack</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// stack.h -- class definition for the stack ADT</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> STACK_H_</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> STACK_H_</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> Item;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Stack</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">enum</span> &#123;MAX = <span class="hljs-number">10</span>&#125;;    <span class="hljs-comment">// constant specific to class</span><br>    Item items[MAX];    <span class="hljs-comment">// holds stack items</span><br>    <span class="hljs-type">int</span> top;            <span class="hljs-comment">// index for top stack item</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Stack</span>();<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isempty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isfull</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-comment">// push() returns false if stack already is full, true otherwise</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">const</span> Item &amp; item)</span></span>;   <span class="hljs-comment">// add item to stack</span><br>    <span class="hljs-comment">// pop() returns false if stack already is empty, true otherwise</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">pop</span><span class="hljs-params">(Item &amp; item)</span></span>;          <span class="hljs-comment">// pop top into item</span><br>&#125;;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><br><span class="hljs-comment">// stack.cpp -- Stack member functions</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stack.h&quot;</span></span><br>Stack::<span class="hljs-built_in">Stack</span>()    <span class="hljs-comment">// create an empty stack</span><br>&#123;<br>    top = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Stack::isempty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> top == <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Stack::isfull</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> top == MAX;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Stack::push</span><span class="hljs-params">(<span class="hljs-type">const</span> Item &amp; item)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (top &lt; MAX)<br>    &#123;<br>        items[top++] = item;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Stack::pop</span><span class="hljs-params">(Item &amp; item)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (top &gt; <span class="hljs-number">0</span>)<br>    &#123;<br>        item = items[--top];<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><p>在第十章书中给出了针对<code>unsigned long</code>类型的栈数据结构示例，此处不再解释具体代码的含义。</p></blockquote><h3 id="The-Definition"><a href="#The-Definition" class="headerlink" title="The Definition"></a>The Definition</h3><p>我们先给出模板类的头文件声明，读者可以自行比较有哪边进行了修改：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Type</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Stack</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">enum</span> &#123;SIZE = <span class="hljs-number">10</span>&#125;;    <span class="hljs-comment">// default size</span><br>    <span class="hljs-type">int</span> stacksize;<br>    Type * items;       <span class="hljs-comment">// holds stack items</span><br>    <span class="hljs-comment">//在这里优化为了指针，更加的高效（相比使用数组存储）</span><br>    <span class="hljs-type">int</span> top;            <span class="hljs-comment">// index for top stack item</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Stack</span><span class="hljs-params">(<span class="hljs-type">int</span> ss = SIZE)</span></span>;<br>    <span class="hljs-built_in">Stack</span>(<span class="hljs-type">const</span> Stack &amp; st);<br>    ~<span class="hljs-built_in">Stack</span>() &#123; <span class="hljs-keyword">delete</span> [] items; &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isempty</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> top == <span class="hljs-number">0</span>; &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isfull</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> top == stacksize; &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">const</span> Type &amp; item)</span></span>;   <span class="hljs-comment">// add item to stack</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">pop</span><span class="hljs-params">(Type &amp; item)</span></span>;          <span class="hljs-comment">// pop top into item</span><br>    Stack &amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Stack &amp; st);<br>&#125;;<br></code></pre></td></tr></table></figure><p>采用模板时，将使用模板定义替换 <code>Stack</code> 声明，使用模板成员函数替换 <code>Stack</code> 的成员函数。和模板函数一样，模板类以下面这样的代码开头 :<code>template &lt;class Type&gt;</code>。</p><p>剩下的操作基本上没什么区别了。（因为定义类在很大程度上就是定义成员函数和方法。那定义模版类就是定义模版函数的过程）</p><p>接下来我们来看类方法的定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Type</span>&gt;<br>    <span class="hljs-comment">//这一行必不可少（相当于定义模版函数的过程）</span><br>Stack&lt;Type&gt;::<span class="hljs-built_in">Stack</span>(<span class="hljs-type">int</span> ss) : <span class="hljs-built_in">stacksize</span>(ss), <span class="hljs-built_in">top</span>(<span class="hljs-number">0</span>)<br>&#123;<br>    items = <span class="hljs-keyword">new</span> Type [stacksize];<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Type</span>&gt;<br>Stack&lt;Type&gt;::<span class="hljs-built_in">Stack</span>(<span class="hljs-type">const</span> Stack &amp; st)<br>&#123;<br>    stacksize = st.stacksize;<br>    top = st.top;<br>    items = <span class="hljs-keyword">new</span> Type [stacksize];<br>    <span class="hljs-comment">//使用动态内存分配，注意指针的安全使用！</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; top; i++)<br>        items[i] = st.items[i];<br>&#125;<br><span class="hljs-comment">//这个显示复制构造函数也是为了指针栈的使用（后文会提到）</span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Type</span>&gt;<br><span class="hljs-type">bool</span> Stack&lt;Type&gt;::<span class="hljs-built_in">push</span>(<span class="hljs-type">const</span> Type &amp; item)<br>&#123;<br>    <span class="hljs-keyword">if</span> (top &lt; stacksize)<br>    &#123;<br>        items[top++] = item;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Type</span>&gt;<br><span class="hljs-type">bool</span> Stack&lt;Type&gt;::<span class="hljs-built_in">pop</span>(Type &amp; item)<br>&#123;<br>    <span class="hljs-keyword">if</span> (top &gt; <span class="hljs-number">0</span>)<br>    &#123;<br>        item = items[--top];<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Type</span>&gt;<br>Stack&lt;Type&gt; &amp; Stack&lt;Type&gt;::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Stack&lt;Type&gt; &amp; st)<br>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;st)<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    <span class="hljs-keyword">delete</span> [] items;<br>    stacksize = st.stacksize;<br>    top = st.top;<br>    items = <span class="hljs-keyword">new</span> Type [stacksize];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; top; i++)<br>        items[i] = st.items[i];<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>; <br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br></code></pre></td></tr></table></figure><div class="note note-info">            <p>类模板的成员函数本身不是一个函数，故不可以<strong>单独编译</strong>，需要在指定模版形式参数的值后（即实现<strong>模版的实例化</strong>后）才能被编译成一个程序。因此，对于类模版而言，往往将<strong>函数定义和类模板的定义</strong>写在同一个头文件中。</p>          </div><h3 id="The-Use-of-Pointer-Stack"><a href="#The-Use-of-Pointer-Stack" class="headerlink" title="The Use of Pointer Stack"></a>The Use of Pointer Stack</h3><p>细心的读者可能会发现，在模版类的函数定义中，多出了这样一个函数（对赋值运算符的运算符重载）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++">Stack &amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Stack &amp; st);<br><span class="hljs-comment">//在public中的函数声明</span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Type</span>&gt;<br>Stack&lt;Type&gt; &amp; Stack&lt;Type&gt;::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Stack&lt;Type&gt; &amp; st)<br>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;st)<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    <span class="hljs-keyword">delete</span> [] items;<br>    stacksize = st.stacksize;<br>    top = st.top;<br>    items = <span class="hljs-keyword">new</span> Type [stacksize];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; top; i++)<br>        items[i] = st.items[i];<br>    <span class="hljs-comment">//考虑到如果数据类型为指针，直接整块赋值会产生非常严重的问题。</span><br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>; <br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>同时，对构造函数和析构函数的定义也做出了相关修改。</p></blockquote><p>为什么要做这样一个修改？<strong>模板类和模版函数非常重要的一点就是模版必须具有通用性</strong>（也可以使用<strong>显示具体化</strong>来为特殊类型打补丁，后文会讲到）。如果模板类型是<strong>指针</strong>（即<strong>指针栈</strong>），那么使用默认的赋值运算符会产生比较严重的问题。</p><blockquote><p>什么严重的问题？欢迎参考第十二章有关动态内存分配的知识，此处不再展开。</p><p><a href="https://xiyuanyang-code.github.io/posts/Dynamic-Memory-and-Classes/">我的博客链接</a></p></blockquote><h4 id="正确使用指针栈"><a href="#正确使用指针栈" class="headerlink" title="正确使用指针栈"></a>正确使用指针栈</h4><p>使用指针栈的方法之一是，让调用程序提供一个指针数组，其中每个指针都指向不同的字符串。把这些指针放在栈中是有意义的，因为每个指针都将指向不同的字符串。注意，创建不同指针是调用程序的职责，而不是栈的职责。<strong>栈的任务是管理指针，而不是创建指针</strong>。  </p><h3 id="Advanced-Usage"><a href="#Advanced-Usage" class="headerlink" title="Advanced Usage"></a>Advanced Usage</h3><h4 id="非类型参数"><a href="#非类型参数" class="headerlink" title="非类型参数"></a>非类型参数</h4><p>在使用模板类的时候，我们通过构造函数在堆上动态分配内存，这样的效率往往比较低。如果<strong>在确定具体类型之后再栈上开辟空间，将会变得更加的高效。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//arraytp.h  -- Array Template</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> ARRAYTP_H_</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ARRAYTP_H_</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>, <span class="hljs-type">int</span> n&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayTP</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>    T ar[n];<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">ArrayTP</span>() &#123;&#125;;<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">ArrayTP</span><span class="hljs-params">(<span class="hljs-type">const</span> T &amp; v)</span></span>;<br>    <span class="hljs-keyword">virtual</span> T &amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> i);<br>    <span class="hljs-keyword">virtual</span> T <span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> i) <span class="hljs-type">const</span>;<br>&#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>, <span class="hljs-type">int</span> n&gt;<br>ArrayTP&lt;T,n&gt;::<span class="hljs-built_in">ArrayTP</span>(<span class="hljs-type">const</span> T &amp; v)<br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        ar[i] = v;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>, <span class="hljs-type">int</span> n&gt;<br>T &amp; ArrayTP&lt;T,n&gt;::<span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> i)<br>&#123;<br>    <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || i &gt;= n)<br>    &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;Error in array limits: &quot;</span> &lt;&lt; i<br>            &lt;&lt; <span class="hljs-string">&quot; is out of range\n&quot;</span>;<br>        std::<span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ar[i];<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>, <span class="hljs-type">int</span> n&gt;<br>T ArrayTP&lt;T,n&gt;::<span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> i) <span class="hljs-type">const</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || i &gt;= n)<br>    &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;Error in array limits: &quot;</span> &lt;&lt; i<br>            &lt;&lt; <span class="hljs-string">&quot; is out of range\n&quot;</span>;<br>        std::<span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ar[i]; <br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p><code>template &lt;class T, int n&gt;</code> 是 C++ 中的一种模板声明方式，其中包含了两种不同类型的模板参数：</p><ul><li><strong><code>T</code><strong>：这是一个</strong>类型模板参数</strong>（Type Template Parameter），表示一个类型，通常用来代表类、结构体、函数等的类型。</li><li><strong><code>n</code><strong>：这是一个</strong>非类型模板参数</strong>（Non-type Template Parameter），表示一个常量值，通常是整数、指针、引用或其他常量值。</li></ul><p><img src="/posts/Above-All/-in-OOP/biaodashi.png" alt="表达式参数"></p><p>缺点是，在<code>n</code>不相同的情况下，编译器会生成两种不同的模版（<strong>哪怕非类型模版参数是相同的</strong>）。非类型参数的使用本质是更改了内存的存储方式，在提升效率的同时牺牲了部分的通用性。（无法创建数组大小可变的类了）</p><h4 id="递归使用模板"><a href="#递归使用模板" class="headerlink" title="递归使用模板"></a>递归使用模板</h4><p><code>ArrayTP&lt; ArrayTP&lt;int,5&gt;, 10&gt; twodee;</code></p><h4 id="pair类"><a href="#pair类" class="headerlink" title="pair类"></a>pair类</h4><div class="note note-info">            <p><code>std::pair</code> 是 C++ 标准库中的一个模板类，用于存储两个不同类型的元素。它可以将两个数据组合成一个对象，这两个数据可以是任意类型，因此 <code>std::pair</code> 是一种非常常见的<strong>通用容器</strong>，特别适用于需要将两个相关数据关联在一起的场景。</p><p><code>std::pair</code> 定义在 <code>&lt;utility&gt;</code> 头文件中，其模板定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span>&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">pair</span> &#123;<br>    T1 first;   <span class="hljs-comment">// 第一个元素</span><br>    T2 second;  <span class="hljs-comment">// 第二个元素</span><br><br>    <span class="hljs-comment">// 默认构造函数</span><br>    <span class="hljs-built_in">pair</span>();<br>    <br>    <span class="hljs-comment">// 带参数的构造函数</span><br>    <span class="hljs-built_in">pair</span>(<span class="hljs-type">const</span> T1&amp; a, <span class="hljs-type">const</span> T2&amp; b);<br>    <br>    <span class="hljs-comment">// 构造函数（使用移动语义）</span><br>    <span class="hljs-built_in">pair</span>(T1&amp;&amp; a, T2&amp;&amp; b);<br><br>    <span class="hljs-comment">// 比较运算符</span><br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> pair&amp; other) <span class="hljs-type">const</span>;<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-type">const</span> pair&amp; other) <span class="hljs-type">const</span>;<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> pair&amp; other) <span class="hljs-type">const</span>;<br>    <span class="hljs-type">bool</span> <span class="hljs-built_in">operator</span>&lt;=(<span class="hljs-type">const</span> pair&amp; other) <span class="hljs-type">const</span>;<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&gt;(<span class="hljs-type">const</span> pair&amp; other) <span class="hljs-type">const</span>;<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&gt;=(<span class="hljs-type">const</span> pair&amp; other) <span class="hljs-type">const</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p><code>std::pair</code> 存储两个值：<code>first</code> 和 <code>second</code>，它们可以是不同类型的数据。<code>T1</code> 是第一个元素的类型，<code>T2</code> 是第二个元素的类型。</p><ul><li><p><strong>默认构造函数</strong>：<code>pair</code> 的两个成员 <code>first</code> 和 <code>second</code> 都会被默认初始化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">double</span>&gt; p1;  <span class="hljs-comment">// p1.first 和 p1.second 都是默认初始化</span><br></code></pre></td></tr></table></figure></li><li><p><strong>带参构造函数</strong>：通过提供两个值初始化 <code>first</code> 和 <code>second</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">double</span>&gt; <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">3.14</span>)</span></span>;  <span class="hljs-comment">// p2.first = 1, p2.second = 3.14</span><br></code></pre></td></tr></table></figure></li><li><p><strong>拷贝构造函数</strong>：允许使用另一个 <code>pair</code> 来初始化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">double</span>&gt; p3 = p2;  <span class="hljs-comment">// p3.first = p2.first, p3.second = p2.second</span><br></code></pre></td></tr></table></figure></li><li><p><strong>移动构造函数</strong>：允许通过右值引用来初始化（C++11 引入的特性）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">double</span>&gt; p4 = std::<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20.5</span>);<br></code></pre></td></tr></table></figure></li></ul><p><strong>操作：</strong></p><ul><li><p><strong>访问成员</strong>：<code>pair</code> 提供了两个公共成员变量 <code>first</code> 和 <code>second</code>，可以直接访问。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">double</span>&gt; <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">3.14</span>)</span></span>;<br>std::cout &lt;&lt; p.first &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; p.second &lt;&lt; std::endl;  <span class="hljs-comment">// 输出: 1, 3.14</span><br></code></pre></td></tr></table></figure></li><li><p>**<code>std::make_pair</code>**：<code>make_pair</code> 是一个方便的函数模板，用于创建 <code>pair</code> 对象，避免手动指定类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> p = std::<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">1</span>, <span class="hljs-number">3.14</span>);  <span class="hljs-comment">// p 是 pair&lt;int, double&gt;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>比较操作符</strong>：<code>pair</code> 支持常见的比较操作符（<code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>）。比较时，<code>pair</code> 会首先比较 <code>first</code>，如果相等，则再比较 <code>second</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">double</span>&gt; <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">3.14</span>)</span>, <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2.718</span>)</span></span>;<br><span class="hljs-keyword">if</span> (p1 &lt; p2) &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;p1 &lt; p2&quot;</span> &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>交换元素</strong>：<code>std::pair</code> 提供了一个 <code>swap</code> 方法用于交换 <code>first</code> 和 <code>second</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">double</span>&gt; <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">3.14</span>)</span>, <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-number">2</span>, <span class="hljs-number">2.718</span>)</span></span>;<br>p<span class="hljs-number">1.</span><span class="hljs-built_in">swap</span>(p2);  <span class="hljs-comment">// 交换 p1 和 p2 的值</span><br></code></pre></td></tr></table></figure></li></ul><p><strong>使用场景</strong></p><p><code>std::pair</code> 经常用于以下场景：</p><ul><li><p><strong>返回多个值</strong>：有时我们需要返回多个相关的值（例如，函数返回两个值），<code>std::pair</code> 是一个非常方便的方式来做到这一点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">double</span>&gt; <span class="hljs-title">get_coordinates</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20.5</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>在容器中存储键值对</strong>：例如，<code>std::map</code> 和 <code>std::unordered_map</code> 等容器使用 <code>std::pair</code> 来存储键值对。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::map&lt;<span class="hljs-type">int</span>, std::string&gt; m;<br>m[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;apple&quot;</span>;<br>m[<span class="hljs-number">2</span>] = <span class="hljs-string">&quot;banana&quot;</span>;<br></code></pre></td></tr></table></figure></li><li><p><strong>配对数据</strong>：在某些算法或数据结构中，两个相关的数据项经常被配对在一起。<code>std::pair</code> 允许你简洁地存储和访问它们。</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span>  <span class="hljs-comment">// 引入 std::pair 和 std::make_pair</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 创建一个 pair</span><br>    <span class="hljs-function">std::pair&lt;<span class="hljs-type">int</span>, std::string&gt; <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;apple&quot;</span>)</span></span>;<br><br>    <span class="hljs-comment">// 访问 pair 的元素</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;First: &quot;</span> &lt;&lt; p<span class="hljs-number">1.f</span>irst &lt;&lt; <span class="hljs-string">&quot;, Second: &quot;</span> &lt;&lt; p<span class="hljs-number">1.</span>second &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 使用 std::make_pair 创建一个 pair</span><br>    <span class="hljs-keyword">auto</span> p2 = std::<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;banana&quot;</span>);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;First: &quot;</span> &lt;&lt; p<span class="hljs-number">2.f</span>irst &lt;&lt; <span class="hljs-string">&quot;, Second: &quot;</span> &lt;&lt; p<span class="hljs-number">2.</span>second &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 比较两个 pair</span><br>    <span class="hljs-keyword">if</span> (p1 &lt; p2) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;p1 is less than p2&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-comment">// 交换两个 pair</span><br>    p<span class="hljs-number">1.</span><span class="hljs-built_in">swap</span>(p2);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;After swap: &quot;</span> &lt;&lt; <span class="hljs-string">&quot;First: &quot;</span> &lt;&lt; p<span class="hljs-number">1.f</span>irst &lt;&lt; <span class="hljs-string">&quot;, Second: &quot;</span> &lt;&lt; p<span class="hljs-number">1.</span>second &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;After swap: &quot;</span> &lt;&lt; <span class="hljs-string">&quot;First: &quot;</span> &lt;&lt; p<span class="hljs-number">2.f</span>irst &lt;&lt; <span class="hljs-string">&quot;, Second: &quot;</span> &lt;&lt; p<span class="hljs-number">2.</span>second &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">First</span>: <span class="hljs-number">1</span>, <span class="hljs-keyword">Second</span>: apple<br><span class="hljs-keyword">First</span>: <span class="hljs-number">2</span>, <span class="hljs-keyword">Second</span>: banana<br>p1 <span class="hljs-keyword">is</span> less than p2<br>After swap: <span class="hljs-keyword">First</span>: <span class="hljs-number">2</span>, <span class="hljs-keyword">Second</span>: banana<br>After swap: <span class="hljs-keyword">First</span>: <span class="hljs-number">1</span>, <span class="hljs-keyword">Second</span>: apple<br></code></pre></td></tr></table></figure>          </div><div class="note note-info">            <h4 id="tuple和tie（补充知识）"><a href="#tuple和tie（补充知识）" class="headerlink" title="tuple和tie（补充知识）"></a>tuple和tie（补充知识）</h4><h5 id="打包函数：std-tie"><a href="#打包函数：std-tie" class="headerlink" title="打包函数：std::tie"></a>打包函数：<code>std::tie</code></h5><p><code>std::tie</code> 是 C++11 引入的一个非常强大且方便的工具，它可以将多个值打包成一个元组，并使得这些值能够像元组一样被进行比较、解构或传递。它在多个方面提供了便利，以下是其强大之处：</p><ol><li><strong>简化多重比较</strong></li></ol><p><code>std::tie</code> 可以将多个变量组合成一个元组，然后直接进行比较。这样，我们可以避免手动写出冗长的多重 <code>if</code> 语句来比较多个值。例如，比较结构体中的多个成员时，<code>std::tie</code> 可以将多个成员打包，按字典顺序（lexicographical order）进行比较。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span> &#123;<br>    <span class="hljs-type">int</span> x, y, z;<br>&#125;;<br><br><span class="hljs-comment">// 使用 std::tie 对 Point 进行比较</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-type">const</span> Point&amp; p1, <span class="hljs-type">const</span> Point&amp; p2)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">tie</span>(p<span class="hljs-number">1.</span>x, p<span class="hljs-number">1.</span>y, p<span class="hljs-number">1.</span>z) &lt; std::<span class="hljs-built_in">tie</span>(p<span class="hljs-number">2.</span>x, p<span class="hljs-number">2.</span>y, p<span class="hljs-number">2.</span>z);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的比较会首先比较 <code>x</code>，如果 <code>x</code> 相同，再比较 <code>y</code>，如果 <code>y</code> 也相同，则比较 <code>z</code>。<strong>这是一个典型的按字典顺序的比较</strong>。</p><ol start="2"><li><strong>简化排序操作</strong></li></ol><p>通过 <code>std::tie</code>，你可以在排序操作中直接比较多个字段，而无需手动指定每个字段的比较方式。比如在 <code>std::sort</code> 中进行排序时，使用 <code>std::tie</code> 让代码更加简洁且易于维护。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;Point&gt; points = &#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;, &#123;<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;&#125;;<br>std::<span class="hljs-built_in">sort</span>(points.<span class="hljs-built_in">begin</span>(), points.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">const</span> Point&amp; p1, <span class="hljs-type">const</span> Point&amp; p2) &#123;<br>    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">tie</span>(p<span class="hljs-number">1.</span>x, p<span class="hljs-number">1.</span>y, p<span class="hljs-number">1.</span>z) &lt; std::<span class="hljs-built_in">tie</span>(p<span class="hljs-number">2.</span>x, p<span class="hljs-number">2.</span>y, p<span class="hljs-number">2.</span>z);<br>&#125;);<br></code></pre></td></tr></table></figure><p>这样，排序时就不需要多个嵌套的 <code>if</code> 语句来分别比较 <code>x</code>, <code>y</code>, <code>z</code>。<code>std::tie</code> 会自动按字段顺序进行比较。</p><ol start="3"><li><strong>方便的结构体解构</strong></li></ol><p><code>std::tie</code> 不仅可以用于比较，还可以用于解构，特别是在函数中返回多个值时，或者从一个元组中提取值时。它让你可以直接将多个值赋给多个变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::tuple&lt;<span class="hljs-type">int</span>, <span class="hljs-type">double</span>, std::string&gt; <span class="hljs-title">getValues</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">make_tuple</span>(<span class="hljs-number">1</span>, <span class="hljs-number">3.14</span>, <span class="hljs-string">&quot;hello&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-type">double</span> d;<br>    std::string s;<br>    std::<span class="hljs-built_in">tie</span>(i, d, s) = <span class="hljs-built_in">getValues</span>();  <span class="hljs-comment">// 直接解构</span><br>    std::cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; d &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; s &lt;&lt; std::endl;  <span class="hljs-comment">// 输出: 1 3.14 hello</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这样，你就可以将一个元组中的元素直接解构到不同的变量中，而不需要手动访问每个元素。</p><ol start="4"><li><strong>元组和非元组类型的统一接口</strong></li></ol><p><code>std::tie</code> 的强大之处还在于它能够与普通类型（如 <code>int</code>，<code>double</code> 等）和标准库类型（如 <code>std::tuple</code>）无缝结合。这使得你在处理多个返回值时非常方便。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a = <span class="hljs-number">5</span>;<br><span class="hljs-type">double</span> b = <span class="hljs-number">3.14</span>;<br>std::<span class="hljs-built_in">tie</span>(a, b) = std::<span class="hljs-built_in">make_tuple</span>(<span class="hljs-number">10</span>, <span class="hljs-number">2.718</span>);  <span class="hljs-comment">// 可以直接解构元组</span><br></code></pre></td></tr></table></figure><ol start="5"><li><strong>更灵活的函数返回值</strong></li></ol><p>当你需要一个函数返回多个值时，<code>std::tie</code> 可以帮助你轻松解构并同时返回多个值，而不需要使用 <code>std::pair</code> 或 <code>std::tuple</code> 来包裹它们。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::tuple&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; <span class="hljs-title">divide</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">make_tuple</span>(a / b, a % b);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> quotient, remainder;<br>    std::<span class="hljs-built_in">tie</span>(quotient, remainder) = <span class="hljs-built_in">divide</span>(<span class="hljs-number">10</span>, <span class="hljs-number">3</span>);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Quotient: &quot;</span> &lt;&lt; quotient &lt;&lt; <span class="hljs-string">&quot;, Remainder: &quot;</span> &lt;&lt; remainder &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="std-tuple"><a href="#std-tuple" class="headerlink" title="std::tuple"></a><code>std::tuple</code></h5><p><code>std::tuple</code> 是 C++11 引入的一个标准库容器，它允许你存储多个不同类型的元素，类似于数组或结构体，但与这两者不同的是，<code>std::tuple</code> 的元素可以是不同类型的。换句话说，<code>tuple</code> 可以看作是一个异构的容器，即它可以存储多个不同类型的值，而不像数组那样只能存储相同类型的元素。</p><ul><li><strong>异构性</strong>：<code>std::tuple</code> 可以包含不同类型的元素（如 <code>int</code>、<code>double</code>、<code>std::string</code> 等），而不像 <code>std::vector</code> 或 <code>std::array</code> 这样的容器只能包含相同类型的元素。</li><li><strong>固定大小</strong>：<code>std::tuple</code> 的大小在编译时就确定了，无法动态改变大小。也就是说，它的大小（即元素的个数）是固定的。</li><li><strong>元素访问</strong>：可以通过索引或者 <code>std::get</code> 来访问 <code>tuple</code> 中的元素。</li></ul><p>你可以通过 <code>std::make_tuple</code> 或直接使用构造函数来创建 <code>tuple</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;tuple&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 创建一个 tuple，包含不同类型的元素</span><br>    <span class="hljs-function">std::tuple&lt;<span class="hljs-type">int</span>, <span class="hljs-type">double</span>, std::string&gt; <span class="hljs-title">t</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">3.14</span>, <span class="hljs-string">&quot;Hello&quot;</span>)</span></span>;<br><br>    <span class="hljs-comment">// 通过 std::get 访问 tuple 中的元素</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;First element: &quot;</span> &lt;&lt; std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">0</span>&gt;(t) &lt;&lt; std::endl;  <span class="hljs-comment">// 输出 10</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Second element: &quot;</span> &lt;&lt; std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">1</span>&gt;(t) &lt;&lt; std::endl; <span class="hljs-comment">// 输出 3.14</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Third element: &quot;</span> &lt;&lt; std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">2</span>&gt;(t) &lt;&lt; std::endl;  <span class="hljs-comment">// 输出 Hello</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>t</code> 是一个包含三个元素的 <code>tuple</code>，它的元素分别是 <code>int</code>、<code>double</code> 和 <code>std::string</code> 类型。</p><p><strong>获取 <code>tuple</code> 中的元素：</strong></p><p>使用 <code>std::get&lt;index&gt;(tuple)</code> 来访问特定位置的元素。索引是编译时确定的，因此使用时需要指定元素的类型或位置。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::tuple&lt;<span class="hljs-type">int</span>, <span class="hljs-type">double</span>, std::string&gt; <span class="hljs-title">t</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">3.14</span>, <span class="hljs-string">&quot;Hello&quot;</span>)</span></span>;<br><br><span class="hljs-comment">// 使用 std::get 获取元素</span><br><span class="hljs-type">int</span> i = std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">0</span>&gt;(t);           <span class="hljs-comment">// 获取第一个元素</span><br><span class="hljs-type">double</span> d = std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">1</span>&gt;(t);        <span class="hljs-comment">// 获取第二个元素</span><br>std::string s = std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">2</span>&gt;(t);   <span class="hljs-comment">// 获取第三个元素</span><br></code></pre></td></tr></table></figure><p><strong>获取 <code>tuple</code> 的大小：</strong></p><p>你可以使用 <code>std::tuple_size</code> 来获取 <code>tuple</code> 中元素的个数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::tuple&lt;<span class="hljs-type">int</span>, <span class="hljs-type">double</span>, std::string&gt; <span class="hljs-title">t</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">3.14</span>, <span class="hljs-string">&quot;Hello&quot;</span>)</span></span>;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;Tuple size: &quot;</span> &lt;&lt; std::tuple_size&lt;<span class="hljs-keyword">decltype</span>(t)&gt;::value &lt;&lt; std::endl;  <span class="hljs-comment">// 输出 3</span><br></code></pre></td></tr></table></figure><p><strong>解构 <code>tuple</code>：</strong></p><p>你可以使用 <code>std::tie</code> 来解构 <code>tuple</code> 中的值，或者直接通过 <code>std::get</code> 提取多个值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::tuple&lt;<span class="hljs-type">int</span>, <span class="hljs-type">double</span>, std::string&gt; <span class="hljs-title">t</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">3.14</span>, <span class="hljs-string">&quot;Hello&quot;</span>)</span></span>;<br><br><span class="hljs-comment">// 解构 tuple</span><br><span class="hljs-type">int</span> a;<br><span class="hljs-type">double</span> b;<br>std::string c;<br>std::<span class="hljs-built_in">tie</span>(a, b, c) = t;<br><br>std::cout &lt;&lt; <span class="hljs-string">&quot;a: &quot;</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot;, b: &quot;</span> &lt;&lt; b &lt;&lt; <span class="hljs-string">&quot;, c: &quot;</span> &lt;&lt; c &lt;&lt; std::endl;<br></code></pre></td></tr></table></figure><p><strong>scenario：</strong></p><ol><li><p><strong>函数返回多个值</strong>：使用 <code>tuple</code> 可以方便地在函数中返回多个不同类型的值，而无需创建自定义结构体。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::tuple&lt;<span class="hljs-type">int</span>, <span class="hljs-type">double</span>&gt; <span class="hljs-title">getValues</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">make_tuple</span>(<span class="hljs-number">10</span>, <span class="hljs-number">3.14</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> values = <span class="hljs-built_in">getValues</span>();<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;First value: &quot;</span> &lt;&lt; std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">0</span>&gt;(values) &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Second value: &quot;</span> &lt;&lt; std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">1</span>&gt;(values) &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>存储异构数据</strong>：当你需要存储异构数据（不同类型的元素）时，<code>tuple</code> 是一个非常方便的选择。例如，可以用它来存储一个人的年龄、名字和身高等不同类型的数据。</p></li><li><p><strong>元组解构和泛型编程</strong>：<code>std::tuple</code> 常用于模板编程中，特别是在处理多类型的返回值或元组解构时，能够提供强大的灵活性。</p></li></ol>          </div><h4 id="模版的实例化和具体化"><a href="#模版的实例化和具体化" class="headerlink" title="模版的实例化和具体化"></a>模版的实例化和具体化</h4><h5 id="隐式实例化"><a href="#隐式实例化" class="headerlink" title="隐式实例化"></a>隐式实例化</h5><p>函数模板的实例化通常由<strong>编译器自动完成</strong>， 编译器根据函数调用时的实际参数类型推断出模板参数的值，将模板参数的值代入函数模板，从而生成一个可执行的模板函数。类模板没这么幸运。编译器无法根据对象定义确定模板实际参数值。例如，定义 <code>Array</code> 类对象时给出的是代表数组下标范围的两个整数， 从中无法推断数组元素的类型，因而需要<strong>定义对象时明确指出模板实际参数的值</strong>。</p><p>以<code>std::vector</code>为例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">thetest</span><span class="hljs-params">(<span class="hljs-number">5</span>,<span class="hljs-number">3</span>)</span></span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> num:thetest)&#123;<br>        cout&lt;&lt;num&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*输出结果</span><br><span class="hljs-comment">3</span><br><span class="hljs-comment">3</span><br><span class="hljs-comment">3</span><br><span class="hljs-comment">3</span><br><span class="hljs-comment">3</span><br><span class="hljs-comment">*/</span><br><br></code></pre></td></tr></table></figure><p>在初始化一个<code>vector</code>对象的时候，我们需要<strong>给出类模板的实际参数表</strong>（即<code>class Type</code>）到底是什么，编译器才会<strong>隐式的根据我们的提示生成对应的示例类和对象</strong>。</p><p>如果使用<code>vector thetest(5,3);</code>的方式进行定义，会产生如下报错：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">testcode_1.cpp: In <span class="hljs-keyword">function</span> <span class="hljs-string">&#x27;int main()&#x27;</span>:<br>testcode_1.cpp:15:12: error: missing template arguments before <span class="hljs-string">&#x27;thetest&#x27;</span><br>     vector thetest(5,3);<br>            ^~~~~~~<br>testcode_1.cpp:16:18: error: <span class="hljs-string">&#x27;thetest&#x27;</span> was not declared <span class="hljs-keyword">in</span> this scope<br>     <span class="hljs-keyword">for</span>(auto num:thetest)&#123;<br>                  ^~~~~~~<br>testcode_1.cpp:16:18: note: suggested alternative: <span class="hljs-string">&#x27;_heapset&#x27;</span><br>     <span class="hljs-keyword">for</span>(auto num:thetest)&#123;<br>                  ^~~~~~~<br>                  _heapset<br></code></pre></td></tr></table></figure><h5 id="显示实例化"><a href="#显示实例化" class="headerlink" title="显示实例化"></a>显示实例化</h5><p>当使用关键词<code>template</code>并指出所需类型来声明类的时候，编译器会生成<strong>类声明的显式实例化</strong>。显式实例化通知编译器生成类模板的完整实例。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Array</span>&#123;<br>    <span class="hljs-comment">//模版类的声明</span><br>&#125;<br><br><br><span class="hljs-keyword">template</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Array</span>&lt;<span class="hljs-type">double</span>&gt;;<br><span class="hljs-comment">//显式实例化生成具体的类</span><br></code></pre></td></tr></table></figure><h5 id="显示具体化（Explicit-Specialization）"><a href="#显示具体化（Explicit-Specialization）" class="headerlink" title="显示具体化（Explicit Specialization）"></a>显示具体化（Explicit Specialization）</h5><p>显式具体化是指特定类型（用于<strong>替换模版中的泛型</strong>）的定义。这一种操作为泛型模版提供了更灵活的可操作性。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Generic version&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 显式特化：针对int类型</span><br><span class="hljs-keyword">template</span> &lt;&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>&lt;<span class="hljs-type">int</span>&gt; &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Specialized version for int&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    MyClass&lt;<span class="hljs-type">double</span>&gt; obj1; <span class="hljs-comment">// 调用通用版本</span><br>    obj<span class="hljs-number">1.</span><span class="hljs-built_in">print</span>();<br>    <br>    MyClass&lt;<span class="hljs-type">int</span>&gt; obj2; <span class="hljs-comment">// 调用针对int类型的特化版本</span><br>    obj<span class="hljs-number">2.</span><span class="hljs-built_in">print</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h5 id="部分具体化（Partial-Specialization）"><a href="#部分具体化（Partial-Specialization）" class="headerlink" title="部分具体化（Partial Specialization）"></a>部分具体化（Partial Specialization）</h5><p>部分特化是指对<strong>模板参数的某些部分进行特化</strong>，而不需要完全特化整个模板。它允许针对一些特定的类型组合或模板参数条件进行特定实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Generic version&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 部分特化：针对T是指针类型的情况</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>&lt;T*, <span class="hljs-type">int</span>&gt; &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Specialized version for pointer and int&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    MyClass&lt;<span class="hljs-type">double</span>, <span class="hljs-type">int</span>&gt; obj1; <span class="hljs-comment">// 调用通用版本</span><br>    obj<span class="hljs-number">1.</span><span class="hljs-built_in">print</span>();<br>    <br>    MyClass&lt;<span class="hljs-type">int</span>*, <span class="hljs-type">int</span>&gt; obj2; <span class="hljs-comment">// 调用部分特化版本</span><br>    obj<span class="hljs-number">2.</span><span class="hljs-built_in">print</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Bash">Generic version<br>Specialized version <span class="hljs-keyword">for</span> pointer and int<br></code></pre></td></tr></table></figure><h4 id="成员模版"><a href="#成员模版" class="headerlink" title="成员模版"></a>成员模版</h4><p>模板可用作<strong>结构、类或模板类的成员</strong>。要完全实现 STL 的设计，必须使用这项特性。  </p><p><strong>成员模板（Member Template）</strong>是 C++ 中的一种功能，允许<strong>在类中定义模板成员函数</strong>。这样，类的成员函数可以根据调用时的类型自动实例化，具备模板的灵活性。</p><p>成员模板的主要作用是实现根据不同类型提供不同实现的功能，而不需要为每种类型手动编写多个成员函数。成员模板与类模板的结合使用，可以让类对不同类型的对象和数据进行通用处理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 成员模板函数</span><br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> U&gt;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(U value)</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Value: &quot;</span> &lt;&lt; value &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    MyClass&lt;<span class="hljs-type">int</span>&gt; obj;<br>    obj.<span class="hljs-built_in">print</span>(<span class="hljs-number">42</span>);       <span class="hljs-comment">// 传入 int 类型</span><br>    obj.<span class="hljs-built_in">print</span>(<span class="hljs-number">3.14</span>);     <span class="hljs-comment">// 传入 double 类型</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>MyClass</code> 是一个类模板，接受一个类型 <code>T</code>。</li><li><code>print</code> 是一个成员模板函数，接受任意类型 <code>U</code> 的参数。</li><li>在 <code>main</code> 函数中，分别用 <code>int</code> 和 <code>double</code> 类型调用 <code>print</code>，成员模板会根据传入类型进行实例化。</li></ul><ol><li><strong>模板参数化成员函数</strong>：成员模板使得同一个成员函数可以根据调用的类型实例化不同的实现。</li><li><strong>灵活性</strong>：可以使类的成员函数适应多种不同的数据类型，而不需要手动为每种类型编写重载函数。</li><li><strong>与类模板配合使用</strong>：通常<strong>成员模板</strong>是与<strong>类模板</strong>配合使用的，使得类和其成员函数都可以泛化。</li></ol><blockquote><p>成员模版相当于对类中的成员函数使用<strong>函数模版</strong>。C++泛型的两种<strong>模板机制</strong>在此刻得到了统一。</p></blockquote><p>我们来看一个更加复杂的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// tempmemb.cpp -- template members</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> std::cout;<br><span class="hljs-keyword">using</span> std::endl;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">beta</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> V&gt;  <span class="hljs-comment">// nested template class member</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">hold</span><br>    &#123;<br>    <span class="hljs-keyword">private</span>:<br>        V val;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">hold</span>(V v  = <span class="hljs-number">0</span>) : <span class="hljs-built_in">val</span>(v) &#123;&#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; cout &lt;&lt; val &lt;&lt; endl; &#125;<br>        <span class="hljs-function">V <span class="hljs-title">Value</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> val; &#125;<br>    &#125;;<br>    hold&lt;T&gt; q;             <span class="hljs-comment">// template object</span><br>    hold&lt;<span class="hljs-type">int</span>&gt; n;           <span class="hljs-comment">// template object</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">beta</span>( T t, <span class="hljs-type">int</span> i) : <span class="hljs-built_in">q</span>(t), <span class="hljs-built_in">n</span>(i) &#123;&#125;<br>    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> U&gt;   <span class="hljs-comment">// template method</span><br>    <span class="hljs-function">U <span class="hljs-title">blab</span><span class="hljs-params">(U u, T t)</span> </span>&#123; <span class="hljs-keyword">return</span> (n.<span class="hljs-built_in">Value</span>() + q.<span class="hljs-built_in">Value</span>()) * u / t; &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Show</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; q.<span class="hljs-built_in">show</span>(); n.<span class="hljs-built_in">show</span>();&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">beta&lt;<span class="hljs-type">double</span>&gt; <span class="hljs-title">guy</span><span class="hljs-params">(<span class="hljs-number">3.5</span>, <span class="hljs-number">3</span>)</span></span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;T was set to double\n&quot;</span>;<br>    guy.<span class="hljs-built_in">Show</span>();<br>    cout &lt;&lt; <span class="hljs-string">&quot;V was set to T, which is double, then V was set to int\n&quot;</span>;<br>    cout &lt;&lt; guy.<span class="hljs-built_in">blab</span>(<span class="hljs-number">10</span>, <span class="hljs-number">2.3</span>) &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;U was set to int\n&quot;</span>;<br>    cout &lt;&lt; guy.<span class="hljs-built_in">blab</span>(<span class="hljs-number">10.0</span>, <span class="hljs-number">2.3</span>) &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;U was set to double\n&quot;</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Done\n&quot;</span>;<br>    <span class="hljs-comment">// std::cin.get();</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>&#125;<br><br></code></pre></td></tr></table></figure><p>输出示例</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Bash">T was <span class="hljs-built_in">set</span> to double<br>3.5<br>3<br>V was <span class="hljs-built_in">set</span> to T, <span class="hljs-built_in">which</span> is double, <span class="hljs-keyword">then</span> V was <span class="hljs-built_in">set</span> to int<br>28<br>U was <span class="hljs-built_in">set</span> to int<br>28.2609<br>U was <span class="hljs-built_in">set</span> to double<br>Done<br></code></pre></td></tr></table></figure><p>模板类<code>hold</code>是<code>beta</code>类的私有成员，在此处一共定义了三个<strong>模版参数</strong>T，V和U，在main函数中，语句<code> beta&lt;double&gt; guy(3.5, 3);</code>将T设置为<code>double</code>类型，因此在guy（是一个beta类）中有两个数据成员：<code>hold&lt;double&gt;</code>和<code>hold&lt;int&gt;</code>。（在这里模版参数V先后被<strong>隐式实例化</strong>为<code>int</code>和<code>double</code>）接下来执行语句<code>guy.blab(10, 2.3)</code>，模版参数U被<strong>隐式实例化</strong>为<code>int</code>（<code>guy.blab(10, 2.3)</code>时也类似）。</p><h4 id="将模板用作参数"><a href="#将模板用作参数" class="headerlink" title="将模板用作参数"></a>将模板用作参数</h4><p>将模板用作参数（Template as a Parameter）是 C++ 中的一种技术，允许将模板本身作为函数、类或其他模板的参数。这种技术通常被称为 <strong>模板模板参数</strong>。它使得可以灵活地将一个模板传递给另一个模板，从而实现高度的泛化和定制化。</p><p>当你将模板用作参数时，你可以传递<strong>一个模板的类型</strong>，而不是实际的类型。这对于处理模板类或函数更加灵活，允许<strong>模板参数不仅是类型，还可以是其他模板类型</strong>。</p><blockquote><p>有一点套娃的感觉</p></blockquote><p><strong>示例 1：将模板作为函数参数</strong></p><p>下面的例子展示了如何将一个模板类作为另一个模板函数的参数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 模板类</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    T value;<br>    <span class="hljs-built_in">MyClass</span>(T v) : <span class="hljs-built_in">value</span>(v) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Value: &quot;</span> &lt;&lt; value &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 一个函数模板，接受模板类作为参数</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br>    <span class="hljs-comment">//这里模版参数T代表一个模版类(在后续main函数中，T被隐式实例化为MyClass这个模板类)</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">callTemplateClass</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">T&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">obj</span><span class="hljs-params">(<span class="hljs-number">42</span>)</span></span>;  <span class="hljs-comment">// 使用模板类 MyClass&lt;int&gt;</span><br>    obj.<span class="hljs-built_in">print</span>();     <span class="hljs-comment">// 输出 &quot;Value: 42&quot;</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">callTemplateClass</span>&lt;MyClass&gt;();  <span class="hljs-comment">// 调用时传递 MyClass 作为模板</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">Value: 42<br></code></pre></td></tr></table></figure><ul><li><code>MyClass</code> 是一个模板类，接受一个类型 <code>T</code>。</li><li><code>callTemplateClass</code> 是一个<strong>模板函数，接受一个模板类作为参数</strong>。<code>template &lt;template &lt;typename&gt; class T&gt;</code> 表示 <code>T</code> 是一个<strong>模板模板参数</strong>。</li><li>在 <code>main</code> 函数中，我们调用 <code>callTemplateClass&lt;MyClass&gt;()</code>，将 <code>MyClass</code> 作为模板传递给 <code>callTemplateClass</code> 函数。</li></ul><blockquote><p>这种规则本质上增添了<strong>模版参数的多样性和灵活性</strong>。</p></blockquote><p><strong>示例 2：将模板作为类参数</strong></p><p>模板也可以作为类的成员，允许类在定义时接受模板作为参数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 定义一个模板类</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    T value;<br>    <span class="hljs-built_in">MyClass</span>(T v) : <span class="hljs-built_in">value</span>(v) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Value: &quot;</span> &lt;&lt; value &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 定义一个类模板，接受模板作为参数</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Wrapper</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    T&lt;<span class="hljs-type">int</span>&gt; obj;  <span class="hljs-comment">// 用 T&lt;int&gt; 来实例化模板类</span><br>    <span class="hljs-built_in">Wrapper</span>(<span class="hljs-type">int</span> v) : <span class="hljs-built_in">obj</span>(v) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;<br>        obj.<span class="hljs-built_in">print</span>();<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">Wrapper&lt;MyClass&gt; <span class="hljs-title">w</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;  <span class="hljs-comment">// 传递 MyClass 作为模板</span><br>    w.<span class="hljs-built_in">print</span>();  <span class="hljs-comment">// 输出 &quot;Value: 10&quot;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>Wrapper</code> 是一个模板类，接受一个模板类作为参数（<code>template &lt;template &lt;typename&gt; class T&gt;</code>）。</li><li><code>Wrapper</code> 类使用 <code>T&lt;int&gt;</code> 来实例化模板类，并通过 <code>obj.print()</code> 来调用它的成员函数。</li><li>在 <code>main</code> 函数中，我们创建了 <code>Wrapper&lt;MyClass&gt;</code> 对象，将 <code>MyClass</code> 作为模板传递给 <code>Wrapper</code>。</li></ul><p><strong>使用模板作为参数的优点</strong></p><ol><li><strong>高度灵活性</strong>：允许传递不同的模板类或函数，增强代码的复用性。</li><li><strong>避免代码重复</strong>：通过接受模板模板参数，可以减少对同类逻辑的多次实现，只需一个模板就能处理不同的类型或类。</li><li><strong>泛化</strong>：通过使用模板模板参数，可以让代码对更多的类型和模板更加通用。</li></ol><h2 id="Friend-Functions-and-Friend-Class"><a href="#Friend-Functions-and-Friend-Class" class="headerlink" title="Friend Functions and Friend Class"></a>Friend Functions and Friend Class</h2><h3 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h3><p>友元函数（<strong>Friend Function</strong>）是 C++ 中的一种机制，允许一个函数（或类）访问另一个类的私有成员和保护成员。虽然友元函数可以访问类的私有和保护成员，但它本身并不是类的成员函数。友元函数通常用于操作一些类内部的细节，但它可能会引入一些需要注意的问题。</p><ul><li>让函数成为类的友元，可以赋予该函数与类的成员函数相同的访问权限（<strong>访问private</strong>）</li><li>例：将运算符重载编写成一个非成员函数</li><li>友元函数具有成员函数的权限，但<strong>作为非成员函数不能使用成员运算符进行调用</strong><ul><li>使用成员函数，可以使用构造函数，这更加高效</li></ul></li><li><strong>只有在函数声明的时候需要加上friend关键词，在函数定义时不可以</strong></li></ul><h4 id="友元函数和在成员函数中运算符重载的区别"><a href="#友元函数和在成员函数中运算符重载的区别" class="headerlink" title="友元函数和在成员函数中运算符重载的区别"></a>友元函数和在成员函数中运算符重载的区别</h4><p>在成员函数中实现运算符重载</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Complex</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    Complex <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Complex&amp; other) <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Complex</span>(real + other.real, imag + other.imag);<br>    &#125;<br>    <span class="hljs-comment">//成员函数重载运算符中，所需的参数数目比运算符使用的参数数目少一个，其中一个是被隐式传递的调用对象(this 指针)</span><br>    <span class="hljs-comment">// 其它成员函数和数据成员</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">double</span> real;<br>    <span class="hljs-type">double</span> imag;<br>&#125;;<br><br></code></pre></td></tr></table></figure><p>在非成员函数中实现运算符重载（友元函数）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Complex</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">double</span> real;<br>    <span class="hljs-type">double</span> imag;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Complex</span>(<span class="hljs-type">double</span> r = <span class="hljs-number">0.0</span>, <span class="hljs-type">double</span> i = <span class="hljs-number">0.0</span>) : <span class="hljs-built_in">real</span>(r), <span class="hljs-built_in">imag</span>(i) &#123;&#125;<br><br>    <span class="hljs-comment">// 声明友元函数</span><br>    <span class="hljs-keyword">friend</span> Complex <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Complex&amp; left, <span class="hljs-type">const</span> Complex&amp; right);<br>&#125;;<br><br></code></pre></td></tr></table></figure><h4 id="友元函数相比于成员函数的优势"><a href="#友元函数相比于成员函数的优势" class="headerlink" title="友元函数相比于成员函数的优势"></a>友元函数相比于成员函数的优势</h4><p>友元函数相对于成员函数具有一些特定的优势，尽管它们打破了类的封装原则，但这些优势在某些情境下是非常有用的：</p><ol><li><strong>操作符重载</strong></li></ol><p>友元函数常用于操作符重载，特别是当操作符需要访问两个不同类或类型的对象时。成员函数只能通过 <code>this</code> 指针访问当前对象的成员，而友元函数可以直接访问两个对象的私有成员。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Complex</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">double</span> real;<br>    <span class="hljs-type">double</span> imag;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// ... 其他成员函数 ...</span><br>    <span class="hljs-keyword">friend</span> Complex <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Complex&amp; a, <span class="hljs-type">const</span> Complex&amp; b);<br>&#125;;<br><br><span class="hljs-comment">// 友元函数定义</span><br>Complex <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Complex&amp; a, <span class="hljs-type">const</span> Complex&amp; b) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Complex</span>(a.real + b.real, a.imag + b.imag);<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li><strong>提高代码的可读性和简洁性</strong></li></ol><ul><li><strong>全局函数</strong>：友元函数可以作为全局函数，这在某些情况下可以使代码更易于理解和维护。例如，上面的 <code>operator+</code> 作为友元函数，使得加法操作看起来更自然，不需要通过对象调用。</li><li><strong>避免不必要的成员函数</strong>：有时，某些操作并不适合作为类的一部分，但仍然需要访问类的私有成员。友元函数可以提供这种访问，而不需要增加类的成员函数。</li></ul><ol start="3"><li><strong>对称性</strong></li></ol><ul><li>友元函数可以提供操作的对称性。例如，在 <code>operator==</code> 的情况下，如果是成员函数，<code>a == b</code> 和 <code>b == a</code> 可能需要不同的实现，而友元函数可以使这两个操作等价。</li></ul><ol start="4"><li><strong>减少this指针的使用</strong></li></ol><ul><li>友元函数没有隐式的 <code>this</code> 指针，这在某些情况下可以提高效率，因为不需要额外的参数传递。</li></ul><ol start="5"><li><strong>访问私有成员而不改变类的接口</strong></li></ol><ul><li>如果你需要一个函数访问类的数据，但不想将这个函数作为类的成员（因为它不属于类的逻辑部分），友元函数可以让你实现这一点，而不改变类的公共接口。</li></ul><ol start="6"><li><strong>跨类访问</strong></li></ol><ul><li>友元函数可以被多个类声明为友元，从而允许<strong>这些类之间共享数据，而不需要通过公共接口或继承</strong>。</li></ul><ol start="7"><li><strong>设计模式的实现</strong></li></ol><ul><li>在一些设计模式中，如桥接模式、适配器模式等，友元函数可以帮助实现跨类协作，而无需暴露类的内部实现细节。</li></ul><p><strong>注意事项</strong>：</p><p>尽管友元函数有这些优势，但它们也有一些潜在的缺点：</p><ul><li><strong>打破封装</strong>：友元函数允许非成员函数访问类的私有成员，可能会破坏类的封装性。</li><li><strong>代码维护</strong>：友元关系可能会使代码的维护变得复杂，因为它增加了类的依赖性。</li><li><strong>滥用</strong>：如果不谨慎使用，友元函数可能会导致代码的可读性和结构性下降。</li></ul><p>因此，在使用友元函数时，应该谨慎考虑是否真的需要这种访问权限，并尽量限制友元函数的数量和范围，以保持类的封装性和代码的清晰度。</p><h3 id="友元类"><a href="#友元类" class="headerlink" title="友元类"></a>友元类</h3><p>在 C++ 中，<code>friend</code> 是一种特殊的机制，它允许某些函数或类访问其他类的私有成员。<code>friend</code> 主要有两种形式：<strong>友元函数</strong> 和 <strong>友元类</strong>。这两种机制在设计某些复杂系统时非常有用，可以让不同类之间进行密切的合作，同时保持类内部的封装性。</p><p><strong>友元类</strong> 是一个类，它被声明为某个类的友元类。友元类的成员函数可以访问该类的私有成员。这种机制通常用于设计两个紧密相关的类，它们需要互相访问私有数据，但又不希望暴露给外部。</p><p><strong>友元类的基本语法</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setA</span><span class="hljs-params">(A&amp; obj)</span></span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> x;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> val) : <span class="hljs-built_in">x</span>(val) &#123;&#125;<br><br>    <span class="hljs-comment">// 声明 B 为友元类</span><br>    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>;<br>&#125;;<br><br><span class="hljs-comment">// B 是 A 的友元类，可以访问 A 的私有成员</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">B::setA</span><span class="hljs-params">(A&amp; obj)</span> </span>&#123;<br>    obj.x = <span class="hljs-number">100</span>;  <span class="hljs-comment">// 直接访问 A 的私有成员</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">A <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br>    B b;<br>    b.<span class="hljs-built_in">setA</span>(a);  <span class="hljs-comment">// B 可以访问 A 的私有成员</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>友元类的应用场景</strong></p><ul><li><strong>设计复杂系统</strong>：友元类的使用可以让两个类之间共享数据和功能，而不暴露这些数据给其他类。例如，在某些库中，可能有一个类负责管理资源（如内存管理），另一个类负责使用这些资源。为了实现高效和紧密的合作，这两个类可能需要互相访问对方的私有成员，这时可以将其中一个类声明为友元类。</li><li><strong>实现成员共享</strong>：友元类通常用于需要相互访问成员数据的类，特别是在某些算法和数据结构的实现中，如链表、树、图等。</li></ul><p><strong>友元类的设计示例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Engine</span>;  <span class="hljs-comment">// 前向声明</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    Engine* engine;  <span class="hljs-comment">// Engine 对象是 Car 的私有成员</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Car</span>() : <span class="hljs-built_in">engine</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br><br>    <span class="hljs-comment">// 声明 Engine 为友元类</span><br>    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Engine</span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Engine</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> horsepower;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Engine</span>(<span class="hljs-type">int</span> hp) : <span class="hljs-built_in">horsepower</span>(hp) &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setCarEngine</span><span class="hljs-params">(Car&amp; car)</span> </span>&#123;<br>        car.engine = <span class="hljs-keyword">this</span>;  <span class="hljs-comment">// Engine 可以访问 Car 的私有成员</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showCarEngineInfo</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Car engine horsepower: &quot;</span> &lt;&lt; horsepower &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>Engine</code> 类被声明为 <code>Car</code> 类的友元类，使得 <code>Engine</code> 类能够访问 <code>Car</code> 类的私有成员。</p><h4 id="友元类与继承"><a href="#友元类与继承" class="headerlink" title="友元类与继承"></a><strong>友元类与继承</strong></h4><p>友元类与继承之间有一些特别的关系。虽然子类继承了父类的公共和保护成员，但<strong>友元关系不被继承</strong>。也就是说，如果<strong>某个类是另一个类的友元类，它并不能自动成为其子类的友元类</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> value;<br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> val) : <span class="hljs-built_in">value</span>(val) &#123;&#125;<br>    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>;  <span class="hljs-comment">// B 是 A 的友元类</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> : <span class="hljs-keyword">public</span> A &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">C</span>(<span class="hljs-type">int</span> val) : <span class="hljs-built_in">A</span>(val) &#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showValue</span><span class="hljs-params">(A&amp; obj)</span> </span>&#123;<br>        std::cout &lt;&lt; obj.value &lt;&lt; std::endl;  <span class="hljs-comment">// B 可以访问 A 的私有成员</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">A <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br>    B b;<br>    b.<span class="hljs-built_in">showValue</span>(a);  <span class="hljs-comment">// 正常，B 可以访问 A 的私有成员</span><br><br>    <span class="hljs-function">C <span class="hljs-title">c</span><span class="hljs-params">(<span class="hljs-number">20</span>)</span></span>;<br>    <span class="hljs-comment">// b.showValue(c);  // 错误，C 没有继承 B 对 A 的友元关系</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的例子中，<code>B</code> 是 <code>A</code> 的友元类，但 <code>C</code> 并没有继承 <code>B</code> 对 <code>A</code> 的友元关系，因此 <code>B</code> 无法访问 <code>C</code> 的私有成员。</p><h4 id="友元与封装"><a href="#友元与封装" class="headerlink" title="友元与封装"></a><strong>友元与封装</strong></h4><p>尽管 <code>friend</code> 允许类外部的函数和类访问私有成员，但它仍然保持了一定的封装性。在设计时，应注意不要过度使用友元关系，因为过多的友元可能会破坏类的封装性，增加类之间的耦合度，导致维护困难。</p><ul><li><strong>适度使用友元</strong>：只有在确实需要类之间紧密合作时，才应考虑使用友元关系。尤其是当某些函数需要访问类的内部细节时，友元函数和友元类可以提供非常强大的功能。</li><li><strong>减少友元的使用</strong>：不推荐随意将大量的类或函数声明为友元，尽量保持类的封装性，使其更具独立性和可维护性。</li></ul><h3 id="更加复杂的友元关系"><a href="#更加复杂的友元关系" class="headerlink" title="更加复杂的友元关系"></a>更加复杂的友元关系</h3><p>在上文我们介绍了两种友元的使用：<strong>友元类和友元函数</strong>。友元函数具有作为外部函数访问类内私有数据成员的特权，而友元类具有<strong>更多的特权</strong>。可以实现<strong>类之间的数据共享</strong>。但是，<strong>类友元的实现</strong>在一定程度上也抹杀了类之间数据的安全性，不符合OOP中<strong>封装</strong>的基本理念。因此，我们可以不将整个类设置为友元，而是只将<strong>另一个类的成员函数设置为友元，限制这种特权的使用</strong>，保证安全性。</p><p>我们来看下面的示例，下文代码给出了电视机和遥控器的类实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// tvfm.h -- Tv and Remote classes using a friend member</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> TVFM_H_</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TVFM_H_</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Tv</span>;                       <span class="hljs-comment">// forward declaration</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Remote</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">enum</span> <span class="hljs-title class_">State</span>&#123;Off, On&#125;;<br>    <span class="hljs-keyword">enum</span> &#123;MinVal,MaxVal = <span class="hljs-number">20</span>&#125;;<br>    <span class="hljs-keyword">enum</span> &#123;Antenna, Cable&#125;;<br>    <span class="hljs-keyword">enum</span> &#123;TV, DVD&#125;;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> mode;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Remote</span>(<span class="hljs-type">int</span> m = TV) : <span class="hljs-built_in">mode</span>(m) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">volup</span><span class="hljs-params">(Tv &amp; t)</span></span>;         <span class="hljs-comment">// prototype only</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">voldown</span><span class="hljs-params">(Tv &amp; t)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">onoff</span><span class="hljs-params">(Tv &amp; t)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">chanup</span><span class="hljs-params">(Tv &amp; t)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">chandown</span><span class="hljs-params">(Tv &amp; t)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set_mode</span><span class="hljs-params">(Tv &amp; t)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set_input</span><span class="hljs-params">(Tv &amp; t)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set_chan</span><span class="hljs-params">(Tv &amp; t, <span class="hljs-type">int</span> c)</span></span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Tv</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">Remote::set_chan</span><span class="hljs-params">(Tv &amp; t, <span class="hljs-type">int</span> c)</span></span>;<br>    <span class="hljs-keyword">enum</span> <span class="hljs-title class_">State</span>&#123;Off, On&#125;;<br>    <span class="hljs-keyword">enum</span> &#123;MinVal,MaxVal = <span class="hljs-number">20</span>&#125;;<br>    <span class="hljs-keyword">enum</span> &#123;Antenna, Cable&#125;;<br>    <span class="hljs-keyword">enum</span> &#123;TV, DVD&#125;;<br><br>    <span class="hljs-built_in">Tv</span>(<span class="hljs-type">int</span> s = Off, <span class="hljs-type">int</span> mc = <span class="hljs-number">125</span>) : <span class="hljs-built_in">state</span>(s), <span class="hljs-built_in">volume</span>(<span class="hljs-number">5</span>),<br>        <span class="hljs-built_in">maxchannel</span>(mc), <span class="hljs-built_in">channel</span>(<span class="hljs-number">2</span>), <span class="hljs-built_in">mode</span>(Cable), <span class="hljs-built_in">input</span>(TV) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">onoff</span><span class="hljs-params">()</span> </span>&#123;state = (state == On)? Off : On;&#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ison</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<span class="hljs-keyword">return</span> state == On;&#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">volup</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">voldown</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">chanup</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">chandown</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set_mode</span><span class="hljs-params">()</span> </span>&#123;mode = (mode == Antenna)? Cable : Antenna;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set_input</span><span class="hljs-params">()</span> </span>&#123;input = (input == TV)? DVD : TV;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">settings</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> state;<br>    <span class="hljs-type">int</span> volume;<br>    <span class="hljs-type">int</span> maxchannel;<br>    <span class="hljs-type">int</span> channel;<br>    <span class="hljs-type">int</span> mode;<br>    <span class="hljs-type">int</span> input;<br>&#125;;<br><br><span class="hljs-comment">// Remote methods as inline functions</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">Remote::volup</span><span class="hljs-params">(Tv &amp; t)</span> </span>&#123; <span class="hljs-keyword">return</span> t.<span class="hljs-built_in">volup</span>();&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">Remote::voldown</span><span class="hljs-params">(Tv &amp; t)</span> </span>&#123; <span class="hljs-keyword">return</span> t.<span class="hljs-built_in">voldown</span>();&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">Remote::onoff</span><span class="hljs-params">(Tv &amp; t)</span> </span>&#123; t.<span class="hljs-built_in">onoff</span>(); &#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">Remote::chanup</span><span class="hljs-params">(Tv &amp; t)</span> </span>&#123;t.<span class="hljs-built_in">chanup</span>();&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">Remote::chandown</span><span class="hljs-params">(Tv &amp; t)</span> </span>&#123;t.<span class="hljs-built_in">chandown</span>();&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">Remote::set_mode</span><span class="hljs-params">(Tv &amp; t)</span> </span>&#123;t.<span class="hljs-built_in">set_mode</span>();&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">Remote::set_input</span><span class="hljs-params">(Tv &amp; t)</span> </span>&#123;t.<span class="hljs-built_in">set_input</span>();&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">Remote::set_chan</span><span class="hljs-params">(Tv &amp; t, <span class="hljs-type">int</span> c)</span> </span>&#123;t.channel = c;&#125; <br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br></code></pre></td></tr></table></figure><p>遥控器可以访问电视机的信息，因此我们自然想到可以把遥控器类设置为电视机类的友元类，但是这样的操作使安全性降低（毕竟电视机还有很多遥控器完成不了的操作），我们可以优化，将<code>Remote::set_chan</code>作为Tv类的友元函数，使其作为<strong>唯一需要友元的方法实现</strong>。</p><p>基于这个想法，我们需要对友元的定义和声明做一些修改。首先，就像函数声明一样，我们需要<code>class Tv</code>语句来实现<strong>前置声明（forward declaration）</strong>。同时，在<code>Remote</code>类的函数定义中包含<code>Tv</code>类的参数列表，因此<strong>需要将Tv类的声明提前到Remote类的函数定义之前。</strong></p><p>内联函数的链接性是内部的，这意味着<strong>函数定义必须在使用函数的文件</strong>中。在这个例子中，内联定义位于头文件中，因此在使用函数的文件中包含头文件可确保将定义放在正确的地方。也可以将定义放在实现文件中，但必须删除关键字 <code>inline</code>，这样函数的链接性将是外部的  </p><blockquote><p>总之就一个原则，<strong>在使用对应的类的时候编译器应该已经看到对应的内容！</strong></p></blockquote><h4 id="互为友元"><a href="#互为友元" class="headerlink" title="互为友元"></a>互为友元</h4><p>除本章前面讨论的，还有其他友元和类的组合形式，下面简要地介绍其中的一些。</p><p>假设由于技术进步，出现了交互式遥控器。例如，交互式遥控器让您能够回答电视节目中的问题，如果回答错误，电视将在控制器上产生嗡嗡声。忽略电视使用这种设施安排观众进入节目的可能性，我们只看 C++的编程方面。新的方案将受益于相互的友情，一些 Remote 方法能够像前面那样影响 Tv 对象，而一些 Tv 方法也能影响 Remote 对象。这可以通过让<strong>类彼此成为对方的友元</strong>来实现，即除了 Remote 是 Tv 的友元外， Tv还是 Remote 的友元。需要记住的一点是，对于使用 Remote 对象的 Tv 方法，其原型可在 Remote 类声明之前声明，但必须在 Remote 类声明之后定义，以便编译器有足够的信息来编译该方法。</p><p><img src="/posts/Above-All/-in-OOP/friend.png" alt="互为友元"></p><h4 id="共同的友元"><a href="#共同的友元" class="headerlink" title="共同的友元"></a>共同的友元</h4><p>需要使用友元的另一种情况是，<strong>函数需要访问两个类的私有数据</strong>。从逻辑上看，这样的函数应是每个类的成员函数，但这是不可能的。它可以是一个类的成员，同时是另一个类的友元，但有时<strong>将函数作为两个类的友元更合理</strong>。例如，假定有一个 Probe 类和一个 Analyzer 类，前者表示某种可编程的测量设备，后者表示某种可编程的分析设备。  </p><p><img src="/posts/Above-All/-in-OOP/frineds.png" alt="共同的友元"></p><h3 id="模板类和友元"><a href="#模板类和友元" class="headerlink" title="模板类和友元"></a>模板类和友元</h3><p>模板类声明也可以有友元。模板的友元分 3 类：</p><ul><li><strong>非模板友元</strong>；</li><li><strong>约束（bound）模板友元</strong>，即友元的类型取决于类被<strong>实例化</strong>时的类型；</li><li><strong>非约束（unbound）模板友元</strong>，即友元的所有具体化都是类的每一个具体化的友元。</li></ul><h5 id="非模版友元"><a href="#非模版友元" class="headerlink" title="非模版友元"></a>非模版友元</h5><p>在 C++ 中，<strong>模板类的非模板友元函数</strong>是指一个<strong>非模板函数</strong>被声明为一个模板类的友元。这样，非模板友元函数可以访问模板类的私有和保护成员。与普通的友元函数类似，非模板友元函数允许特定的函数访问类的内部实现，但在模板类中，它们<strong>并不依赖于模板参数</strong>。</p><p>假设我们有一个模板类 <code>MyClass</code>，其中包含一个私有成员 <code>value</code>，并希望定义一个非模板函数来访问它。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    T value;<br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyClass</span>(T v) : <span class="hljs-built_in">value</span>(v) &#123;&#125;<br><br>    <span class="hljs-comment">// 声明一个非模板友元函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">printValue</span><span class="hljs-params">(<span class="hljs-type">const</span> MyClass&lt;<span class="hljs-type">int</span>&gt;&amp; obj)</span></span>;  <span class="hljs-comment">// 只对 MyClass&lt;int&gt; 类型的对象有效</span><br>&#125;;<br><br><span class="hljs-comment">// 非模板友元函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printValue</span><span class="hljs-params">(<span class="hljs-type">const</span> MyClass&lt;<span class="hljs-type">int</span>&gt;&amp; obj)</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Value: &quot;</span> &lt;&lt; obj.value &lt;&lt; endl;  <span class="hljs-comment">// 可以访问 MyClass&lt;int&gt; 的私有成员</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">MyClass&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">obj</span><span class="hljs-params">(<span class="hljs-number">42</span>)</span></span>;  <span class="hljs-comment">// 创建一个 MyClass&lt;int&gt; 类型的对象</span><br>    <span class="hljs-built_in">printValue</span>(obj);       <span class="hljs-comment">// 调用非模板友元函数，打印值</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li><code>MyClass</code> 是一个模板类，接受类型 <code>T</code> 作为模板参数，并包含一个私有成员 <code>value</code>。</li><li><code>printValue</code> 是一个非模板函数，它被声明为 <code>MyClass&lt;int&gt;</code> 的友元函数。由于 <code>printValue</code> 只与 <code>MyClass&lt;int&gt;</code> 相关，因此它的参数类型为 <code>MyClass&lt;int&gt;</code>，而不是模板类型 <code>T</code>。</li><li>在 <code>main</code> 函数中，我们创建了一个 <code>MyClass&lt;int&gt;</code> 类型的对象，并通过 <code>printValue</code> 访问其私有成员。</li></ol><p><strong>注意点</strong></p><ul><li><strong>非模板友元函数的类型限定</strong>：非模板友元函数只能访问<strong>特定模板实例化的类的成员</strong>。在上述例子中，<code>printValue</code> 只能作为 <code>MyClass&lt;int&gt;</code> 的友元函数，而无法访问其他类型实例化的 <code>MyClass</code> 对象（例如 <code>MyClass&lt;double&gt;</code>）。</li><li><strong>模板类和非模板友元函数的结合</strong>：非模板友元函数与模板类的结合需要对特定类型的模板实例进行访问，因此它通常不如模板友元函数灵活。但它在某些场景中非常有用，例如当<strong>你只希望特定类型的模板类暴露内部实现时</strong>。</li></ul><blockquote><p>一般来说，非模版友元函数和普通的友元函数没有区别（针对<strong>特定实例化后的友元函数</strong>），这样做一定程度上牺牲了泛型编程的<strong>通用性</strong>，但可以对特定类型做<strong>更精细的操作</strong>。</p></blockquote><h5 id="约束友元"><a href="#约束友元" class="headerlink" title="约束友元"></a>约束友元</h5><p>为约束模板友元作准备，要使<strong>类的每一个具体化都获得与友元匹配的具体化</strong>。这比非模板友元复杂些。包含以下三步：</p><ul><li>在类定义的前面声明每个模板函数  <ul><li><code>template &lt;typename T&gt; void counts();</code></li><li><code>template &lt;typename T&gt; void report(T &amp;);</code></li></ul></li><li>在函数中再次将模板声明为友元。这些语句根据类模板参数的类型声明具体化  <ul><li><code>template &lt;typename TT&gt;</code>（类模版的模版参数声明）</li><li><code> friend void counts&lt;TT&gt;();</code></li><li>声明中的<code>&lt;&gt;</code>指出这是模板具体化。对于<code>report()</code>， <code>&lt;&gt;</code>可以为空，因为可以从函数参数推断出。</li></ul></li><li>为友元提供模板定义 <ul><li><code>template &lt;typename T&gt;   void counts()</code></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// tmp2tmp.cpp -- template friends to a template class</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> std::cout;<br><span class="hljs-keyword">using</span> std::endl;<br><br><span class="hljs-comment">// template prototypes</span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">report</span><span class="hljs-params">(T &amp;)</span></span>;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">counts</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-comment">// template class</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> TT&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HasFriendT</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>    TT item;<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> ct;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">HasFriendT</span>(<span class="hljs-type">const</span> TT &amp; i) : <span class="hljs-built_in">item</span>(i) &#123;ct++;&#125;<br>    ~<span class="hljs-built_in">HasFriendT</span>() &#123; ct--; &#125;<br>    <span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-built_in">counts</span>&lt;TT&gt;();<br>    <span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> report&lt;&gt;(HasFriendT&lt;TT&gt; &amp;);<br>&#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-type">int</span> HasFriendT&lt;T&gt;::ct = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// template friend functions definitions</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">counts</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;template size: &quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(HasFriendT&lt;T&gt;) &lt;&lt; <span class="hljs-string">&quot;; &quot;</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;template counts(): &quot;</span> &lt;&lt; HasFriendT&lt;T&gt;::ct &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">report</span><span class="hljs-params">(T &amp; hf)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; hf.item &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">counts</span>&lt;<span class="hljs-type">int</span>&gt;();<br>    <span class="hljs-function">HasFriendT&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">hfi1</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br>    <span class="hljs-function">HasFriendT&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">hfi2</span><span class="hljs-params">(<span class="hljs-number">20</span>)</span></span>;<br>    <span class="hljs-function">HasFriendT&lt;<span class="hljs-type">double</span>&gt; <span class="hljs-title">hfdb</span><span class="hljs-params">(<span class="hljs-number">10.5</span>)</span></span>;<br>    <span class="hljs-built_in">report</span>(hfi1);  <span class="hljs-comment">// generate report(HasFriendT&lt;int&gt; &amp;)</span><br>    <span class="hljs-built_in">report</span>(hfi2);  <span class="hljs-comment">// generate report(HasFriendT&lt;int&gt; &amp;)</span><br>    <span class="hljs-built_in">report</span>(hfdb);  <span class="hljs-comment">// generate report(HasFriendT&lt;double&gt; &amp;)</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;counts&lt;int&gt;() output:\n&quot;</span>;<br>    <span class="hljs-built_in">counts</span>&lt;<span class="hljs-type">int</span>&gt;();<br>    cout &lt;&lt; <span class="hljs-string">&quot;counts&lt;double&gt;() output:\n&quot;</span>;<br>    <span class="hljs-built_in">counts</span>&lt;<span class="hljs-type">double</span>&gt;();<br>    <span class="hljs-comment">// std::cin.get();</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-number">10</span><br><span class="hljs-number">20</span><br><span class="hljs-number">10.5</span><br>counts&lt;int&gt;() output:<br>template size: <span class="hljs-number">4</span>; template counts(): <span class="hljs-number">2</span><br>counts&lt;double&gt;() output:<br>template size: <span class="hljs-number">8</span>; template counts(): <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h5 id="非约束友元"><a href="#非约束友元" class="headerlink" title="非约束友元"></a>非约束友元</h5><p>前一节中的约束模板友元函数是在<strong>类外面声明的模板的具体化</strong>。 int 类具体化获得 int 函数具体化，依此类推。通过在类内部声明模板，可以<strong>创建非约束友元函数</strong>，即每个函数具体化都是每个类具体化的友元。对于非约束友元，友元模板类型参数与模板类类型参数是不同的。</p><p><strong>非约束友元</strong>指的是模板类的友元函数或类没有任何类型约束，它们可以接受任何类型的模板实例化，并且不对模板参数施加限制。</p><p>特点：</p><ul><li>友元函数可以访问模板类的私有成员。</li><li>友元函数没有模板参数的约束，因此可以接受任何类型的模板实例化。</li><li>没有额外的限制条件，适用性广泛。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// manyfrnd.cpp -- unbound template friend to a template class</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> std::cout;<br><span class="hljs-keyword">using</span> std::endl;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ManyFriend</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>    T item;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">ManyFriend</span>(<span class="hljs-type">const</span> T &amp; i) : <span class="hljs-built_in">item</span>(i) &#123;&#125;<br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> C, <span class="hljs-keyword">typename</span> D&gt; <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">show2</span><span class="hljs-params">(C &amp;, D &amp;)</span></span>;<br>&#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> C, <span class="hljs-keyword">typename</span> D&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show2</span><span class="hljs-params">(C &amp; c, D &amp; d)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; c.item &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; d.item &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">ManyFriend&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">hfi1</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br>    <span class="hljs-function">ManyFriend&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">hfi2</span><span class="hljs-params">(<span class="hljs-number">20</span>)</span></span>;<br>    <span class="hljs-function">ManyFriend&lt;<span class="hljs-type">double</span>&gt; <span class="hljs-title">hfdb</span><span class="hljs-params">(<span class="hljs-number">10.5</span>)</span></span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;hfi1, hfi2: &quot;</span>;<br>    <span class="hljs-built_in">show2</span>(hfi1, hfi2);<br>    cout &lt;&lt; <span class="hljs-string">&quot;hfdb, hfi2: &quot;</span>;<br>    <span class="hljs-built_in">show2</span>(hfdb, hfi2);<br>    <span class="hljs-comment">// std::cin.get();</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell">hfi1, hfi2: <span class="hljs-number">10</span>, <span class="hljs-number">20</span><br>hfdb, hfi2: <span class="hljs-number">10.5</span>, <span class="hljs-number">20</span><br></code></pre></td></tr></table></figure><p><strong>非约束友元 vs 约束友元</strong></p><table><thead><tr><th>特性</th><th>非约束友元</th><th>约束友元</th></tr></thead><tbody><tr><td><strong>定义</strong></td><td>不对模板参数进行类型约束</td><td>对<strong>模板参数进行类型约束</strong>（如通过概念、<code>enable_if</code>）</td></tr><tr><td><strong>适用性</strong></td><td>可以接受任何类型的模板实例</td><td>只能接受符合约束条件的模板实例</td></tr><tr><td><strong>类型安全性</strong></td><td>没有类型限制，可能出现不安全的用法</td><td>强制类型安全，只有符合特定条件的类型才能使用</td></tr><tr><td><strong>灵活性</strong></td><td>更加灵活，不限制类型</td><td>更加严格，只能与特定类型一起使用</td></tr><tr><td><strong>示例</strong></td><td><code>friend void printValue(const MyClass&lt;T&gt;&amp; obj);</code></td><td><code>friend void printValue(const MyClass&lt;T&gt;&amp; obj) requires IntegralType&lt;T&gt;;</code></td></tr></tbody></table><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>C++提供了几种重用代码的手段。第 13 章介绍的公有继承能够建立 is-a 关系，这样派生类可以重用基类的代码。私有继承和保护继承也使得能够重用基类的代码，但建立的是 has-a 关系。使用私有继承时，基类的公有成员和保护成员将成为派生类的私有成员；使用保护继承时，基类的公有成员和保护成员将成为派生类的保护成员。无论使用哪种继承，基类的公有接口都将成为派生类的内部接口。这有时候被称为继承实现，但并不继承接口，因为派生类对象不能显式地使用基类的接口。因此，不能将派生对象看作是一种基类对象。由于这个原因，在不进行显式类型转换的情况下，基类指针或引用将不能指向派生类对象。</p><p>还可以通过开发包含对象成员的类来重用类代码。这种方法被称为包含、层次化或组合，它建立的也是has-a 关系。与私有继承和保护继承相比，包含更容易实现和使用，所以通常优先采用这种方式。然而，私有继承和保护继承比包含有一些不同的功能。例如，继承允许派生类访问基类的保护成员；还允许派生类重新定义从基类那里继承的虚函数。因为包含不是继承，所以通过包含来重用类代码时，不能使用这些功能。另一方面，如果需要使用某个类的几个对象，则用包含更适合。例如， State 类可以包含一组 County对象。</p><p>多重继承（MI）使得能够在类设计中重用多个类的代码。私有 MI 或保护 MI 建立 has-a 关系，而公有MI 建立 is-a 关系。 MI 会带来一些问题，即多次定义同一个名称，继承多个基类对象。可以使用类限定符来解决名称二义性的问题，使用虚基类来避免继承多个基类对象的问题。但使用虚基类后，就需要为编写构造函数初始化列表以及解决二义性问题引入新的规则。</p><p>类模板使得能够创建通用的类设计，其中类型（通常是成员类型）由类型参数表示。</p><blockquote><p>END For OOP</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Code</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tutorial</tag>
      
      <tag>C/C++</tag>
      
      <tag>OOP</tag>
      
      <tag>C++ Primer Plus</tag>
      
      <tag>Finished</tag>
      
      <tag>Inheritance</tag>
      
      <tag>Code Reuse</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode-Mistake-collection-31-40</title>
    <link href="/posts/Leetcode-Mistake-collection-31-40/"/>
    <url>/posts/Leetcode-Mistake-collection-31-40/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Mistake-collection-31-40"><a href="#Leetcode-Mistake-collection-31-40" class="headerlink" title="Leetcode-Mistake-collection-31-40"></a>Leetcode-Mistake-collection-31-40</h1><h1 id="程设错题-31-35-20241112"><a href="#程设错题-31-35-20241112" class="headerlink" title="程设错题 31-35 20241112"></a>程设错题 31-35 20241112</h1><h2 id="1-上机错题-寻找字符串的最大非重复子串问题"><a href="#1-上机错题-寻找字符串的最大非重复子串问题" class="headerlink" title="1 上机错题 寻找字符串的最大非重复子串问题"></a>1 上机错题 寻找字符串的最大非重复子串问题</h2><h4 id="解法1基本双循环枚举（略）"><a href="#解法1基本双循环枚举（略）" class="headerlink" title="解法1基本双循环枚举（略）"></a>解法1基本双循环枚举（略）</h4><h4 id="解法2-使用双指针"><a href="#解法2-使用双指针" class="headerlink" title="解法2 使用双指针"></a>解法2 使用双指针</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    string theinput;cin&gt;&gt;theinput;<br>    <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,j=<span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> maxoflength=<span class="hljs-number">0</span>;<br>    unordered_map&lt;<span class="hljs-type">char</span>,<span class="hljs-type">int</span>&gt; list;<br><br>    <span class="hljs-keyword">for</span>(;j&lt;theinput.<span class="hljs-built_in">length</span>();j++)&#123;<br>        <span class="hljs-keyword">if</span>(list.<span class="hljs-built_in">find</span>(theinput[j])!=list.<span class="hljs-built_in">end</span>())&#123;<br>            i=list[theinput[j]]<span class="hljs-number">+1</span>;<br>            <span class="hljs-keyword">if</span>(j-i<span class="hljs-number">+1</span>&gt;maxoflength)&#123;<br>                maxoflength=j-i<span class="hljs-number">+1</span>;<br>            &#125;<br>        &#125;<br>        list[theinput[j]]=j;<br>    &#125;<br>    cout&lt;&lt;maxoflength;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-Leetcode-888-公平糖果交换"><a href="#2-Leetcode-888-公平糖果交换" class="headerlink" title="2 Leetcode 888 公平糖果交换"></a>2 Leetcode 888 公平糖果交换</h2><p>爱丽丝和鲍勃拥有不同总数量的糖果。给你两个数组 <code>aliceSizes</code> 和 <code>bobSizes</code> ，<code>aliceSizes[i]</code> 是爱丽丝拥有的第 <code>i</code> 盒糖果中的糖果数量，<code>bobSizes[j]</code> 是鲍勃拥有的第 <code>j</code> 盒糖果中的糖果数量。</p><p>两人想要互相交换一盒糖果，这样在交换之后，他们就可以拥有相同总数量的糖果。一个人拥有的糖果总数量是他们每盒糖果数量的总和。</p><p>返回一个整数数组 <code>answer</code>，其中 <code>answer[0]</code> 是爱丽丝必须交换的糖果盒中的糖果的数目，<code>answer[1]</code> 是鲍勃必须交换的糖果盒中的糖果的数目。如果存在多个答案，你可以返回其中 <strong>任何一个</strong> 。题目测试用例保证存在与输入对应的答案。</p><h4 id="解法1-双循环枚举"><a href="#解法1-双循环枚举" class="headerlink" title="解法1 双循环枚举"></a>解法1 双循环枚举</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">fairCandySwap</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; aliceSizes, vector&lt;<span class="hljs-type">int</span>&gt;&amp; bobSizes)</span> </span>&#123;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> sum1=<span class="hljs-number">0</span>,sum2=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> alice:aliceSizes)&#123;<br>            sum1+=alice;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> bob:bobSizes)&#123;<br>            sum2+=bob;<br>        &#125;<br>        <span class="hljs-type">int</span> target=<span class="hljs-built_in">abs</span>(sum1-sum2)/<span class="hljs-number">2</span>;<br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> alice:aliceSizes)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> bob:bobSizes)&#123;<br>                <span class="hljs-keyword">if</span>(sum1&gt;sum2&amp;&amp;alice-bob==target)&#123;<br>                    ans.<span class="hljs-built_in">push_back</span>(alice);<br>                    ans.<span class="hljs-built_in">push_back</span>(bob);<br>                    <span class="hljs-keyword">return</span> ans;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(sum1&lt;sum2&amp;&amp;bob-alice==target)&#123;<br>                    ans.<span class="hljs-built_in">push_back</span>(alice);<br>                    ans.<span class="hljs-built_in">push_back</span>(bob);<br>                    <span class="hljs-keyword">return</span> ans;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> &#123;&#125;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="解法2-使用哈希表存储，优化查找方案"><a href="#解法2-使用哈希表存储，优化查找方案" class="headerlink" title="解法2 使用哈希表存储，优化查找方案"></a>解法2 使用哈希表存储，优化查找方案</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">fairCandySwap</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; aliceSizes, vector&lt;<span class="hljs-type">int</span>&gt;&amp; bobSizes)</span> </span>&#123;<br>        <span class="hljs-type">int</span> sumA = <span class="hljs-built_in">accumulate</span>(aliceSizes.<span class="hljs-built_in">begin</span>(), aliceSizes.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>);<br>        <span class="hljs-type">int</span> sumB = <span class="hljs-built_in">accumulate</span>(bobSizes.<span class="hljs-built_in">begin</span>(), bobSizes.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>);<br>        <span class="hljs-type">int</span> delta = (sumA - sumB) / <span class="hljs-number">2</span>;<br>        <span class="hljs-comment">//这里差值可以取负值，就不用分类讨论</span><br>        <span class="hljs-function">unordered_set&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">rec</span><span class="hljs-params">(aliceSizes.begin(), aliceSizes.end())</span></span>;<br>        <span class="hljs-comment">//对Alice的数组创建哈希表（自动删去重复元素）</span><br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; y : bobSizes) &#123;<br>            <span class="hljs-type">int</span> x = y + delta;<br>            <span class="hljs-keyword">if</span> (rec.<span class="hljs-built_in">count</span>(x)) &#123;<br>                <span class="hljs-comment">//如果找到了，就说明存在</span><br>                ans = vector&lt;<span class="hljs-type">int</span>&gt;&#123;x, y&#125;;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h2 id="3-Leetcode-473-火柴拼正方形"><a href="#3-Leetcode-473-火柴拼正方形" class="headerlink" title="3 Leetcode 473 火柴拼正方形"></a>3 Leetcode 473 火柴拼正方形</h2><p>你将得到一个整数数组 <code>matchsticks</code> ，其中 <code>matchsticks[i]</code> 是第 <code>i</code> 个火柴棒的长度。你要用 <strong>所有的火柴棍</strong> 拼成一个正方形。你 <strong>不能折断</strong> 任何一根火柴棒，但你可以把它们连在一起，而且每根火柴棒必须 <strong>使用一次</strong> 。</p><p>如果你能使这个正方形，则返回 <code>true</code> ，否则返回 <code>false</code> 。</p><h3 id="补充：DFS（深度优先搜索）的C-代码实现"><a href="#补充：DFS（深度优先搜索）的C-代码实现" class="headerlink" title="补充：DFS（深度优先搜索）的C++代码实现"></a>补充：DFS（深度优先搜索）的C++代码实现</h3><p>DFS的关键：优先搜索点的未被访问的邻居节点</p><p>非递归的代码示例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">const</span> vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; graph, vector&lt;<span class="hljs-type">bool</span>&gt;&amp; visited)</span> </span>&#123;<br>    <span class="hljs-comment">// 使用一个栈来模拟递归</span><br>    stack&lt;<span class="hljs-type">int</span>&gt; s;<br>    s.<span class="hljs-built_in">push</span>(start);<br>    <span class="hljs-comment">//将起始点start压入栈中</span><br><br>    <span class="hljs-keyword">while</span> (!s.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-comment">// 从栈顶取出一个节点</span><br>        <span class="hljs-type">int</span> node = s.<span class="hljs-built_in">top</span>();<br>        s.<span class="hljs-built_in">pop</span>();<br><br>        <span class="hljs-comment">// 如果节点未被访问过</span><br>        <span class="hljs-keyword">if</span> (!visited[node]) &#123;<br>            <span class="hljs-comment">// 标记为已访问</span><br>            visited[node] = <span class="hljs-literal">true</span>;<br>            <br>            <span class="hljs-comment">// 打印当前访问的节点</span><br>            cout &lt;&lt; <span class="hljs-string">&quot;Visiting node: &quot;</span> &lt;&lt; node &lt;&lt; endl;<br><br>            <span class="hljs-comment">// 将该节点的所有未访问的邻居节点压入栈中</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = graph[node].<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>                <span class="hljs-keyword">if</span> (!visited[graph[node][i]]) &#123;<br>                    s.<span class="hljs-built_in">push</span>(graph[node][i]);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 示例图的邻接表表示</span><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; graph = &#123;<br>        &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;,      <span class="hljs-comment">// 节点0的邻居节点是1和2</span><br>        &#123;<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;,   <span class="hljs-comment">// 节点1的邻居节点是0、3和4</span><br>        &#123;<span class="hljs-number">0</span>, <span class="hljs-number">5</span>&#125;,      <span class="hljs-comment">// 节点2的邻居节点是0和5</span><br>        &#123;<span class="hljs-number">1</span>, <span class="hljs-number">4</span>&#125;,      <span class="hljs-comment">// 节点3的邻居节点是1和4</span><br>        &#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>&#125;,      <span class="hljs-comment">// 节点4的邻居节点是1和3</span><br>        &#123;<span class="hljs-number">2</span>&#125;          <span class="hljs-comment">// 节点5的邻居节点是2</span><br>    &#125;;<br><br>    <span class="hljs-type">int</span> numNodes = graph.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">visited</span><span class="hljs-params">(numNodes, <span class="hljs-literal">false</span>)</span></span>;<br><br>    <span class="hljs-comment">// 从节点0开始DFS</span><br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>, graph, visited);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>优化为递归的版本：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> node, <span class="hljs-type">const</span> vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; graph, vector&lt;<span class="hljs-type">bool</span>&gt;&amp; visited)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (visited[node]) <span class="hljs-keyword">return</span>;<br>    visited[node] = <span class="hljs-literal">true</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Visiting node: &quot;</span> &lt;&lt; node &lt;&lt; endl;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> neighbor : graph[node]) &#123;<br>        <span class="hljs-keyword">if</span> (!visited[neighbor]) &#123;<br>            <span class="hljs-built_in">dfs</span>(neighbor, graph, visited);<br>            <span class="hljs-comment">//遍历每一个未被访问的邻居节点实现全局搜索</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BFS-广度优先搜索"><a href="#BFS-广度优先搜索" class="headerlink" title="BFS 广度优先搜索"></a>BFS 广度优先搜索</h3><p>下面是使用C++实现的BFS的示例代码，该代码会遍历一个图，并打印每个节点的访问顺序：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">const</span> vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; graph, vector&lt;<span class="hljs-type">bool</span>&gt;&amp; visited)</span> </span>&#123;<br>    <span class="hljs-comment">// 使用队列来存储待访问的节点</span><br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    <br>    <span class="hljs-comment">// 将起始节点标记为已访问并入队</span><br>    visited[start] = <span class="hljs-literal">true</span>;<br>    q.<span class="hljs-built_in">push</span>(start);<br><br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-comment">// 从队列中取出一个节点</span><br>        <span class="hljs-type">int</span> node = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br><br>        <span class="hljs-comment">// 打印当前访问的节点</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;Visiting node: &quot;</span> &lt;&lt; node &lt;&lt; endl;<br><br>        <span class="hljs-comment">// 遍历当前节点的所有邻居节点</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> neighbor : graph[node]) &#123;<br>            <span class="hljs-comment">// 如果邻居节点未被访问过，标记为已访问并入队</span><br>            <span class="hljs-keyword">if</span> (!visited[neighbor]) &#123;<br>                visited[neighbor] = <span class="hljs-literal">true</span>;<br>                q.<span class="hljs-built_in">push</span>(neighbor);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 示例图的邻接表表示</span><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; graph = &#123;<br>        &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;,      <span class="hljs-comment">// 节点0的邻居节点是1和2</span><br>        &#123;<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;,   <span class="hljs-comment">// 节点1的邻居节点是0、3和4</span><br>        &#123;<span class="hljs-number">0</span>, <span class="hljs-number">5</span>&#125;,      <span class="hljs-comment">// 节点2的邻居节点是0和5</span><br>        &#123;<span class="hljs-number">1</span>, <span class="hljs-number">4</span>&#125;,      <span class="hljs-comment">// 节点3的邻居节点是1和4</span><br>        &#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>&#125;,      <span class="hljs-comment">// 节点4的邻居节点是1和3</span><br>        &#123;<span class="hljs-number">2</span>&#125;          <span class="hljs-comment">// 节点5的邻居节点是2</span><br>    &#125;;<br><br>    <span class="hljs-type">int</span> numNodes = graph.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">visited</span><span class="hljs-params">(numNodes, <span class="hljs-literal">false</span>)</span></span>;<br><br>    <span class="hljs-comment">// 从节点0开始BFS</span><br>    <span class="hljs-built_in">bfs</span>(<span class="hljs-number">0</span>, graph, visited);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li><p><strong>图的表示</strong>: 这里使用邻接表来表示图，每个节点的邻居节点存储在一个<code>vector</code>中。</p></li><li><p><strong>BFS函数</strong>：</p><ul><li><code>bfs</code>函数接受起始节点<code>start</code>，图<code>graph</code>，以及一个用于标记节点是否已访问的<code>visited</code>数组。</li><li>使用一个队列<code>queue</code>来模拟BFS的层级访问过程。</li><li>将起始节点标记为已访问并入队。</li><li>当队列不为空时，弹出队列的第一个节点（FIFO），打印该节点，然后将其所有未访问的邻居节点标记为已访问并入队。</li></ul></li><li><p><strong>主函数</strong>：</p><ul><li>定义了一个示例图。</li><li>创建一个<code>visited</code>数组来跟踪每个节点的访问状态。</li><li>从节点0开始调用BFS函数。</li></ul></li></ol><p>这个示例展示了如何使用队列来实现BFS。如果你更喜欢使用递归来实现BFS，可以使用一个辅助函数来模拟队列的功能，但通常非递归的实现更直观和高效，因为BFS本身就是一个层级遍历的过程。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> index, vector&lt;<span class="hljs-type">int</span>&gt; &amp;matchsticks, vector&lt;<span class="hljs-type">int</span>&gt; &amp;edges, <span class="hljs-type">int</span> len)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (index == matchsticks.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; edges.<span class="hljs-built_in">size</span>()<span class="hljs-comment">/*4*/</span>; i++) &#123;<br>            edges[i] += matchsticks[index];<br>            <span class="hljs-keyword">if</span> (edges[i] &lt;= len &amp;&amp; <span class="hljs-built_in">dfs</span>(index + <span class="hljs-number">1</span>, matchsticks, edges, len)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            edges[i] -= matchsticks[index];<br>            <span class="hljs-comment">//算法的关键：判断条件：如果edges没有超过边界，那么尝试把第index+1根火柴添加到每一条边上</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">makesquare</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;matchsticks)</span> </span>&#123;<br>        <span class="hljs-type">int</span> totalLen = <span class="hljs-built_in">accumulate</span>(matchsticks.<span class="hljs-built_in">begin</span>(), matchsticks.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span> (totalLen % <span class="hljs-number">4</span> != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-built_in">sort</span>(matchsticks.<span class="hljs-built_in">begin</span>(), matchsticks.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">greater</span>&lt;<span class="hljs-type">int</span>&gt;()); <br>        <span class="hljs-comment">// 减少搜索量</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">edges</span><span class="hljs-params">(<span class="hljs-number">4</span>)</span></span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>, matchsticks, edges, totalLen / <span class="hljs-number">4</span>);<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h2 id="4-Leetcode-921-栈（LIFO）的应用"><a href="#4-Leetcode-921-栈（LIFO）的应用" class="headerlink" title="4 Leetcode 921 栈（LIFO）的应用"></a>4 Leetcode 921 栈（LIFO）的应用</h2><p>栈的“先进后出”</p><p>只有满足下面几点之一，括号字符串才是有效的：</p><ul><li>它是一个空字符串，或者</li><li>它可以被写成 <code>AB</code> （<code>A</code> 与 <code>B</code> 连接）, 其中 <code>A</code> 和 <code>B</code> 都是有效字符串，或者</li><li>它可以被写作 <code>(A)</code>，其中 <code>A</code> 是有效字符串。</li></ul><p>给定一个括号字符串 <code>s</code> ，在每一次操作中，你都可以在字符串的任何位置插入一个括号</p><ul><li>例如，如果 <code>s = &quot;()))&quot;</code> ，你可以插入一个开始括号为 <code>&quot;(()))&quot;</code> 或结束括号为 <code>&quot;())))&quot;</code> 。</li></ul><p>返回 <em>为使结果字符串 <code>s</code> 有效而必须添加的最少括号数</em>。</p><h4 id="解法：使用栈！"><a href="#解法：使用栈！" class="headerlink" title="解法：使用栈！"></a>解法：使用栈！</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minAddToMakeValid</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        stack &lt;<span class="hljs-type">char</span>&gt; thekuohao;<br>        <span class="hljs-comment">//代表一个栈，之后不断压入内容</span><br>        <span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> ch:s)&#123;<br>            <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;(&#x27;</span>)&#123;<br>                thekuohao.<span class="hljs-built_in">push</span>(ch);<br>                <span class="hljs-comment">//左括号希望在后面找到他唯一匹配的右括号</span><br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;)&#x27;</span>)&#123;<br>                <span class="hljs-keyword">if</span>(!thekuohao.<span class="hljs-built_in">empty</span>()&amp;&amp;thekuohao.<span class="hljs-built_in">top</span>()==<span class="hljs-string">&#x27;(&#x27;</span>)&#123;<br>                    thekuohao.<span class="hljs-built_in">pop</span>();<br>                    <span class="hljs-comment">//找到了，弹出栈顶的左括号，同时不压入右括号</span><br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    count++;<br>                    <span class="hljs-comment">//说明此时的右括号无人访问，需要在另一个方向压入新的左括号</span><br>                    <span class="hljs-comment">//count统计到的时需要添加的左括号（即存在盈余的右括号）</span><br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count+thekuohao.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">//最后留在栈中的括号都是未被匹配到的左括号</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>如果降低空间复杂度O（1），则可以这样做：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minAddToMakeValid</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> leftCount = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;c : s) &#123;<br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                leftCount++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (leftCount &gt; <span class="hljs-number">0</span>) &#123;<br>                    leftCount--;<br>                    <span class="hljs-comment">//那么右括号一定可以找到被匹配的左括号</span><br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    ans++;<br>                    <span class="hljs-comment">//leftcount==0，说明此时应该在另一侧加入括号</span><br>                &#125;<br>            &#125;<br>        &#125;<br>        ans += leftCount;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h2 id="5-Leetcode-937-自定义排序"><a href="#5-Leetcode-937-自定义排序" class="headerlink" title="5 Leetcode 937 自定义排序"></a>5 Leetcode 937 自定义排序</h2><p>给你一个日志数组 <code>logs</code>。每条日志都是以空格分隔的字串，其第一个字为字母与数字混合的 <strong>标识符</strong> 。</p><p>有两种不同类型的日志：</p><ul><li><strong>字母日志</strong>：除标识符之外，所有字均由小写字母组成</li><li><strong>数字日志</strong>：除标识符之外，所有字均由数字组成</li></ul><p>请按下述规则将日志重新排序：</p><ul><li>所有 <strong>字母日志</strong> 都排在 <strong>数字日志</strong> 之前。</li><li><strong>字母日志</strong> 在内容不同时，忽略标识符后，按内容字母顺序排序；在内容相同时，按标识符排序。</li><li><strong>数字日志</strong> 应该保留原来的相对顺序。</li></ul><p>返回日志的最终顺序。</p><p><strong>示例 1：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：logs = [<span class="hljs-string">&quot;dig1 8 1 5 1&quot;</span>,<span class="hljs-string">&quot;let1 art can&quot;</span>,<span class="hljs-string">&quot;dig2 3 6&quot;</span>,<span class="hljs-string">&quot;let2 own kit dig&quot;</span>,<span class="hljs-string">&quot;let3 art zero&quot;</span>]<br>输出：[<span class="hljs-string">&quot;let1 art can&quot;</span>,<span class="hljs-string">&quot;let3 art zero&quot;</span>,<span class="hljs-string">&quot;let2 own kit dig&quot;</span>,<span class="hljs-string">&quot;dig1 8 1 5 1&quot;</span>,<span class="hljs-string">&quot;dig2 3 6&quot;</span>]<br>解释：<br>字母日志的内容都不同，所以顺序为 <span class="hljs-string">&quot;art can&quot;</span>, <span class="hljs-string">&quot;art zero&quot;</span>, <span class="hljs-string">&quot;own kit dig&quot;</span> 。<br>数字日志保留原来的相对顺序 <span class="hljs-string">&quot;dig1 8 1 5 1&quot;</span>, <span class="hljs-string">&quot;dig2 3 6&quot;</span> 。<br></code></pre></td></tr></table></figure><p><strong>对于较为复杂的排序问题，可以尝试使用自定义排序的方法实现排序规则的“自定义”。</strong></p><h4 id="最基本的例子：使用sort函数实现升序和降序数组排序"><a href="#最基本的例子：使用sort函数实现升序和降序数组排序" class="headerlink" title="最基本的例子：使用sort函数实现升序和降序数组排序"></a>最基本的例子：使用sort函数实现升序和降序数组排序</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-comment">// 自定义比较函数</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    <span class="hljs-comment">// 这里定义你的排序规则</span><br>    <span class="hljs-comment">// 返回true表示a应该在b之前（即a较小）</span><br>    <span class="hljs-keyword">return</span> a &lt; b;  <span class="hljs-comment">// 这是一个简单的升序比较</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; numbers = &#123;<span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">9</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;;<br><br>    <span class="hljs-comment">// 使用自定义比较函数进行升序排序</span><br>    std::<span class="hljs-built_in">sort</span>(numbers.<span class="hljs-built_in">begin</span>(), numbers.<span class="hljs-built_in">end</span>(), compare);<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;自定义升序排序后的结果: &quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; num : numbers) &#123;<br>        std::cout &lt;&lt; num &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    std::cout &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 现在定义一个不同的比较函数进行降序排序</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">descendingCompare</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> a &gt; b;  <span class="hljs-comment">// 返回true表示a应该在b之后（即b较小）</span><br>    &#125;<br><br>    <span class="hljs-comment">// 使用自定义比较函数进行降序排序</span><br>    std::<span class="hljs-built_in">sort</span>(numbers.<span class="hljs-built_in">begin</span>(), numbers.<span class="hljs-built_in">end</span>(), descendingCompare);<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;自定义降序排序后的结果: &quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; num : numbers) &#123;<br>        std::cout &lt;&lt; num &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    std::cout &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">reorderLogFiles</span><span class="hljs-params">(vector&lt;string&gt;&amp; logs)</span> </span>&#123;<br>        <span class="hljs-built_in">stable_sort</span>(logs.<span class="hljs-built_in">begin</span>(), logs.<span class="hljs-built_in">end</span>(), [&amp;](<span class="hljs-type">const</span> string &amp; log1, <span class="hljs-type">const</span> string &amp; log2) &#123;<br>            <span class="hljs-comment">//使用stable_sort保证相同元素排序的稳定性</span><br>            <span class="hljs-type">int</span> pos1 = log<span class="hljs-number">1.f</span>ind_first_of(<span class="hljs-string">&quot; &quot;</span>);<br>            <span class="hljs-type">int</span> pos2 = log<span class="hljs-number">2.f</span>ind_first_of(<span class="hljs-string">&quot; &quot;</span>);<br>            <span class="hljs-comment">//库函数find_first_of()可以实现定位到字符串的目标字符的第一个索引位置</span><br>            <br>            <span class="hljs-type">bool</span> isDigit1 = <span class="hljs-built_in">isdigit</span>(log1[pos1 + <span class="hljs-number">1</span>]);<br>            <span class="hljs-type">bool</span> isDigit2 = <span class="hljs-built_in">isdigit</span>(log2[pos2 + <span class="hljs-number">1</span>]);<br>            <span class="hljs-comment">//这两个bool值判断是否为数字，进而实现对两种不同的日志的分类</span><br>            <span class="hljs-keyword">if</span> (isDigit1 &amp;&amp; isDigit2) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                <span class="hljs-comment">//都是数字，保持位置</span><br>            &#125;<br>            <span class="hljs-keyword">if</span> (!isDigit1 &amp;&amp; !isDigit2) &#123;<br>                <span class="hljs-comment">//如果都不是数字</span><br>                string s1 = log<span class="hljs-number">1.</span><span class="hljs-built_in">substr</span>(pos1);<br>                <span class="hljs-comment">//复制子串的库函数 substr()</span><br>                string s2 = log<span class="hljs-number">2.</span><span class="hljs-built_in">substr</span>(pos2);<br>                <span class="hljs-keyword">if</span> (s1 != s2) &#123;<br>                    <span class="hljs-comment">//string类重载了对应运算符，可以直接实现字符串的比较(逐位比较)</span><br>                    <span class="hljs-keyword">return</span> s1 &lt; s2;<br>                &#125;<br>                <span class="hljs-keyword">return</span> log1 &lt; log2;<br>                <span class="hljs-comment">//如果内容相同，则比较日志头部log1和log2</span><br>            &#125;<br>            <span class="hljs-keyword">return</span> isDigit1 ? <span class="hljs-literal">false</span> : <span class="hljs-literal">true</span>;<br>            <span class="hljs-comment">//最后一种情况，一个为数字，一个为字符，则根据规则字符应该排在前面</span><br>        &#125;);<br>        <span class="hljs-comment">//以上内容都是Lambda表达式，实现对自定义排序函数compare的定义</span><br>        <span class="hljs-comment">//在compare中，如果匿名函数返回false，说明不用交换顺序</span><br>        <span class="hljs-keyword">return</span> logs;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h3 id="补充知识点讲解：Lambda表达式"><a href="#补充知识点讲解：Lambda表达式" class="headerlink" title="补充知识点讲解：Lambda表达式"></a>补充知识点讲解：Lambda表达式</h3><p>在C++中，lambda表达式（Lambda Expressions）<strong>是一种简洁的方式来定义匿名函数对象</strong>（即没有名称的函数），它允许你直接在代码中定义小型的、一次性使用的函数。<strong>这些函数对象可以捕获外部作用域中的变量</strong>，并可以在需要时直接使用。Lambda表达式的引入使得C++编程更加灵活和方便，特别是在需要短小、临时函数时。以下是关于lambda表达式的一些关键点：</p><h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><p>Lambda表达式的基本形式如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">[捕获列表](参数列表)可变性规范 -&gt; 返回类型 &#123;<br>    <span class="hljs-comment">// 函数体</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>捕获列表</strong>：<code>[]</code> 用于指定哪些外部变量应该被lambda表达式捕获。可以是：<ul><li><code>[]</code> 什么都不捕获。</li><li><code>[=]</code> 按值捕获所有可见的外部变量。</li><li><code>[&amp;]</code> 按引用捕获所有可见的外部变量。</li><li><code>[x, &amp;y]</code> 按值捕获<code>x</code>，按引用捕获<code>y</code>。</li></ul></li><li><strong>参数列表</strong>：类似于普通函数的参数列表，可以为空。</li><li><strong>可变性规范</strong>：<code>mutable</code>关键字表示lambda表达式可以修改被值捕获的变量。</li><li><strong>返回类型</strong>：如果lambda表达式包含多个<code>return</code>语句或需要明确指定返回类型，可以使用<code>-&gt;</code>来指定。</li><li><strong>函数体</strong>：包含lambda表达式的实际代码。</li></ul><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; numbers = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>    <span class="hljs-type">int</span> factor = <span class="hljs-number">2</span>;<br><br>    <span class="hljs-comment">// 使用lambda表达式对向量中的每个元素乘以factor</span><br>    std::for_each(numbers.<span class="hljs-built_in">begin</span>(), numbers.<span class="hljs-built_in">end</span>(), [factor](<span class="hljs-type">int</span> &amp;n) &#123;<br>        n *= factor;<br>    &#125;);<br><br>    <span class="hljs-comment">// 打印结果</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; num : numbers) &#123;<br>        std::cout &lt;&lt; num &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    std::cout &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 另一个lambda表达式示例，返回一个函数</span><br>    <span class="hljs-keyword">auto</span> add = [](<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y) -&gt; <span class="hljs-type">int</span> &#123;<br>        <span class="hljs-keyword">return</span> x + y;<br>    &#125;;<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;1 + 2 = &quot;</span> &lt;&lt; <span class="hljs-built_in">add</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li><strong>匿名性</strong>：Lambda表达式是匿名的，不需要为其定义一个名称。</li><li><strong>捕获外部变量</strong>：可以捕获外部作用域的变量，允许这些变量在lambda表达式内使用。</li><li><strong>简洁性</strong>：相比于定义一个函数对象或函数指针，lambda表达式更加简洁。</li><li><strong>闭包</strong>：lambda表达式可以创建闭包，捕获的变量在lambda表达式执行时仍然有效。</li></ul><p>Lambda表达式在C++11及以后的标准中被引入，极大地方便了编写简短的函数式代码，常用于STL算法、事件处理、异步编程等场景。</p><h3 id="补充知识点讲解：深入了解sort函数"><a href="#补充知识点讲解：深入了解sort函数" class="headerlink" title="补充知识点讲解：深入了解sort函数"></a>补充知识点讲解：深入了解sort函数</h3><p><code>std::sort</code>在C++标准库中实现的是<strong>内省排序（Introsort）</strong>，这是一种混合排序算法，结合了快速排序（Quicksort）、堆排序（Heapsort）和插入排序（Insertion Sort）的优点。以下是<code>std::sort</code>的基本原理：</p><h4 id="1-快速排序（Quicksort）"><a href="#1-快速排序（Quicksort）" class="headerlink" title="1. 快速排序（Quicksort）"></a>1. <strong>快速排序（Quicksort）</strong></h4><ul><li><code>std::sort</code>首先尝试使用快速排序，因为快速排序在平均情况下有很好的性能，时间复杂度为O(n log n)。</li><li>快速排序通过选择一个枢轴元素（pivot）将数组分成两部分，比枢轴小的元素放在一侧，比枢轴大的元素放在另一侧，然后递归地对这两部分进行排序。</li></ul><h4 id="2-堆排序（Heapsort）"><a href="#2-堆排序（Heapsort）" class="headerlink" title="2. 堆排序（Heapsort）"></a>2. <strong>堆排序（Heapsort）</strong></h4><ul><li>当快速排序的递归深度超过一定阈值时（通常是log n），<code>std::sort</code>会切换到堆排序。</li><li>堆排序保证了最坏情况下的时间复杂度为O(n log n)，避免了快速排序在某些情况下可能退化到O(n^2)的性能。</li></ul><h4 id="3-插入排序（Insertion-Sort）"><a href="#3-插入排序（Insertion-Sort）" class="headerlink" title="3. 插入排序（Insertion Sort）"></a>3. <strong>插入排序（Insertion Sort）</strong></h4><ul><li>对于小规模的数据（通常是少于16个元素的子数组），<code>std::sort</code>会使用插入排序，因为在小数据集上，插入排序的性能通常优于其他排序算法。</li></ul><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ul><li><strong>自适应性</strong>：<code>std::sort</code>根据数据的大小和递归深度自动选择最适合的排序策略，这使得它在各种情况下都表现良好。</li><li><strong>稳定性</strong>：<code>std::sort</code>不是稳定的排序算法，这意味着相同元素的相对顺序在排序后可能改变。如果需要稳定排序，可以使用<code>std::stable_sort</code>。</li><li><strong>内存使用</strong>：<code>std::sort</code>通常是原地排序算法，意味它不需要额外的内存空间（除了递归调用栈），这对大规模数据的排序是非常有利的。</li></ul><p>由于C++标准库的具体实现可能会因不同的编译器和标准库版本而有所不同，这里提供一个简化的、概念性的<code>std::sort</code>实现，展示内省排序的核心思想：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">namespace</span> std &#123;<br>    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">RandomIt</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">Compare</span> = std::less&lt;&gt;&gt;<br>    <span class="hljs-type">void</span> <span class="hljs-built_in">sort</span>(RandomIt first, RandomIt last, Compare comp = <span class="hljs-built_in">Compare</span>()) &#123;<br>        <span class="hljs-comment">// 内省排序的阈值，通常为log(n)</span><br>        <span class="hljs-type">const</span> <span class="hljs-type">int</span> introsort_threshold = <span class="hljs-number">2</span> * <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-built_in">log</span>(last - first) / <span class="hljs-built_in">log</span>(<span class="hljs-number">2</span>));<br><br>        <span class="hljs-comment">// 辅助函数，执行快速排序</span><br>        <span class="hljs-keyword">auto</span> quicksort = [&amp;](RandomIt low, RandomIt high, <span class="hljs-type">int</span> depth) &#123;<br>            <span class="hljs-keyword">if</span> (high - low &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 已经排序或只有一个元素</span><br><br>            <span class="hljs-keyword">if</span> (depth == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// 达到最大深度，使用堆排序</span><br>                std::<span class="hljs-built_in">make_heap</span>(low, high, comp);<br>                std::<span class="hljs-built_in">sort_heap</span>(low, high, comp);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br><br>            --depth;<br><br>            <span class="hljs-comment">// 选择枢轴并进行分区</span><br>            RandomIt pivot = std::<span class="hljs-built_in">partition</span>(low, high, <br>                [&amp;](<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; a) &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">comp</span>(a, *std::<span class="hljs-built_in">next</span>(high, <span class="hljs-number">-1</span>)); &#125;);<br><br>            <span class="hljs-comment">// 递归排序左右两部分</span><br>            <span class="hljs-built_in">quicksort</span>(low, pivot, depth);<br>            <span class="hljs-built_in">quicksort</span>(pivot, high, depth);<br>        &#125;;<br><br>        <span class="hljs-comment">// 开始内省排序</span><br>        <span class="hljs-built_in">quicksort</span>(first, last, introsort_threshold);<br><br>        <span class="hljs-comment">// 对小规模数据使用插入排序</span><br>        <span class="hljs-keyword">if</span> (last - first &lt;= <span class="hljs-number">16</span>) &#123;<br>            <span class="hljs-keyword">for</span> (RandomIt i = first + <span class="hljs-number">1</span>; i != last; ++i) &#123;<br>                <span class="hljs-keyword">auto</span> key = *i;<br>                RandomIt j = i - <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">while</span> (j &gt;= first &amp;&amp; <span class="hljs-built_in">comp</span>(key, *j)) &#123;<br>                    *(j + <span class="hljs-number">1</span>) = *j;<br>                    --j;<br>                &#125;<br>                *(j + <span class="hljs-number">1</span>) = key;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h4><ol><li><p><strong>内省排序阈值</strong>：<code>introsort_threshold</code>用于决定何时从快速排序切换到堆排序，通常设置为<code>2 * log(n)</code>。</p></li><li><p><strong>快速排序部分</strong>：</p><ul><li><code>quicksort</code>函数实现了快速排序的核心逻辑。</li><li>使用<code>std::partition</code>进行分区，基于比较函数<code>comp</code>。</li><li>当递归深度达到<code>introsort_threshold</code>时，切换到堆排序。</li></ul></li><li><p><strong>堆排序</strong>：</p><ul><li>当达到最大递归深度时，调用<code>std::make_heap</code>和<code>std::sort_heap</code>来完成排序。</li></ul></li><li><p><strong>插入排序</strong>：</p><ul><li>对于小规模数据（这里设定为16个元素或更少），使用插入排序来优化性能。</li></ul></li><li><p><strong>比较函数</strong>：</p><ul><li><code>comp</code>参数允许用户提供自定义的比较函数，实现自定义排序逻辑。</li></ul></li></ol><p>请注意，这是一个简化的实现，实际的标准库实现可能包含更多的优化：</p><ul><li>选择枢轴的策略可能更复杂，以避免最坏情况（如已经排序或逆序的数组）。</li><li>可能使用不同的阈值来决定何时切换到堆排序或插入排序。</li><li>内存管理和性能优化，如减少递归调用的栈空间使用。</li><li>可能使用其他技术来减少比较次数或提高缓存命中率。</li></ul><p>这种实现展示了内省排序的基本理念：结合快速排序的平均性能优势、堆排序的最坏情况保证，以及插入排序在小数据集上的效率。</p><h1 id="程序设计错题-36-40"><a href="#程序设计错题-36-40" class="headerlink" title="程序设计错题 36-40"></a>程序设计错题 36-40</h1><h2 id="1-Leetcode-334-经典算法题：递增三元子序列排序"><a href="#1-Leetcode-334-经典算法题：递增三元子序列排序" class="headerlink" title="1.Leetcode 334 经典算法题：递增三元子序列排序"></a>1.Leetcode 334 经典算法题：递增三元子序列排序</h2><p>给你一个整数数组 nums ，判断这个数组中是否存在长度为 3 的递增子序列。</p><p>如果存在这样的三元组下标 (i, j, k) 且满足 i &lt; j &lt; k ，使得 nums[i] &lt; nums[j] &lt; nums[k] ，返回 true ；否则，返回 false。</p><h4 id="解法1-O-n-3-暴力枚举"><a href="#解法1-O-n-3-暴力枚举" class="headerlink" title="解法1 O(n^3)暴力枚举"></a>解法1 O(n^3)暴力枚举</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">increasingTriplet</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>()&lt;<span class="hljs-number">3</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i<span class="hljs-number">+2</span>&lt;nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i<span class="hljs-number">+2</span>;j&lt;nums.<span class="hljs-built_in">size</span>();j++)&#123;<br>                <span class="hljs-keyword">if</span>(nums[j]&lt;=nums[i])&#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=i<span class="hljs-number">+1</span>;k&lt;j;k++)&#123;<br>                        <span class="hljs-keyword">if</span>(nums[j]&gt;nums[k]&amp;&amp;nums[k]&gt;nums[i])&#123;<br>                            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="解法2-动态规划（也会超时）"><a href="#解法2-动态规划（也会超时）" class="headerlink" title="解法2 动态规划（也会超时）"></a>解法2 动态规划（也会超时）</h4><p>维护一个dp[i]<strong>来记录每个位置的最长递增子序列的长度</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">increasingTriplet</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() &lt; <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(nums.size(), <span class="hljs-number">1</span>)</span></span>;<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; i; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (nums[i] &gt; nums[j]) &#123;<br>                    dp[i] = std::<span class="hljs-built_in">max</span>(dp[i], dp[j] + <span class="hljs-number">1</span>);<br>                    <span class="hljs-keyword">if</span> (dp[i] &gt;= <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><p>牺牲空间复杂度，换取时间复杂度：O(n^2)和O(n)</p><h4 id="优化1-使用双向遍历"><a href="#优化1-使用双向遍历" class="headerlink" title="优化1 使用双向遍历"></a>优化1 使用双向遍历</h4><p><img src="/posts/Above-All/istake-collection-31-40/1.png" alt="双向遍历"></p><p>维护数组的好处：提高了空间复杂度，但是不用在每一次遍历的时候重新找存在的元素了（相当于动态规划的思想）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">increasingTriplet</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n=nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(n&lt;<span class="hljs-number">3</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">leftnum</span><span class="hljs-params">(n,nums[<span class="hljs-number">0</span>])</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">rightnum</span><span class="hljs-params">(n,nums[n<span class="hljs-number">-1</span>])</span></span>;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;<br>            leftnum[i]=<span class="hljs-built_in">min</span>(leftnum[i<span class="hljs-number">-1</span>],nums[i]);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n<span class="hljs-number">-2</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>            rightnum[i]=<span class="hljs-built_in">max</span>(rightnum[i<span class="hljs-number">+1</span>],nums[i]);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n<span class="hljs-number">-1</span>;i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i]&gt;leftnum[i<span class="hljs-number">-1</span>]&amp;&amp;nums[i]&lt;rightnum[i<span class="hljs-number">+1</span>])&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>时间复杂度：O(n^2)</p><p>空间复杂度：O(n^2)</p><h4 id="优化2-贪婪算法"><a href="#优化2-贪婪算法" class="headerlink" title="优化2 贪婪算法"></a>优化2 贪婪算法</h4><p>first 和 second 代表这个数组中我们所找到的最小值和次小值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;climits&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">increasingTriplet</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> first = INT_MAX, second = INT_MAX;<br>        <span class="hljs-comment">//定义系统的最大最小值</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> n : nums) &#123;<br>            <span class="hljs-keyword">if</span> (n &lt;= first) &#123;<br>                first = n;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n &lt;= second) &#123;<br>                second = n;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//(n&gt;first &amp;&amp; n&gt;second)</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                <span class="hljs-comment">//理论分析：找到最小值和次小值为什么就可以判定true？</span><br>                <span class="hljs-comment">//找到了n&gt;first &amp;&amp; n&gt;second，则n作为三元组的最后一个数，而且根据遍历的规则，n的前面一个数一定是当前数组的second或者first！</span><br>                <span class="hljs-comment">//如果是second，那么说明first还在前面，找到了符合条件的三元组</span><br>                <span class="hljs-comment">//如果是first，因为这里n&gt;second，说明second的值已经被更新过，说明在n前面，first的值至少被更新过两次，second至少被更新过一次</span><br>                <span class="hljs-comment">//a1(数组第一个数，被更新为first)——a2(second)--a3(first)--n</span><br>                <span class="hljs-comment">//a1和a3之间还可以有很多次second和first值的更新，a3&lt;a1&lt;a2&lt;n;</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><p>时间复杂度O(n)，空间复杂度O(1)</p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C/C++</tag>
      
      <tag>Leetcode notes</tag>
      
      <tag>algorithm</tag>
      
      <tag>Finished</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode-Mistake-collection-21-30</title>
    <link href="/posts/Leetcode-Mistake-collection-21-30/"/>
    <url>/posts/Leetcode-Mistake-collection-21-30/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Mistake-collection-21-30"><a href="#Leetcode-Mistake-collection-21-30" class="headerlink" title="Leetcode-Mistake-collection-21-30"></a>Leetcode-Mistake-collection-21-30</h1><h1 id="程设错题-21-24-2024-11-1-2024-11-4"><a href="#程设错题-21-24-2024-11-1-2024-11-4" class="headerlink" title="程设错题 21-24 2024-11-1 2024-11-4"></a>程设错题 21-24 2024-11-1 2024-11-4</h1><h2 id="1-Leetcode-453-最小操作次数使数组元素相等"><a href="#1-Leetcode-453-最小操作次数使数组元素相等" class="headerlink" title="1. Leetcode 453 最小操作次数使数组元素相等"></a>1. Leetcode 453 最小操作次数使数组元素相等</h2><p><strong>不要所有方法都使用最原始的编程方法解决！</strong></p><p>给你一个长度为 <code>n</code> 的整数数组，每次操作将会使 <code>n - 1</code> 个元素增加 <code>1</code> 。返回让数组所有元素相等的最小操作次数。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,2,3]</span><br>输出：3<br>解释：<br>只需要3次操作（注意每次操作会增加两个元素的值）：<br><span class="hljs-comment">[1,2,3]</span>  =&gt;  <span class="hljs-comment">[2,3,3]</span>  =&gt;  <span class="hljs-comment">[3,4,3]</span>  =&gt;  <span class="hljs-comment">[4,4,4]</span><br></code></pre></td></tr></table></figure><h3 id="解法1-最基本解法（计算-枚举）"><a href="#解法1-最基本解法（计算-枚举）" class="headerlink" title="解法1 最基本解法（计算+枚举）"></a>解法1 最基本解法（计算+枚举）</h3><p>​<strong>时间复杂度过高</strong>（最坏时间复杂度：O(n^2)）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minMoves</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>()==<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> max=nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> num:nums)&#123;<br>            sum+=num;<br>            <span class="hljs-keyword">if</span>(num&gt;max)&#123;<br>                max=num;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> diff=nums.<span class="hljs-built_in">size</span>()*max-sum;<br>        <span class="hljs-keyword">while</span>(diff%(nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>))&#123;<br>            diff+=(nums.<span class="hljs-built_in">size</span>());<br>        &#125;<br>        <span class="hljs-type">bool</span> flag=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> standard=(<span class="hljs-built_in">long</span>(diff)+sum)/nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">while</span>(!flag)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> num:nums)&#123;<br>                <span class="hljs-keyword">if</span>(standard-num&gt;(diff/(nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>)))&#123;<br>                    flag=<span class="hljs-number">0</span>;<br>                    standard+=nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>                    diff+=nums.<span class="hljs-built_in">size</span>()*(nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                flag=<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> diff/(nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="解法2-巧妙的转化"><a href="#解法2-巧妙的转化" class="headerlink" title="解法2 巧妙的转化"></a>解法2 巧妙的转化</h3><p>​因为只需要找出让数组所有元素相等的最小操作次数，所以我们不需要考虑数组中各个元素的绝对大小，即不需要真正算出数组中所有元素相等时的元素值，只需要考虑数组中元素相对大小的变化即可。</p><p>​因此，每次操作既可以理解为使 n−1 个元素增加 1，也可以理解使 1 个元素减少 1。显然，后者更利于我们的计算。</p><p>​于是，要计算让数组中所有元素相等的操作数，我们只需要计算将数组中所有元素都减少到数组中元素最小值所需的操作数。</p><p><strong>这个方法没有次数的限制，所以不用通过枚举找到可行解！</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minMoves</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> minNum = *<span class="hljs-built_in">min_element</span>(nums.<span class="hljs-built_in">begin</span>(),nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-comment">//找到数组中的最小值</span><br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            res += num - minNum;<br>        &#125;<br>        <span class="hljs-comment">//通过累加得到一共需要操作的次数</span><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="2-Leetcode-448-找到数组中消失的数字"><a href="#2-Leetcode-448-找到数组中消失的数字" class="headerlink" title="2. Leetcode 448 找到数组中消失的数字"></a>2. Leetcode 448 找到数组中消失的数字</h2><p>给你一个含 <code>n</code> 个整数的数组 <code>nums</code> ，其中 <code>nums[i]</code> 在区间 <code>[1, n]</code> 内。请你找出所有在 <code>[1, n]</code> 范围内但没有出现在 <code>nums</code> 中的数字，并以数组的形式返回结果。</p><h3 id="解法1-使用动态数组（new-delete）"><a href="#解法1-使用动态数组（new-delete）" class="headerlink" title="解法1 使用动态数组（new&amp;delete）"></a>解法1 使用动态数组（new&amp;delete）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">findDisappearedNumbers</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        vector &lt;<span class="hljs-type">int</span>&gt; successful;<br>        <span class="hljs-type">int</span> n=nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">bool</span> *list=<span class="hljs-keyword">new</span> <span class="hljs-type">bool</span>[n];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            list[i]=<span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> num:nums)&#123;<br>            list[num<span class="hljs-number">-1</span>]=<span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(!list[i])&#123;<br>                successful.<span class="hljs-built_in">push_back</span>(i<span class="hljs-number">+1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">delete</span>[] list;<br>        <span class="hljs-keyword">return</span> successful;<br>        <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="解法2-原地哈希表"><a href="#解法2-原地哈希表" class="headerlink" title="解法2 原地哈希表"></a>解法2 原地哈希表</h3><p><strong>不开辟新的内存空间，在原来的数组上进行操作</strong></p><p>我们可以用一个哈希表记录数组 nums 中的数字，由于数字范围均在 [1,n] 中，记录数字后我们再利用哈希表检查 [1,n] 中的每一个数是否出现，从而找到缺失的数字。</p><p>由于数字范围均在 [1,n] 中，我们也可以用一个长度为 n 的数组来代替哈希表。这一做法的空间复杂度是 O(n) 的。我们的目标是优化空间复杂度到 O(1)。</p><p>注意到 nums 的长度恰好也为 n，能否让 nums 充当哈希表呢？</p><p>由于 nums 的数字范围均在 [1,n] 中，我们可以<strong>利用这一范围之外的数字</strong>，来表达「是否存在」的含义。</p><p>具体来说，遍历 nums，每遇到一个数 x，就让 nums[x−1] 增加 n。由于 nums 中所有数均在 [1,n] 中，增加以后，这些数必然大于 n。最后我们遍历 nums，若 nums[i] 未大于 n，就说明没有遇到过数 i+1。这样我们就找到了缺失的数字。</p><p>注意，<strong>当我们遍历到某个位置时，其中的数可能已经被增加过，因此需要对 n 取模</strong>来还原出它本来的值。</p><p><strong>取模&amp;加倍数（进制）</strong>可以让一个数通过不同的运算储存不同的信息，例如32以10为进制可以储存3,2两个信息</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">findDisappearedNumbers</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; num : nums) &#123;<br>            <span class="hljs-type">int</span> x = (num - <span class="hljs-number">1</span>) % n;<br>            <span class="hljs-comment">//-1 problem，注意数组下标从0开始</span><br>            <span class="hljs-comment">//通过%取余运算得到原来的值</span><br>            nums[x] += n;<br>        &#125;<br>        vector&lt;<span class="hljs-type">int</span>&gt; ret;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] &lt;= n) &#123;<br>                <span class="hljs-comment">//证明这个值未出现过</span><br>                ret.<span class="hljs-built_in">push_back</span>(i + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h2 id="3-Leetcode-455-贪心算法分配饼干"><a href="#3-Leetcode-455-贪心算法分配饼干" class="headerlink" title="3. Leetcode 455 贪心算法分配饼干"></a>3. Leetcode 455 贪心算法分配饼干</h2><h3 id="补充：贪心算法"><a href="#补充：贪心算法" class="headerlink" title="补充：贪心算法"></a>补充：贪心算法</h3><p><strong>保证局部最优解&#x3D;全局最优解！</strong></p><h4 id="1-最优子结构性质"><a href="#1-最优子结构性质" class="headerlink" title="1. 最优子结构性质"></a>1. 最优子结构性质</h4><p><strong>定义</strong>：一个问题具有最优子结构性质，意味着问题的最优解可以通过其子问题的最优解来构建。这是动态规划和贪婪算法的共同特征。</p><p><strong>作用</strong>：如果一个问题具有最优子结构性质，贪婪算法可以通过解决每个子问题的最优解来逐步构建全局最优解。例如，在最小生成树问题中，局部最优的边选择能够合并成全局最优的生成树。</p><h4 id="2-无后效性"><a href="#2-无后效性" class="headerlink" title="2. 无后效性"></a>2. 无后效性</h4><p><strong>定义</strong>：无后效性是指当前选择不会影响未来选择的可行性或最优性。这意味着每一步做出的选择不会限制后续步骤中其他选择的可能性。</p><p><strong>作用</strong>：无后效性确保了贪婪算法在每一步做出局部最优选择时，不会对后续步骤产生负面影响。例如，在活动选择问题中，选择结束时间最早的活动不会影响后续活动的选择空间。</p><h4 id="3-贪婪选择性质的应用场景"><a href="#3-贪婪选择性质的应用场景" class="headerlink" title="3. 贪婪选择性质的应用场景"></a>3. 贪婪选择性质的应用场景</h4><p>一些典型的应用场景包括：</p><ul><li><strong>活动选择问题</strong>：选择一组互不重叠的活动，贪婪选择性质确保选择最早结束的活动是最优的。</li><li><strong>最小生成树问题</strong>：通过选择权重最小且不形成环的边来构建最小生成树。</li><li><strong>单源最短路径问题（无负权边）</strong>：在Dijkstra算法中，每次选择当前未访问顶点中距离最小的顶点。</li></ul><h4 id="4-不适用贪婪算法的问题"><a href="#4-不适用贪婪算法的问题" class="headerlink" title="4. 不适用贪婪算法的问题"></a>4. 不适用贪婪算法的问题</h4><p>并不是所有问题都适合用贪婪算法来解决。对于不具备贪婪选择性质的问题，贪婪算法可能无法找到全局最优解。例如：</p><ul><li><strong>旅行商问题（TSP）</strong>：贪婪算法可能无法找到最短路径，因为局部最优选择可能导致全局次优解。</li><li><strong>背包问题</strong>：在0-1背包问题中，贪婪算法可能无法找到最优解，因为选择价值密度最高的物品可能导致无法装入其他更有价值的组合。</li></ul><h4 id="5-识别适用性"><a href="#5-识别适用性" class="headerlink" title="5. 识别适用性"></a>5. 识别适用性</h4><p>在应用贪婪算法之前，识别问题是否具备贪婪选择性质和最优子结构是关键。通常需要通过理论分析或构造反例来验证贪婪策略的有效性。</p><p>总结来说，贪婪算法适用于那些具有最优子结构和无后效性的问题。在这些问题中，贪婪选择性质确保每一步的局部最优选择最终能组合成全局最优解。对于不具备这些性质的问题，可能需要其他算法（如动态规划或回溯）来找到全局最优解。</p><h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。</p><p>对每个孩子 <code>i</code>，都有一个胃口值 <code>g[i]</code>，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 <code>j</code>，都有一个尺寸 <code>s[j]</code> 。如果 <code>s[j] &gt;= g[i]</code>，我们可以将这个饼干 <code>j</code> 分配给孩子 <code>i</code> ，这个孩子会得到满足。你的目标是满足尽可能多的孩子，并输出这个最大数值。</p><h3 id="解法1-排序后遍历（繁琐做法）"><a href="#解法1-排序后遍历（繁琐做法）" class="headerlink" title="解法1:排序后遍历（繁琐做法）"></a>解法1:排序后遍历（繁琐做法）</h3><p>时间复杂度：<em>O</em>(<em>m</em>log<em>m</em>+<em>n</em>log<em>n</em>+<em>m</em>⋅<em>n</em>)</p><p>​mlogm和nlogn是排序的时间复杂度，mn是最后遍历的时间复杂度</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findContentChildren</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; g, vector&lt;<span class="hljs-type">int</span>&gt;&amp; s)</span> </span>&#123;<br>        <span class="hljs-built_in">sort</span>(g.<span class="hljs-built_in">begin</span>(),g.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">sort</span>(s.<span class="hljs-built_in">begin</span>(),s.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> select=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;g.<span class="hljs-built_in">size</span>()&amp;&amp;select&lt;s.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=select;j&lt;s.<span class="hljs-built_in">size</span>();j++)&#123;<br>                <span class="hljs-keyword">if</span>(s[j]&gt;=g[i])&#123;<br>                    count++;<br>                    j++;<br>                    select=j;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">//其实这里通过select不断提升j的枚举起点有点类似于双指针策略，但是代码的冗余之处在于如果出现遍历完还没有找到的情况，应该直接跳出外循环（我们已经排序过数组了）</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>解法1的小修改:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findContentChildren</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; g, vector&lt;<span class="hljs-type">int</span>&gt;&amp; s)</span> </span>&#123;<br>        <span class="hljs-built_in">sort</span>(g.<span class="hljs-built_in">begin</span>(),g.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">sort</span>(s.<span class="hljs-built_in">begin</span>(),s.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> select=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">bool</span> flag=<span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;g.<span class="hljs-built_in">size</span>()&amp;&amp;select&lt;s.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=select;j&lt;s.<span class="hljs-built_in">size</span>();j++)&#123;<br>                <span class="hljs-keyword">if</span>(s[j]&gt;=g[i])&#123;<br>                    flag=<span class="hljs-literal">true</span>;<br>                    count++;<br>                    j++;<br>                    select=j;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(!flag)&#123;<br>                <span class="hljs-keyword">return</span> count;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>        <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>(这样就不会超时了，但是代码还有优化的空间)</p><ul><li>这里其实不需要写两层for循环控制两个指针！</li></ul><h3 id="解法2：优化使用双指针"><a href="#解法2：优化使用双指针" class="headerlink" title="解法2：优化使用双指针"></a>解法2：优化使用双指针</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findContentChildren</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; g, vector&lt;<span class="hljs-type">int</span>&gt;&amp; s)</span> </span>&#123;<br>        <span class="hljs-built_in">sort</span>(g.<span class="hljs-built_in">begin</span>(), g.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">sort</span>(s.<span class="hljs-built_in">begin</span>(), s.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//define two pointers</span><br>        <span class="hljs-keyword">while</span> (i &lt; g.<span class="hljs-built_in">size</span>() &amp;&amp; j &lt; s.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-keyword">if</span> (s[j] &gt;= g[i]) &#123;<br>                count++;<br>                i++;<br>                <span class="hljs-comment">//if allocate successfully,then the both pointers get forward</span><br>            &#125;<br>            j++;<br>            <span class="hljs-comment">//whenever the allocate, the biscuit pointer gets forward</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><p>时间复杂度：O(mlogm)+O(nlogn)+O(m+n)&#x3D;O(mlogm+nlogn)</p><h3 id="补充：双指针"><a href="#补充：双指针" class="headerlink" title="补充：双指针"></a>补充：双指针</h3><p>双指针是一种常用的算法技巧，尤其在处理数组或链表等线性数据结构时非常有效。它通过使用两个指针来遍历数据结构，能够在某些情况下优化时间复杂度或简化逻辑。以下是双指针技巧的一些常见应用场景和简单介绍：</p><h3 id="1-快慢指针"><a href="#1-快慢指针" class="headerlink" title="1. 快慢指针"></a>1. 快慢指针</h3><ul><li><strong>应用场景</strong>：检测链表中的环、找到链表的中间节点。</li><li><strong>方法</strong>：<ul><li>使用两个指针，一个快指针每次移动两步，一个慢指针每次移动一步。</li><li>如果快指针和慢指针相遇，说明存在环。</li><li>找中间节点时，当快指针到达链表末尾时，慢指针正好在中间。</li></ul></li></ul><h3 id="2-左右指针"><a href="#2-左右指针" class="headerlink" title="2. 左右指针"></a>2. 左右指针</h3><ul><li><strong>应用场景</strong>：解决排序数组中的问题，如二分查找、三数之和。</li><li><strong>方法</strong>：<ul><li>初始化两个指针，分别指向数组的两端。</li><li>根据问题的要求，向中间移动指针。</li><li>常用于查找满足某种条件的对或子序列。</li><li>也可以实现动态的查找。</li></ul></li></ul><h3 id="3-滑动窗口"><a href="#3-滑动窗口" class="headerlink" title="3. 滑动窗口"></a>3. 滑动窗口</h3><ul><li><strong>应用场景</strong>：解决子数组问题，如最长无重复子串、最小覆盖子串。</li><li><strong>方法</strong>：<ul><li>使用两个指针定义一个窗口，初始时窗口为空。</li><li>移动右指针扩展窗口，移动左指针缩小窗口，直到满足条件。</li><li>在每次窗口变化时更新结果。</li></ul></li></ul><h3 id="示例：使用双指针解决有序数组中的两数之和"><a href="#示例：使用双指针解决有序数组中的两数之和" class="headerlink" title="示例：使用双指针解决有序数组中的两数之和"></a>示例：使用双指针解决有序数组中的两数之和</h3><p>假设我们有一个有序数组，想找到两个数，使它们的和等于目标值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; numbers, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = numbers.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>        <span class="hljs-type">int</span> sum = numbers[left] + numbers[right];<br>        <span class="hljs-keyword">if</span> (sum == target) &#123;<br>            <span class="hljs-keyword">return</span> &#123;left + <span class="hljs-number">1</span>, right + <span class="hljs-number">1</span>&#125;; <span class="hljs-comment">// 返回索引从1开始</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &lt; target) &#123;<br>            left++; <span class="hljs-comment">// 增加左指针以增加总和</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            right--; <span class="hljs-comment">// 减少右指针以减少总和</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> &#123;&#125;; <span class="hljs-comment">// 如果没有找到，返回空</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>双指针技巧通过合理移动两个指针，可以有效地减少遍历次数或简化算法逻辑。选择合适的双指针策略（如快慢指针、左右指针、滑动窗口）可以帮助解决许多复杂的算法问题。</p><h2 id="4-ACwing-633-两数平方和判断"><a href="#4-ACwing-633-两数平方和判断" class="headerlink" title="4. ACwing 633 两数平方和判断"></a>4. ACwing 633 两数平方和判断</h2><p>给定一个非负整数 <code>c</code> ，你要判断是否存在两个整数 <code>a</code> 和 <code>b</code>，使得 <code>a^2 + b^2 = c</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：c = 5<br>输出：true<br>解释：1 *<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 2 </span>*<span class="hljs-number"> 2 </span>= 5<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs llvm">输入：<span class="hljs-keyword">c</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span><br>输出：<span class="hljs-keyword">false</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= c &lt;= 2^31 - 1</code></li></ul><p>最暴力的解法：双循环暴力枚举（复杂度：O(n^2))</p><p>优化方法：使用sqrt函数省去一层循环</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">judgeSquareSum</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span> </span>&#123;<br>        <span class="hljs-type">double</span> b;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">long</span> <span class="hljs-type">long</span>  i=<span class="hljs-number">0</span>;(i)*i&lt;=c;i++)&#123;<br>            b=<span class="hljs-built_in">sqrt</span>(c-i*i);&#123;<br>                <span class="hljs-keyword">if</span>(b==<span class="hljs-built_in">int</span>(b))&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="补充方法：使用双指针枚举"><a href="#补充方法：使用双指针枚举" class="headerlink" title="补充方法：使用双指针枚举"></a>补充方法：使用双指针枚举</h4><p><img src="/posts/Above-All/istake-collection-21-30/1.png" alt="two pointers"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">judgeSquareSum</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span> </span>&#123;<br>        <span class="hljs-type">long</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">long</span> right = (<span class="hljs-type">int</span>)<span class="hljs-built_in">sqrt</span>(c);<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-type">long</span> sum = left * left + right * right;<br>            <span class="hljs-keyword">if</span> (sum == c) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &gt; c) &#123;<br>                right--;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                left++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h1 id="程序设计错题-25-30-20241105"><a href="#程序设计错题-25-30-20241105" class="headerlink" title="程序设计错题  25-30 20241105"></a>程序设计错题  25-30 20241105</h1><h2 id="1-Leetcode-877-先手必胜策略判断"><a href="#1-Leetcode-877-先手必胜策略判断" class="headerlink" title="1. Leetcode 877 先手必胜策略判断"></a>1. Leetcode 877 先手必胜策略判断</h2><p>Alice 和 Bob 用几堆石子在做游戏一共有偶数堆石子，<strong>排成一行</strong>；每堆都有 <strong>正</strong> 整数颗石子，数目为 <code>piles[i]</code> 。</p><p>游戏以谁手中的石子最多来决出胜负。石子的 <strong>总数</strong> 是 <strong>奇数</strong> ，所以没有平局。</p><p>Alice 和 Bob 轮流进行，<strong>Alice 先开始</strong> 。 每回合，玩家从行的 <strong>开始</strong> 或 <strong>结束</strong> 处取走整堆石头。 这种情况一直持续到没有更多的石子堆为止，此时手中 <strong>石子最多</strong> 的玩家 <strong>获胜</strong> 。</p><p>假设 Alice 和 Bob 都发挥出最佳水平，当 Alice 赢得比赛时返回 <code>true</code> ，当 Bob 赢得比赛时返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：piles = [5,3,4,5]<br>输出：true<br>解释：<br>Alice 先开始，只能拿前<span class="hljs-number"> 5 </span>颗或后<span class="hljs-number"> 5 </span>颗石子 。<br>假设他取了前<span class="hljs-number"> 5 </span>颗，这一行就变成了 [3,4,5] 。<br>如果 Bob 拿走前<span class="hljs-number"> 3 </span>颗，那么剩下的是 [4,5]，Alice 拿走后<span class="hljs-number"> 5 </span>颗赢得<span class="hljs-number"> 10 </span>分。<br>如果 Bob 拿走后<span class="hljs-number"> 5 </span>颗，那么剩下的是 [3,4]，Alice 拿走后<span class="hljs-number"> 4 </span>颗赢得<span class="hljs-number"> 9 </span>分。<br>这表明，取前<span class="hljs-number"> 5 </span>颗石子对 Alice 来说是一个胜利的举动，所以返回 true 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">piles</span> = [<span class="hljs-number">3</span>,<span class="hljs-number">7</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>2 &lt;= piles.length &lt;= 500</code></li><li><code>piles.length</code> 是 <strong>偶数</strong></li><li><code>1 &lt;= piles[i] &lt;= 500</code></li><li><code>sum(piles[i])</code> 是 <strong>奇数</strong></li></ul><p><strong>分析</strong>：此题贪婪算法并不适应，因为局部最优并不是全局最优</p><h4 id="为什么不能用贪婪算法？"><a href="#为什么不能用贪婪算法？" class="headerlink" title="为什么不能用贪婪算法？"></a>为什么不能用贪婪算法？</h4><ol><li><strong>局部最优不等于全局最优</strong>：在这种零和博弈中，贪婪策略只能保证每次选择当前最佳（即最多的石子堆），但这并不一定能得到最终的胜利。因为后续的选择会影响到剩余石子的选择，而不只是当前的选择。例如，某个玩家如果总是选择当前最多的石子堆，可能会在后续失去更多的机会，最终导致输掉游戏。</li><li><strong>博弈的前瞻性</strong>：每次玩家的选择不仅仅影响当前局面，还会影响到接下来的选择。理想的策略需要考虑未来的回合，预测对方的反应，并选择一个能最终获得胜利的方案。贪婪算法通常缺乏这种全局视野。</li><li><strong>博弈的相互作用</strong>：这道题的核心在于两方玩家都在做决策，而每个决策都会影响到后续的局面。需要通过动态规划来考虑在所有可能的局面下，哪种选择能够获得最终最优的结果。</li></ol><h3 id="解法-：区间动态规划"><a href="#解法-：区间动态规划" class="headerlink" title="解法 ：区间动态规划"></a>解法 ：区间动态规划</h3><p>为了求解这个问题，我们可以定义一个动态规划表 <code>dp[i][j]</code> 来表示在石子堆的区间 <code>[i, j]</code> 中，<strong>当前玩家</strong>（注意有可能是Bob！）与对手玩家的所得到石子之差的最大值。</p><h4 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h4><p>假设当前玩家面对的石子堆是 <code>[i, j]</code>，他可以选择：</p><ul><li>从前端取走 <code>piles[i]</code>，剩下的区间是 <code>[i+1, j]</code>，这个时候，剩下的区间 <code>[i+1, j]</code> 会是对方的回合。</li><li>从后端取走 <code>piles[j]</code>，剩下的区间是 <code>[i, j-1]</code>，这个时候，剩下的区间 <code>[i, j-1]</code> 会是对方的回合。</li></ul><p>对于每种选择，当前玩家的得分是<strong>他取走的石子的数量加上对方在剩余区间中的最差得分</strong>。为了确保当前玩家的策略最优，我们需要选取对方最差的选择（即，最小化对方得到的分数）。</p><p>因此，状态转移方程为：</p><ul><li><code>dp[i][j] = max(piles[i] + (sum(i+1, j) - dp[i+1][j]), piles[j] + (sum(i, j-1) - dp[i][j-1]))</code></li><li>这里是全局最优解！</li></ul><p>其中，<code>sum(i, j)</code> 是从 <code>i</code> 到 <code>j</code> 的石子堆总数。</p><h4 id="动态规划实现"><a href="#动态规划实现" class="headerlink" title="动态规划实现"></a>动态规划实现</h4><p>为了避免重复计算区间和，我们可以预先计算所有区间的石子总和，并使用这些预计算的和来加速我们的 DP 计算。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">stoneGame</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; piles)</span> </span>&#123;<br>        <span class="hljs-type">int</span> length = piles.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">auto</span> dp = vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;(length, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(length));<br>        <span class="hljs-comment">//定义二维数组</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>            dp[i][i] = piles[i];<br>        &#125;<br>        <span class="hljs-comment">//特殊情况：游戏进行到了最后一轮</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = length - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; length; j++) &#123;<br>                dp[i][j] = <span class="hljs-built_in">max</span>(piles[i] - dp[i + <span class="hljs-number">1</span>][j], piles[j] - dp[i][j - <span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//特殊的检索方法。类似于一个上三角矩阵并且确定了矩阵主对角线的元素的值</span><br>        <span class="hljs-comment">//这样可以保证每个元素在递归的时候都有值！</span><br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][length - <span class="hljs-number">1</span>] &gt; <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//dp[0][length - 1]代表能拿到的最优解</span><br>        <span class="hljs-comment">//在这里使用了归一化的思路，这样只要判断是否&gt;0就行了</span><br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><p>使用不同的动态规划数组：</p><p>​dp代表当前玩家在当前状态下，能够得到的最优解</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">stoneGame</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; piles)</span> </span>&#123;<br>        <br>        <span class="hljs-type">int</span> length=piles.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">auto</span> sumcount=vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;(length,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(length));<br>        <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;length;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;length;j++)&#123;<br>                <span class="hljs-keyword">if</span>(j&lt;i)&#123;<br>                    sumcount[i][j]=<span class="hljs-number">0</span>;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=i;k&lt;=j;k++)&#123;<br>                        sum+=piles[k];<br>                    &#125;<br>                    sumcount[i][j]=sum;<br>                    sum=<span class="hljs-number">0</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">auto</span> dp = vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;(length,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(length));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;length;i++)&#123;<br>            dp[i][i]=<span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=length<span class="hljs-number">-2</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i<span class="hljs-number">+1</span>;j&lt;length;j++)&#123;<br>                dp[i][j]=<span class="hljs-built_in">max</span>(piles[i]+sumcount[i<span class="hljs-number">+1</span>][j]-dp[i<span class="hljs-number">+1</span>][j],piles[j]+sumcount[i][j<span class="hljs-number">-1</span>]-dp[i][j<span class="hljs-number">-1</span>]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-number">2</span>*dp[<span class="hljs-number">0</span>][length<span class="hljs-number">-1</span>]&gt;sumcount[<span class="hljs-number">0</span>][length<span class="hljs-number">-1</span>])&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="2-Leetcode-942-DI字符串序列匹配生成"><a href="#2-Leetcode-942-DI字符串序列匹配生成" class="headerlink" title="2. Leetcode 942 DI字符串序列匹配生成"></a>2. Leetcode 942 DI字符串序列匹配生成</h2><p>由范围 <code>[0,n]</code> 内所有整数组成的 <code>n + 1</code> 个整数的排列序列可以表示为长度为 <code>n</code> 的字符串 <code>s</code> ，其中:</p><ul><li>如果 <code>perm[i] &lt; perm[i + 1]</code> ，那么 <code>s[i] == &#39;I&#39;</code> </li><li>如果 <code>perm[i] &gt; perm[i + 1]</code> ，那么 <code>s[i] == &#39;D&#39;</code></li></ul><p>给定一个字符串 <code>s</code> ，重构排列 <code>perm</code> 并返回它。如果有多个有效排列perm，则返回其中 <strong>任何一个</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：s = <span class="hljs-string">&quot;IDID&quot;</span><br>输出：[<span class="hljs-number">0</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：s = <span class="hljs-string">&quot;III&quot;</span><br>输出：[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：s = <span class="hljs-string">&quot;DDI&quot;</span><br>输出：[<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><h3 id="非常经典的贪心算法！"><a href="#非常经典的贪心算法！" class="headerlink" title="非常经典的贪心算法！"></a>非常经典的贪心算法！</h3><p>考虑 perm[0] 的值，根据题意：</p><p>如果 s[0]&#x3D;‘I’，那么令 perm[0]&#x3D;0，则无论 perm[1] 为何值都满足 perm[0]&lt;perm[1]；<br>如果 s[0]&#x3D;‘D’，那么令 perm[0]&#x3D;n，则无论 perm[1] 为何值都满足 perm[0]&gt;perm[1]；<br>确定好 perm[0] 后，剩余的 n−1 个字符和 n 个待确定的数就变成了一个和原问题相同，但规模为 n−1 的问题。因此我们可以继续按照上述方法确定 perm[1]：如果 s[1]&#x3D;‘I’，那么令 perm[1] 为剩余数字中的最小数；如果 s[1]&#x3D;‘D’，那么令 perm[1] 为剩余数字中的最大数。如此循环直至剩下一个数，填入 perm[n] 中。</p><p>如何实现该贪心算法？</p><h3 id="解法1：使用set容器自动削头去尾"><a href="#解法1：使用set容器自动削头去尾" class="headerlink" title="解法1：使用set容器自动削头去尾"></a>解法1：使用set容器自动削头去尾</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">diStringMatch</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        vector &lt;<span class="hljs-type">int</span>&gt; ans;<br>        <span class="hljs-type">int</span> n=s.<span class="hljs-built_in">length</span>();<br>        set &lt;<span class="hljs-type">int</span>&gt; allthenum;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;i++)&#123;<br>            allthenum.<span class="hljs-built_in">insert</span>(i);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;I&#x27;</span>)&#123;<br>                ans.<span class="hljs-built_in">push_back</span>(*(allthenum.<span class="hljs-built_in">begin</span>()));<br>                allthenum.<span class="hljs-built_in">erase</span>(allthenum.<span class="hljs-built_in">begin</span>());<br><br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                ans.<span class="hljs-built_in">push_back</span>((*<span class="hljs-built_in">prev</span>(allthenum.<span class="hljs-built_in">end</span>())));<br>                allthenum.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">prev</span>(allthenum.<span class="hljs-built_in">end</span>()));<br>                <br>            &#125;<br>        &#125;<br>        ans.<span class="hljs-built_in">push_back</span>(*(allthenum.<span class="hljs-built_in">begin</span>()));<br>        <span class="hljs-keyword">return</span> ans;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>set容器的底层是红黑树，可以实现自动元素的排序，但不支持元素的索引，要使用迭代器</strong></p><p><code>std::set</code>的迭代器是双向迭代器（bidirectional iterator），而不是随机访问迭代器（random access iterator），因此不支持减法操作。</p><p>如果你想获取<code>std::set</code>中最后一个元素的值，可以使用如下方法：</p><p>使用<code>std::prev</code></p><p><code>std::prev</code>是一个标准库函数，用于获取给定迭代器的前一个位置。你可以使用它来获取<code>set</code>的最后一个元素：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iterator&gt;</span> <span class="hljs-comment">// for std::prev</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::set&lt;<span class="hljs-type">int</span>&gt; allthenum = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><br>    <span class="hljs-comment">// 获取 set 的最后一个元素</span><br>    <span class="hljs-keyword">if</span> (!allthenum.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-type">int</span> lastElement = *std::<span class="hljs-built_in">prev</span>(allthenum.<span class="hljs-built_in">end</span>());<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Last element: &quot;</span> &lt;&lt; lastElement &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>allthenum.end()</code>返回的是一个指向<code>set</code>末尾的迭代器（即在最后一个元素之后的位置）。</li><li><code>std::prev(allthenum.end())</code>返回的是指向最后一个元素的迭代器。</li><li>使用<code>*</code>解引用这个迭代器来获取最后一个元素的值。</li></ul><p>这种方法是标准的方式来访问<code>std::set</code>的最后一个元素。确保在访问元素之前，检查集合是否为空，以避免解引用无效迭代器。</p><h3 id="解法2：优化解法：这里斩头或者去尾并不会改变剩下元素的排列顺序，所以可以使用vector数组（略）"><a href="#解法2：优化解法：这里斩头或者去尾并不会改变剩下元素的排列顺序，所以可以使用vector数组（略）" class="headerlink" title="解法2：优化解法：这里斩头或者去尾并不会改变剩下元素的排列顺序，所以可以使用vector数组（略）"></a>解法2：优化解法：这里斩头或者去尾并不会改变剩下元素的排列顺序，所以可以使用vector数组（略）</h3><p>此处也可以选择不开新的数组，直接使用双指针完成</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">diStringMatch</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">length</span>(), lo = <span class="hljs-number">0</span>, hi = n;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">perm</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            perm[i] = (s[i] == <span class="hljs-string">&#x27;I&#x27;</span> ? lo++ : hi--);<br>        &#125;<br>        perm[n] = lo; <span class="hljs-comment">// 最后剩下一个数，此时 lo == hi</span><br>        <span class="hljs-keyword">return</span> perm;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h2 id="3-Leetcode-11-盛水容器"><a href="#3-Leetcode-11-盛水容器" class="headerlink" title="3. Leetcode 11 盛水容器"></a>3. Leetcode 11 盛水容器</h2><p>给定一个长度为 <code>n</code> 的整数数组 <code>height</code> 。有 <code>n</code> 条垂线，第 <code>i</code> 条线的两个端点是 <code>(i, 0)</code> 和 <code>(i, height[i])</code> 。</p><p>找出其中的两条线，使得它们与 <code>x</code> 轴共同构成的容器可以容纳最多的水。</p><p>返回容器可以储存的最大水量。</p><p><strong>说明：</strong>你不能倾斜容器。</p><p><strong>示例 1：</strong></p><p><img src="https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg" alt="img"></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：[<span class="hljs-number">1,8,6,2</span>,<span class="hljs-number">5,4,8,3</span>,<span class="hljs-number">7</span>]<br>输出：<span class="hljs-number">49</span> <br>解释：图中垂直线代表输入数组 [<span class="hljs-number">1,8,6,2</span>,<span class="hljs-number">5,4,8,3</span>,<span class="hljs-number">7</span>]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 <span class="hljs-number">49</span>。<br></code></pre></td></tr></table></figure><p>最暴力解法：双枚举（超时）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxArea</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; height)</span> </span>&#123;<br>        <span class="hljs-type">long</span> max=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">long</span> ans;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;height.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i<span class="hljs-number">+1</span>;j&lt;height.<span class="hljs-built_in">size</span>();j++)&#123;<br>                ans=(j-i)*<span class="hljs-built_in">min</span>(height[i],height[j]);<br>                <span class="hljs-keyword">if</span>(ans&gt;max)&#123;<br>                    max=ans;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="解法优化：对枚举的剪枝操作"><a href="#解法优化：对枚举的剪枝操作" class="headerlink" title="解法优化：对枚举的剪枝操作"></a>解法优化：对枚举的剪枝操作</h4><p>剪枝算法是一种在搜索算法中用于减少计算量和提高效率的技术。它通过在搜索过程中剪去不必要的分支，从而避免遍历整个搜索空间。剪枝算法在许多领域中都有应用，尤其是在解决组合优化问题和博弈树搜索（如棋类游戏）时非常有效。以下是剪枝算法的一些关键概念和常见应用：</p><h5 id="关键概念"><a href="#关键概念" class="headerlink" title="关键概念"></a>关键概念</h5><ol><li><p><strong>搜索空间</strong>：这是所有可能解的集合。搜索算法的目标是找到满足某些条件的解。</p></li><li><p><strong>剪枝条件</strong>：在搜索过程中，算法会评估当前路径或分支是否有可能产生更优解。如果确定某个分支不可能产生更优解，则可以安全地剪去该分支。</p></li><li><p><strong>有效性</strong>：剪枝的有效性在于它能显著减少需要评估的节点数量，从而加快搜索速度。</p></li></ol><h5 id="常见类型"><a href="#常见类型" class="headerlink" title="常见类型"></a>常见类型</h5><ol><li><p><strong>Alpha-Beta 剪枝</strong>：</p><ul><li>这是博弈树搜索中常用的剪枝算法，特别是在两人零和游戏中（如国际象棋、围棋）。</li><li>它通过维护两个值（alpha 和 beta）来跟踪当前已知的最佳选择，从而剪去不可能影响最终决策的分支。</li></ul></li><li><p><strong>分支限界法</strong>：</p><ul><li>这是一种用于解决组合优化问题（如旅行商问题、背包问题）的算法。</li><li>它通过在搜索过程中计算当前路径的下界，并与当前已知的最优解进行比较，来决定是否剪去某个分支。</li></ul></li></ol><h5 id="应用领域"><a href="#应用领域" class="headerlink" title="应用领域"></a>应用领域</h5><ul><li><strong>人工智能和游戏</strong>：在游戏 AI 中，剪枝算法用于减少需要考虑的可能动作组合。</li><li><strong>组合优化</strong>：在解决诸如旅行商问题、背包问题等问题时，剪枝算法可以显著减少计算复杂度。</li><li><strong>决策树</strong>：在机器学习中，剪枝用于简化决策树模型，防止过拟合。</li></ul><h5 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h5><ul><li><strong>提高效率</strong>：通过减少需要评估的节点数量，剪枝算法可以显著加快搜索速度。</li><li><strong>节省资源</strong>：减少计算和内存使用，使得算法能够处理更大的问题规模。</li></ul><p>剪枝算法的核心在于通过合理的评估和决策，<strong>避免不必要的计算</strong>，从而提升算法的整体性能。</p><p>有哪些不必要的计算？</p><ul><li><p>嵌套循环————双指针</p></li><li><p>在指针移动是根据判定进行移动，而不是先移动再做判断</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxArea</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; height)</span> </span>&#123;<br>        <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,j=height.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-type">long</span> max=<span class="hljs-built_in">min</span>(height[<span class="hljs-number">0</span>],height[j])*(height.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>);<br>        <span class="hljs-type">long</span> ans;<br>        <span class="hljs-keyword">while</span>(i&lt;j)&#123;<br>            ans=<span class="hljs-built_in">min</span>(height[i],height[j])*(j-i);<br>            <span class="hljs-keyword">if</span>(ans&gt;max)&#123;<br>                max=ans;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(height[i]&lt;height[j])&#123;<br>                i++;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                j--;<br>            &#125;<br>            <span class="hljs-comment">//关键的if—else语句，确定是哪边往哪个方向移动。</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>时间复杂度：O(n)</p></li></ul><h2 id="4-Leetcode-121-买卖股票的最佳时期"><a href="#4-Leetcode-121-买卖股票的最佳时期" class="headerlink" title="4 Leetcode 121 买卖股票的最佳时期"></a>4 Leetcode 121 买卖股票的最佳时期</h2><p>给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。</p><p>你只能选择 <strong>某一天</strong> 买入这只股票，并选择在 <strong>未来的某一个不同的日子</strong> 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p><p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 <code>0</code> 。</p><p>方法1：暴力方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(prices.<span class="hljs-built_in">size</span>()==<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <br>        <span class="hljs-type">int</span> summax=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i<span class="hljs-number">+1</span>&lt;prices.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i<span class="hljs-number">+1</span>;j&lt;prices.<span class="hljs-built_in">size</span>();j++)&#123;<br>                <span class="hljs-keyword">if</span>(prices[j]-prices[i]&gt;summax)&#123;<br>                    summax=prices[j]-prices[i];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> summax;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>方法2：优化暴力双循环（枚举剪枝）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(prices.<span class="hljs-built_in">size</span>()==<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <br>        <span class="hljs-type">int</span> summax=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i<span class="hljs-number">+1</span>&lt;prices.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(i&gt;=<span class="hljs-number">1</span>&amp;&amp;prices[i]&gt;prices[i<span class="hljs-number">-1</span>])&#123;<br>                <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-comment">//去掉一些完全不可能的情况（枚举剪枝）</span><br>            &#125;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i<span class="hljs-number">+1</span>;j&lt;prices.<span class="hljs-built_in">size</span>();j++)&#123;<br>                <span class="hljs-keyword">if</span>(j&gt;=<span class="hljs-number">1</span>&amp;&amp;prices[j]&lt;prices[j<span class="hljs-number">-1</span>])&#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(prices[j]-prices[i]&gt;summax)&#123;<br>                    summax=prices[j]-prices[i];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> summax;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>方法3：一次遍历（双指针）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(prices.<span class="hljs-built_in">size</span>()==<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,j=<span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//前后指针：j为前置指针，i为后置指针</span><br>        <span class="hljs-type">int</span> summax=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(j&lt;prices.<span class="hljs-built_in">size</span>())&#123;<br>            <span class="hljs-keyword">if</span>(prices[j]&lt;prices[i])&#123;<br>                i=j;<br>                <span class="hljs-comment">//更新i的位置</span><br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">if</span>(prices[j]-prices[i]&gt;summax)&#123;<br>                    summax=prices[j]-prices[i];<br>                &#125;<br>            &#125;<br>            j++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> summax;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>方法4：核心：在任何时刻，最大利润等于当前价格减去最低价格</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;<br>        <span class="hljs-comment">// 初始化一个很大的数值作为初始的股票最低价格</span><br>        <span class="hljs-type">int</span> inf = <span class="hljs-number">1e9</span>;<br>        <span class="hljs-type">int</span> minprice = inf;<br>        <span class="hljs-comment">// 初始化最大利润为0</span><br>        <span class="hljs-type">int</span> maxprofit = <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-comment">// 遍历价格数组</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> price : prices) &#123;<br>            <span class="hljs-comment">// 计算当前的利润（当前价格减去最低价格），并更新最大利润</span><br>            maxprofit = <span class="hljs-built_in">max</span>(maxprofit, price - minprice);<br>            <span class="hljs-comment">//price-mimprice就是在price之前的所有数的最小值！</span><br>            <span class="hljs-comment">// 更新最低价格</span><br>            minprice = <span class="hljs-built_in">min</span>(price, minprice);<br>        &#125;<br>        <br>        <span class="hljs-comment">// 返回最大利润</span><br>        <span class="hljs-keyword">return</span> maxprofit;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h2 id="5-Leetcode-136-只出现一次的数字"><a href="#5-Leetcode-136-只出现一次的数字" class="headerlink" title="5 Leetcode 136 只出现一次的数字"></a>5 Leetcode 136 只出现一次的数字</h2><p>给你一个 <strong>非空</strong> 整数数组 <code>nums</code> ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p><p>你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。</p><p>方法1：哈希表存储（线性时间复杂度&amp;线性空间复杂度）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        unordered_set&lt;<span class="hljs-type">int</span>&gt; judge;<br>        <span class="hljs-type">long</span> sum1=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> num:nums)&#123;<br>            sum1+=num;<br>            <span class="hljs-keyword">if</span>(judge.<span class="hljs-built_in">find</span>(num)==judge.<span class="hljs-built_in">end</span>())&#123;<br>                judge.<span class="hljs-built_in">insert</span>(num);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                sum1-=<span class="hljs-number">2</span>*num;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum1;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>方法2：使用<strong>位运算</strong>！</p><h3 id="补充：位运算中的异或运算"><a href="#补充：位运算中的异或运算" class="headerlink" title="补充：位运算中的异或运算"></a>补充：位运算中的异或运算</h3><p>异或运算（XOR，eXclusive OR）是一种逻辑运算，它在计算机科学和数学中有着广泛的应用。以下是关于异或运算的原理和运算律的简要介绍：</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>异或运算的基本规则如下：</p><ul><li><strong>0 XOR 0 &#x3D; 0</strong></li><li><strong>1 XOR 0 &#x3D; 1</strong></li><li><strong>0 XOR 1 &#x3D; 1</strong></li><li><strong>1 XOR 1 &#x3D; 0</strong></li></ul><p>换句话说，两个操作数不同时结果为1，相同则结果为0。这解释了“eXclusive OR”的含义，即“排他或”。</p><p>对于十进制数：a^0&#x3D;a！</p><h4 id="运算律"><a href="#运算律" class="headerlink" title="运算律"></a>运算律</h4><p>异或运算具有以下特性：</p><ol><li><p><strong>交换律（Commutative Law）</strong>：</p><ul><li><code>A ^ B = B ^ A</code>，即异或操作的结果与操作数的顺序无关。</li></ul></li><li><p><strong>结合律（Associative Law）</strong>：</p><ul><li><code>(A ^ B) ^ C = A ^ (B ^ C)</code>，这意味着异或操作可以任意分组进行。</li></ul></li><li><p><strong>恒等律（Identity Law）</strong>：</p><ul><li><code>A ^ 0 = A</code>，即任何数与0异或，结果还是该数。</li></ul></li><li><p><strong>自反律（Self-Inverse Law）</strong>：</p><ul><li><code>A ^ A = 0</code>，任何数与自身异或，结果为0。</li></ul></li><li><p><strong>零元素（Zero Element）</strong>：</p><ul><li><code>A ^ 1 = ~A</code>（即A的补码），这表明1在异或运算中起到了一种特殊的作用，它可以翻转操作数的每一位。</li></ul></li><li><p><strong>分配律（Distributive Law）</strong>：</p><ul><li>异或运算不遵循传统意义上的分配律，但它与与运算（AND）有部分分配律：<ul><li><code>A ^ (B &amp; C) = (A ^ B) &amp; (A ^ C)</code>，这在某些情况下可以用于简化计算。</li></ul></li></ul></li></ol><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><ul><li><strong>数据校验</strong>：异或运算常用于数据校验，如奇偶校验或检验和。</li><li><strong>加密</strong>：在一些简单的加密算法中使用异或运算，因为它可以隐藏信息。</li><li><strong>位操作</strong>：在编程中，异或运算可以用来交换变量值（不使用临时变量），翻转特定位，计算汉明距离等。</li><li><strong>解决问题</strong>：在算法设计中，异或运算可以用于解决一些特殊问题，如找出数组中唯一不重复的元素。</li></ul><p>异或运算由于其独特的特性，在计算机编程和数字电路设计中都有广泛的应用，它提供了一种非常高效的方式来处理和操作二进制数据。</p><p>所以：<strong>对这个数组的所有数进行位运算</strong>，最后通过位运算的 <strong>结合律和交换律</strong>，一定可以化成a^0&#x3D;a的形式，其中a就是目标数！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> e: nums) ret ^= e;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h2 id="6-Leetcode-169-多数元素问题"><a href="#6-Leetcode-169-多数元素问题" class="headerlink" title="6 Leetcode 169 多数元素问题"></a>6 Leetcode 169 多数元素问题</h2><p><strong>非常经典的一道例题！</strong></p><p>给定一个大小为 <code>n</code> 的数组 <code>nums</code> ，返回其中的多数元素。多数元素是指在数组中出现次数 <strong>大于</strong> <code>⌊ n/2 ⌋</code> 的元素。</p><p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p><h4 id="方法1：使用哈希表（unordered-map"><a href="#方法1：使用哈希表（unordered-map" class="headerlink" title="方法1：使用哈希表（unordered_map)"></a>方法1：使用哈希表（unordered_map)</h4><p>时空复杂度均为O(n)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n=nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> standard=n/<span class="hljs-number">2</span>;<br>        unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; Mymap;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> num:nums)&#123;<br>            <span class="hljs-keyword">if</span>(Mymap.<span class="hljs-built_in">find</span>(num)!=Mymap.<span class="hljs-built_in">end</span>())&#123;<br>                Mymap[num]++;<br>                <span class="hljs-keyword">if</span>(Mymap[num]&gt;standard)&#123;<br>                    <span class="hljs-keyword">return</span> num;<br>                &#125;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                Mymap.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(num,<span class="hljs-number">1</span>));<br>                <span class="hljs-keyword">if</span>(Mymap[num]&gt;standard)&#123;<br>                    <span class="hljs-keyword">return</span> num;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> &#123;&#125;;<br>       <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="方法2：字符串匹配算法"><a href="#方法2：字符串匹配算法" class="headerlink" title="方法2：字符串匹配算法"></a>方法2：字符串匹配算法</h4><p>（详细内容见补充讲义：KMP算法和BM算法）：两种十分高效的字符串检索算法</p><p>首先：如果一个数组存在多数元素，<strong>则多数元素唯一</strong></p><p>所以多数元素一定会被当选作为candidate！</p><p><strong><code>Boyer-Moore 投票算法</code></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> candidate = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 假设第一个元素是候选者</span><br>        <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;      <span class="hljs-comment">// 计数器</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            <span class="hljs-keyword">if</span> (count == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// 如果计数器为0，则将当前元素设为新的候选者(因为如果count==0,说明当前的candidate元素肯定不是多数元素！)</span><br>                candidate = num;<br>                <span class="hljs-comment">//选择了一位新的候选者！</span><br>            &#125;<br>            <br>            <span class="hljs-comment">// 如果当前元素与候选者相同，计数器加1；否则减1</span><br>            count += (num == candidate) ? <span class="hljs-number">1</span> : <span class="hljs-number">-1</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 在结束遍历后，candidate 就是多数元素</span><br>        <span class="hljs-keyword">return</span> candidate;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><p>算法解释：</p><p>这个算法基于一个关键的观察：如果一个元素是多数元素，<strong>那么它出现的次数一定超过数组长度的一半</strong>。因此：</p><ul><li>每次我们遇到一个与当前候选者相同的元素，<code>count</code>就增加1，因为这支持了我们的候选者。</li><li>每次遇到不同的元素，<code>count</code>就减1，因为这对当前候选者不利。</li></ul><p>由于多数元素出现的次数超过一半，只要我们遍历完整个数组，最后剩下的候选者一定是多数元素。这是因为：</p><ul><li>当<code>count</code>为0时，我们选择新的候选者，这意味着之前的候选者在当前位置之前出现的次数和非候选者出现的次数相等。</li><li>由于多数元素出现的次数超过一半，在数组结束时，它一定会成为最后的候选者。</li><li>时间复杂度O(n)，空间复杂度O（1）</li></ul><p>算法的弊端：优化了时空复杂度，只依赖一次遍历就解决了问题，但无法解决不存在多数元素的情况！</p><h4 id="方法3：分治算法"><a href="#方法3：分治算法" class="headerlink" title="方法3：分治算法"></a>方法3：分治算法</h4><p>如果数 a 是数组 nums 的众数，如果我们将 nums 分成两部分，那么 a 必定是至少一部分的众数。</p><p>我们可以使用反证法来证明这个结论。假设 a 既不是左半部分的众数，也不是右半部分的众数，那么 a 出现的次数少于 l &#x2F; 2 + r &#x2F; 2 次，其中 l 和 r 分别是左半部分和右半部分的长度。由于 l &#x2F; 2 + r &#x2F; 2 &lt;&#x3D; (l + r) &#x2F; 2，说明 a 也不是数组 nums 的众数，因此出现了矛盾。所以这个结论是正确的。</p><p>这样以来，我们就可以使用分治法解决这个问题：将数组分成左右两部分，分别求出左半部分的众数 a1 以及右半部分的众数 a2，随后在 a1 和 a2 中选出正确的众数。</p><p>根据众数的唯一性，总能通过类似的方法逼近得到最后的众数（<strong>类似于闭区间套定理</strong>）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">count_in_range</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> lo, <span class="hljs-type">int</span> hi)</span> </span>&#123;<br>        <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = lo; i &lt;= hi; ++i)<br>            <span class="hljs-keyword">if</span> (nums[i] == target)<br>                ++count;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>    <span class="hljs-comment">//区间求target出现次数函数</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">majority_element_rec</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> lo, <span class="hljs-type">int</span> hi)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (lo == hi)<br>            <span class="hljs-keyword">return</span> nums[lo];<br>        <span class="hljs-comment">//递归的结束标志</span><br>        <span class="hljs-type">int</span> mid = (lo + hi) / <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> left_majority = <span class="hljs-built_in">majority_element_rec</span>(nums, lo, mid);<br>        <span class="hljs-type">int</span> right_majority = <span class="hljs-built_in">majority_element_rec</span>(nums, mid + <span class="hljs-number">1</span>, hi);<br>        <span class="hljs-comment">//此处为递归的重复调用！</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">count_in_range</span>(nums, left_majority, lo, hi) &gt; (hi - lo + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">return</span> left_majority;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">count_in_range</span>(nums, right_majority, lo, hi) &gt; (hi - lo + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">return</span> right_majority;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">majority_element_rec</span>(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C/C++</tag>
      
      <tag>Leetcode notes</tag>
      
      <tag>algorithm</tag>
      
      <tag>Finished</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode-Mistake-collection-11-20</title>
    <link href="/posts/Leetcode-Mistake-collection-11-20/"/>
    <url>/posts/Leetcode-Mistake-collection-11-20/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Mistake-collection-11-20"><a href="#Leetcode-Mistake-collection-11-20" class="headerlink" title="Leetcode-Mistake-collection-11-20"></a>Leetcode-Mistake-collection-11-20</h1><h1 id="程设错题-6-10-20241015-20241020"><a href="#程设错题-6-10-20241015-20241020" class="headerlink" title="程设错题 6-10 20241015-20241020"></a>程设错题 6-10 20241015-20241020</h1><h2 id="1-ACwing-776-字符串移位问题"><a href="#1-ACwing-776-字符串移位问题" class="headerlink" title="1.ACwing 776 字符串移位问题"></a>1.ACwing 776 字符串移位问题</h2><p>对于一个字符串来说，定义一次循环移位操作为：将字符串的第一个字符移动到末尾形成新的字符串。</p><p>给定两个字符串 s1s1 和 s2s2，要求判定其中一个字符串是否是另一字符串通过若干次循环移位后的新字符串的子串。</p><p>例如 <code>CDAA</code> 是由 <code>AABCD</code> 两次移位后产生的新串 <code>BCDAA</code> 的子串，而 <code>ABCD</code> 与 <code>ACBD</code> 则不能通过多次移位来得到其中一个字符串是新串的子串。</p><p><strong>输入格式</strong></p><p>共一行，包含两个字符串，中间由单个空格隔开。</p><p>字符串只包含字母和数字，长度不超过 3030。</p><p><strong>输出格式</strong></p><p>如果一个字符串是另一字符串通过若干次循环移位产生的新串的子串，则输出 <code>true</code>，否则输出 <code>false</code>。</p><h3 id="基本思路："><a href="#基本思路：" class="headerlink" title="基本思路："></a>基本思路：</h3><ul><li>使用函数，判断一个字符串是不是另一个字符串的子串</li><li>利用for循环实现对目标数组的移位处理，并且对每个新移位的字符串调用该函数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">judgestring</span><span class="hljs-params">(string teststring,string standardstring)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(teststring.<span class="hljs-built_in">length</span>()&lt;standardstring.<span class="hljs-built_in">length</span>())&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">if</span>(teststring.<span class="hljs-built_in">find</span>(standardstring)==<span class="hljs-number">-1</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    string movestring,standardstring;<br>    cin&gt;&gt;movestring&gt;&gt;standardstring;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;movestring.<span class="hljs-built_in">length</span>()<span class="hljs-number">-1</span>;)&#123;<br>        movestring.<span class="hljs-built_in">push_back</span>(movestring[<span class="hljs-number">0</span>]);<br>        movestring.<span class="hljs-built_in">erase</span>(movestring.<span class="hljs-built_in">begin</span>());<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">judgestring</span>(movestring,standardstring))&#123;<br>            cout&lt;&lt;<span class="hljs-string">&quot;true&quot;</span>;<br>            <span class="hljs-keyword">goto</span> end;<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;<span class="hljs-string">&quot;false&quot;</span>;<br>    end:;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="优化思路："><a href="#优化思路：" class="headerlink" title="优化思路："></a>优化思路：</h3><p>若将一个字符串首尾相接，则不需要进行移项操作（相当于顺序没有发生变化）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(string a, string b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> len = a.<span class="hljs-built_in">size</span>();<br>    a += a; <span class="hljs-comment">//复制字符串并连接</span><br>    <span class="hljs-comment">//if (a.find(b) &gt;= 0 &amp;&amp; a.find(b) &lt; len) return true; //判断是否包含</span><br>    <span class="hljs-keyword">if</span> (a.<span class="hljs-built_in">find</span>(b) != string::npos) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">//判断a中是否包含b</span><br>    <span class="hljs-comment">//两种判断方式，推荐第二种，若find函数未找到，则会返回一个特殊常量string::npos</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    string a, b;<br>    cin &gt;&gt; a &gt;&gt; b;<br>    <span class="hljs-keyword">if</span> (a.<span class="hljs-built_in">size</span>() &lt; b.<span class="hljs-built_in">size</span>()) <span class="hljs-built_in">swap</span>(a, b);<br>    <span class="hljs-comment">//默认a是更大的string类</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(a, b)) cout &lt;&lt; <span class="hljs-string">&quot;true&quot;</span>;<br>    <span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-string">&quot;false&quot;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="2-ACwing-777-字符串的最小周期问题"><a href="#2-ACwing-777-字符串的最小周期问题" class="headerlink" title="2.ACwing 777 字符串的最小周期问题"></a>2.ACwing 777 字符串的最小周期问题</h2><p>给定一个字符串s,求其最小的周期格段</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    string s;<br>    <span class="hljs-type">int</span> flag=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=s.<span class="hljs-built_in">length</span>();++i)&#123;<br>        <span class="hljs-comment">//外层循环：枚举可能的周期，从小到大枚举，第一个得到的值就是目标值</span><br>        flag=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(len%i!=<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;i&lt;s.<span class="hljs-built_in">length</span>();j++)&#123;<br>            <span class="hljs-keyword">if</span>(s[j]!=s[j%i])&#123;<br>                <span class="hljs-comment">//核心代码:判断每一个j和j%i是否相等，判断是否符合周期性的定义。</span><br>                flag=<span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(flag)&#123;<br>                cout&lt;&lt;s.<span class="hljs-built_in">length</span>()/i&lt;&lt;endl;<br>                <span class="hljs-keyword">goto</span> :end;<br>            &#125;<br>        &#125;<br>        cout&lt;&lt;<span class="hljs-string">&quot;-1&quot;</span>;<br>        end:;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-Leetcode-217-存在重复元素（进阶版）"><a href="#3-Leetcode-217-存在重复元素（进阶版）" class="headerlink" title="3.Leetcode 217 存在重复元素（进阶版）"></a>3.Leetcode 217 存在重复元素（进阶版）</h2><p><a href="https://leetcode.cn/problems/contains-duplicate/">原题链接</a></p><p>给你一个整数数组 <code>nums</code> 。如果任一值在数组中出现 <strong>至少两次</strong> ，返回 <code>true</code> ；如果数组中每个元素互不相同，返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><p><strong>输入：</strong>nums &#x3D; [1,2,3,1]</p><p><strong>输出：</strong>true</p><p><strong>解释：</strong></p><p>元素 1 在下标 0 和 3 出现。</p><h3 id="1-最暴力方法：使用枚举筛查-O-n-2"><a href="#1-最暴力方法：使用枚举筛查-O-n-2" class="headerlink" title="1.最暴力方法：使用枚举筛查 O(n^2)"></a>1.最暴力方法：使用枚举筛查 O(n^2)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">containsDuplicate</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; findnums;<br>        findnums.<span class="hljs-built_in">reserve</span>(<span class="hljs-number">10000</span>);<br>        <span class="hljs-type">int</span> input=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">auto</span> it=std::<span class="hljs-built_in">find</span>(findnums.<span class="hljs-built_in">begin</span>(),findnums.<span class="hljs-built_in">end</span>(),nums[i]);<br>            <span class="hljs-keyword">if</span>(it!=findnums.<span class="hljs-built_in">end</span>())&#123;<br>                input=<span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                findnums.<span class="hljs-built_in">push_back</span>(nums[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">bool</span>(input);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>分析：效率过低，每次插入一个新值都需要重新查找一遍findnums数组</p><p>优化：将findnums数组优化为unordered_set（使用哈希表来存储出现过的元素效率更高）</p><h3 id="优化代码："><a href="#优化代码：" class="headerlink" title="优化代码："></a>优化代码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">containsDuplicate</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        std::unordered_set&lt;<span class="hljs-type">int</span>&gt; seen;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            <span class="hljs-comment">//编程习惯：遍历的简化写法</span><br>            <span class="hljs-keyword">if</span> (seen.<span class="hljs-built_in">find</span>(num) != seen.<span class="hljs-built_in">end</span>()) &#123;<br>                <span class="hljs-comment">//如果找到了num,直接输出true</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            seen.<span class="hljs-built_in">insert</span>(num);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h3 id="知识补充：哈希表"><a href="#知识补充：哈希表" class="headerlink" title="知识补充：哈希表"></a>知识补充：哈希表</h3><p>​使用哈希表（如 <code>std::unordered_set</code>）存储已经遇到的元素，<strong>时间复杂度更低</strong>的原因主要在于哈希表的查找和插入操作的平均时间复杂度是 O(1)。这是因为哈希表通过哈希函数将元素映射到一个数组中的特定位置，从而实现了快速的查找和插入。以下是详细解释：</p><h5 id="哈希表的工作原理"><a href="#哈希表的工作原理" class="headerlink" title="哈希表的工作原理"></a>哈希表的工作原理</h5><ol><li><strong>哈希函数</strong>：哈希表使用一个哈希函数将每个元素的值转换为一个哈希码（通常是一个整数），这个哈希码对应哈希表中的一个位置（桶）。</li><li><strong>存储位置</strong>：元素被存储在对应的桶中，查找和插入操作都可以通过计算哈希码直接定位到相应的桶，从而避免了线性扫描。</li><li><strong>冲突处理</strong>：当多个元素映射到同一个桶时，哈希表使用冲突处理机制（如链地址法或开放地址法）来处理这些冲突。</li></ol><h5 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h5><ul><li><strong>查找</strong>：在理想情况下，哈希表的查找操作只需计算一次哈希函数并访问一个桶，时间复杂度为 O(1)。</li><li><strong>插入</strong>：插入操作也只需计算一次哈希函数并将元素放入相应的桶中，时间复杂度为 O(1)。</li><li><strong>删除</strong>：类似于查找和插入，删除操作也可以在 O(1) 时间内完成。</li></ul><h5 id="对比线性查找"><a href="#对比线性查找" class="headerlink" title="对比线性查找"></a>对比线性查找</h5><ul><li><strong>线性查找</strong>：在向量或链表中查找一个元素需要遍历所有元素，时间复杂度为 O(n)。（例如vector)</li><li><strong>哈希查找</strong>：在哈希表中查找一个元素平均只需要 O(1) 时间，可以显著提高查找效率。</li></ul><h5 id="实际应用中的考虑"><a href="#实际应用中的考虑" class="headerlink" title="实际应用中的考虑"></a>实际应用中的考虑</h5><p>虽然哈希表的平均时间复杂度是 O(1)，但在最坏情况下（例如哈希函数不均匀导致所有元素映射到同一个桶），时间复杂度可以退化到 O(n)。然而，通过选择合适的哈希函数和合理的负载因子，最坏情况发生的概率可以被大大降低。</p><h5 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h5><p>使用哈希表存储已经遇到的元素，可以利用其快速查找和插入的特性，将包含重复元素的检查操作的时间复杂度从 O(n^2) 降低到 O(n)，在处理大数据集时显著提高性能。</p><h2 id="4-Leetcode-219-存在重复元素II-（进阶版）"><a href="#4-Leetcode-219-存在重复元素II-（进阶版）" class="headerlink" title="4.Leetcode 219 存在重复元素II （进阶版）"></a>4.Leetcode 219 存在重复元素II （进阶版）</h2><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，判断数组中是否存在两个 <strong>不同的索引</strong> <code>i</code> 和 <code>j</code> ，满足 <code>nums[i] == nums[j]</code> 且 <code>abs(i - j) &lt;= k</code> 。如果存在，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p>思路：此处使用unordered_set会比较麻烦，unordered_set 键值对就是自己本身，这里可以使用unordered_map类型的容器，实现两个值之间的一一映射。</p><p>（在上一题中只是判断是否存在，对元素的索引和顺序并未提出要求，故使用unordered_set 即可）</p><h3 id="代码实现：使用映射"><a href="#代码实现：使用映射" class="headerlink" title="代码实现：使用映射"></a>代码实现：使用映射</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">containsNearbyDuplicate</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; dictionary; <span class="hljs-comment">// 用于存储每个元素的最新索引</span><br>        <span class="hljs-type">int</span> length = nums.<span class="hljs-built_in">size</span>(); <span class="hljs-comment">// 获取数组的长度</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123; <span class="hljs-comment">// 遍历数组</span><br>            <span class="hljs-type">int</span> num = nums[i]; <span class="hljs-comment">// 当前元素</span><br>            <span class="hljs-comment">// 如果当前元素已经存在于字典中，并且当前索引与存储的索引之差小于等于 k</span><br>            <span class="hljs-keyword">if</span> (dictionary.<span class="hljs-built_in">count</span>(num) &amp;&amp; i - dictionary[num] &lt;= k) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 找到符合条件的重复元素，返回 true</span><br>            &#125;<br>            dictionary[num] = i; <span class="hljs-comment">// 更新字典中的索引  nums[i]-&gt;i的映射</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 遍历完数组后，未找到符合条件的重复元素，返回 false</span><br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h4 id="相关代码解释"><a href="#相关代码解释" class="headerlink" title="相关代码解释"></a>相关代码解释</h4><ul><li><p>基本思路：创建dictionary的map映射，并对nums数组不断进行操作，如果找到两个相同的元素并且索引小于k，直接return true，如果没有，则储存一对新的映射（元素唯一）</p></li><li><p>unordered_map容器中键值保持唯一性，使用 <code>[]</code> 运算符插入相同键时，新值会覆盖旧值。使用 <code>insert</code> 方法插入相同键时，插入操作会失败，原值保持不变。</p></li><li><p>count函数：</p><p><code>std::unordered_map</code> 的 <code>count</code> 函数用于检查特定键是否存在于映射中。它返回一个整数值，表示具有指定键的元素数量。在 <code>std::unordered_map</code> 中，每个键是唯一的，因此 <code>count</code> 函数的返回值只能是 <code>0</code> 或 <code>1</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">count</span><span class="hljs-params">(<span class="hljs-type">const</span> Key&amp; key)</span> <span class="hljs-type">const</span></span>;<br></code></pre></td></tr></table></figure><ul><li><code>key</code>：要检查的键。</li><li>返回值：如果键存在，则返回 <code>1</code>；否则返回 <code>0</code>。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::unordered_map&lt;<span class="hljs-type">int</span>, std::string&gt; myMap;<br>    myMap[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;one&quot;</span>;<br>    myMap[<span class="hljs-number">2</span>] = <span class="hljs-string">&quot;two&quot;</span>;<br>    myMap[<span class="hljs-number">3</span>] = <span class="hljs-string">&quot;three&quot;</span>;<br><br>    <span class="hljs-type">int</span> key = <span class="hljs-number">2</span>;<br><br>    <span class="hljs-comment">// 使用 count 函数检查键是否存在</span><br>    <span class="hljs-keyword">if</span> (myMap.<span class="hljs-built_in">count</span>(key)) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Key &quot;</span> &lt;&lt; key &lt;&lt; <span class="hljs-string">&quot; exists in the map with value: &quot;</span> &lt;&lt; myMap[key] &lt;&lt; std::endl;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Key &quot;</span> &lt;&lt; key &lt;&lt; <span class="hljs-string">&quot; does not exist in the map.&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">Key <span class="hljs-number">2</span> exists <span class="hljs-keyword">in</span> <span class="hljs-keyword">the</span> map <span class="hljs-keyword">with</span> <span class="hljs-built_in">value</span>: <span class="hljs-literal">two</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="容器：unordered-map简介"><a href="#容器：unordered-map简介" class="headerlink" title="容器：unordered_map简介"></a>容器：unordered_map简介</h4><p><code>unordered_map</code> 是 C++ 标准库中的一个关联容器，用于存储键值对。它基于哈希表实现，提供了平均常数时间复杂度的插入、删除和查找操作。</p><p>特性</p><ol><li><strong>无序存储</strong>：元素存储在哈希表中，因此没有特定的顺序。</li><li><strong>唯一键</strong>：每个键在容器中是唯一的。</li><li><strong>高效操作</strong>：插入、删除和查找操作的平均时间复杂度为 <code>O(1)</code>，最坏情况下为 <code>O(n)</code>，但这种情况很少发生。</li></ol><p>常用操作</p><ul><li><strong>插入元素</strong>：使用 <code>insert</code> 方法或 <code>[]</code> 运算符。</li><li><strong>删除元素</strong>：使用 <code>erase</code> 方法。</li><li><strong>查找元素</strong>：使用 <code>find</code> 方法或 <code>count</code> 方法。</li><li><strong>访问元素</strong>：使用 <code>[]</code> 运算符。</li></ul><p>示例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::unordered_map&lt;<span class="hljs-type">int</span>, std::string&gt; myMap;<br><br>    <span class="hljs-comment">// 插入元素</span><br>    myMap[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;one&quot;</span>;<br>    myMap[<span class="hljs-number">2</span>] = <span class="hljs-string">&quot;two&quot;</span>;<br>    myMap.<span class="hljs-built_in">insert</span>(&#123;<span class="hljs-number">3</span>, <span class="hljs-string">&quot;three&quot;</span>&#125;);<br><br>    <span class="hljs-comment">// 访问元素</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Key 1: &quot;</span> &lt;&lt; myMap[<span class="hljs-number">1</span>] &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Key 2: &quot;</span> &lt;&lt; myMap[<span class="hljs-number">2</span>] &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 查找元素</span><br>    <span class="hljs-keyword">auto</span> it = myMap.<span class="hljs-built_in">find</span>(<span class="hljs-number">3</span>);<br>    <span class="hljs-comment">//find函数用来返回一个迭代器，如果找到就返回特定键值的迭代器，如果没有找到就返回对应的.end()迭代器</span><br>    <span class="hljs-keyword">if</span> (it != myMap.<span class="hljs-built_in">end</span>()) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Found key 3 with value: &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; std::endl;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Key 3 not found.&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-comment">// 删除元素</span><br>    myMap.<span class="hljs-built_in">erase</span>(<span class="hljs-number">2</span>);<br><br>    <span class="hljs-comment">// 检查元素是否存在</span><br>    <span class="hljs-keyword">if</span> (myMap.<span class="hljs-built_in">count</span>(<span class="hljs-number">2</span>)) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Key 2 exists in the map.&quot;</span> &lt;&lt; std::endl;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Key 2 does not exist in the map.&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">Key <span class="hljs-number">1</span>: <span class="hljs-literal">one</span><br>Key <span class="hljs-number">2</span>: <span class="hljs-literal">two</span><br>Found key <span class="hljs-number">3</span> <span class="hljs-keyword">with</span> <span class="hljs-built_in">value</span>: <span class="hljs-literal">three</span><br>Key <span class="hljs-number">2</span> does <span class="hljs-keyword">not</span> exist <span class="hljs-keyword">in</span> <span class="hljs-keyword">the</span> map.<br></code></pre></td></tr></table></figure><h3 id="思路2：滑动窗口"><a href="#思路2：滑动窗口" class="headerlink" title="思路2：滑动窗口"></a>思路2：滑动窗口</h3><p>根据题目要求，并不是所有的题目的数据都要用一个数组进行储存再查找的过程。</p><p>思路：设置滑动窗口的双枚举i，j</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">containsNearbyDuplicate</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i<span class="hljs-number">+1</span>;j&lt;=i+k&amp;&amp;j&lt;nums.<span class="hljs-built_in">size</span>();j++)&#123;<br>                <span class="hljs-keyword">if</span>(nums[i]==nums[j])&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>时间复杂度：O(Kn)      空间复杂度O(1)</p><p>算法优化：</p><p>​考虑数组 nums 中的每个长度不超过 k+1 的滑动窗口，同一个滑动窗口中的任意两个下标差的绝对值不超过 k。如果存在一个滑动窗口，其中有重复元素，则<strong>存在两个不同的下标 i 和 j 满足 nums[i]&#x3D;nums[j] 且 ∣i−j∣≤k</strong>。如果所有滑动窗口中都没有重复元素，则不存在符合要求的下标。因此，只要<strong>遍历每个滑动窗口，判断滑动窗口中是否有重复元素即可</strong>。</p><p>​如果一个滑动窗口的结束下标是 i，则该滑动窗口的开始下标是 max(0,i−k)。可以使用哈希集合存储滑动窗口中的元素。从左到右遍历数组 nums，当遍历到下标 i 时，具体操作如下：</p><p>​如果 i&gt;k，则下标 i−k−1 处的元素被移出滑动窗口，因此将 nums[i−k−1] 从哈希集合中删除；</p><p>​判断 nums[i] 是否在哈希集合中，如果在哈希集合中则在同一个滑动窗口中有重复元素，返回 true，如果不在哈希集合中则将其加入哈希集合。</p><p>​当遍历结束时，如果所有滑动窗口中都没有重复元素，返回 false。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">containsNearbyDuplicate</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        unordered_set&lt;<span class="hljs-type">int</span>&gt; s;<br>        <span class="hljs-comment">//s就是滑动窗口，用一个unordered_set存储，可以减少一个for循环，降低时间复杂度</span><br>        <span class="hljs-type">int</span> length = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i &gt; k) &#123;<br>                s.<span class="hljs-built_in">erase</span>(nums[i - k - <span class="hljs-number">1</span>]);<br>            &#125;<br>            <span class="hljs-comment">//当i&gt;k时，每次执行i++时都需要将滑动窗口的最后一个元素驱逐出窗口</span><br>            <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">count</span>(nums[i])) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            s.<span class="hljs-built_in">emplace</span>(nums[i]);<br>            <span class="hljs-comment">//在每一次i++前，都会插入一个新元素，之后会执行命令count，判断新插入的元素是否已经存在在滑动窗口中，如果是，直接return true</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><p>时间复杂度：O(n)</p><h4 id="emplace函数"><a href="#emplace函数" class="headerlink" title="emplace函数"></a>emplace函数</h4><p><code>emplace</code> 是 C++11 引入的一个成员函数，用于在容器中原地构造元素。对于 <code>unordered_map</code>，<code>emplace</code> 可以避免不必要的临时对象创建和复制，从而提高性能。<code>emplace</code> 方法接受键和值的构造参数，并直接在容器中构造元素。</p><p><code>emplace</code> 的用法</p><p><code>emplace</code> 的函数签名如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span>... Args&gt;<br><span class="hljs-function">std::pair&lt;iterator, <span class="hljs-type">bool</span>&gt; <span class="hljs-title">emplace</span><span class="hljs-params">(Args&amp;&amp;... args)</span></span>;<br></code></pre></td></tr></table></figure><ul><li><strong>参数</strong>：<code>args</code> 是传递给元素构造函数的参数。</li><li><strong>返回值</strong>：返回一个 <code>std::pair</code>，其中第一个元素是指向插入元素的迭代器，第二个元素是一个布尔值，表示插入是否成功。</li></ul><p>示例</p><p>以下示例展示了如何使用 <code>emplace</code> 在 <code>unordered_map</code> 中插入元素：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::unordered_map&lt;<span class="hljs-type">int</span>, std::string&gt; myMap;<br><br>    <span class="hljs-comment">// 使用 emplace 插入元素</span><br>    myMap.<span class="hljs-built_in">emplace</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;one&quot;</span>);<br>    myMap.<span class="hljs-built_in">emplace</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;two&quot;</span>);<br><br>    <span class="hljs-comment">// 打印初始内容</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Initial map:&quot;</span> &lt;&lt; std::endl;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; pair : myMap) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Key: &quot;</span> &lt;&lt; pair.first &lt;&lt; <span class="hljs-string">&quot;, Value: &quot;</span> &lt;&lt; pair.second &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-comment">// 尝试使用 emplace 插入相同键</span><br>    <span class="hljs-keyword">auto</span> result = myMap.<span class="hljs-built_in">emplace</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;uno&quot;</span>);<br><br>    <span class="hljs-keyword">if</span> (result.second) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Emplace succeeded.&quot;</span> &lt;&lt; std::endl;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Emplace failed. Key 1 already exists with value: &quot;</span> &lt;&lt; myMap[<span class="hljs-number">1</span>] &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-comment">// 打印更新后的内容</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Updated map:&quot;</span> &lt;&lt; std::endl;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; pair : myMap) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Key: &quot;</span> &lt;&lt; pair.first &lt;&lt; <span class="hljs-string">&quot;, Value: &quot;</span> &lt;&lt; pair.second &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">Initial map:</span><br><span class="hljs-attr">Key:</span> <span class="hljs-number">1</span><span class="hljs-string">,</span> <span class="hljs-attr">Value:</span> <span class="hljs-string">one</span><br><span class="hljs-attr">Key:</span> <span class="hljs-number">2</span><span class="hljs-string">,</span> <span class="hljs-attr">Value:</span> <span class="hljs-string">two</span><br><span class="hljs-attr">Emplace failed. Key 1 already exists with value:</span> <span class="hljs-string">one</span><br><span class="hljs-attr">Updated map:</span><br><span class="hljs-attr">Key:</span> <span class="hljs-number">1</span><span class="hljs-string">,</span> <span class="hljs-attr">Value:</span> <span class="hljs-string">one</span><br><span class="hljs-attr">Key:</span> <span class="hljs-number">2</span><span class="hljs-string">,</span> <span class="hljs-attr">Value:</span> <span class="hljs-string">two</span><br></code></pre></td></tr></table></figure><p><code>emplace</code> 与 <code>insert</code> 的区别</p><ul><li>**<code>insert</code>**：需要先构造一个临时对象，然后再插入到容器中，可能会有额外的复制或移动操作。</li><li>**<code>emplace</code>**：直接在容器中构造对象，避免了不必要的临时对象创建和复制操作，提高了性能。</li></ul><p>总结</p><ul><li><code>emplace</code> 方法用于在 <code>unordered_map</code> 中原地构造元素，避免不必要的临时对象创建和复制操作。</li><li>如果插入的键已经存在，<code>emplace</code> 操作将失败，原值保持不变。</li></ul><h1 id="程设错题-15-20-20241027-20241031"><a href="#程设错题-15-20-20241027-20241031" class="headerlink" title="程设错题 15-20 20241027-20241031"></a>程设错题 15-20 20241027-20241031</h1><h2 id="1-Leetcode-283-移动零"><a href="#1-Leetcode-283-移动零" class="headerlink" title="1.Leetcode 283 移动零"></a>1.Leetcode 283 移动零</h2><p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p><p><strong>请注意</strong> ，必须在不复制数组的情况下原地对数组进行操作。</p><p><strong>示例 1:</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入: nums = <span class="hljs-string">[0,1,0,3,12]</span><br>输出: <span class="hljs-string">[1,3,12,0,0]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: nums = <span class="hljs-comment">[0]</span><br>输出: <span class="hljs-comment">[0]</span><br></code></pre></td></tr></table></figure><p><strong>提示</strong>:</p><ul><li><code>1 &lt;= nums.length &lt;= 104</code></li><li><code>-231 &lt;= nums[i] &lt;= 231 - 1</code></li></ul><h3 id="解法①"><a href="#解法①" class="headerlink" title="解法①"></a>解法①</h3><p>使用vector数组中的push_back和erase成员函数对数组进行遍历，得到移动完成的数组</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">moveZeroes</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> counter=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> iter=nums.<span class="hljs-built_in">begin</span>();counter&lt;nums.<span class="hljs-built_in">size</span>();counter++)&#123;<br>            <span class="hljs-keyword">if</span>(*(iter)==<span class="hljs-number">0</span>)&#123;<br>                nums.<span class="hljs-built_in">erase</span>(iter,iter<span class="hljs-number">+1</span>);<br>                nums.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);<br>                <span class="hljs-comment">//如果发现0，对数组进行操作，将0删除，并添加至末尾</span><br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                iter++;<br>                <span class="hljs-comment">//如果发现的不是0，不进行操作，迭代器后移一位</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> num:nums)&#123;<br>            cout&lt;&lt;num;<br>            <span class="hljs-comment">//遍历数组输出结果</span><br>        &#125;<br>        <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>时间复杂度：O(n^2)(erase操作的时间复杂度是O(n)，再加上外层的循环)</p><h3 id="解法②"><a href="#解法②" class="headerlink" title="解法②"></a>解法②</h3><p>解法①的低效之处：在于erase的清除过程太繁琐</p><p>改进：操作所有非零数值，使其按顺序挪到数组的开头，覆盖开头的值，并将结尾的所有剩余值修改成0。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">moveZeroes</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> nonZeroIndex = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// 将所有非零元素移动到数组的前面</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] != <span class="hljs-number">0</span>) &#123;<br>                nums[nonZeroIndex++] = nums[i];<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 将剩余的位置填充为零</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = nonZeroIndex; i &lt; n; ++i) &#123;<br>            nums[i] = <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 打印数组</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> num : nums) &#123;<br>            cout &lt;&lt; num &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>        cout &lt;&lt; endl;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>时间复杂度：O(n)</p><h3 id="解法③-双指针并行处理"><a href="#解法③-双指针并行处理" class="headerlink" title="解法③ 双指针并行处理"></a>解法③ 双指针并行处理</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">moveZeroes</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>(), left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (right &lt; n) &#123;<br>            <span class="hljs-keyword">if</span> (nums[right]) &#123;<br>                <span class="hljs-built_in">swap</span>(nums[left], nums[right]);<br>                left++;<br>                <span class="hljs-comment">//如果nums[right]不是0，那么和左指针发生交换，右指针是试探指针，左指针代表已经检查过是非零值的元素，并将左指针右移一位</span><br>                <span class="hljs-comment">//最坏的情况:没有0，则左指针和右指针完全同步</span><br>            &#125;<br>            right++;<br>        &#125;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><p>时间复杂度：O(n)</p><h2 id="2-Leetcode-290-单词映射"><a href="#2-Leetcode-290-单词映射" class="headerlink" title="2.Leetcode 290 单词映射"></a>2.Leetcode 290 单词映射</h2><p>给定一种规律 <code>pattern</code> 和一个字符串 <code>s</code> ，判断 <code>s</code> 是否遵循相同的规律。</p><p>这里的 <strong>遵循</strong> 指完全匹配，例如， <code>pattern</code> 里的每个字母和字符串 <code>s</code> 中的每个非空单词之间存在着双向连接的对应规律。</p><p><strong>示例1:</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">输入: <span class="hljs-keyword">pattern</span> <span class="hljs-operator">=</span> &quot;abba&quot;, s <span class="hljs-operator">=</span> &quot;dog cat cat dog&quot;<br>输出: <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elixir">输入<span class="hljs-symbol">:pattern</span> = <span class="hljs-string">&quot;abba&quot;</span>, s = <span class="hljs-string">&quot;dog cat cat fish&quot;</span><br>输出: <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">输入: <span class="hljs-keyword">pattern</span> <span class="hljs-operator">=</span> &quot;aaaa&quot;, s <span class="hljs-operator">=</span> &quot;dog cat cat dog&quot;<br>输出: <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p> 代码解法</p><p>思路：</p><ul><li><p>如何获得子字符串作为单词？</p><ul><li><p>使用substr()</p></li><li><p>使用双指针</p></li><li><p><code>substr</code> 是 C++ 中 <code>std::string</code> 类的一个成员函数，用于从字符串中提取子字符串。它有两个参数：</p><ol><li><strong>起始位置（pos）</strong>：要提取的子字符串的起始索引。</li><li><strong>长度（len）</strong>：要提取的子字符串的长度（可选）。如果不指定，则提取到字符串的末尾。</li></ol><p>语法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::string <span class="hljs-title">substr</span><span class="hljs-params">(<span class="hljs-type">size_t</span> pos = <span class="hljs-number">0</span>, <span class="hljs-type">size_t</span> len = npos)</span> <span class="hljs-type">const</span></span>;<br></code></pre></td></tr></table></figure><ul><li><code>pos</code>：开始提取的位置。</li><li><code>len</code>：要提取的字符数。</li><li><code>npos</code>：一个特殊值，表示直到字符串的末尾。</li></ul><p>示例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::string text = <span class="hljs-string">&quot;Hello, World!&quot;</span>;<br>    <br>    <span class="hljs-comment">// 提取从位置 7 开始的子字符串，长度为 5</span><br>    std::string sub1 = text.<span class="hljs-built_in">substr</span>(<span class="hljs-number">7</span>, <span class="hljs-number">5</span>);<br>    std::cout &lt;&lt; sub1 &lt;&lt; std::endl;  <span class="hljs-comment">// 输出 &quot;World&quot;</span><br>    <br>    <span class="hljs-comment">// 提取从位置 7 开始的子字符串，直到字符串末尾</span><br>    std::string sub2 = text.<span class="hljs-built_in">substr</span>(<span class="hljs-number">7</span>);<br>    std::cout &lt;&lt; sub2 &lt;&lt; std::endl;  <span class="hljs-comment">// 输出 &quot;World!&quot;</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意事项</p><ul><li>如果 <code>pos</code> 超出字符串长度，会抛出 <code>std::out_of_range</code> 异常。</li><li>如果 <code>len</code> 超出可用长度，则提取到字符串的末尾。</li></ul><p><code>substr</code> 是处理字符串时非常有用的工具，尤其是在需要提取特定部分的场景中。</p></li></ul></li><li><p>如何构建一一映射的关系</p><ul><li>使用两个unordered_map</li></ul></li><li><p>如何处理两个数量不相等的情况</p><ul><li>使用计数器</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">wordPattern</span><span class="hljs-params">(string pattern, string str)</span> </span>&#123;<br>        unordered_map&lt;string, <span class="hljs-type">char</span>&gt; str2ch;<br>        unordered_map&lt;<span class="hljs-type">char</span>, string&gt; ch2str;<br>        <span class="hljs-type">int</span> m = str.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> ch : pattern) &#123;<br>            <span class="hljs-keyword">if</span> (i &gt;= m) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                <span class="hljs-comment">//如果 i 超过或等于 str 的长度，说明 str 中的单词数量不足以匹配 pattern，返回 false(此时ch还在遍历Pattern，但是i已经超过str的长度了，说明str不够长)</span><br>            &#125;<br>            <span class="hljs-type">int</span> j = i;<br>            <span class="hljs-comment">//经典的双指针解法，截取一个子字符串</span><br>            <span class="hljs-keyword">while</span> (j &lt; m &amp;&amp; str[j] != <span class="hljs-string">&#x27; &#x27;</span>) j++;<br>            <span class="hljs-comment">//截取一个单词</span><br>            <span class="hljs-type">const</span> string &amp;tmp = str.<span class="hljs-built_in">substr</span>(i, j - i);<br>            <span class="hljs-comment">//此处已经跳出循环，故包含了&#x27; &#x27;的情况，单词长度就是j-i</span><br>            <span class="hljs-keyword">if</span> (str2ch.<span class="hljs-built_in">count</span>(tmp) &amp;&amp; str2ch[tmp] != ch) &#123;<br>                <span class="hljs-comment">//如果map映射中已经有了这个单词的映射，并且这个单词的映射并不等于现在遍历得到的ch</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (ch2str.<span class="hljs-built_in">count</span>(ch) &amp;&amp; ch2str[ch] != tmp) &#123;<br>                <span class="hljs-comment">//反过来，如果map映射已经有了字符的映射并且这个字符的映射并不等于现在得到的单词</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-comment">//以上两个条件都为false，故在两个映射中填充进新的值。</span><br>            str2ch[tmp] = ch;<br>            ch2str[ch] = tmp;<br>            i = j + <span class="hljs-number">1</span>;<br>            <span class="hljs-comment">//更新双指针ij的位置</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> i &gt;= m;<br>        <span class="hljs-comment">//如果i&lt;m,说明还有单词未被输出，说明Pattern不够长，输出false</span><br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h2 id="3-Leetcode-350-两数组交集"><a href="#3-Leetcode-350-两数组交集" class="headerlink" title="3. Leetcode 350 两数组交集"></a>3. Leetcode 350 两数组交集</h2><p>给你两个整数数组 <code>nums1</code> 和 <code>nums2</code> ，请你以数组形式返回两数组的交集。返回结果中每个元素出现的次数，应与元素在两个数组中都出现的次数一致（如果出现次数不一致，则考虑取较小值）。可以不考虑输出结果的顺序。</p><h3 id="解法1-最基本的思路"><a href="#解法1-最基本的思路" class="headerlink" title="解法1   最基本的思路"></a>解法1   最基本的思路</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">intersect</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>        <span class="hljs-type">int</span> list1[<span class="hljs-number">1001</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-type">int</span> list2[<span class="hljs-number">1001</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br>        vector&lt;<span class="hljs-type">int</span>&gt; succedd;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> num1:nums1)&#123;<br>            list1[num1]++;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> num2:nums2)&#123;<br>            list2[num2]++;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">1001</span>;i++)&#123;<br>            <span class="hljs-keyword">if</span>(list1[i]&amp;&amp;list2[i])&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-built_in">min</span>(list1[i],list2[i]);j++)&#123;<br>                    succedd.<span class="hljs-built_in">push_back</span>(i);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> succedd;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="解法2-优化：使用哈希表存储值"><a href="#解法2-优化：使用哈希表存储值" class="headerlink" title="解法2 优化：使用哈希表存储值"></a>解法2 优化：使用哈希表存储值</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">intersect</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (nums<span class="hljs-number">1.</span><span class="hljs-built_in">size</span>() &gt; nums<span class="hljs-number">2.</span><span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">intersect</span>(nums2, nums1);<br>        &#125;<br>        <span class="hljs-comment">//为了减少空间复杂度，优先遍历元素数较少的数组</span><br>        unordered_map &lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; m;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums1) &#123;<br>            ++m[num];<br>        &#125;<br>        <span class="hljs-comment">//遍历nums1</span><br>        vector&lt;<span class="hljs-type">int</span>&gt; intersection;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums2) &#123;<br>            <span class="hljs-keyword">if</span> (m.<span class="hljs-built_in">count</span>(num)) &#123;<br>                intersection.<span class="hljs-built_in">push_back</span>(num);<br>                <span class="hljs-comment">//如果出现，则插入到目标序列中</span><br>                --m[num];<br>                <span class="hljs-comment">//相当于用掉了num1中的一个数，故要减1</span><br>                <span class="hljs-keyword">if</span> (m[num] == <span class="hljs-number">0</span>) &#123;<br>                    m.<span class="hljs-built_in">erase</span>(num);<br>                &#125;<br>                <span class="hljs-comment">//踢出num出s，代表nums1中对应的数已经被用完了</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> intersection;<br>    &#125;<br>&#125;;<br><br><br></code></pre></td></tr></table></figure><h3 id="解法3-排序-双指针遍历"><a href="#解法3-排序-双指针遍历" class="headerlink" title="解法3  排序+双指针遍历"></a>解法3  排序+双指针遍历</h3><p><strong>对于数组问题，可以先进行排序再进行操作！</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">intersect</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>        <span class="hljs-built_in">sort</span>(nums<span class="hljs-number">1.</span><span class="hljs-built_in">begin</span>(), nums<span class="hljs-number">1.</span><span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">sort</span>(nums<span class="hljs-number">2.</span><span class="hljs-built_in">begin</span>(), nums<span class="hljs-number">2.</span><span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> length1 = nums<span class="hljs-number">1.</span><span class="hljs-built_in">size</span>(), length2 = nums<span class="hljs-number">2.</span><span class="hljs-built_in">size</span>();<br>        vector&lt;<span class="hljs-type">int</span>&gt; intersection;<br>        <span class="hljs-type">int</span> index1 = <span class="hljs-number">0</span>, index2 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (index1 &lt; length1 &amp;&amp; index2 &lt; length2) &#123;<br>            <span class="hljs-keyword">if</span> (nums1[index1] &lt; nums2[index2]) &#123;<br>                index1++;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums1[index1] &gt; nums2[index2]) &#123;<br>                index2++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">//nums1[]==nums2[]</span><br>                <span class="hljs-comment">//同时向前前进一位</span><br>                intersection.<span class="hljs-built_in">push_back</span>(nums1[index1]);<br>                index1++;<br>                index2++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> intersection;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h2 id="4-Leetcode-438-字符串的字母异位词"><a href="#4-Leetcode-438-字符串的字母异位词" class="headerlink" title="4. Leetcode 438 字符串的字母异位词"></a>4. Leetcode 438 字符串的字母异位词</h2><p>给定两个字符串 <code>s</code> 和 <code>p</code>，找到 <code>s</code> 中所有 <code>p</code> 的 <strong>异位词</strong> 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。</p><p><strong>示例 1:</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入: s = <span class="hljs-string">&quot;cbaebabacd&quot;</span>, <span class="hljs-selector-tag">p</span> = <span class="hljs-string">&quot;abc&quot;</span><br>输出: <span class="hljs-selector-attr">[0,6]</span><br>解释:<br>起始索引等于 <span class="hljs-number">0</span> 的子串是 <span class="hljs-string">&quot;cba&quot;</span>, 它是 <span class="hljs-string">&quot;abc&quot;</span> 的异位词。<br>起始索引等于 <span class="hljs-number">6</span> 的子串是 <span class="hljs-string">&quot;bac&quot;</span>, 它是 <span class="hljs-string">&quot;abc&quot;</span> 的异位词。<br></code></pre></td></tr></table></figure><p> <strong>示例 2:</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入: s = <span class="hljs-string">&quot;abab&quot;</span>, <span class="hljs-selector-tag">p</span> = <span class="hljs-string">&quot;ab&quot;</span><br>输出: <span class="hljs-selector-attr">[0,1,2]</span><br>解释:<br>起始索引等于 <span class="hljs-number">0</span> 的子串是 <span class="hljs-string">&quot;ab&quot;</span>, 它是 <span class="hljs-string">&quot;ab&quot;</span> 的异位词。<br>起始索引等于 <span class="hljs-number">1</span> 的子串是 <span class="hljs-string">&quot;ba&quot;</span>, 它是 <span class="hljs-string">&quot;ab&quot;</span> 的异位词。<br>起始索引等于 <span class="hljs-number">2</span> 的子串是 <span class="hljs-string">&quot;ab&quot;</span>, 它是 <span class="hljs-string">&quot;ab&quot;</span> 的异位词。<br></code></pre></td></tr></table></figure><h3 id="解法1-使用基本思路"><a href="#解法1-使用基本思路" class="headerlink" title="解法1 使用基本思路"></a>解法1 使用基本思路</h3><p>从i&#x3D;0开始，遍历s数组，切割得到子串，然后判定s的子串和p是否为异位串。</p><p><strong>本质上是优化的滑动窗口</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">findAnagrams</span><span class="hljs-params">(string s, string p)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">length</span>() &lt; p.<span class="hljs-built_in">length</span>()) &#123;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i + p.<span class="hljs-built_in">length</span>() - <span class="hljs-number">1</span> &lt; s.<span class="hljs-built_in">length</span>(); i++) &#123;<br>                string s2 = s.<span class="hljs-built_in">substr</span>(i, p.<span class="hljs-built_in">length</span>());<br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">judgeyiwei</span>(s2, p)) &#123;<br>                    ans.<span class="hljs-built_in">push_back</span>(i);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">judgeyiwei</span><span class="hljs-params">(string s1, string s2)</span> </span>&#123;<br>        <span class="hljs-type">int</span> numlist[<span class="hljs-number">26</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s<span class="hljs-number">1.l</span>ength(); i++) &#123;<br>            numlist[s1[i] - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>            numlist[s2[i] - <span class="hljs-string">&#x27;a&#x27;</span>]--;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (numlist[i]) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="解法2-不定长滑动窗口优化"><a href="#解法2-不定长滑动窗口优化" class="headerlink" title="解法2 不定长滑动窗口优化"></a>解法2 不定长滑动窗口优化</h3><p>基本原理：枚举子串 s ′的右端点，如果发现 s ′其中一种字母的出现次数大于 p 的这种字母的出现次数，则右移 s ′的左端点。如果发现 s ′的长度等于 p 的长度，则说明 s ′的每种字母的出现次数，和 p 的每种字母的出现次数都相同，那么 s ′是 p 的异位词。</p><p><strong>有点类似于双指针</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">findAnagrams</span><span class="hljs-params">(string s, string p)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        <span class="hljs-type">int</span> cnt[<span class="hljs-number">26</span>]&#123;<span class="hljs-number">0</span>&#125;; <span class="hljs-comment">// 统计 p 的每种字母的出现次数</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : p) &#123;<br>            cnt[c - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        &#125;<br>        <span class="hljs-comment">//接下来对s字符串进行遍历操作(遍历右端点作为外层循环，在内部用while循环控制左端点)</span><br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> right = <span class="hljs-number">0</span>; right &lt; s.<span class="hljs-built_in">size</span>(); right++) &#123;<br>            <span class="hljs-type">int</span> c = s[right] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            cnt[c]--; <span class="hljs-comment">// 右端点字母进入窗口，相当于把p中减掉一个对应的字符</span><br>            <span class="hljs-keyword">while</span> (cnt[c] &lt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// c对应的字符(ASCII)太多了</span><br>                cnt[s[left] - <span class="hljs-string">&#x27;a&#x27;</span>]++; <span class="hljs-comment">// 左端点字母离开窗口</span><br>                left++; <br>            &#125;<br>            <span class="hljs-keyword">if</span> (right - left + <span class="hljs-number">1</span> == p.<span class="hljs-built_in">length</span>()) &#123; <span class="hljs-comment">// s&#x27; 和 p 的每种字母的出现次数都相同</span><br>                ans.<span class="hljs-built_in">push_back</span>(left); <span class="hljs-comment">// s&#x27; 左端点下标加入答案</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h2 id="5-Leetcode-443-字符串压缩问题"><a href="#5-Leetcode-443-字符串压缩问题" class="headerlink" title="5.Leetcode 443 字符串压缩问题"></a>5.Leetcode 443 字符串压缩问题</h2><p>给你一个字符数组 <code>chars</code> ，请使用下述算法压缩：</p><p>从一个空字符串 <code>s</code> 开始。对于 <code>chars</code> 中的每组 <strong>连续重复字符</strong> ：</p><ul><li>如果这一组长度为 <code>1</code> ，则将字符追加到 <code>s</code> 中。</li><li>否则，需要向 <code>s</code> 追加字符，后跟这一组的长度。</li></ul><p>压缩后得到的字符串 <code>s</code> <strong>不应该直接返回</strong> ，需要转储到字符数组 <code>chars</code> 中。需要注意的是，如果组长度为 <code>10</code> 或 <code>10</code> 以上，则在 <code>chars</code> 数组中会被拆分为多个字符。</p><p>请在 <strong>修改完输入数组后</strong> ，返回该数组的新长度。</p><p>你必须设计并实现一个只使用常量额外空间的算法来解决此问题。</p><p><strong>必须在原来的数组上进行修改！</strong></p><h3 id="解法：双指针"><a href="#解法：双指针" class="headerlink" title="解法：双指针"></a>解法：双指针</h3><p>为了实现原地压缩，我们可以使用双指针分别标志我们在字符串中读和写的位置。每次当读指针 read 移动到某一段连续相同子串的最右侧，我们就在写指针 write 处依次写入该子串对应的字符和子串长度即可。</p><p>在实际代码中，当读指针 read 位于字符串的末尾，或读指针 read 指向的字符不同于下一个字符时，我们就认为<strong>读指针 read 位于某一段连续相同子串的最右侧</strong>。该子串对应的字符即为读指针 read 指向的字符串。我们使用变量 left 记录该子串的最左侧的位置，这样子串长度即为 read−left+1。</p><p>特别地，为了达到 O(1) 空间复杂度，我们需要自行实现将数字转化为字符串写入到原字符串的功能。这里我们采用短除法将子串长度倒序写入原字符串中，然后再将其反转即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">compress</span><span class="hljs-params">(vector&lt;<span class="hljs-type">char</span>&gt;&amp; chars)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = chars.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> write = <span class="hljs-number">0</span>, left = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> read = <span class="hljs-number">0</span>; read &lt; n; read++) &#123;<br>            <span class="hljs-keyword">if</span> (read == n - <span class="hljs-number">1</span> || chars[read] != chars[read + <span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-comment">//由于写的速度肯定没有读的快，故不用担心write会覆盖未被读取的初始值</span><br>                chars[write++] = chars[read];<br>                <span class="hljs-type">int</span> num = read - left + <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span> (num &gt; <span class="hljs-number">1</span>) &#123;<br>                    <span class="hljs-type">int</span> anchor = write;<br>                    <span class="hljs-keyword">while</span> (num &gt; <span class="hljs-number">0</span>) &#123;<br>                        chars[write++] = num % <span class="hljs-number">10</span> + <span class="hljs-string">&#x27;0&#x27;</span>;<br>                        num /= <span class="hljs-number">10</span>;<br>                    &#125;<br>                    <span class="hljs-built_in">reverse</span>(&amp;chars[anchor], &amp;chars[write]);<br>                    <span class="hljs-comment">//实现输入一个数字倒序插入char数组中（也可以使用stringstream）</span><br>                &#125;<br>                left = read + <span class="hljs-number">1</span>;<br>                <span class="hljs-comment">//后面还会执行read++，本质上就是更新read和left的位置使其对齐</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> write;<br>    &#125;<br>&#125;;<br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C/C++</tag>
      
      <tag>Leetcode notes</tag>
      
      <tag>algorithm</tag>
      
      <tag>Finished</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode-Mistake-collection-1-10</title>
    <link href="/posts/Leetcode-Mistake-collection-1-10/"/>
    <url>/posts/Leetcode-Mistake-collection-1-10/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Mistake-collection-1-10"><a href="#Leetcode-Mistake-collection-1-10" class="headerlink" title="Leetcode-Mistake-collection-1-10"></a>Leetcode-Mistake-collection-1-10</h1><h1 id="程设错题总结-1-5"><a href="#程设错题总结-1-5" class="headerlink" title="程设错题总结 1~5"></a>程设错题总结 1~5</h1><p>【完成时间：2024-10-15】</p><p>【补档时间：2024-12-9】</p><h2 id="1-Leetcode202-Happynumber"><a href="#1-Leetcode202-Happynumber" class="headerlink" title="1.Leetcode202 Happynumber"></a>1.Leetcode202 Happynumber</h2><p><a href="https://leetcode.cn/problems/happy-number/description/">原题链接</a></p><hr><p>编写一个算法来判断一个数 <code>n</code> 是不是快乐数。</p><p><strong>「快乐数」</strong> 定义为：</p><ul><li>对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。</li><li>然后重复这个过程直到这个数变为 1，也可能是 <strong>无限循环</strong> 但始终变不到 1。</li><li>如果这个过程 <strong>结果为</strong> 1，那么这个数就是快乐数。</li></ul><p>如果 <code>n</code> 是 <em>快乐数</em> 就返回 <code>true</code> ；不是，则返回 <code>false</code> 。</p><p> <strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：n = 19<br>输出：true<br>解释：<br>12 +<span class="hljs-number"> 92 </span>= 82<br>82 +<span class="hljs-number"> 22 </span>= 68<br>62 +<span class="hljs-number"> 82 </span>= 100<br>12 +<span class="hljs-number"> 02 </span>+<span class="hljs-number"> 02 </span>= 1<br></code></pre></td></tr></table></figure><hr><h3 id="1-使用快慢指针解决循环问题"><a href="#1-使用快慢指针解决循环问题" class="headerlink" title="1.使用快慢指针解决循环问题"></a>1.使用快慢指针解决循环问题</h3><p>当快指针追上慢指针时，代表完成了一次循环。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">happynumber</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123;<br>        <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(n!=<span class="hljs-number">0</span>)&#123;<br>            sum+=(n%<span class="hljs-number">10</span>)*(n%<span class="hljs-number">10</span>);<br>            n/=<span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isHappy</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-type">int</span> i=n,j=n;<br>        <span class="hljs-keyword">do</span>&#123;<br>            i=<span class="hljs-built_in">happynumber</span>(i);<br>            j=<span class="hljs-built_in">happynumber</span>(j);<br>            j=<span class="hljs-built_in">happynumber</span>(j);<br>            <span class="hljs-keyword">if</span>(i==<span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(i!=j);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="2-使用哈希表存储"><a href="#2-使用哈希表存储" class="headerlink" title="2.使用哈希表存储"></a>2.使用哈希表存储</h3><p>此处使用容器：unordered_set</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">happynumber</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123;<br>        <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(n!=<span class="hljs-number">0</span>)&#123;<br>            sum+=(n%<span class="hljs-number">10</span>)*(n%<span class="hljs-number">10</span>);<br>            n/=<span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isHappy</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        unordered_set &lt;<span class="hljs-type">int</span>&gt; list;<br>        <span class="hljs-keyword">while</span>(n!=<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">if</span>(list.<span class="hljs-built_in">find</span>(n)!=list.<span class="hljs-built_in">end</span>())&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                list.<span class="hljs-built_in">insert</span>(n);<br>            &#125;<br>            n=<span class="hljs-built_in">happynumber</span>(n);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="2-Acwing-817-数组去重"><a href="#2-Acwing-817-数组去重" class="headerlink" title="2.Acwing 817 数组去重"></a>2.Acwing 817 数组去重</h2><p><a href="https://www.acwing.com/problem/content/819/">原题链接</a></p><hr><p>给定一个长度为 nn 的数组 aa，请你编写一个函数：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_unique_count</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> n)</span></span>;  <span class="hljs-comment">// 返回数组前n个数中的不同数的个数</span><br></code></pre></td></tr></table></figure><p><strong>输入格式</strong></p><p>第一行包含一个整数 nn。</p><p>第二行包含 nn 个整数，表示数组 aa。</p><p><strong>输出格式</strong></p><p>共一行，包含一个整数表示数组中不同数的个数。</p><p><strong>数据范围</strong></p><p>1≤n≤10001≤n≤1000,<br>1≤ai≤10001≤ai≤1000。</p><p><strong>输入样例：</strong></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">5</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p><strong>输出样例：</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">4<br></code></pre></td></tr></table></figure><hr><h3 id="method1：使用STL"><a href="#method1：使用STL" class="headerlink" title="method1：使用STL"></a>method1：使用STL</h3><p><strong>unique函数</strong>：</p><p>unique是C++语言中的STL函数，包含于<algorithm>头文件中。 <strong>功能是将数组中相邻的重复元素去除</strong>。 然而其本质是将重复的元素移动到数组的末尾，最后再将迭代器指向第一个重复元素的下标。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n, s[<span class="hljs-number">1010</span>];<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) cin &gt;&gt; s[i];<br>    <span class="hljs-built_in">sort</span>(s, s + n);<br>    cout &lt;&lt; <span class="hljs-built_in">unique</span>(s, s + n) - s;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="method2：基本方法"><a href="#method2：基本方法" class="headerlink" title="method2：基本方法"></a>method2：基本方法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> b[<span class="hljs-number">1001</span>];<br><span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br><span class="hljs-comment">/*两个数组的区别：</span><br><span class="hljs-comment">a[]代表输入的数组（待去重的数组）</span><br><span class="hljs-comment">b[]数组是一个状态数组，其下标对应的值和a[]对应，初始值均为0，一旦出现a[i],即代表下标为a[i]的b[]被访问过，状态值变为1。（且只有初次访问是生效的）</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_unique_count</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(b[a[i]]==<span class="hljs-number">0</span>)<br>        b[a[i]]=<span class="hljs-number">1</span>;<br>        sum++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br><span class="hljs-comment">//函数作用：统计数组中一共出现了多少不相同的数。</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">int</span> n;<br>  cin&gt;&gt;n;<br>  <span class="hljs-type">int</span> a[n<span class="hljs-number">+1</span>];<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>  &#123;<br>      cin&gt;&gt;a[i];<br>  &#125;<br>  cout&lt;&lt;<span class="hljs-built_in">get_unique_count</span>(a,n);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="3-ACwing-15-二维数组的查找"><a href="#3-ACwing-15-二维数组的查找" class="headerlink" title="3.ACwing 15 二维数组的查找"></a>3.ACwing 15 二维数组的查找</h2><p><a href="https://www.acwing.com/problem/content/16/">题目链接</a></p><p>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。</p><p>请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><p><strong>数据范围</strong></p><p>二维数组中元素个数范围 [0,1000][0,1000]</p><p><strong>样例</strong></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">输入数组：<br><span class="hljs-string"></span><br><span class="hljs-string">[</span><br><span class="hljs-string">  [1,2,8,9]</span>，<br><span class="hljs-string">  [2,4,9,12]</span>，<br><span class="hljs-string">  [4,7,10,13]</span>，<br><span class="hljs-string">  [6,8,11,15]</span><br>]<br><br>如果输入查找数值为<span class="hljs-number">7</span>，则返回<span class="hljs-literal">true</span>，<br><br>如果输入查找数值为<span class="hljs-number">5</span>，则返回<span class="hljs-literal">false</span>。<br></code></pre></td></tr></table></figure><p><img src="/posts/Above-All/istake-collection-1-10/3.png" alt="Scanning"></p><p>思路：</p><p>​1.暴力循环（两个for循环嵌套）</p><p>​2.通过数组大小关系的规律实现<strong>逐步逼近</strong>的策略</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Find</span><span class="hljs-params">(<span class="hljs-type">int</span> target, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; array)</span> </span>&#123;<br>        <span class="hljs-type">int</span> row=array.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> col=array[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> i=row<span class="hljs-number">-1</span>;<br>        <span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//定义扫描的初始位置，(row-1,0),即数组棋盘的左下角</span><br>        <span class="hljs-keyword">while</span>(i&gt;=<span class="hljs-number">0</span>&amp;&amp;j&lt;col)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(target==array[i][j])<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-comment">//得到return后即可跳出循环，代表查找成功</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(target&lt;array[i][j])<br>                i--;<br>            <span class="hljs-comment">//删去最下面一行(判断大小关系)</span><br>            <span class="hljs-keyword">else</span><br>                j++;<br>            <span class="hljs-comment">//删去第一列，移动到第二列(判断大小关系)</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br></code></pre></td></tr></table></figure><h2 id="4-Acwing3801-最佳连续子数组"><a href="#4-Acwing3801-最佳连续子数组" class="headerlink" title="4.Acwing3801 最佳连续子数组"></a>4.Acwing3801 最佳连续子数组</h2><p><a href="https://www.acwing.com/problem/content/3804/">原题链接</a></p><p>给定一个长度为 nn 的数组 a1,a2,…,ana1,a2,…,an。</p><p>请你找到其中的最佳<strong>连续</strong>子数组。</p><p>最佳连续子数组需满足：</p><ol><li>子数组内各元素的算术平均数（即所有元素之和除以元素个数）尽可能大。</li><li>满足条件 11 的前提下，子数组的长度尽可能长。</li></ol><p>输出最佳连续子数组的长度。</p><p><strong>输入格式</strong></p><p>第一行包含整数 TT，表示共有 TT 组测试数据。</p><p>每组数据，第一行包含整数 nn。</p><p>第二行包含 nn 个整数 a1,a2,…,ana1,a2,…,an。</p><p><strong>输出格式</strong></p><p>每组数据输出一行结果，表示最佳连续子数组的长度。</p><h3 id="最暴力解法：分别枚举首项和尾项-O-n-2"><a href="#最暴力解法：分别枚举首项和尾项-O-n-2" class="headerlink" title="最暴力解法：分别枚举首项和尾项 O(n^2)"></a>最暴力解法：分别枚举首项和尾项 O(n^2)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">testbestarray</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n; cin&gt;&gt;n;<br>    <span class="hljs-type">int</span> numarray[n];<br>    <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>,targetnumber=<span class="hljs-number">0</span>;<br>    <span class="hljs-type">double</span> maxave=<span class="hljs-number">0</span>,ave;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        cin&gt;&gt;numarray[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i;j&lt;n;j++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=i;k&lt;=j;k++)&#123;<br>                sum+=numarray[k];<br>            &#125;<br>            <span class="hljs-comment">//在已知i，j的情况下，遍历对子数组求和</span><br>            ave=<span class="hljs-built_in">double</span>(sum)/(j-i<span class="hljs-number">+1</span>);<br>            <span class="hljs-keyword">if</span>(ave&gt;maxave)&#123;<br>                maxave=ave;<br>                targetnumber=(j-i<span class="hljs-number">+1</span>);<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ave==maxave)&#123;<br>                <span class="hljs-keyword">if</span>((j-i<span class="hljs-number">+1</span>)&gt;targetnumber)&#123;<br>                    targetnumber=(j-i<span class="hljs-number">+1</span>);<br>                &#125;<br>            &#125;<br>            sum=<span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> targetnumber;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> T; cin&gt;&gt;T;<br>    <span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (count&lt;T)&#123;<br>        cout&lt;&lt;<span class="hljs-built_in">testbestarray</span>()&lt;&lt;endl;<br>        count++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="解法优化："><a href="#解法优化：" class="headerlink" title="解法优化："></a>解法优化：</h3><p><strong>分治的思想</strong>：将一个大问题拆分成若干个小问题再分别解决。</p><p>子问题1：最大子数列的值</p><p>​<em><strong>最大子数列的值一定等于数列中最大项的值</strong></em></p><p>子问题2：在子数列平均值最大的情况下，找到最长长度：</p><p>​<em><strong>找到数列中是否有若干项连续，且值均为最大值。</strong></em></p><p>优化代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">testbestarray</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n; cin&gt;&gt;n;<br>    <span class="hljs-type">int</span> numarray[n];<br>    <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>,max=<span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;<span class="hljs-type">int</span> countmax=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        cin&gt;&gt;numarray[i];<br>        max=(numarray[i]&gt;max?numarray[i]:max);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;)&#123;<br>        <span class="hljs-keyword">if</span>(i&lt;n&amp;&amp;numarray[i]==max)&#123;<br>            <span class="hljs-keyword">while</span>(i&lt;n&amp;&amp;numarray[i]==max)&#123;<br>            count++;<br>            i++;<br>            &#125;<br>            i++;<br>            countmax=(countmax&lt;count?count:countmax);<br>            count=<span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i&lt;n)&#123;<br>            i++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//这一段for循环是筛查的核心，如果某元素是列表中最大值，则进入while循环直到第一个非最大值元素的出现终止while循环，同时结束count++，并最大化countmax。在遍历完一整个数组后，即可得到最大子区间的长度。</span><br>    <span class="hljs-keyword">return</span> countmax;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> T; cin&gt;&gt;T;<br>    <span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (count&lt;T)&#123;<br>        cout&lt;&lt;<span class="hljs-built_in">testbestarray</span>()&lt;&lt;endl;<br>        count++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><h3 id="进一步简化："><a href="#进一步简化：" class="headerlink" title="进一步简化："></a>进一步简化：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">10e5</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> a[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> T;<br>    cin &gt;&gt; T;<br>    <span class="hljs-keyword">while</span>(T--)<br>    &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br><br>        <span class="hljs-type">int</span> m = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        &#123;<br>            cin &gt;&gt; a[i];<br>            m = <span class="hljs-built_in">max</span>(m, a[i]);<span class="hljs-comment">//m保存最大值</span><br>        &#125;<br><br>        <span class="hljs-type">int</span> res = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n;i++)<span class="hljs-comment">//求长度</span><br>        &#123;<br>            <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span>(i &lt; n &amp;&amp; a[i] == m)<br>            &#123;<br>                t++;<br>                i++;<br>            &#125;<br>            res = <span class="hljs-built_in">max</span>(res, t);<br>        &#125;<br>        <span class="hljs-comment">/*核心while循环：</span><br><span class="hljs-comment">        此处不用再添加if语句，直接使用外部的for循环即可。</span><br><span class="hljs-comment">        */</span><br>        cout &lt;&lt; res &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="5-ACwing-862-三元组排序"><a href="#5-ACwing-862-三元组排序" class="headerlink" title="5.ACwing 862 三元组排序"></a>5.ACwing 862 三元组排序</h2><p><a href="https://www.acwing.com/problem/content/864/">原题链接</a></p><p>给定 N 个三元组(x,y,z)，其中 xx 是整数，yy 是浮点数，zz 是字符串。</p><p>请你按照 x 从小到大的顺序将这些三元组打印出来。</p><p>数据保证不同三元组的 xx 值互不相同。</p><p><strong>输入格式</strong></p><p>第一行包含整数 N。</p><p>接下来 N 行，每行包含一个整数 x，一个浮点数 y，一个字符串 z，表示一个三元组，三者之间用空格隔开。</p><p><strong>输出格式</strong></p><p>共 N 行，按照 x 从小到大的顺序，每行输出一个三元组。</p><p>注意，所有输入和输出的浮点数 y 均保留两位小数。</p><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><ul><li>最基本的排序使用排序算法（此处用algorithm库中的sort（）函数）</li><li>如何构建一一对应的关系？<ul><li>map容器</li><li>pair：将两组数据整合成一个数据对<ul><li>（int,（double,string））</li><li>对pair类型的int数排序，一一对应的（double，string）满足映射</li></ul></li></ul></li></ul><h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h3><h4 id="①最基本的数组实现"><a href="#①最基本的数组实现" class="headerlink" title="①最基本的数组实现"></a>①最基本的数组实现</h4><p>排序算法（Bubblesort）+交换函数swap（）（内置在C++库中）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n; cin&gt;&gt;n;<br>    <span class="hljs-type">int</span> intlist[n];<br>    <span class="hljs-type">double</span> doublelist[n];<br>    string stringlist[n];<br>    <span class="hljs-comment">//定义三个数组，分别储存三种不同的数据结构。</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        cin&gt;&gt;intlist[i]&gt;&gt;doublelist[i]&gt;&gt;stringlist[i];<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=n;j&gt;<span class="hljs-number">1</span>;j--)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;j<span class="hljs-number">-1</span>;i++)&#123;<br>            <span class="hljs-keyword">if</span>(intlist[i]&gt;intlist[i<span class="hljs-number">+1</span>])&#123;<br>                <span class="hljs-built_in">swap</span>(intlist[i],intlist[i<span class="hljs-number">+1</span>]);<br>                <span class="hljs-built_in">swap</span>(doublelist[i],doublelist[i<span class="hljs-number">+1</span>]);<br>                <span class="hljs-built_in">swap</span>(stringlist[i],stringlist[i<span class="hljs-number">+1</span>]);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//核心算法：冒泡排序</span><br>    <span class="hljs-comment">//从第一位开始逐项与后一位冒泡比较确定是否交换，第一轮下来就确定末尾项为最大值。</span><br>    <span class="hljs-comment">//之后通过外层的for循环逐步确定直至首项</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %.2lf&quot;</span>,intlist[i],doublelist[i]);<br>        cout&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;stringlist[i]&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="②map映射"><a href="#②map映射" class="headerlink" title="②map映射"></a>②map映射</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;map&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> x first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> y second</span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">10010</span>;<br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">double</span>, string&gt; PII;<br>map&lt;<span class="hljs-type">int</span>, PII&gt; ans;<br><span class="hljs-comment">//定义了一个从int向PII的映射，就不用使用两次pair了</span><br><span class="hljs-type">int</span> n;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-type">double</span> b;<br>    string c;<br>    cin &gt;&gt; n;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ )<br>    &#123;<br>        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;<br>        ans.<span class="hljs-built_in">insert</span>(&#123;a, &#123;b, c&#125;&#125;);<br>    &#125;<br><br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> iter = ans.<span class="hljs-built_in">begin</span>(); iter != ans.<span class="hljs-built_in">end</span>(); iter ++ )<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %.2f %s\n&quot;</span>, iter-&gt;x, iter-&gt;y.x, iter-&gt;y.y.<span class="hljs-built_in">c_str</span>());  <br>    <span class="hljs-comment">/*这里 iter是一个迭代器</span><br><span class="hljs-comment">    iter-&gt;first代表指向map类型的first成员函数（即自变量）</span><br><span class="hljs-comment">    iter-&gt;second代表指向因变量</span><br><span class="hljs-comment">    iter-&gt;second.first代表指向因变量pair的第一个元素</span><br><span class="hljs-comment">    iter-&gt;second.second               第二个元素</span><br><span class="hljs-comment">    c_str()返回一个指向字符串的指针</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="③使用pair类型"><a href="#③使用pair类型" class="headerlink" title="③使用pair类型"></a>③使用pair类型</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> x first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> y second</span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">10010</span>;<br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, pair&lt;<span class="hljs-type">double</span>, string &gt;&gt; PII;<br><br>vector&lt;PII&gt; ans;<br><span class="hljs-type">int</span> n, a;<br><span class="hljs-type">double</span> b;<br>string s;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ )<br>    &#123;<br>        cin &gt;&gt; a &gt;&gt; b &gt;&gt; s;<br>        ans.<span class="hljs-built_in">push_back</span>(&#123;a, &#123;b, s&#125;&#125;);<br>        <span class="hljs-comment">//vector类型的push_back函数，&#123;a,&#123;b,s&#125;&#125;是一个PII类型的数据</span><br>    &#125;<br>    <span class="hljs-built_in">sort</span>(ans.<span class="hljs-built_in">begin</span>(), ans.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-comment">//使用sort()函数实现ans这个vector的自动排序(默认升序)</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i: ans)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %.2lf %s\n&quot;</span>,i.x, i.y.x, i.y.y.<span class="hljs-built_in">c_str</span>());   <br>    <span class="hljs-comment">//若i是一个pair类型，则i.first代表pair的第一个元素，而i.second代表pair的第二个元素。</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="程设错题-610-2024101520241020"><a href="#程设错题-610-2024101520241020" class="headerlink" title="程设错题 610 2024101520241020"></a>程设错题 6<del>10 20241015</del>20241020</h1><h2 id="1-经典问题：找质数"><a href="#1-经典问题：找质数" class="headerlink" title="1.经典问题：找质数"></a>1.经典问题：找质数</h2><h3 id="方法1：基本枚举法-O-n-3-2"><a href="#方法1：基本枚举法-O-n-3-2" class="headerlink" title="方法1：基本枚举法 O(n^3&#x2F;2)"></a>方法1：基本枚举法 O(n^3&#x2F;2)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isprime</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">2</span>||n==<span class="hljs-number">3</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i*i&lt;=n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(n%i==<span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countPrimes</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;n;i++)&#123;<br>            sum+=<span class="hljs-built_in">isprime</span>(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="方法2：埃氏筛"><a href="#方法2：埃氏筛" class="headerlink" title="方法2：埃氏筛"></a>方法2：埃氏筛</h3><p>​枚举没有考虑到数与数的关联性，因此难以再继续优化时间复杂度。接下来我们介绍一个常见的算法，该算法由希腊数学家厄拉多塞（Eratosthenes）提出，称为厄拉多塞筛法，简称埃氏筛。</p><p>​我们考虑这样一个事实：<strong>如果 x 是质数，那么大于 x 的 x 的倍数 2x,3x,… 一定不是质数</strong>，因此我们可以从这里入手。</p><p>​我们设 isPrime[i] 表示数 i 是不是质数，如果是质数则为 1，否则为 0。从小到大遍历每个数，如果这个数为质数，则将其所有的倍数都标记为合数（除了该质数本身），即 0，这样在运行结束的时候我们即能知道质数的个数。</p><p>​这种方法的正确性是比较显然的：这种方法显然不会将质数标记成合数；另一方面，当从小到大遍历到数 x 时，倘若它是合数，则它一定是某个小于 x 的质数 y 的整数倍，故根据此方法的步骤，我们在遍历到 y 时，就一定会在此时将 x 标记为 isPrime[x]&#x3D;0。因此，这种方法也不会将合数标记为质数。</p><p>​当然这里还可以继续优化，对于一个质数 x，如果按上文说的我们从 2x 开始标记其实是冗余的，应该直接从 x⋅x 开始标记，因为 2x,3x,… 这些数一定在 x 之前就被其他数的倍数标记过了，例如 2 的所有倍数，3 的所有倍数等。</p><p><strong>这种方法不用再判断单个数是否为质数，可以减少筛查从1~n的次数</strong></p><p><strong>埃氏筛的筛查方法：从一个已知的质数开始排除无限多比他大的合数</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countPrimes</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">isPrime</span><span class="hljs-params">(n, <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-comment">//初始化</span><br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (isPrime[i]) &#123;<br>                <span class="hljs-comment">//则该数为质数</span><br>                ans += <span class="hljs-number">1</span>;<br>                <span class="hljs-comment">//接下来的操作：标志其倍数为合数</span><br>                <span class="hljs-comment">//从n^2开始标记！(对于倍数kn,k&lt;n,一定有数k为质数，在之前被标记过)</span><br>                <span class="hljs-keyword">if</span> ((<span class="hljs-type">long</span> <span class="hljs-type">long</span>)i * i &lt; n) &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i * i; j &lt; n; j += i) &#123;<br>                        isPrime[j] = <span class="hljs-number">0</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h3 id="3-线性筛O-n"><a href="#3-线性筛O-n" class="headerlink" title="3.线性筛O(n)"></a>3.线性筛O(n)</h3><p><img src="/posts/Above-All/istake-collection-1-10/1.png" alt="Linear Time Complexity"></p><p>x&#x3D;k*primes[i]，则对于数x*primes[i+1]&#x3D;k*primes[i]*primes[i+1],可以在primes[i+1]遍历的时候取到</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countPrimes</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; primes;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">isPrime</span><span class="hljs-params">(n, <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (isPrime[i]) &#123;<br>                primes.<span class="hljs-built_in">push_back</span>(i);<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; primes.<span class="hljs-built_in">size</span>() &amp;&amp; i * primes[j] &lt; n; ++j) &#123;<br>                isPrime[i * primes[j]] = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">if</span> (i % primes[j] == <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> primes.<span class="hljs-built_in">size</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="2-数组输出：平方矩阵问题"><a href="#2-数组输出：平方矩阵问题" class="headerlink" title="2.数组输出：平方矩阵问题"></a>2.数组输出：平方矩阵问题</h2><p><img src="/posts/Above-All/istake-collection-1-10/2.png" alt="Question 2"></p><p>思路：<strong>最基本的数组输出：</strong>两层for循环嵌套（通过外层循环每执行一次回车跳转到下一行进行输出）</p><h3 id="解法一：曼哈顿距离-坐标法"><a href="#解法一：曼哈顿距离-坐标法" class="headerlink" title="解法一：曼哈顿距离+坐标法"></a>解法一：曼哈顿距离+坐标法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printarray</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">while</span>(n!=<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">printarray</span>(n);<br>        cout&lt;&lt;endl;<br>        cin&gt;&gt;n;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printarray</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123;<br>    <span class="hljs-type">double</span> maxi;<br>    <span class="hljs-type">int</span> list[n][n];<br>    <span class="hljs-keyword">if</span>(n%<span class="hljs-number">2</span>==<span class="hljs-number">1</span>)&#123;<br>        maxi=(n<span class="hljs-number">+1</span>)/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>                list[i][j]=<span class="hljs-built_in">int</span>(maxi-<span class="hljs-built_in">max</span>(<span class="hljs-built_in">abs</span>((n<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>-i),<span class="hljs-built_in">abs</span>((n<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>-j)));<br>                <span class="hljs-comment">//核心代码：对应位置上的数和其到中心点的曼哈顿距离有关！</span><br>                cout&lt;&lt;list[i][j]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>            &#125;<br>            cout&lt;&lt;endl;<br>        &#125;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        maxi=n/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>                list[i][j]=<span class="hljs-built_in">int</span>(maxi<span class="hljs-number">+0.5</span>-<span class="hljs-built_in">max</span>(<span class="hljs-built_in">abs</span>(<span class="hljs-built_in">double</span>(n<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>-i),<span class="hljs-built_in">abs</span>(<span class="hljs-built_in">double</span>(n<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>-j)));<br>                <span class="hljs-comment">//偶数的情况不存在唯一的中心点，但中心点的作用只是通过曼哈顿距离的坐标表示来确定对应位置上的数的值。故可以引入一个虚拟中心点（浮点数：(n-1)/2）</span><br>                cout&lt;&lt;list[i][j]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>            &#125;<br>            cout&lt;&lt;endl;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="优化解法：不再依赖中心点，直接根据坐标输出值"><a href="#优化解法：不再依赖中心点，直接根据坐标输出值" class="headerlink" title="优化解法：不再依赖中心点，直接根据坐标输出值"></a>优化解法：不再依赖中心点，直接根据坐标输出值</h3><blockquote><p>①通过观察回字形矩阵, 矩阵关于对角线是左上方和右下方对称的<br>②利用二维行列循环, <strong>获取行列+1的最小值(即min(i + 1, j + 1))</strong>, 可得如下图形(例如n &#x3D;&#x3D; 4):<br>1 1 1 1<br>1 2 2 <del>2</del><br>1 2 <del>3 3</del><br>1 <del>2 3 4</del><br>可以看出未划横线部分（左上部分）满足题解,此时如果使图像沿着对角线翻转,再重合,即可求解答案<br>③翻转图像,采用min(n - i, n - j)即可, 得到图像如下(例如n &#x3D;&#x3D; 4):<br><del>4 3 2</del> 1<br><del>3 3</del> 2 1<br><del>2</del> 2 2 1<br>1 1 1 1<br>④进行图像的重合, 对应位置取最小值即可求解min(Left上, right下)</p></blockquote><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br> <span class="hljs-type">int</span> n;<br><span class="hljs-keyword">while</span> (cin &gt;&gt; n, n)&#123;<br> <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)&#123;<br>     <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j ++)&#123;<br>         cout &lt;&lt; <span class="hljs-built_in">min</span>(<span class="hljs-built_in">min</span>(i + <span class="hljs-number">1</span>, j + <span class="hljs-number">1</span>), <span class="hljs-built_in">min</span>(n - i, n - j)) &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>         <span class="hljs-comment">//通过一个min（）,输出对应的数字</span><br>     &#125;<br>     cout &lt;&lt; endl ;<br> &#125;<br> cout &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure></blockquote><h3 id="方法二：蛇形矩阵求解"><a href="#方法二：蛇形矩阵求解" class="headerlink" title="方法二：蛇形矩阵求解"></a>方法二：<strong>蛇形矩阵</strong>求解</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> m[N][N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-type">int</span> dx[] = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, dy[] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;;<br>    <span class="hljs-comment">//每个向量代表向不同方向移动</span><br><br>    <span class="hljs-keyword">while</span>(cin &gt;&gt; n, n )&#123;<br>        <span class="hljs-built_in">memset</span>(m, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> m);<span class="hljs-comment">//初始化数组</span><br>        <span class="hljs-type">int</span> d = <span class="hljs-number">1</span>, x = <span class="hljs-number">0</span>, y = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 表示改变方向次数</span><br>        <span class="hljs-type">int</span> res = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 回形当前圈数</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n * n; i ++)&#123;<br>            <span class="hljs-comment">//i是一个计数器，代表一共输出i个数</span><br>            <span class="hljs-type">int</span> a = x + dx[d], b = y + dy[d];<br>            <span class="hljs-comment">//(x,y) is the previous point,and (a,b)is the point that has moved</span><br>            <span class="hljs-comment">//一个很关键的点：(a,b)相当于探路的坐标，并不会直接赋值给(x,y)。一旦if语句发现(a,b)异常(例如需要拐弯或进入小循环)，则会重新调整方向后再赋值给x,y</span><br>            m[x][y] = res;<br><br>            <span class="hljs-keyword">if</span> (a &lt; <span class="hljs-number">0</span> || a &gt;= n || b &lt; <span class="hljs-number">0</span> || b &gt;= n || m[a][b])&#123;<br>                <span class="hljs-comment">//可能的需要改变方向的情况：走到底需要拐弯，走到头(m[a][b]已经被填充，输出一个非0值)</span><br>                d = (d + <span class="hljs-number">1</span>) % <span class="hljs-number">4</span>;<br>                <span class="hljs-comment">//d的改变：1——2——3——4</span><br>                a = x + dx[d], b = y + dy[d];<br>                cnt ++;<br>                <span class="hljs-keyword">if</span> (!(cnt % <span class="hljs-number">4</span>)) res ++;<br>                <span class="hljs-comment">//当cnt==4时，代表转完了一圈，则进入小圈中</span><br>            &#125;<br>            x = a, y = b;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j ++)<br>                cout &lt;&lt; m[i][j] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>            cout &lt;&lt; endl;<br>        &#125;<br>        cout &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="3-斐波那契数列"><a href="#3-斐波那契数列" class="headerlink" title="3.斐波那契数列"></a>3.斐波那契数列</h2><h3 id="（1）基本的递归做法"><a href="#（1）基本的递归做法" class="headerlink" title="（1）基本的递归做法"></a>（1）基本的递归做法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span>  <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Fib</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n,m;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        cin&gt;&gt;m;<br>        cout&lt;&lt;<span class="hljs-built_in">Fib</span>(m)&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Fib</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(x==<span class="hljs-number">1</span>||x==<span class="hljs-number">2</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Fib</span>(x<span class="hljs-number">-1</span>)+<span class="hljs-built_in">Fib</span>(x<span class="hljs-number">-2</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="（2）方法优化"><a href="#（2）方法优化" class="headerlink" title="（2）方法优化"></a>（2）方法优化</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> t;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  cin&gt;&gt;t;<br>  <span class="hljs-keyword">while</span>(t--)<br>  &#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> number=<span class="hljs-number">0</span>,numberfront=<span class="hljs-number">1</span>,numberfrofront;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;=n; i++)<br>    &#123;<br>      <span class="hljs-keyword">if</span> (i==n)&#123;<br>          <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Fib(%d) = %lld\n&quot;</span>,n,number);<br>      &#125;<br>      numberfrofront=number+numberfront;<br>      number=numberfront;<br>      numberfrofront=numberfront;<br>      <span class="hljs-comment">//相当于做迭代，不断向前进（比递归的时间复杂度要低）</span><br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>·此处也可以使用vector数组存储生成的每一项，可减少计算的复杂（不用每次函数调用的时候都要重新计算一遍）</p><h2 id="4-ACwing-只出现一次的字符"><a href="#4-ACwing-只出现一次的字符" class="headerlink" title="4.ACwing 只出现一次的字符"></a>4.ACwing 只出现一次的字符</h2><p>题目描述<br>给你一个只包含小写字母的字符串。</p><p>请你判断是否存在只在字符串中出现过一次的字符。</p><p>如果存在，则输出满足条件的字符中位置最靠前的那个。</p><p>如果没有，输出 no。</p><p>输入格式<br>共一行，包含一个由小写字母构成的字符串。</p><p>数据保证字符串的长度不超过 100000</p><p>输出格式<br>输出满足条件的第一个字符。</p><p>如果没有，则输出 no。</p><h3 id="思路：构建一种映射的关系"><a href="#思路：构建一种映射的关系" class="headerlink" title="思路：构建一种映射的关系"></a>思路：构建一种映射的关系</h3><p>直接使用两个数组构建映射的关系（前提是数组的长度已知）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    string test;<br>    cin&gt;&gt;test;<br>    <span class="hljs-type">int</span> list[<span class="hljs-number">1000</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i:test)&#123;<br>            list[i]++;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i:test)&#123;<br>        <span class="hljs-comment">//注意这里遍历不是按list的顺序进行遍历，而是还是按照test的值(不同字符的ASCII码)来进行遍历，确保输出的始终是最大且最靠前的一项。</span><br>        <span class="hljs-keyword">if</span>(list[i]==<span class="hljs-number">1</span>)&#123;<br>            cout&lt;&lt;i;<br>            <span class="hljs-keyword">goto</span> end;<br>        &#125; <br>    &#125;<br>    cout&lt;&lt;<span class="hljs-string">&quot;no&quot;</span>;<br>    end:<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-ACwing-字符串中最长的连续出现的字符"><a href="#5-ACwing-字符串中最长的连续出现的字符" class="headerlink" title="5.ACwing 字符串中最长的连续出现的字符"></a>5.ACwing 字符串中最长的连续出现的字符</h2><p>求一个字符串中最长的连续出现的字符，输出该字符及其出现次数，字符串中无空白字符（空格、回车和 tabtab），如果这样的字符不止一个，则输出第一个。</p><p><strong>输入格式</strong></p><p>第一行输入整数 NN，表示测试数据的组数。</p><p>每组数据占一行，包含一个不含空白字符的字符串，字符串长度不超过 200200。</p><p><strong>输出格式</strong></p><p>共一行，输出最长的连续出现的字符及其出现次数，中间用空格隔开。</p><h4 id="解法①：最基本的思路"><a href="#解法①：最基本的思路" class="headerlink" title="解法①：最基本的思路"></a>解法①：最基本的思路</h4><ul><li>使用前后指针和flag判断连续字符</li><li>使用countlist数组记录每个字符连续出现的最大值</li><li>使用vector数组successful按顺序储存连续出现的字符，并且在其值更新时自动移动到序列尾端</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">findthelongest</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> countlist[<span class="hljs-number">300</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br>    vector &lt;<span class="hljs-type">char</span>&gt; successful;<br>    <span class="hljs-type">int</span> flag=<span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> tempcount=<span class="hljs-number">0</span>;<br>    string teststring;<br>    cin&gt;&gt;teststring;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;teststring.<span class="hljs-built_in">length</span>()<span class="hljs-number">-1</span>;i++)&#123;<br>        <span class="hljs-keyword">if</span>(teststring[i]==teststring[i<span class="hljs-number">+1</span>])&#123;<br>            flag=<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">find</span>(successful.<span class="hljs-built_in">begin</span>(),successful.<span class="hljs-built_in">end</span>(),teststring[i])==successful.<span class="hljs-built_in">end</span>())&#123;<br>                successful.<span class="hljs-built_in">push_back</span>(teststring[i]);<br>            &#125;<br>            <br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            flag=<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span>(tempcount&gt;countlist[teststring[i]])&#123;<br>                countlist[teststring[i]]=tempcount;<br>                successful.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">remove</span>(successful.<span class="hljs-built_in">begin</span>(),successful.<span class="hljs-built_in">end</span>(),teststring[i]));<br>                successful.<span class="hljs-built_in">push_back</span>(teststring[i]);<br>            &#125;<br>            tempcount=<span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(flag==<span class="hljs-number">1</span>)&#123;<br>            tempcount++;<br>            <span class="hljs-keyword">if</span>(i==teststring.<span class="hljs-built_in">length</span>()<span class="hljs-number">-2</span>)&#123;<br>                <span class="hljs-keyword">if</span>(tempcount&gt;countlist[teststring[i]])&#123;<br>                countlist[teststring[i]]=tempcount;<br>                successful.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">remove</span>(successful.<span class="hljs-built_in">begin</span>(),successful.<span class="hljs-built_in">end</span>(),teststring[i]));<br>                successful.<span class="hljs-built_in">push_back</span>(teststring[i]);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> max=<span class="hljs-number">0</span>;<br>    <span class="hljs-type">char</span> maxchar=teststring[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">if</span>(!successful.<span class="hljs-built_in">empty</span>())&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> tes:successful)&#123;<br>        <span class="hljs-keyword">if</span>(countlist[tes]&gt;max)&#123;<br>            maxchar=tes;<br>            max=countlist[tes];<br>        &#125;<br>    &#125;<br>    &#125;<br>    cout&lt;&lt;maxchar&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;max<span class="hljs-number">+1</span>&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> N;cin&gt;&gt;N;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;N;i++)&#123;<br>        <span class="hljs-built_in">findthelongest</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="解法②可移动的双指针"><a href="#解法②可移动的双指针" class="headerlink" title="解法②可移动的双指针"></a>解法②可移动的双指针</h3><p>解法优化：</p><ul><li>使用可移动的双指针ij，每次只有j向前不断移动直到遇到不同的元素，i最后追上j</li><li>适应覆盖的思想而不使用指针存储</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> T;<br>    cin &gt;&gt; T;<br>    <span class="hljs-keyword">while</span>(T --)<br>    &#123;<br>        <span class="hljs-type">int</span> maxn = <span class="hljs-number">-1</span>;<span class="hljs-comment">//maxn记录最大长度</span><br>        string str, maxs;<span class="hljs-comment">//maxs记录最大长度时的字符</span><br>        cin &gt;&gt; str;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; str.<span class="hljs-built_in">size</span>();)<br>        &#123;<br>            <span class="hljs-type">int</span> j = i;<br>            <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span>(str[j] == str[i] &amp;&amp; j &lt; str.<span class="hljs-built_in">size</span>())<span class="hljs-comment">//当指针j没有越界且与指针i的内容相同时移动</span><br>                j ++, cnt ++;<br>            <span class="hljs-keyword">if</span>(cnt &gt; maxn)<span class="hljs-comment">//更新最大值</span><br>                maxn = cnt, maxs = str[i];<br>            i = j ;<span class="hljs-comment">//移动指针i</span><br>        &#125;<br>        cout &lt;&lt; maxs &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; maxn &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C/C++</tag>
      
      <tag>Leetcode notes</tag>
      
      <tag>algorithm</tag>
      
      <tag>Finished</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode-Mistake-collection</title>
    <link href="/posts/Leetcode-Mistake-collection/"/>
    <url>/posts/Leetcode-Mistake-collection/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Mistake-collection"><a href="#Leetcode-Mistake-collection" class="headerlink" title="Leetcode-Mistake-collection"></a>Leetcode-Mistake-collection</h1><p>笔者又来开新坑啦！</p><h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>在笔者刚刚步入大一时（也就是这学期），仗着自己暑假为数不多的C语言语法存货，觉得学校C++的课程进度有些落后，便在网上寻寻觅觅，想通过<strong>刷题</strong>的方式提升自己的代码水平。</p><p>当在网上搜索“新手小白刷编程题什么网站上最好”，十有八九跳出来的都是<strong>Leetcode</strong>。确实，<a href="https://leetcode.cn/">Leetcode</a>可以算作是数一数二优秀的编程训练网站了，各种界面设计也很符合我的审美。（就像他自己说的，<strong>全球极客挚爱的技术成长平台</strong>）。但是，对于当时习惯于把所有代码全部放进一个臃肿的<code>main</code>函数的我来说，Leetcode犹如一座高不可攀的山峰，好不容易弄懂了什么叫<strong>函数封装</strong>，竭尽全力也没办法做出 <a href="https://leetcode.cn/problems/two-sum/">第一道题</a>。🤡</p><p>之后在看 <a href="https://www.hello-algo.com/chapter_hello_algo/">Hello 算法</a>的时候在序言看到了一段感同身受的话：</p><blockquote><p>两眼一抹黑地刷题似乎是最受欢迎的方法，简单、直接且有效。然而刷题就如同玩“扫雷”游戏，自学能力强的人能够顺利将地雷逐个排掉，而基础不足的人很可能被炸得满头是包，并在挫折中步步退缩。通读教材也是一种常见做法，但对于面向求职的人来说，毕业论文、投递简历、准备笔试和面试已经消耗了大部分精力，啃厚重的书往往变成了一项艰巨的挑战。</p></blockquote><p>回想自己Leetcode的刷题之旅，真的是<strong>痛并快乐着</strong>，痛在算法题冷酷无情，将你所有的bug暴露无遗，根本不给你侥幸的机会，快乐在钻研一道题后终于看见<strong>超过了100%的人</strong>，快乐在从一开始的举步维艰，到逐渐能够尝试黄色中档题，再到得心应手，心平气和。</p><p><strong>因此，我在此开坑，将自己过去，现在以及将来在Leetcode上所做的好题，错题，看到的优秀题解以及我自己整理一些笔记等等整理成博客的形式，一篇博客五道题，希望以此留作纪念，并能够给有相同志向的小伙伴们一点鼓励和指引。</strong></p><h2 id="内容（实时更新）"><a href="#内容（实时更新）" class="headerlink" title="内容（实时更新）"></a>内容（实时更新）</h2><h3 id="第一学期（主要以语法题和最基本的算法题为主）"><a href="#第一学期（主要以语法题和最基本的算法题为主）" class="headerlink" title="第一学期（主要以语法题和最基本的算法题为主）"></a>第一学期（主要以语法题和最基本的算法题为主）</h3><ul><li>基本语法题<ul><li>数组、引用和指针的相关操作</li><li>OOP</li><li>STL入门</li></ul></li><li>基本算法入门<ul><li>排序算法</li><li>分治算法</li><li>回溯算法和递归算法</li><li>动态规划</li><li>贪心算法</li></ul></li></ul><h3 id="第二学期（重点：数据结构）"><a href="#第二学期（重点：数据结构）" class="headerlink" title="第二学期（重点：数据结构）"></a>第二学期（重点：数据结构）</h3><p>（期待一波来年开春的疯狂更新~）</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://leetcode.cn/u/affectionate-hamiltonyhv/">我的Leetcode主页</a></p><p><a href="https://leetcode.cn/">Leetcode</a></p><p><a href="https://books.halfrost.com/leetcode/">Leetcode Cookbook</a></p><hr><blockquote><p>English Version</p></blockquote><h1 id="Starting-a-New-Adventure-Again"><a href="#Starting-a-New-Adventure-Again" class="headerlink" title="Starting a New Adventure Again!"></a>Starting a New Adventure Again!</h1><h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><p>When I first started university (this semester), armed with my limited knowledge of C language syntax from a short summer learning stint, I felt the pace of my C++ course at school was a bit slow. So, I searched online for ways to improve my coding skills through <strong>problem-solving practice</strong>.</p><p>When looking up “best websites for beginners to practice coding,” <strong>LeetCode</strong> popped up in most results. Indeed, <a href="https://leetcode.cn/">LeetCode</a> is one of the best programming training platforms, and its interface design aligns perfectly with my aesthetic (as they call themselves, <strong>“The beloved tech growth platform for geeks worldwide”</strong>). However, for someone like me who used to put all the code into one bloated <code>main</code> function, LeetCode seemed like an insurmountable mountain. After finally understanding what <strong>function encapsulation</strong> was, I still couldn’t manage to solve <a href="https://leetcode.cn/problems/two-sum/">the first problem</a>. 🤡</p><p>While reading <a href="https://www.hello-algo.com/chapter_hello_algo/">Hello Algorithm</a>, I came across a sentiment in the preface that resonated deeply with me:</p><blockquote><p>Diving blindly into problem-solving is perhaps the most popular method—it’s simple, direct, and effective. However, it’s like playing a “Minesweeper” game: self-learners with a strong foundation can defuse the mines one by one, while those lacking fundamentals might get blown up and retreat in frustration. Reading textbooks is another common approach, but for job seekers, writing theses, submitting resumes, and preparing for tests and interviews consume most of their energy, making heavy textbooks a daunting challenge.</p></blockquote><p>Looking back on my LeetCode journey, it truly has been a mix of <strong>pain and joy</strong>. The pain lies in the ruthless nature of algorithm problems, exposing all your bugs without mercy, leaving no room for luck. The joy comes from finally solving a problem and seeing <strong>“outperformed 100% of users”</strong>, from struggling with initial problems to tackling mid-level yellow questions, and eventually solving problems calmly and confidently.</p><p><strong>That’s why I’m starting this series—to document the good problems, mistakes, excellent solutions, and notes from my past, present, and future LeetCode journey in the form of blog posts. Each post will include five problems, serving as a record and hopefully providing encouragement and guidance to like-minded peers.</strong></p><hr><h2 id="Content-Updated-in-Real-Time"><a href="#Content-Updated-in-Real-Time" class="headerlink" title="Content (Updated in Real-Time)"></a>Content (Updated in Real-Time)</h2><h3 id="First-Semester-Primarily-syntax-and-basic-algorithm-problems"><a href="#First-Semester-Primarily-syntax-and-basic-algorithm-problems" class="headerlink" title="First Semester (Primarily syntax and basic algorithm problems)"></a>First Semester (Primarily syntax and basic algorithm problems)</h3><ul><li><strong>Basic Syntax Problems</strong><ul><li>Array, reference, and pointer operations</li><li>OOP (Object-Oriented Programming)</li><li>Intro to STL (Standard Template Library)</li></ul></li><li><strong>Basic Algorithms</strong><ul><li>Sorting algorithms</li><li>Divide-and-conquer</li><li>Backtracking and recursion</li><li>Dynamic programming</li><li>Greedy algorithms</li></ul></li></ul><h3 id="Second-Semester-Focus-Data-Structures"><a href="#Second-Semester-Focus-Data-Structures" class="headerlink" title="Second Semester (Focus: Data Structures)"></a>Second Semester (Focus: Data Structures)</h3><p><em>(Looking forward to some crazy updates next spring!)</em></p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://leetcode.cn/u/affectionate-hamiltonyhv/">My LeetCode Profile</a></li><li><a href="https://leetcode.cn/">LeetCode</a></li><li><a href="https://books.halfrost.com/leetcode/">LeetCode Cookbook</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Announcement</tag>
      
      <tag>C/C++</tag>
      
      <tag>Leetcode notes</tag>
      
      <tag>algorithm</tag>
      
      <tag>Finished</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Class-Inheritance</title>
    <link href="/posts/Class-Inheritance/"/>
    <url>/posts/Class-Inheritance/</url>
    
    <content type="html"><![CDATA[<h1 id="C-Primer-Plus-Tutorial-13"><a href="#C-Primer-Plus-Tutorial-13" class="headerlink" title="C++ Primer Plus Tutorial-13"></a>C++ Primer Plus Tutorial-13</h1><h1 id="面向对象编程教程——Section③"><a href="#面向对象编程教程——Section③" class="headerlink" title="面向对象编程教程——Section③"></a>面向对象编程教程——Section③</h1><center><p style="color: red;"><b><font size=6.5>Chapter 13 Class Inheritance</font></b></p></center><center><p style="color: red;"><b><font size=6.5>类的继承</font></b></p></center><p>【写在前面的话】</p><p><a href="https://xiyuanyang-code.github.io/posts/C-plus-plus-Primer-Plus-tutorial/">C++ Primer Plus Tutorial</a></p><p><a href="https://xiyuanyang-code.github.io/tags/OOP/">系列文章</a></p><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>在本文中，你将学到面向对象编程中的又一个核心思想：继承与多态。本文从一个基本的基类讲起并延伸到派生类的定义和基本使用，探讨派生类和基类的特殊关系。接下来本文深入继承的原理，介绍在多态公有继承中的<strong>is-a</strong>关系和虚函数，已经动态联编和静态联编的基本知识。接着本文介绍了抽象基类的使用提高效率以及在派生类中使用动态内存分配的注意事项。最后本文对OOP的基本精神——封装、继承与多态和相关基础知识做了梳理。</p><blockquote><p>In this article, you will learn another core concept in object-oriented programming: inheritance and polymorphism. The article begins with a basic base class and extends to the definition and basic usage of derived classes, exploring the special relationship between derived and base classes. Next, the article delves into the principles of inheritance, introducing the <strong>is-a</strong> relationship in polymorphic public inheritance, virtual functions, and the basics of dynamic and static binding. Then, the article discusses the use of abstract base classes to improve efficiency, as well as considerations for using dynamic memory allocation in derived classes. Finally, the article summarizes the fundamental principles of OOP—encapsulation, inheritance, and polymorphism—along with related foundational knowledge.</p></blockquote><h2 id="Table-of-Contents"><a href="#Table-of-Contents" class="headerlink" title="Table of Contents"></a>Table of Contents</h2><ul><li>基类函数和派生类函数的简单示例<ul><li>派生类的构造函数</li><li>使用派生类</li><li>派生类和基类的特殊关系</li></ul></li><li>继承<ul><li>多态公有继承</li><li>虚函数</li><li>静态联编和动态联编</li></ul></li><li>抽象基类</li><li>继承和动态内存分配</li><li>对面向对象基本知识的总结</li></ul><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>在程序设计中，代码的重用是非常重要的，这一点在面向对象编程也不例外。一种最简单的“代码重用”是最简单的<code>Ctrl-C,Ctrl-V</code>程序员，手动修改代码实现重用（乐）。那么，我们如何在不修改代码的基础上实现代码（对于OOP而言，主要是类和对象）的重用呢？这便是<strong>类的继承</strong>：从已有的类（基类）将特征和方法继承给一个新的类（派生类）。同时，类的继承也保证了安全性，派生类可以提供新特性，甚至不需要访问源代码就可以派生出类，实现<strong>数据的封装</strong>。（这不正是OOP的核心和精髓吗）</p><p>接下来的一章，让我们走进类继承的世界。</p><h2 id="Example-Base-class-and-derived-class"><a href="#Example-Base-class-and-derived-class" class="headerlink" title="Example: Base class and derived class"></a>Example: Base class and derived class</h2><p>文章首先给出一个比较简单的基类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// tabtenn0.h -- a table-tennis base class</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> TABTENN0_H_</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TABTENN0_H_</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> std::string;<br><span class="hljs-comment">// simple base class</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TableTennisPlayer</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>    string firstname;<br>    string lastname;<br>    <span class="hljs-type">bool</span> hasTable;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">TableTennisPlayer</span> (<span class="hljs-type">const</span> string &amp; fn = <span class="hljs-string">&quot;none&quot;</span>,<span class="hljs-type">const</span> string &amp; ln = <span class="hljs-string">&quot;none&quot;</span>, <span class="hljs-type">bool</span> ht = <span class="hljs-literal">false</span>);<br>    <span class="hljs-comment">//默认构造函数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Name</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-comment">//输出会员的姓名</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">HasTable</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> hasTable; &#125;;<br>    <span class="hljs-comment">//判断会员是否有球桌</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ResetTable</span><span class="hljs-params">(<span class="hljs-type">bool</span> v)</span> </span>&#123; hasTable = v; &#125;;<br>    <span class="hljs-comment">//重设球桌状态</span><br>&#125;;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//tabtenn0.cpp -- simple base-class methods</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;tabtenn0.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br>TableTennisPlayer::<span class="hljs-built_in">TableTennisPlayer</span> (<span class="hljs-type">const</span> string &amp; fn, <br>    <span class="hljs-type">const</span> string &amp; ln, <span class="hljs-type">bool</span> ht) : <span class="hljs-built_in">firstname</span>(fn),<span class="hljs-built_in">lastname</span>(ln), <span class="hljs-built_in">hasTable</span>(ht) &#123;&#125;<br>    <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TableTennisPlayer::Name</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>    std::cout &lt;&lt; lastname &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; firstname;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// usett0.cpp -- using a base class</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;tabtenn0.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">( <span class="hljs-type">void</span> )</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">using</span> std::cout;<br>    <span class="hljs-function">TableTennisPlayer <span class="hljs-title">player1</span><span class="hljs-params">(<span class="hljs-string">&quot;Chuck&quot;</span>, <span class="hljs-string">&quot;Blizzard&quot;</span>, <span class="hljs-literal">true</span>)</span></span>;<br>    <span class="hljs-function">TableTennisPlayer <span class="hljs-title">player2</span><span class="hljs-params">(<span class="hljs-string">&quot;Tara&quot;</span>, <span class="hljs-string">&quot;Boomdea&quot;</span>, <span class="hljs-literal">false</span>)</span></span>;<br>    player<span class="hljs-number">1.</span><span class="hljs-built_in">Name</span>();<br>    <span class="hljs-keyword">if</span> (player<span class="hljs-number">1.</span><span class="hljs-built_in">HasTable</span>())<br>        cout &lt;&lt; <span class="hljs-string">&quot;: has a table.\n&quot;</span>;<br>    <span class="hljs-keyword">else</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;: hasn&#x27;t a table.\n&quot;</span>;<br>    player<span class="hljs-number">2.</span><span class="hljs-built_in">Name</span>();<br>    <span class="hljs-keyword">if</span> (player<span class="hljs-number">2.</span><span class="hljs-built_in">HasTable</span>())<br>        cout &lt;&lt; <span class="hljs-string">&quot;: has a table&quot;</span>;<br>    <span class="hljs-keyword">else</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;: hasn&#x27;t a table.\n&quot;</span>;<br>    <span class="hljs-comment">// std::cin.get();</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>现在，我要在这个类的基础之上派生出一个新的类，来记录乒乓球运动员在比赛中的得分。</p><p>先来看写好的头文件，再来逐行解析：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// tabtenn1.h -- a table-tennis base class</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> TABTENN1_H_</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TABTENN1_H_</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> std::string;<br><span class="hljs-comment">// simple base class</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TableTennisPlayer</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>    string firstname;<br>    string lastname;<br>    <span class="hljs-type">bool</span> hasTable;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">TableTennisPlayer</span> (<span class="hljs-type">const</span> string &amp; fn = <span class="hljs-string">&quot;none&quot;</span>,<span class="hljs-type">const</span> string &amp; ln = <span class="hljs-string">&quot;none&quot;</span>, <span class="hljs-type">bool</span> ht = <span class="hljs-literal">false</span>);<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Name</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">HasTable</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> hasTable; &#125;;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ResetTable</span><span class="hljs-params">(<span class="hljs-type">bool</span> v)</span> </span>&#123; hasTable = v; &#125;;<br>&#125;;<br><br><span class="hljs-comment">// simple derived class</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RatedPlayer</span> : <span class="hljs-keyword">public</span> TableTennisPlayer<br>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> rating;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">RatedPlayer</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> r = <span class="hljs-number">0</span>, <span class="hljs-type">const</span> string &amp; fn = <span class="hljs-string">&quot;none&quot;</span>,<br>                 <span class="hljs-type">const</span> string &amp; ln = <span class="hljs-string">&quot;none&quot;</span>, <span class="hljs-type">bool</span> ht = <span class="hljs-literal">false</span>);<br>    <span class="hljs-built_in">RatedPlayer</span>(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> r, <span class="hljs-type">const</span> TableTennisPlayer &amp; tp);<br>    <span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title">Rating</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> rating; &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ResetRating</span> <span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> r)</span> </span>&#123;rating = r;&#125;<br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br></code></pre></td></tr></table></figure><p>很容易的看出，<code>RatedPlayer</code>是从<code>TableTennisPlayer</code>派生出来的派生类。最基本的语法定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">RatedPlayer</span> : <span class="hljs-keyword">public</span> TableTennisPlayer<br>&#123;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-comment">//your Declaration here</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//your Declaration here</span><br>&#125;;<br><br></code></pre></td></tr></table></figure><p>冒号指出 <code>RatedPlayer</code> 类的基类是 <code>TableTennisplayer</code> 类。上述特殊的声明头表明 <code>TableTennisPlayer</code> 是一个<strong>公有基类</strong>，这被称为<strong>公有派生</strong>。<strong>派生类对象包含基类对象</strong>。使用公有派生，<strong>基类的公有成员将成为派生类的公有成员</strong>；<strong>基类的私有部分也将成为派生类的一部分</strong>，但只能通过基类的公有和保护方法访问（稍后将介绍保护成员）。</p><p><code>Ratedplayer</code>对象将具有以下特征：</p><ul><li>派生类对象存储了基类的数据成员（派生类继承了基类的实现）；</li><li>派生类对象可以使用基类的方法（派生类继承了基类的接口）。</li></ul><blockquote><p>派生类就像基类的“儿子”，子承父业，可以直接继承父亲的所有遗产。</p></blockquote><p>这是<strong>继承</strong>的部分，同时，派生类也可以实现自己的新方法和新成员，这也在3~6行的代码处定义。</p><ul><li>派生类<strong>需要</strong>自己的构造函数（<strong>这很重要！</strong>）</li><li>派生类可以添加额外的数据方法和数据成员。</li></ul><h3 id="派生类的构造函数：访问权限的考虑"><a href="#派生类的构造函数：访问权限的考虑" class="headerlink" title="派生类的构造函数：访问权限的考虑"></a>派生类的构造函数：访问权限的考虑</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">RatedPlayer</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> r = <span class="hljs-number">0</span>, <span class="hljs-type">const</span> string &amp; fn = <span class="hljs-string">&quot;none&quot;</span>,<br>             <span class="hljs-type">const</span> string &amp; ln = <span class="hljs-string">&quot;none&quot;</span>, <span class="hljs-type">bool</span> ht = <span class="hljs-literal">false</span>);<br><span class="hljs-built_in">RatedPlayer</span>(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> r, <span class="hljs-type">const</span> TableTennisPlayer &amp; tp);<br></code></pre></td></tr></table></figure><p>上文代码是派生类中实现的两个构造函数，可以看出，构造函数要同时定义<strong>原有基类的数据成员和新添加的数据成员</strong>（第一个构造函数）。当然，偷懒一点也是可以的，可以在构造函数中使用到<strong>基类的对象</strong>（第二个构造函数）。</p><p>但是，构造函数的设计并不是像想象的那么简单。前文的<code>Introduction</code>讲过，派生类甚至可以在不访问基类的情况下实现继承。实际上，<strong>派生类不可以直接访问基类的私有成员，而必须通过基类定义的方法进行访问（和外部的函数一样，只能通过接口进行访问）</strong>，换句话来说，<strong>派生类构造函数必须使用基类构造函数</strong>。</p><h4 id="第一种构造函数"><a href="#第一种构造函数" class="headerlink" title="第一种构造函数"></a>第一种构造函数</h4><p>这点就显得非常矛盾了，因为从上文第一个构造函数的视角看过去，我们貌似<strong>给派生类的每一个私有成员提供了数据，貌似可以直接访问所有的私有成员，包括基类和派生类</strong>。实际上，并不是这样，下面我们来详细解释这一点。</p><p>我们更进一步，给出第一个构造函数的声明和定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//函数声明</span><br><span class="hljs-built_in">RatedPlayer</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> r = <span class="hljs-number">0</span>, <span class="hljs-type">const</span> string &amp; fn = <span class="hljs-string">&quot;none&quot;</span>, <span class="hljs-type">const</span> string &amp; ln = <span class="hljs-string">&quot;none&quot;</span>, <span class="hljs-type">bool</span> ht = <span class="hljs-literal">false</span>);<br><br><span class="hljs-comment">//函数定义</span><br>RatedPlayer::<span class="hljs-built_in">RatedPlayer</span>(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> r, <span class="hljs-type">const</span> string &amp; fn,<span class="hljs-type">const</span> string &amp; ln, <span class="hljs-type">bool</span> ht) : <span class="hljs-built_in">TableTennisPlayer</span>(fn, ln, ht)<br>&#123;<br>    rating = r;<br>&#125;<br></code></pre></td></tr></table></figure><p>在创建派生类对象时，程序首先会创建<strong>基类对象</strong>。因此，在使用派生类对象的构造函数时，对应的基类对象已经存在。</p><blockquote><p>这很好理解，儿子出生之前，爸爸肯定得出生。</p></blockquote><p>理解了这一点后，我们再来看函数的定义，我们会发现很独特的一行，<code>TableTennisPlayer(fn, ln, ht)</code>。这行代码叫<strong>成员初始化列表</strong>，是可执行的代码，用来调用基类<code>TableTennisPlayer</code>的构造函数。<code>fn, ln, ht</code>作为三个形式参数，接受实参并将其本身传递给<code>TableTennisPlayer</code>构造函数的形式参数，后者将创建一个<strong>嵌套的基类对象</strong>（先创建爸爸），接着，进入派生类函数的函数体，完成对派生类对象的创建。（再创建儿子）</p><p>如果省略了成员初始化列表，那么程序会调用<strong>默认的构造函数</strong>创建一个基类对象，而无法使用显式的构造函数，程序就无法读取到我们希望赋给对象的数据。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//没有成员初始化列表的情况</span><br>RatedPlayer::<span class="hljs-built_in">RatedPlayer</span>(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> r, <span class="hljs-type">const</span> string &amp; fn,<span class="hljs-type">const</span> string &amp; ln, <span class="hljs-type">bool</span> ht) : <br>&#123;<br>    rating = r;<br>&#125;<br><br><span class="hljs-comment">//与下面的代码等效</span><br>RatedPlayer::<span class="hljs-built_in">RatedPlayer</span>(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> r, <span class="hljs-type">const</span> string &amp; fn,<span class="hljs-type">const</span> string &amp; ln, <span class="hljs-type">bool</span> ht) : <br><span class="hljs-built_in">TableTennisPlayer</span>()<br><span class="hljs-comment">//使用无参数的默认构造函数</span><br>&#123;<br>    rating = r;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="第二种构造函数"><a href="#第二种构造函数" class="headerlink" title="第二种构造函数"></a>第二种构造函数</h4><p>接下来，我们来看第二种更加简洁的构造函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//函数声明</span><br><span class="hljs-built_in">RatedPlayer</span>(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> r, <span class="hljs-type">const</span> TableTennisPlayer &amp; tp);<br><br><span class="hljs-comment">//函数定义</span><br>RatedPlayer::<span class="hljs-built_in">RatedPlayer</span>(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> r, <span class="hljs-type">const</span> TableTennisPlayer &amp; tp)<br>    : <span class="hljs-built_in">TableTennisPlayer</span>(tp)<br>&#123;<br>        rating=r;<br>&#125;<br><br><span class="hljs-comment">//函数定义的等价形式</span><br>RatedPlayer::<span class="hljs-built_in">RatedPlayer</span>(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> r, <span class="hljs-type">const</span> TableTennisPlayer &amp; tp)<br>    : <span class="hljs-built_in">TableTennisPlayer</span>(tp), <span class="hljs-built_in">rating</span>(r)<br>&#123;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>来看这里的初始化成员列表，传入的参数是一个<code>const TableTennisPlayer &amp;</code>类型，因此，系统会调用默认的<strong>复制构造函数</strong>（这是个很有趣的问题，我们在<a href="https://xiyuanyang-code.github.io/posts/Dynamic-Memory-and-Classes/">第十二章</a>的时候重点讨论了，这里使用默认的复制构造函数是不会产生任何问题的）。</p><p>当然，我们也可以对<strong>派生类成员使用初始化列表</strong>，在这种情况下，应该使用成员名而不是类名。</p><blockquote><p>释放对象的顺序与创建对象的顺序相反，即首先执行派生类的析构函数，然后自动调用基类的析构函数。  </p></blockquote><div class="note note-success">            <p><strong>小总结</strong>： 创建派生类对象时，程序首先<strong>调用基类构造函数</strong>，然后再<strong>调用派生类构造函数</strong>。基类构造函数负责初始化继承的数据成员；派生类构造函数主要用于初始化新增的数据成员。派生类的构造函数总是调用一个基类构造函数。可以使用初始化器列表语法指明要使用的基类构造函数，否则将使用默认的基类构造函数。派生类对象过期时，程序将首先调用派生类析构函数，然后再调用基类析构函数。</p>          </div><p>现在，我们可以给出派生类的全部函数定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//tabtenn1.cpp -- simple base-class methods</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;tabtenn1.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br>TableTennisPlayer::<span class="hljs-built_in">TableTennisPlayer</span> (<span class="hljs-type">const</span> string &amp; fn, <br>    <span class="hljs-type">const</span> string &amp; ln, <span class="hljs-type">bool</span> ht) : <span class="hljs-built_in">firstname</span>(fn),<span class="hljs-built_in">lastname</span>(ln), <span class="hljs-built_in">hasTable</span>(ht) &#123;&#125;<br>    <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TableTennisPlayer::Name</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>    std::cout &lt;&lt; lastname &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; firstname;<br>&#125;<br><br><span class="hljs-comment">// RatedPlayer methods</span><br>RatedPlayer::<span class="hljs-built_in">RatedPlayer</span>(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> r, <span class="hljs-type">const</span> string &amp; fn,<br>    <span class="hljs-type">const</span> string &amp; ln, <span class="hljs-type">bool</span> ht) : <span class="hljs-built_in">TableTennisPlayer</span>(fn, ln, ht)<br>&#123;<br>    rating = r;<br>&#125;<br><br>RatedPlayer::<span class="hljs-built_in">RatedPlayer</span>(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> r, <span class="hljs-type">const</span> TableTennisPlayer &amp; tp)<br>    : <span class="hljs-built_in">TableTennisPlayer</span>(tp), <span class="hljs-built_in">rating</span>(r)<br>&#123;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="使用派生类"><a href="#使用派生类" class="headerlink" title="使用派生类"></a>使用派生类</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// usett1.cpp -- using base class and derived class</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;tabtenn1.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">( <span class="hljs-type">void</span> )</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">using</span> std::cout;<br>    <span class="hljs-keyword">using</span> std::endl;<br>    <span class="hljs-function">TableTennisPlayer <span class="hljs-title">player1</span><span class="hljs-params">(<span class="hljs-string">&quot;Tara&quot;</span>, <span class="hljs-string">&quot;Boomdea&quot;</span>, <span class="hljs-literal">false</span>)</span></span>;<br>    <span class="hljs-function">RatedPlayer <span class="hljs-title">rplayer1</span><span class="hljs-params">(<span class="hljs-number">1140</span>, <span class="hljs-string">&quot;Mallory&quot;</span>, <span class="hljs-string">&quot;Duck&quot;</span>, <span class="hljs-literal">true</span>)</span></span>;<br>    rplayer<span class="hljs-number">1.</span><span class="hljs-built_in">Name</span>();          <span class="hljs-comment">// derived object uses base method</span><br>    <span class="hljs-keyword">if</span> (rplayer<span class="hljs-number">1.</span><span class="hljs-built_in">HasTable</span>())<br>        cout &lt;&lt; <span class="hljs-string">&quot;: has a table.\n&quot;</span>;<br>    <span class="hljs-keyword">else</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;: hasn&#x27;t a table.\n&quot;</span>;<br>    player<span class="hljs-number">1.</span><span class="hljs-built_in">Name</span>();           <span class="hljs-comment">// base object uses base method</span><br>    <span class="hljs-keyword">if</span> (player<span class="hljs-number">1.</span><span class="hljs-built_in">HasTable</span>())<br>        cout &lt;&lt; <span class="hljs-string">&quot;: has a table&quot;</span>;<br>    <span class="hljs-keyword">else</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;: hasn&#x27;t a table.\n&quot;</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Name: &quot;</span>;<br>    rplayer<span class="hljs-number">1.</span><span class="hljs-built_in">Name</span>();<br>    cout &lt;&lt; <span class="hljs-string">&quot;; Rating: &quot;</span> &lt;&lt; rplayer<span class="hljs-number">1.</span><span class="hljs-built_in">Rating</span>() &lt;&lt; endl;<br><span class="hljs-comment">// initialize RatedPlayer using TableTennisPlayer object</span><br>    <span class="hljs-function">RatedPlayer <span class="hljs-title">rplayer2</span><span class="hljs-params">(<span class="hljs-number">1212</span>, player1)</span></span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Name: &quot;</span>;<br>    rplayer<span class="hljs-number">2.</span><span class="hljs-built_in">Name</span>();<br>    cout &lt;&lt; <span class="hljs-string">&quot;; Rating: &quot;</span> &lt;&lt; rplayer<span class="hljs-number">2.</span><span class="hljs-built_in">Rating</span>() &lt;&lt; endl;<br>    <span class="hljs-comment">// std::cin.get();</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="派生类和基类的特殊关系"><a href="#派生类和基类的特殊关系" class="headerlink" title="派生类和基类的特殊关系"></a>派生类和基类的特殊关系</h3><p>用形象的话说，派生类是儿子，继承自基类（爸爸）的方法和数据成员。但是，基类又有自己的“隐私”，派生类是能通过公共接口实现对基类的访问，即无法直接访问其私有成员。</p><blockquote><p>派生类相当于一种<strong>在定义和结构上</strong>获得“权限”的类，权限在于可以直接继承基类所定义好的成员和方法（在定义层面的<strong>继承</strong>），但是<strong>在操作上</strong>，派生类并没有从基类处获得任何特权，不能访问的还是不能访问。</p></blockquote><p>从这条出发，我们可以归纳派生类和基类之间的特殊关系：</p><ul><li>派生类对象可以使用基类的方法，条件是<strong>方法不是私有的</strong>。</li><li><strong>基类指针可以在不进行显示转换的情况下指向派生类对象。</strong></li><li><strong>基类引用可以在不进行显示转换的情况下引用派生类对象。</strong></li></ul><blockquote><p>二、三两条非常的重要，<strong>指针和引用类型的兼容性</strong>确保了其可以在基类和派生类之间反复横跳，更加的灵活。（同时也更加的复杂和危险）</p></blockquote><h4 id="基类指针可以在不进行显示转换的情况下指向派生类对象"><a href="#基类指针可以在不进行显示转换的情况下指向派生类对象" class="headerlink" title="基类指针可以在不进行显示转换的情况下指向派生类对象"></a>基类指针可以在不进行显示转换的情况下指向派生类对象</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base class&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Derived class&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Derived d;<br>    Base* basePtr = &amp;d; <span class="hljs-comment">// 基类指针指向派生类对象</span><br>    basePtr-&gt;<span class="hljs-built_in">display</span>(); <span class="hljs-comment">// 输出: Derived class (多态行为)</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="基类引用可以在不进行显示转换的情况下引用派生类对象。"><a href="#基类引用可以在不进行显示转换的情况下引用派生类对象。" class="headerlink" title="基类引用可以在不进行显示转换的情况下引用派生类对象。"></a>基类引用可以在不进行显示转换的情况下引用派生类对象。</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base class&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Derived class&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Derived d;<br>    Base&amp; baseRef = d; <span class="hljs-comment">// 基类引用绑定到派生类对象</span><br>    baseRef.<span class="hljs-built_in">display</span>(); <span class="hljs-comment">// 输出: Derived class (多态行为)</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><p>注意关键词<code>virtual</code>，之后会讲到，否则会发生静态绑定现象。</p></blockquote><ul><li>基类指针和引用只能调用基类方法，而不可以调用派生类的方法。<ul><li>因为派生类允许添加新的数据成员，如果允许调用会产生很多奇怪的问题。</li></ul></li><li>基类指针和应用可以指向派生类的对象<ul><li><a href="https://blog.csdn.net/goodgoodstudy___/article/details/124905482">这篇讲的很清楚</a></li><li>这里涉及到一些有关虚函数的知识点，暂时先跳过。</li></ul></li><li><strong>基类对象也可以被派生类对象初始化（或赋值）</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">RatedPlayer <span class="hljs-title">player1</span><span class="hljs-params">(<span class="hljs-number">1840</span>,<span class="hljs-string">&quot;o1&quot;</span>,<span class="hljs-string">&quot;Loaf&quot;</span>,<span class="hljs-literal">true</span>)</span></span>;<br><span class="hljs-function">TableTennisPlayer <span class="hljs-title">player2</span><span class="hljs-params">(player1)</span></span>;    <span class="hljs-comment">//VALID</span><br></code></pre></td></tr></table></figure><p>可以用<strong>引用兼容性</strong>的属性来解释这个问题，调用基类的构造函数时不存在匹配的构造函数，故会调用隐式复制构造函数<code>TableTennisPlayer(const TableTennisPlayer&amp;)</code>，形参是<strong>对基类的引用</strong>，<strong>可以在不进行显式转换的</strong>情况下引用派生类对象<code>player1</code>。因此，复制构造函数将嵌套在<code>player1</code>基类中的<code>TableTennisPlayer</code>赋值给了<code>player2</code>。</p><h2 id="Inheritance"><a href="#Inheritance" class="headerlink" title="Inheritance"></a>Inheritance</h2><p>派生类和基类的特殊关系在本质上基于C++继承的底层模型。C++有常见的三种继承方式：</p><ul><li><p>公有继承（<strong>is-a关系</strong>）</p><ul><li>派生类也是一个基类对象，可以执行基类对象执行的任何操作。</li><li><strong>is-a：is a kind of</strong>（往往是抽象与具象的关系）</li></ul><blockquote><p>如果一个派生类选择以<strong>公有继承</strong>的方式，那么应该可以被改写成<strong>XX is a kind of XXX</strong>的形式。例如，香蕉类公有继承水果类（香蕉类可以使用水果类的所有数据和方法，同时香蕉也可以定义自己的数据成员和方法），可以说Banana is a kind of fruit.</p></blockquote><blockquote><p>除了<strong>is a</strong>还有什么关系？有很多，比如<strong>has-a, is-like-a, is-implemented-as-a, uses-a</strong>等等关系，不过，这些都不适合使用公有继承的方式实现。</p></blockquote></li><li><p>保护继承</p></li><li><p>私有继承</p></li></ul><h3 id="多态公有继承"><a href="#多态公有继承" class="headerlink" title="多态公有继承"></a>多态公有继承</h3><p>在传统的继承关系中，派生类可以使用基类的成员函数（只要他不是私有成员）。但有时，派生类希望个性化地修改基类成员函数的方法来实现个性化的目的，因此有必要对基类成员函数进行修改，而非<strong>完全实现</strong>。这种思想被称作<strong>多态</strong>，这种继承方式也被称作多态公有继承。</p><h4 id="例子：Brass-Plus类和Brass类"><a href="#例子：Brass-Plus类和Brass类" class="headerlink" title="例子：Brass Plus类和Brass类"></a>例子：<code>Brass Plus类</code>和<code>Brass类</code></h4><p>书上给出了另一个有关银行的例子，有关类的实现原理请自行阅读。</p><blockquote><p>现在来看另一个例子。由于 Webtown 俱乐部的工作经历，您成了 Pontoon 银行的首席程序员。银行要求您完成的第一项工作是开发两个类。一个类用于表示基本支票账户—Brass Account，另一个类用于表示代表 Brass Plus 支票账户，它添加了透支保护特性。也就是说，如果用户签出一张超出其存款余额的支票——但是超出的数额并不是很大，银行将支付这张支票，对超出的部分收取额外的费用，并追加罚款。可以根据要保存的数据以及允许执行的操作来确定这两种账户的特征。</p><p>下面是用于 Brass Account 支票账户的信息：</p><ul><li>客户姓名；</li><li>账号；</li><li>当前结余。</li></ul><p>下面是可以执行的操作：</p><ul><li>创建账户；</li><li>存款；</li><li>取款；</li><li>显示账户信息。</li></ul><p>Pontoon 银行希望 Brass Plus 支票账户包含 Brass Account 的所有信息及如下信息：</p><ul><li>透支上限；</li><li>透支贷款利率；</li><li>当前的透支总额。</li></ul><p>不需要新增操作，但有两种操作的实现不同：</p><ul><li>对于取款操作，必须考虑透支保护；</li><li>显示操作必须显示 Brass Plus 账户的其他信息。</li></ul><p>假设将第一个类命名为 Brass，第二个类为 BrassPlus。应从 Brass 公有派生出 BrassPlus 吗？要回答这个问题，必须先回答另一个问题： BrassPlus 类是否满足 is-a 条件？当然满足。对于 Brass 对象是正确的事情，对于 BrassPlus 对象也是正确的。它们都将保存客户姓名、账号以及结余。使用这两个类都可以存款、取款和显示账户信息。请注意， is-a 关系通常是不可逆的。也就是说，水果不是香蕉；同样， Brass 对象不具备 BrassPlus 对象的所有功能。</p></blockquote><p>我们直接来看代码，以下是有关两个类实现的头文件声明：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// brass.h  -- bank account classes</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> BRASS_H_</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BRASS_H_</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-comment">// Brass Account Class</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Brass</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>    std::string fullName;<br>    <span class="hljs-type">long</span> acctNum;<br>    <span class="hljs-type">double</span> balance;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Brass</span>(<span class="hljs-type">const</span> std::string &amp; s = <span class="hljs-string">&quot;Nullbody&quot;</span>, <span class="hljs-type">long</span> an = <span class="hljs-number">-1</span>,<br>                <span class="hljs-type">double</span> bal = <span class="hljs-number">0.0</span>);<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Deposit</span><span class="hljs-params">(<span class="hljs-type">double</span> amt)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Withdraw</span><span class="hljs-params">(<span class="hljs-type">double</span> amt)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">Balance</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">ViewAcct</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Brass</span>() &#123;&#125;<br>&#125;;<br><br><span class="hljs-comment">//Brass Plus Account Class</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BrassPlus</span> : <span class="hljs-keyword">public</span> Brass<br>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">double</span> maxLoan;<br>    <span class="hljs-type">double</span> rate;<br>    <span class="hljs-type">double</span> owesBank;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">BrassPlus</span>(<span class="hljs-type">const</span> std::string &amp; s = <span class="hljs-string">&quot;Nullbody&quot;</span>, <span class="hljs-type">long</span> an = <span class="hljs-number">-1</span>,<br>            <span class="hljs-type">double</span> bal = <span class="hljs-number">0.0</span>, <span class="hljs-type">double</span> ml = <span class="hljs-number">500</span>,<br>            <span class="hljs-type">double</span> r = <span class="hljs-number">0.11125</span>);<br>    <span class="hljs-built_in">BrassPlus</span>(<span class="hljs-type">const</span> Brass &amp; ba, <span class="hljs-type">double</span> ml = <span class="hljs-number">500</span>, <br>                        <span class="hljs-type">double</span> r = <span class="hljs-number">0.11125</span>);<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">ViewAcct</span><span class="hljs-params">()</span><span class="hljs-type">const</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Withdraw</span><span class="hljs-params">(<span class="hljs-type">double</span> amt)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ResetMax</span><span class="hljs-params">(<span class="hljs-type">double</span> m)</span> </span>&#123; maxLoan = m; &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ResetRate</span><span class="hljs-params">(<span class="hljs-type">double</span> r)</span> </span>&#123; rate = r; &#125;;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ResetOwes</span><span class="hljs-params">()</span> </span>&#123; owesBank = <span class="hljs-number">0</span>; &#125;<br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>我们发现有以下几点：</p><ul><li><code>BrassPlus</code>类和<code>Brass</code>类都定义了同名函数<code>Withdraw()</code>和<code>Viewacct()</code>。<ul><li>编译器将根据对象的类型自动选择使用哪个类定义中的函数。</li></ul></li><li>出现了新关键词<code>virtual</code><strong>（虚方法）</strong></li></ul><h4 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h4><p>函数<code>Withdraw()</code>和<code>Viewacct()</code>不同于一般的方法 ，在基类和派生类中都有自己的定义（而且定义一般是不同的），这些函数在面向对象编程中被称为<strong>虚函数</strong>。</p><div class="note note-info">            <p>虚函数是指一个<strong>在基类中声明并可以在派生类中重写的成员函数</strong>。虚函数的主要作用是实现<strong>运行时多态</strong>（Runtime Polymorphism），即程序在执行过程中根据对象的实际类型调用相应的函数版本，而不是<strong>根据指针或引用的类型来决定</strong>。</p>          </div><p>下面我们来详细解释一下这个定义，请看如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Base class show&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Derived class show&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Base* basePtr;  <span class="hljs-comment">// 基类指针</span><br>    Derived derivedObj;  <span class="hljs-comment">// 派生类对象</span><br>    <br>    basePtr = &amp;derivedObj;  <span class="hljs-comment">// 基类指针指向派生类对象</span><br>    <br>    <span class="hljs-comment">// 虚函数的调用</span><br>    basePtr-&gt;<span class="hljs-built_in">show</span>();  <span class="hljs-comment">// 运行时会调用派生类的 show()，输出: Derived class show</span><br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在这里，指针<code>basePtr</code>的<strong>定义类型</strong>是Base（基类），但是指向一个派生类的对象（上文提到过这种行为是合法的）。那么在下一行调用<code>show</code>函数的时候是应该<strong>优先考虑指针本身的类型</strong>，还是考虑<strong>指针指向对象的类型</strong>呢？因此，C++引入了关键词<code>virtual</code>来声明一个虚函数，对于虚函数而言，在调用时会<strong>根据对象的实际类型来调用相对应的同名函数</strong>，比如在上文由于baseptr指向的<strong>实际对象</strong>是一个派生类的对象，所以会<strong>调用派生类的函数</strong>。</p><blockquote><p>如果不加virtual关键词，编译器会报错（这个需要更加深入的知识了）</p></blockquote><p>有意思的是，基类<code>Brass</code>的虚构函数同样使用了<code>virtual</code>关键词来定义，这样做是为了确保释放派生对象时，按照正确的顺序调用析构函数。（这形成了一种惯例，后文会再提到）</p><p>接下来，我们来看两个类的具体定义。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// brass.cpp -- bank account class methods</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;brass.h&quot;</span></span><br><span class="hljs-keyword">using</span> std::cout;<br><span class="hljs-keyword">using</span> std::endl;<br><span class="hljs-keyword">using</span> std::string;<br><br><span class="hljs-comment">// formatting stuff</span><br><span class="hljs-keyword">typedef</span> std::ios_base::fmtflags format;<br><span class="hljs-keyword">typedef</span> std::streamsize precis;<br><span class="hljs-function">format <span class="hljs-title">setFormat</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">restore</span><span class="hljs-params">(format f, precis p)</span></span>;<br><br><span class="hljs-comment">// Brass methods</span><br><br>Brass::<span class="hljs-built_in">Brass</span>(<span class="hljs-type">const</span> string &amp; s, <span class="hljs-type">long</span> an, <span class="hljs-type">double</span> bal)<br>&#123;<br>    fullName = s;<br>    acctNum = an;<br>    balance = bal;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Brass::Deposit</span><span class="hljs-params">(<span class="hljs-type">double</span> amt)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (amt &lt; <span class="hljs-number">0</span>)<br>        cout &lt;&lt; <span class="hljs-string">&quot;Negative deposit not allowed; &quot;</span><br>             &lt;&lt; <span class="hljs-string">&quot;deposit is cancelled.\n&quot;</span>;<br>    <span class="hljs-keyword">else</span><br>        balance += amt;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Brass::Withdraw</span><span class="hljs-params">(<span class="hljs-type">double</span> amt)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// set up ###.## format</span><br>    format initialState = <span class="hljs-built_in">setFormat</span>();<br>    precis prec = cout.<span class="hljs-built_in">precision</span>(<span class="hljs-number">2</span>);<br><br>    <span class="hljs-keyword">if</span> (amt &lt; <span class="hljs-number">0</span>)<br>        cout &lt;&lt; <span class="hljs-string">&quot;Withdrawal amount must be positive; &quot;</span><br><br>             &lt;&lt; <span class="hljs-string">&quot;withdrawal canceled.\n&quot;</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (amt &lt;= balance)<br>        balance -= amt;<br>    <span class="hljs-keyword">else</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;Withdrawal amount of $&quot;</span> &lt;&lt; amt<br>             &lt;&lt; <span class="hljs-string">&quot; exceeds your balance.\n&quot;</span><br>             &lt;&lt; <span class="hljs-string">&quot;Withdrawal canceled.\n&quot;</span>;<br>    <span class="hljs-built_in">restore</span>(initialState, prec);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">Brass::Balance</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> balance;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Brass::ViewAcct</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>     <span class="hljs-comment">// set up ###.## format</span><br>    format initialState = <span class="hljs-built_in">setFormat</span>();<br>    precis prec = cout.<span class="hljs-built_in">precision</span>(<span class="hljs-number">2</span>);<br>    cout &lt;&lt; <span class="hljs-string">&quot;Client: &quot;</span> &lt;&lt; fullName &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Account Number: &quot;</span> &lt;&lt; acctNum &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Balance: $&quot;</span> &lt;&lt; balance &lt;&lt; endl;<br>    <span class="hljs-built_in">restore</span>(initialState, prec); <span class="hljs-comment">// Restore original format</span><br>&#125;<br><br><span class="hljs-comment">// BrassPlus Methods</span><br>BrassPlus::<span class="hljs-built_in">BrassPlus</span>(<span class="hljs-type">const</span> string &amp; s, <span class="hljs-type">long</span> an, <span class="hljs-type">double</span> bal,<br>           <span class="hljs-type">double</span> ml, <span class="hljs-type">double</span> r) : <span class="hljs-built_in">Brass</span>(s, an, bal)<br>&#123;<br>    maxLoan = ml;<br>    owesBank = <span class="hljs-number">0.0</span>;<br>    rate = r;<br>&#125;<br><br>BrassPlus::<span class="hljs-built_in">BrassPlus</span>(<span class="hljs-type">const</span> Brass &amp; ba, <span class="hljs-type">double</span> ml, <span class="hljs-type">double</span> r)<br>           : <span class="hljs-built_in">Brass</span>(ba)   <span class="hljs-comment">// uses implicit copy constructor</span><br>&#123;<br>    maxLoan = ml;<br>    owesBank = <span class="hljs-number">0.0</span>;<br>    rate = r;<br>&#125;<br><br><span class="hljs-comment">// redefine how ViewAcct() works</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BrassPlus::ViewAcct</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// set up ###.## format</span><br>    format initialState = <span class="hljs-built_in">setFormat</span>();<br>    precis prec = cout.<span class="hljs-built_in">precision</span>(<span class="hljs-number">2</span>);<br><br>    Brass::<span class="hljs-built_in">ViewAcct</span>();   <span class="hljs-comment">// display base portion</span><br>    <span class="hljs-comment">//注意：这里必须要使用作用域解析运算符，否则会发生无终止递归。（因为编译器会默认认为这里的ViewAcct是调用BrassPlus类中的方法）</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;Maximum loan: $&quot;</span> &lt;&lt; maxLoan &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Owed to bank: $&quot;</span> &lt;&lt; owesBank &lt;&lt; endl;<br>    cout.<span class="hljs-built_in">precision</span>(<span class="hljs-number">3</span>);  <span class="hljs-comment">// ###.### format</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;Loan Rate: &quot;</span> &lt;&lt; <span class="hljs-number">100</span> * rate &lt;&lt; <span class="hljs-string">&quot;%\n&quot;</span>;<br>    <span class="hljs-built_in">restore</span>(initialState, prec); <br>&#125;<br><br><span class="hljs-comment">// redefine how Withdraw() works</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BrassPlus::Withdraw</span><span class="hljs-params">(<span class="hljs-type">double</span> amt)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// set up ###.## format</span><br>    format initialState = <span class="hljs-built_in">setFormat</span>();<br>    precis prec = cout.<span class="hljs-built_in">precision</span>(<span class="hljs-number">2</span>);<br><br>    <span class="hljs-type">double</span> bal = <span class="hljs-built_in">Balance</span>();<br>    <span class="hljs-keyword">if</span> (amt &lt;= bal)<br>        Brass::<span class="hljs-built_in">Withdraw</span>(amt);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( amt &lt;= bal + maxLoan - owesBank)<br>    &#123;<br>        <span class="hljs-type">double</span> advance = amt - bal;<br>        owesBank += advance * (<span class="hljs-number">1.0</span> + rate);<br>        cout &lt;&lt; <span class="hljs-string">&quot;Bank advance: $&quot;</span> &lt;&lt; advance &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Finance charge: $&quot;</span> &lt;&lt; advance * rate &lt;&lt; endl;<br>        <span class="hljs-built_in">Deposit</span>(advance);<br>        Brass::<span class="hljs-built_in">Withdraw</span>(amt);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;Credit limit exceeded. Transaction cancelled.\n&quot;</span>;<br>    <span class="hljs-built_in">restore</span>(initialState, prec); <br>&#125;<br><br><span class="hljs-function">format <span class="hljs-title">setFormat</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// set up ###.## format</span><br>    <span class="hljs-keyword">return</span> cout.<span class="hljs-built_in">setf</span>(std::ios_base::fixed, <br>                std::ios_base::floatfield);<br>&#125; <br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">restore</span><span class="hljs-params">(format f, precis p)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout.<span class="hljs-built_in">setf</span>(f, std::ios_base::floatfield);<br>    cout.<span class="hljs-built_in">precision</span>(p);<br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><p>代码除了注意在定义同名函数的时候<strong>使用作用域运算符以防混淆</strong>，其他都和类的继承的语法知识点没有太多的联系，可自行跳过。</p></blockquote><h3 id="静态联编和动态联编"><a href="#静态联编和动态联编" class="headerlink" title="静态联编和动态联编"></a>静态联编和动态联编</h3><p><strong>函数名联编：</strong>将源代码的函数调用解释为执行特定的函数代码块。</p><p>如果编译器在<strong>编译时</strong>完成了这种联编，那么被称为<strong>静态联编</strong>。但是，由于虚函数的存在，OOP的<strong>多态性</strong>让这种行为变得困难（虚函数保证了调用的函数和对象的实际类型相匹配，而基类指针即可以指向派生类也可以指向基类，这就让编译器很难确定调用哪一个函数）。因此，编译器生成一种<strong>在程序运行时选择正确的虚方法的代码</strong>，这种方法被称为<strong>动态联编</strong>。</p><blockquote><p>和<strong>动态内存分配</strong>有着异曲同工之妙！如果需要再程序运行时确定数组的大小N，则需要使用动态内存分配的方法在程序运行时动态地在<strong>堆</strong>上分配相匹配的内存容量。</p></blockquote><h4 id="指针和引用类型的兼容性"><a href="#指针和引用类型的兼容性" class="headerlink" title="指针和引用类型的兼容性"></a>指针和引用类型的兼容性</h4><p>（这一块有点复杂并且无聊，笔者直接给出结论）</p><ul><li><strong>向上强制转换</strong>：将派生类应用或指针转换为基类引用或指针<ul><li>不需要进行显式类型转换（is-a关系可以看做一种子集关系）</li><li>具有可传递性和兼容性</li></ul></li><li><strong>向下强制转换</strong>：将基类应用或指针转换为派生类引用或指针<ul><li>必须使用显式类型转换</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-comment">// 基类的虚函数</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;Base class display&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Base</span>() &#123;&#125;  <span class="hljs-comment">// 虚析构函数，确保派生类对象能够被正确销毁</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;  <span class="hljs-comment">// 派生类重写 display 函数</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;Derived class display&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-comment">// 派生类的特有函数</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;Derived class show&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 向上转换</span><br>    Derived derivedObj;<br>    Base* basePtr = &amp;derivedObj;  <span class="hljs-comment">// Derived* -&gt; Base* 向上转换</span><br><br>    <span class="hljs-comment">// 使用 basePtr 调用 display()，实际调用的是 Derived 的 display()</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;Using basePtr (upcasting):&quot;</span> &lt;&lt; endl;<br>    basePtr-&gt;<span class="hljs-built_in">display</span>();  <span class="hljs-comment">// 输出: Derived class display</span><br><br>    <span class="hljs-comment">// 向下转换</span><br>    Derived* derivedPtr = <span class="hljs-built_in">dynamic_cast</span>&lt;Derived*&gt;(basePtr);  <span class="hljs-comment">// Base* -&gt; Derived* 向下转换</span><br>    <span class="hljs-keyword">if</span> (derivedPtr) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Using derivedPtr (downcasting):&quot;</span> &lt;&lt; endl;<br>        derivedPtr-&gt;<span class="hljs-built_in">show</span>();  <span class="hljs-comment">// 输出: Derived class show</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Downcasting failed&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-comment">// 向下转换失败的例子</span><br>    Base* anotherBasePtr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Base</span>();  <span class="hljs-comment">// 创建一个纯 Base 类型的对象</span><br>    Derived* failedCastPtr = <span class="hljs-built_in">dynamic_cast</span>&lt;Derived*&gt;(anotherBasePtr);  <span class="hljs-comment">// Base* -&gt; Derived* 向下转换（尝试转换但是转换失败）</span><br>    <span class="hljs-keyword">if</span> (failedCastPtr) &#123;<br>        failedCastPtr-&gt;<span class="hljs-built_in">show</span>();  <span class="hljs-comment">// 不会执行到这里</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Failed downcasting Base* to Derived*&quot;</span> &lt;&lt; endl;  <span class="hljs-comment">// 输出: Failed downcasting Base* to Derived*</span><br>    &#125;<br><br>    <span class="hljs-keyword">delete</span> anotherBasePtr;  <span class="hljs-comment">// 释放内存</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="虚函数成员和动态联编"><a href="#虚函数成员和动态联编" class="headerlink" title="虚函数成员和动态联编"></a>虚函数成员和动态联编</h4><blockquote><p>在原书中，此节介绍了三部分知识：</p><ul><li>为什么有两种类型的联编</li><li>动态联编为何不设置为默认的联编方式</li><li>动态联编的工作原理<ul><li>虚函数表</li></ul></li></ul></blockquote><p>在本文中，我们暂且跳过这一部分，把重点放在虚函数使用的相关注意事项：</p><div class="note note-info">            <ul><li><p>在基类方法的声明中使用关键字 <code>virtual</code> 可使该方法在基类以及所有的派生类（包括从派生类派生出来的类）中是虚的。</p></li><li><p>如果使用指向对象的引用或指针来调用虚方法，程序将使用为对象类型定义的方法，而不使用为引用或指针类型定义的方法。这称为动态联编或晚期联编。这种行为非常重要，因为这样<strong>基类指针或引用可以指向派生类对象</strong>。</p></li><li><p>如果定义的类将被用作基类，则应将那些要在派生类中重新定义的类方法声明为虚的。</p></li><li><p>构造函数不能是虚函数。</p><ul><li>创建派生类对象时会调用基类的构造函数，所以没啥意义。（反正肯定会被调用）</li></ul></li><li><p><strong>析构函数应当是虚函数。</strong></p><ul><li>如果派生类新定义了动态内存分配，那么在调用时如果基类的析构函数不是虚函数，那么如果一个基类指针指向了派生类对象，在调用析构函数的时候会<strong>调用基类的析构函数</strong>，这在派生类中新定义的成员不会被<code>delete</code>掉，产生内存泄漏。</li></ul></li><li><p>友元不能是虚函数（友元不是类成员）</p></li><li><p>重新定义的问题</p><ul><li><p>如果派生类没有重新定义函数，就直接使用基类的版本。</p></li><li><p>如果派生类位于派生链中（一串派生类），那么使用<strong>最新的虚函数版本</strong>。</p></li><li><p><strong>重新定义基类的方法不是重载。</strong>如果在派生类中重新定义函数，将不是使用相同的函数特征标覆盖基类声明，而是隐藏同名的基类方法，不管参数特征标如何。</p><ul><li><p>如果重新定义继承的方法，应确保与原来的原型完全相同，但如果返回类型是基类引用或指针，则可以修改为指向派生类的引用或指针（这种例外是新出现的）。这种特性被称为返回类型协变（covariance of return type），因为允许返回类型随类类型的变化而变化。</p></li><li><p>如果基类声明被重载，应该在派生类中重新定义所有的基类版本。</p></li></ul></li></ul></li></ul>          </div><p><img src="https://ooo.0x0.ooo/2025/01/11/OEfRai.png" alt="Covirance of Return Type"></p><p><img src="https://ooo.0x0.ooo/2025/01/11/OEftNX.png" alt="基类声明被重载"></p><h2 id="Protected"><a href="#Protected" class="headerlink" title="Protected"></a>Protected</h2><p>我们使用<code>public</code>和<code>private</code>来实现对类成员访问权限的控制。同时，我们存在<code>protected</code>关键词。</p><ul><li>与<code>private</code>相比，<code>protected</code>可以被派生类成员直接访问。</li><li>与<code>public</code>相比，<code>protected</code><strong>只能</strong>被派生类成员直接访问，而不能在外部直接访问。</li></ul><blockquote><p>通过protected的实现，基类终于给派生类赋予了一些在访问上的<strong>特权</strong>！</p></blockquote><h2 id="Abstract-Base-Class"><a href="#Abstract-Base-Class" class="headerlink" title="Abstract Base Class"></a>Abstract Base Class</h2><p>在is-a关系中，我们希望<strong>派生类 is a kind of 基类</strong>，因为这样派生类使用基类的成员方法才有意义。但是有些时候使用基类的方法会成为累赘。</p><blockquote><p>例如圆是一种特殊的椭圆。在基类椭圆类中，我们可能会定义椭圆的一些参数和方法，比如长轴短轴离心率，在继承给圆的时候，当然可以把<strong>圆看做一种特殊的椭圆</strong>。但是实际上如果从零开始设计圆类，我们可能只需要圆心和半径即可，这样基类的方法反而是一种使问题变的更加复杂的累赘。</p></blockquote><p>因此，我们可以<strong>从圆和椭圆中提取出抽象的共性，放在一个抽象基类（ABC）中，比如计算面积等方法</strong>，实现代码的重用。如果抽象基类没有包含必要的数据成员来实现有共性的函数，C++使用<strong>纯虚函数（pure virtual function）</strong>提供未实现的函数。</p><blockquote><p>ABC是一种很高深的思想，万事万物的本质原理是什么？亚里士多德提出了<strong>第一性原理</strong>的阐释。在C++中，抽象基类便像第一性原理，后续的派生类都建立在抽象基类的基础之上。真可谓一生二，二生三，三生万物。这便是ABC的哲学！</p></blockquote><p>我们来看代码的示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// acctabc.h  -- bank account classes</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> ACCTABC_H_</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ACCTABC_H_</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-comment">// Abstract Base Class</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AcctABC</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>    std::string fullName;<br>    <span class="hljs-type">long</span> acctNum;<br>    <span class="hljs-type">double</span> balance;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Formatting</span> <br>    &#123;<br>        std::ios_base::fmtflags flag;<br>        std::streamsize pr;<br>        <span class="hljs-comment">//用来设置和恢复格式</span><br>    &#125;;<br>    <span class="hljs-function"><span class="hljs-type">const</span> std::string &amp; <span class="hljs-title">FullName</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<span class="hljs-keyword">return</span> fullName;&#125;<br>    <span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-title">AcctNum</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<span class="hljs-keyword">return</span> acctNum;&#125;<br>    <span class="hljs-function">Formatting <span class="hljs-title">SetFormat</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Restore</span><span class="hljs-params">(Formatting &amp; f)</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-keyword">public</span>: <br>    <span class="hljs-built_in">AcctABC</span>(<span class="hljs-type">const</span> std::string &amp; s = <span class="hljs-string">&quot;Nullbody&quot;</span>, <span class="hljs-type">long</span> an = <span class="hljs-number">-1</span>,<br>                <span class="hljs-type">double</span> bal = <span class="hljs-number">0.0</span>);<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Deposit</span><span class="hljs-params">(<span class="hljs-type">double</span> amt)</span> </span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Withdraw</span><span class="hljs-params">(<span class="hljs-type">double</span> amt)</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">// pure virtual function</span><br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">Balance</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<span class="hljs-keyword">return</span> balance;&#125;;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">ViewAcct</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;     <span class="hljs-comment">// pure virtual function</span><br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">AcctABC</span>() &#123;&#125;<br>    <span class="hljs-comment">//提供纯虚函数接口</span><br>&#125;;<br><br><span class="hljs-comment">// Brass Account Class</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Brass</span> :<span class="hljs-keyword">public</span> AcctABC<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Brass</span>(<span class="hljs-type">const</span> std::string &amp; s = <span class="hljs-string">&quot;Nullbody&quot;</span>, <span class="hljs-type">long</span> an = <span class="hljs-number">-1</span>,<br>           <span class="hljs-type">double</span> bal = <span class="hljs-number">0.0</span>) : <span class="hljs-built_in">AcctABC</span>(s, an, bal) &#123; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Withdraw</span><span class="hljs-params">(<span class="hljs-type">double</span> amt)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">ViewAcct</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Brass</span>() &#123;&#125;<br>&#125;;<br><br><span class="hljs-comment">//Brass Plus Account Class</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BrassPlus</span> : <span class="hljs-keyword">public</span> AcctABC<br>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">double</span> maxLoan;<br>    <span class="hljs-type">double</span> rate;<br>    <span class="hljs-type">double</span> owesBank;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">BrassPlus</span>(<span class="hljs-type">const</span> std::string &amp; s = <span class="hljs-string">&quot;Nullbody&quot;</span>, <span class="hljs-type">long</span> an = <span class="hljs-number">-1</span>,<br>            <span class="hljs-type">double</span> bal = <span class="hljs-number">0.0</span>, <span class="hljs-type">double</span> ml = <span class="hljs-number">500</span>,<br>            <span class="hljs-type">double</span> r = <span class="hljs-number">0.10</span>);<br>    <span class="hljs-built_in">BrassPlus</span>(<span class="hljs-type">const</span> Brass &amp; ba, <span class="hljs-type">double</span> ml = <span class="hljs-number">500</span>, <span class="hljs-type">double</span> r = <span class="hljs-number">0.1</span>);<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">ViewAcct</span><span class="hljs-params">()</span><span class="hljs-type">const</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Withdraw</span><span class="hljs-params">(<span class="hljs-type">double</span> amt)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ResetMax</span><span class="hljs-params">(<span class="hljs-type">double</span> m)</span> </span>&#123; maxLoan = m; &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ResetRate</span><span class="hljs-params">(<span class="hljs-type">double</span> r)</span> </span>&#123; rate = r; &#125;;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ResetOwes</span><span class="hljs-params">()</span> </span>&#123; owesBank = <span class="hljs-number">0</span>; &#125;<br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br></code></pre></td></tr></table></figure><p>以下是一些对代码和抽象基类的解读：</p><ul><li>纯虚函数在声明时需要再尾部加上”0”。</li><li>ABC的主要作用是为<strong>派生类提供一些共性的纯虚函数接口</strong>。</li></ul><p>我们来看一看函数定义中纯虚函数是怎么定义的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// acctabc.cpp -- bank account class methods</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;acctabc.h&quot;</span></span><br><span class="hljs-keyword">using</span> std::cout;<br><span class="hljs-keyword">using</span> std::ios_base;<br><span class="hljs-keyword">using</span> std::endl;<br><span class="hljs-keyword">using</span> std::string;<br><br><span class="hljs-comment">// Abstract Base Class</span><br>AcctABC::<span class="hljs-built_in">AcctABC</span>(<span class="hljs-type">const</span> string &amp; s, <span class="hljs-type">long</span> an, <span class="hljs-type">double</span> bal)<br>&#123;<br>    fullName = s;<br>    acctNum = an;<br>    balance = bal;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AcctABC::Deposit</span><span class="hljs-params">(<span class="hljs-type">double</span> amt)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (amt &lt; <span class="hljs-number">0</span>)<br>        cout &lt;&lt; <span class="hljs-string">&quot;Negative deposit not allowed; &quot;</span>&lt;&lt; <span class="hljs-string">&quot;deposit is cancelled.\n&quot;</span>;<br>    <span class="hljs-keyword">else</span><br>        balance += amt;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AcctABC::Withdraw</span><span class="hljs-params">(<span class="hljs-type">double</span> amt)</span></span><br><span class="hljs-function"></span>&#123;<br>    balance -= amt;<br>&#125;<br><br><span class="hljs-comment">// protected methods for formatting</span><br><span class="hljs-function">AcctABC::Formatting <span class="hljs-title">AcctABC::SetFormat</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-comment">// set up ###.## format</span><br>    Formatting f;<br>    f.flag = <br>        cout.<span class="hljs-built_in">setf</span>(ios_base::fixed, ios_base::floatfield);<br>    f.pr = cout.<span class="hljs-built_in">precision</span>(<span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">return</span> f; <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AcctABC::Restore</span><span class="hljs-params">(Formatting &amp; f)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>    cout.<span class="hljs-built_in">setf</span>(f.flag, ios_base::floatfield);<br>    cout.<span class="hljs-built_in">precision</span>(f.pr);<br>&#125;<br><br><span class="hljs-comment">// Brass methods</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Brass::Withdraw</span><span class="hljs-params">(<span class="hljs-type">double</span> amt)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (amt &lt; <span class="hljs-number">0</span>)<br>        cout &lt;&lt; <span class="hljs-string">&quot;Withdrawal amount must be positive; &quot;</span><br>             &lt;&lt; <span class="hljs-string">&quot;withdrawal canceled.\n&quot;</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (amt &lt;= <span class="hljs-built_in">Balance</span>())<br>        AcctABC::<span class="hljs-built_in">Withdraw</span>(amt);<br>    <span class="hljs-keyword">else</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;Withdrawal amount of $&quot;</span> &lt;&lt; amt<br>             &lt;&lt; <span class="hljs-string">&quot; exceeds your balance.\n&quot;</span><br>             &lt;&lt; <span class="hljs-string">&quot;Withdrawal canceled.\n&quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Brass::ViewAcct</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>   <br>    Formatting f = <span class="hljs-built_in">SetFormat</span>();<br>    cout &lt;&lt; <span class="hljs-string">&quot;Brass Client: &quot;</span> &lt;&lt; <span class="hljs-built_in">FullName</span>() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Account Number: &quot;</span> &lt;&lt; <span class="hljs-built_in">AcctNum</span>() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Balance: $&quot;</span> &lt;&lt; <span class="hljs-built_in">Balance</span>() &lt;&lt; endl;<br>    <span class="hljs-built_in">Restore</span>(f);<br>&#125;<br><br><span class="hljs-comment">// BrassPlus Methods</span><br>BrassPlus::<span class="hljs-built_in">BrassPlus</span>(<span class="hljs-type">const</span> string &amp; s, <span class="hljs-type">long</span> an, <span class="hljs-type">double</span> bal,<br>           <span class="hljs-type">double</span> ml, <span class="hljs-type">double</span> r) : <span class="hljs-built_in">AcctABC</span>(s, an, bal)<br>&#123;<br>    maxLoan = ml;<br>    owesBank = <span class="hljs-number">0.0</span>;<br>    rate = r; <br>&#125;<br><br>BrassPlus::<span class="hljs-built_in">BrassPlus</span>(<span class="hljs-type">const</span> Brass &amp; ba, <span class="hljs-type">double</span> ml, <span class="hljs-type">double</span> r)<br>           : <span class="hljs-built_in">AcctABC</span>(ba)   <span class="hljs-comment">// uses implicit copy constructor</span><br>&#123;<br>    maxLoan = ml;<br>    owesBank = <span class="hljs-number">0.0</span>;<br>    rate = r;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BrassPlus::ViewAcct</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>    Formatting f = <span class="hljs-built_in">SetFormat</span>();<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;BrassPlus Client: &quot;</span> &lt;&lt; <span class="hljs-built_in">FullName</span>() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Account Number: &quot;</span> &lt;&lt; <span class="hljs-built_in">AcctNum</span>() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Balance: $&quot;</span> &lt;&lt; <span class="hljs-built_in">Balance</span>() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Maximum loan: $&quot;</span> &lt;&lt; maxLoan &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Owed to bank: $&quot;</span> &lt;&lt; owesBank &lt;&lt; endl;<br>    cout.<span class="hljs-built_in">precision</span>(<span class="hljs-number">3</span>);<br>    cout &lt;&lt; <span class="hljs-string">&quot;Loan Rate: &quot;</span> &lt;&lt; <span class="hljs-number">100</span> * rate &lt;&lt; <span class="hljs-string">&quot;%\n&quot;</span>;<br>    <span class="hljs-built_in">Restore</span>(f);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BrassPlus::Withdraw</span><span class="hljs-params">(<span class="hljs-type">double</span> amt)</span></span><br><span class="hljs-function"></span>&#123;<br>    Formatting f = <span class="hljs-built_in">SetFormat</span>();<br><br>    <span class="hljs-type">double</span> bal = <span class="hljs-built_in">Balance</span>();<br>    <span class="hljs-keyword">if</span> (amt &lt;= bal)<br>        AcctABC::<span class="hljs-built_in">Withdraw</span>(amt);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( amt &lt;= bal + maxLoan - owesBank)<br>    &#123;<br>        <span class="hljs-type">double</span> advance = amt - bal;<br>        owesBank += advance * (<span class="hljs-number">1.0</span> + rate);<br>        cout &lt;&lt; <span class="hljs-string">&quot;Bank advance: $&quot;</span> &lt;&lt; advance &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Finance charge: $&quot;</span> &lt;&lt; advance * rate &lt;&lt; endl;<br>        <span class="hljs-built_in">Deposit</span>(advance);<br>        AcctABC::<span class="hljs-built_in">Withdraw</span>(amt);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;Credit limit exceeded. Transaction cancelled.\n&quot;</span>;<br>    <span class="hljs-built_in">Restore</span>(f); <br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="继承和动态内存分配"><a href="#继承和动态内存分配" class="headerlink" title="继承和动态内存分配"></a>继承和动态内存分配</h2><p>在阅读这一部分之前，建议读者先阅读<a href="https://xiyuanyang-code.github.io/posts/Dynamic-Memory-and-Classes/">第十二章</a>了解有关C++中的复制构造函数，析构函数，赋值运算符等等相关知识。本部分将继续围绕在类的继承背景下，如何实现动态内存分配。</p><h3 id="派生类不使用new"><a href="#派生类不使用new" class="headerlink" title="派生类不使用new"></a>派生类不使用<code>new</code></h3><p>先来看这样一个使用动态内存分配的基类：</p><p><img src="https://ooo.0x0.ooo/2025/01/11/OEfJdL.png" alt="baseDMA"></p><p>这个基类动态分配内存给一个指向字符的指针（<strong>涉及到了按址传递，故使用默认的复制构造函数会存在风险</strong>），同时也手动定义了显式的赋值运算符，复制构造函数和析构函数。那么，如果以此为基类的派生类没有使用动态内存分配，便<strong>不需要再为派生类显式地定义显式析构函数，复制构造函数和重载赋值运算符。</strong></p><blockquote><p>为什么？你当然可以显式定义，但没有任何的必要。因为默认的赋值运算符和复制构造函数都是在使用动态内存时会产生冲突，基类的动态内存已经手动显示定义，故不存在隐患。</p><p>在复制类所继承的类组件时，会优先使用被继承类的显式构造函数。（对赋值同样也是如此）</p></blockquote><h3 id="派生类使用new"><a href="#派生类使用new" class="headerlink" title="派生类使用new"></a>派生类使用<code>new</code></h3><p>这便是更加复杂的情况，我们来看一个使用动态内存的派生类：</p><p><img src="https://ooo.0x0.ooo/2025/01/11/OEfJdL.png" alt="Derived Class with DMA.png"></p><div class="note note-danger">            <p><strong>在这种情况下，必须为派生类定义显式析构函数、复制构造函数和赋值运算符 。</strong>因为派生类添加了新的数据成员使用动态内存分配，而基类的方法中并不包含这个成员的操作。因此需要额外定义来防止内存泄漏等严重问题。</p>          </div><h3 id="使用友元"><a href="#使用友元" class="headerlink" title="使用友元"></a>使用友元</h3><p>来看下面的综合代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// dma.h  -- inheritance and dynamic memory allocation</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> DMA_H_</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DMA_H_</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-comment">//  Base Class Using DMA</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">baseDMA</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">char</span> * label;<br>    <span class="hljs-type">int</span> rating;<br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">baseDMA</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> * l = <span class="hljs-string">&quot;null&quot;</span>, <span class="hljs-type">int</span> r = <span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">baseDMA</span>(<span class="hljs-type">const</span> baseDMA &amp; rs);<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">baseDMA</span>();<br>    <span class="hljs-comment">//使用虚函数</span><br>    baseDMA &amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> baseDMA &amp; rs);<br>    <span class="hljs-keyword">friend</span> std::ostream &amp; <span class="hljs-keyword">operator</span>&lt;&lt;(std::ostream &amp; os, <br>                                     <span class="hljs-type">const</span> baseDMA &amp; rs);<br>    <span class="hljs-comment">//友元函数（流输出运算符）</span><br>&#125;;<br><br><span class="hljs-comment">// derived class without DMA</span><br><span class="hljs-comment">// no destructor needed</span><br><span class="hljs-comment">// uses implicit copy constructor</span><br><span class="hljs-comment">// uses implicit assignment operator</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">lacksDMA</span> :<span class="hljs-keyword">public</span> baseDMA<br>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">enum</span> &#123; COL_LEN = <span class="hljs-number">40</span>&#125;;<br>    <span class="hljs-type">char</span> color[COL_LEN];<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">lacksDMA</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> * c = <span class="hljs-string">&quot;blank&quot;</span>, <span class="hljs-type">const</span> <span class="hljs-type">char</span> * l = <span class="hljs-string">&quot;null&quot;</span>,<br>              <span class="hljs-type">int</span> r = <span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">lacksDMA</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> * c, <span class="hljs-type">const</span> baseDMA &amp; rs);<br>    <span class="hljs-keyword">friend</span> std::ostream &amp; <span class="hljs-keyword">operator</span>&lt;&lt;(std::ostream &amp; os, <br>                                     <span class="hljs-type">const</span> lacksDMA &amp; rs);<br>&#125;;<br><br><span class="hljs-comment">// derived class with DMA</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">hasDMA</span> :<span class="hljs-keyword">public</span> baseDMA<br>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">char</span> * style;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">hasDMA</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> * s = <span class="hljs-string">&quot;none&quot;</span>, <span class="hljs-type">const</span> <span class="hljs-type">char</span> * l = <span class="hljs-string">&quot;null&quot;</span>,<br>              <span class="hljs-type">int</span> r = <span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">hasDMA</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> * s, <span class="hljs-type">const</span> baseDMA &amp; rs);<br>    <span class="hljs-built_in">hasDMA</span>(<span class="hljs-type">const</span> hasDMA &amp; hs);<br>    ~<span class="hljs-built_in">hasDMA</span>();<br>    hasDMA &amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> hasDMA &amp; rs);  <br>    <span class="hljs-keyword">friend</span> std::ostream &amp; <span class="hljs-keyword">operator</span>&lt;&lt;(std::ostream &amp; os, <br>                                     <span class="hljs-type">const</span> hasDMA &amp; rs);<br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// dma.cpp --dma class methods</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;dma.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-comment">// baseDMA methods</span><br>baseDMA::<span class="hljs-built_in">baseDMA</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> * l, <span class="hljs-type">int</span> r)<br>&#123;<br>    label = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[std::<span class="hljs-built_in">strlen</span>(l) + <span class="hljs-number">1</span>];<br>    std::<span class="hljs-built_in">strcpy</span>(label, l);<br>    rating = r;<br>&#125;<br><br>baseDMA::<span class="hljs-built_in">baseDMA</span>(<span class="hljs-type">const</span> baseDMA &amp; rs)<br>&#123;<br>    label = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[std::<span class="hljs-built_in">strlen</span>(rs.label) + <span class="hljs-number">1</span>];<br>    std::<span class="hljs-built_in">strcpy</span>(label, rs.label);<br>    rating = rs.rating;<br>&#125;<br><br>baseDMA::~<span class="hljs-built_in">baseDMA</span>()<br>&#123;<br>    <span class="hljs-keyword">delete</span> [] label;<br>&#125;<br><br>baseDMA &amp; baseDMA::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> baseDMA &amp; rs)<br>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;rs)<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    <span class="hljs-keyword">delete</span> [] label;<br>    label = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[std::<span class="hljs-built_in">strlen</span>(rs.label) + <span class="hljs-number">1</span>];<br>    std::<span class="hljs-built_in">strcpy</span>(label, rs.label);<br>    rating = rs.rating;<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br>    <br>std::ostream &amp; <span class="hljs-keyword">operator</span>&lt;&lt;(std::ostream &amp; os, <span class="hljs-type">const</span> baseDMA &amp; rs)<br>&#123;<br>    os &lt;&lt; <span class="hljs-string">&quot;Label: &quot;</span> &lt;&lt; rs.label &lt;&lt; std::endl;<br>    os &lt;&lt; <span class="hljs-string">&quot;Rating: &quot;</span> &lt;&lt; rs.rating &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> os;<br>&#125;<br><br><span class="hljs-comment">// lacksDMA methods</span><br>lacksDMA::<span class="hljs-built_in">lacksDMA</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> * c, <span class="hljs-type">const</span> <span class="hljs-type">char</span> * l, <span class="hljs-type">int</span> r)<br>    : <span class="hljs-built_in">baseDMA</span>(l, r)<br>&#123;<br>    std::<span class="hljs-built_in">strncpy</span>(color, c, <span class="hljs-number">39</span>);<br>    color[<span class="hljs-number">39</span>] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>&#125;<br><br>lacksDMA::<span class="hljs-built_in">lacksDMA</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> * c, <span class="hljs-type">const</span> baseDMA &amp; rs)<br>    : <span class="hljs-built_in">baseDMA</span>(rs)<br>&#123;<br>    std::<span class="hljs-built_in">strncpy</span>(color, c, COL_LEN - <span class="hljs-number">1</span>);<br>    color[COL_LEN - <span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>&#125;<br><br>std::ostream &amp; <span class="hljs-keyword">operator</span>&lt;&lt;(std::ostream &amp; os, <span class="hljs-type">const</span> lacksDMA &amp; ls)<br>&#123;<br>    os &lt;&lt; (<span class="hljs-type">const</span> baseDMA &amp;) ls;<br>    os &lt;&lt; <span class="hljs-string">&quot;Color: &quot;</span> &lt;&lt; ls.color &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> os;<br>&#125;<br><br><span class="hljs-comment">// hasDMA methods</span><br>hasDMA::<span class="hljs-built_in">hasDMA</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> * s, <span class="hljs-type">const</span> <span class="hljs-type">char</span> * l, <span class="hljs-type">int</span> r)<br>         : <span class="hljs-built_in">baseDMA</span>(l, r)<br>&#123;<br>    style = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[std::<span class="hljs-built_in">strlen</span>(s) + <span class="hljs-number">1</span>];<br>    std::<span class="hljs-built_in">strcpy</span>(style, s);<br>&#125;<br><br>hasDMA::<span class="hljs-built_in">hasDMA</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> * s, <span class="hljs-type">const</span> baseDMA &amp; rs)<br>         : <span class="hljs-built_in">baseDMA</span>(rs)<br>&#123;<br>    style = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[std::<span class="hljs-built_in">strlen</span>(s) + <span class="hljs-number">1</span>];<br>    std::<span class="hljs-built_in">strcpy</span>(style, s);<br>&#125;<br><br>hasDMA::<span class="hljs-built_in">hasDMA</span>(<span class="hljs-type">const</span> hasDMA &amp; hs)<br>         : <span class="hljs-built_in">baseDMA</span>(hs)  <span class="hljs-comment">// invoke base class copy constructor</span><br>&#123;<br>    style = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[std::<span class="hljs-built_in">strlen</span>(hs.style) + <span class="hljs-number">1</span>];<br>    std::<span class="hljs-built_in">strcpy</span>(style, hs.style);<br>&#125;<br><br>hasDMA::~<span class="hljs-built_in">hasDMA</span>()<br>&#123;<br>    <span class="hljs-keyword">delete</span> [] style;<br>&#125;<br><br>hasDMA &amp; hasDMA::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> hasDMA &amp; hs)<br>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;hs)<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    baseDMA::<span class="hljs-keyword">operator</span>=(hs);  <span class="hljs-comment">// copy base portion，赋值基类的数据成员</span><br>    <span class="hljs-comment">//这个语句等价于 *this = hs;</span><br>    <span class="hljs-keyword">delete</span> [] style;         <span class="hljs-comment">// prepare for new style</span><br>    style = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[std::<span class="hljs-built_in">strlen</span>(hs.style) + <span class="hljs-number">1</span>];<br>    std::<span class="hljs-built_in">strcpy</span>(style, hs.style);<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br>    <br>std::ostream &amp; <span class="hljs-keyword">operator</span>&lt;&lt;(std::ostream &amp; os, <span class="hljs-type">const</span> hasDMA &amp; hs)<br>&#123;<br>    os &lt;&lt; (<span class="hljs-type">const</span> baseDMA &amp;) hs;<br>    <span class="hljs-comment">//使用强制类型转换，使得该行可以调用基类的友元函数</span><br>    os &lt;&lt; <span class="hljs-string">&quot;Style: &quot;</span> &lt;&lt; hs.style &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> os;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在 C++ 中，<strong>友元函数</strong>的行为与普通成员函数不同。友元函数是 <strong>根据它所声明的类</strong> 来确定是否有权限访问该类的私有和保护成员的，而与对象的动态类型无关。因此，友元函数并不遵循 <strong>多态性</strong> 规则。</p><p>例如有以下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span>;  <span class="hljs-comment">// 前置声明</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> baseValue;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Base</span>() : <span class="hljs-built_in">baseValue</span>(<span class="hljs-number">10</span>) &#123;&#125;<br><br>    <span class="hljs-comment">// 友元函数声明</span><br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">printBaseValue</span><span class="hljs-params">(Base&amp; b)</span></span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> derivedValue;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Derived</span>() : <span class="hljs-built_in">derivedValue</span>(<span class="hljs-number">20</span>) &#123;&#125;<br><br>    <span class="hljs-comment">// 友元函数声明，同名函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">printBaseValue</span><span class="hljs-params">(Derived&amp; d)</span></span>;<br>&#125;;<br><br><span class="hljs-comment">// 基类的友元函数定义</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printValue</span><span class="hljs-params">(Base&amp; b)</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Base Value: &quot;</span> &lt;&lt; b.baseValue &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">// 派生类的友元函数定义</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printValue</span><span class="hljs-params">(Derived&amp; d)</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Derived Value: &quot;</span> &lt;&lt; d.derivedValue &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Derived d;<br>    Base* basePtr = &amp;d;  <span class="hljs-comment">// 基类指针指向派生类对象</span><br>    <span class="hljs-comment">// 使用基类指针调用基类的友元函数</span><br>    <span class="hljs-built_in">printValue</span>(*basePtr);  <span class="hljs-comment">// 将会调用 Base 类的友元函数</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>输出结果：<code>Base Value: 10</code></p><p><code>basePtr</code>指针的类型是基类指针，但是指向了一个派生类对象。对于成员函数使用<strong>虚函数声明</strong>保证了调用的函数与实际指向的对象类型相符。（会调用派生类的函数）<strong>但友元函数虽然有访问私有数据成员的特权</strong>，但他不是成员函数，因此友元函数根据类的声明位置（即函数特征标的匹配程度）来决定调用的。在这里编译器判定<code>basePtr</code>指针的类型是基类指针，因此会调用**基类的<code>printValue()</code>**函数，哪怕它指向的是一个派生类对象。</p><p>这就是为什么派生类指针如果想使用基类的友元函数必须先<strong>强制类型转换成</strong>一个基类的指针（就像代码的第105~110行）。</p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p><strong>恭喜你！你已经掌握OOP的基本知识，可以进行一些实操锻炼了！</strong>笔者自己在阅读10,11,12,13四章时非常的痛苦，感觉非常的不适应，但是一路走来，在掌握了OOP的哲学和最基本的原则之后，一切纷繁复杂的语法原理似乎都有理可依。</p><p>接下来，我们将系统梳理这四章的一些内容，受篇幅限制，本部分主要以思维导图和关键词的形式呈现，详细内容大家可以看原书的13.8节。</p><p>OOP的基本精神：</p><ul><li><p>封装（保证操作的安全性和便利性）</p><ul><li><code>private</code><ul><li>储存私有的数据成员</li></ul></li><li><code>public</code><ul><li>一些方法（函数）<ul><li>构造函数<ul><li>默认构造函数</li><li>复制构造函数</li><li>显示定义的构造函数和复制构造函数（深拷贝）</li></ul></li><li>析构函数（显示定义）<ul><li>在12节重点介绍了这些函数和<strong>动态内存分配</strong></li></ul></li><li>运算符重载<ul><li>使用友元函数，this指针</li><li>显示定义赋值运算符</li></ul></li></ul></li><li>提供了访问私有数据成员的接口</li><li>友元函数的声明</li></ul></li><li><code>protected</code><ul><li>基类成员给予派生类成员的一些特权</li></ul></li></ul></li><li><p>继承与多态</p><ul><li>基类——派生类</li><li>公有继承的<strong>is-a</strong>关系</li><li>继承函数的体系就是这一章节的目录（不再归纳）</li></ul><p><img src="https://ooo.0x0.ooo/2025/01/11/OEf4Et.png" alt="Conclusion"></p></li></ul><p>当然，OOP的精神远不止于此！在接下来的第十四章，我们将更加深入的探寻<strong>C++中的其他继承关系和代码重用问题。</strong></p><div class="note note-info">            <p>无论如何，请你记住，面向对象编程是一种精神，而不是繁文缛节的语法。</p>          </div><blockquote><p>THE END                     ——2024&#x2F;12&#x2F;11</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Code</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tutorial</tag>
      
      <tag>C/C++</tag>
      
      <tag>OOP</tag>
      
      <tag>C++ Primer Plus</tag>
      
      <tag>Finished</tag>
      
      <tag>Inheritance</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linked-List-Implementation-Based-on-Structs</title>
    <link href="/posts/Linked-List-Implementation-Based-on-Structs/"/>
    <url>/posts/Linked-List-Implementation-Based-on-Structs/</url>
    
    <content type="html"><![CDATA[<h1 id="Linked-List-Implementation-Based-on-Structs"><a href="#Linked-List-Implementation-Based-on-Structs" class="headerlink" title="Linked List Implementation Based on Structs"></a>Linked List Implementation Based on Structs</h1><p>封面插图截自 <a href="https://www.hello-algo.com/">Hello 算法</a></p><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><blockquote><p>这篇博客从0开始实现了如何<strong>使用结构体完成链表</strong>这一数据结构，并且实现了链表的插入，删除，遍历，查找等基本操作</p><p>This blog starts from scratch to demonstrate how to <strong>implement a linked list data structure using structs</strong>, covering the basic operations including insertion, deletion, traversal, and searching.</p></blockquote><h2 id="Concept"><a href="#Concept" class="headerlink" title="Concept"></a>Concept</h2><p>数组经常用于同类型数据的储存，但是数组规模必须在使用前确定（<strong>连续的顺序数据结构</strong>），这样会带来空间的浪费和诸多不利。但<strong>链表（Linked List）</strong>可以实现在增加元素的时候按需动态分配新的内存，实现了一种<strong>非连续存储</strong>。</p><p><img src="https://www.hello-algo.com/chapter_array_and_linkedlist/array.assets/array_definition.png" alt="数组定义与存储方式"></p><p><img src="https://www.hello-algo.com/chapter_array_and_linkedlist/linked_list.assets/linkedlist_definition.png" alt="链表定义与存储方式"></p><blockquote><p>以上两图节选自 <a href="https://www.hello-algo.com/chapter_array_and_linkedlist/array/">Hello 算法：数组和链表</a></p></blockquote><p>对于数据的存储，最常见的一项操作就是<strong>遍历数据类型中的所有（或者）部分元素</strong>，数组通过指针的<strong>自增操作</strong>实现遍历，但受限于非线性的存储方式，链表无法实现这一点。因此，为了能够达到和数组相同的遍历功能，链表中的每一个元素（或被称为<strong>节点</strong>），都需要一块内存来专门存储<strong>指向下一个元素的节点</strong>。</p><h2 id="Categories"><a href="#Categories" class="headerlink" title="Categories"></a>Categories</h2><ul><li><strong>单向链表</strong>：即前面介绍的普通链表。单向链表的节点包含值和指向下一节点的引用两项数据。我们将首个节点称为头节点，将最后一个节点称为<strong>尾节点</strong>，尾节点指向**空 <code>None</code>**（最后一个节点的节点指针指向空指针） 。</li><li><strong>环形链表</strong>：如果我们令单向链表的尾节点指向头节点（首尾相接），则得到一个环形链表。在环形链表中，任意节点都可以视作头节点。<ul><li>环形列表也可以分为双循环链表和单循环链表</li></ul></li><li><strong>双向链表</strong>：与单向链表相比，双向链表记录了两个方向的引用。<strong>双向链表的节点定义同时包含指向后继节点（下一个节点）和前驱节点（上一个节点）的引用（指针）</strong>。相较于单向链表，双向链表更具灵活性，可以朝两个方向遍历链表，但相应地也需要占用更多的内存空间。</li></ul><p><img src="https://www.hello-algo.com/chapter_array_and_linkedlist/linked_list.assets/linkedlist_common_types.png" alt="Categories"></p><p>图片来源：<a href="https://www.hello-algo.com/chapter_array_and_linkedlist/linked_list/#423">4.2  链表 - Hello 算法</a></p><h2 id="Definition-and-Implementaition"><a href="#Definition-and-Implementaition" class="headerlink" title="Definition and Implementaition"></a>Definition and Implementaition</h2><p>链表的每个节点由两个部分组成：<strong>数据元素本身和指向下一节点的指针。</strong>以下以单链表的相关操作为例：</p><h3 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">linkNode</span>&#123;<br>    datatype data;、<br>    <span class="hljs-comment">//datatype可以为任何一种数据类型，用来描述数据元素的本身的值</span><br>    linkNode* next;<br>&#125;;<br></code></pre></td></tr></table></figure><p>①<code>datatype</code>除了可以是一些<strong>基本数据类型</strong>，例如<code>int</code>，<code>double</code>等之外，也可以是<strong>自定义的非基本数据类型。</strong>例如，可以定义单链表的数据元素为另一个结构体类型的变量，则<code>datatype</code>需要相对应的改变。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node1</span>&#123;<br>    <span class="hljs-type">int</span> thenum;<br>    Node1 *next;<br>&#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node2</span>&#123;<br>    Node1 data;<br>    Node2 *next;<br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    Node1 *linklist1;<br>    <span class="hljs-comment">//定义了一个单链表</span><br>    Node2 *linklist2;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>②next是<strong>指向下一节点的指针</strong>，因此数据类型就是<strong>指向自身类型（自身结构体）</strong>，这种结构被称为<strong>自引用结构</strong>。</p><h3 id="Operations"><a href="#Operations" class="headerlink" title="Operations"></a>Operations</h3><p>对于基本数据结构，我们往往会关注一些基本的“<strong>操作</strong>”，例如插入，修改，删除，排序，访问（遍历）等等。这是数据结构走向算法的具体实现（一个从抽象到具象的过程），同时，由于每一种数据结构实现的底层原理有所不同，其具体的操作的方法和复杂度、优劣势等也各不相同。下文将介绍<strong>链表的创建，插入，访问，删除等基本操作通过结构体实现的底层原理</strong>，并给出一些具体的应用。</p><p>链表由于其自身<strong>非连续的物理结构特征</strong>，<strong>比数组占用更多的内存空间（用来存储下一个节点的地址），但是更加的灵活，扩展性强。</strong>如此结构使链表相比于数组具有更快的插入和删除元素的速度，但是牺牲了访问遍历元素的复杂度。</p><center>表 4-1  数组与链表的效率对比</center><table><thead><tr><th align="center"></th><th align="center">数组</th><th align="center">链表</th></tr></thead><tbody><tr><td align="center">存储方式</td><td align="center">连续内存空间</td><td align="center">分散内存空间</td></tr><tr><td align="center">容量扩展</td><td align="center">长度不可变</td><td align="center">可灵活扩展</td></tr><tr><td align="center">内存效率</td><td align="center">元素占用内存少</td><td align="center">元素占用内存多</td></tr><tr><td align="center">访问元素</td><td align="center">O(1)</td><td align="center">O(n)</td></tr><tr><td align="center">添加元素</td><td align="center">O(n)</td><td align="center">O(1)</td></tr><tr><td align="center">删除元素</td><td align="center">O(n)</td><td align="center">O(1)</td></tr></tbody></table><p>选自 <a href="https://www.hello-algo.com/chapter_array_and_linkedlist/linked_list/#422-vs">Hello算法：数组和链表的比较</a></p><p>接下来，我们一步一步实现自己的链表。</p><p>首先定义<strong>节点</strong>，这是每个链表的基本单元，包括<code>val</code>（储存当前节点的值）和<code>next</code>指向下一个节点地址的指针，在后文笔者习惯把它称为这个节点的<strong>引用</strong>。</p><p>注意到在结构体中增加了一行隐式构造函数，可以在新创建一个节点时设置默认参数（避免指针产生许多奇奇怪怪的问题）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ListNode</span> &#123;<br>    <span class="hljs-type">int</span> val;<br>    ListNode *next;<br>    <span class="hljs-built_in">ListNode</span>(<span class="hljs-type">int</span> value = <span class="hljs-number">0</span>, ListNode *next = <span class="hljs-literal">nullptr</span>) : <span class="hljs-built_in">val</span>(value), <span class="hljs-built_in">next</span>(next) &#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="单链表的创建"><a href="#单链表的创建" class="headerlink" title="单链表的创建"></a>单链表的创建</h4><p>如何初始化一个单链表？难道就是<strong>空空如也？</strong>显然不是，在之后的许多操作时，为了避免指针产生越界的情况，我们经常需要对链表进行<strong>置空检查</strong>（判断链表是否为空）。因此，我们需要再初始化一个新链表时，创建一个<strong>头结点</strong>，并对头节点的指向下一节点的指针初始化为<strong>空指针</strong>。</p><blockquote><p>以下对链表的若干操作都写成函数的形式，方便向OOP的过渡。</p><p>我既然都写析构函数和构造函数了，为什么不直接创建一个类呢（乐）</p></blockquote><p><strong>头结点非常的重要</strong>！！！它代表着链表这一条长蛇的开端，很多操作都是从头结点开始的。</p><p>在之后的操作中，<code>head-&gt;next==nullptr</code>就是对链表的置空检查（可以写成函数封装的形式），如果返回值为<code>true</code>，则代表链表为空，需要对头结点直接操作。</p><p><strong>头结点是链表中额外加入的一个特殊结点，它不存放数据，只是作为链表的开始标记，位于链表的最前面，它的指针部分指向表中的第一个元素，这样就保证了链表中每个结点前面都有一个结点 。</strong></p><blockquote><p>其实头结点也可以指向第一个实际数据，但是这样会导致在后续的链表操作中如果涉及对头结点（也就是首元素）的修改，会变得非常复杂，在这里笔者给出头结点不储存数据的链表实现。</p></blockquote><p>我们定义的第一个函数就是结构体的<strong>默认构造函数</strong>，只有在创建一个新链表的时候才会使用到，其功能是将头结点的引用设置为空指针。同样的，我们也可以设置<strong>析构函数</strong>，在链表结束其生命周期的时候自动调用，通过while循环自动<code>delete</code>所有节点（包括头结点）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">LinkedList</span> &#123;<br>    <span class="hljs-comment">// By default, construct a sentinel node that does not store any value, and its reference points to the first element of the list</span><br>    <span class="hljs-comment">// Initially, it points to nullptr</span><br>    ListNode* sentinel;<br>    <span class="hljs-type">int</span> size = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//size represents the number of nodes in the Linkedlist</span><br><br>    <span class="hljs-comment">// Constructor: Initialize the sentinel node, allocate memory on the heap for it</span><br>    <span class="hljs-built_in">LinkedList</span>(): <span class="hljs-built_in">sentinel</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>()), <span class="hljs-built_in">size</span>(<span class="hljs-number">0</span>) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Created successfully&quot;</span> &lt;&lt; endl;<br>    &#125;;<br><br>    <span class="hljs-comment">// Destructor: Iteratively delete all nodes (including the memory pointed to by the sentinel node initially)</span><br>    <span class="hljs-comment">// Once the sentinel points to a null pointer, the destruction process is complete</span><br>    ~<span class="hljs-built_in">LinkedList</span>() &#123;<br>        <span class="hljs-keyword">while</span> (sentinel != <span class="hljs-literal">nullptr</span>) &#123;<br>            ListNode* temp = sentinel;<br>            sentinel = sentinel-&gt;next;<br>            <span class="hljs-keyword">delete</span> temp;<br>        &#125;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Destroyed successfully&quot;</span> &lt;&lt; endl;<br>    &#125;<br></code></pre></td></tr></table></figure><h4 id="单链表的插入"><a href="#单链表的插入" class="headerlink" title="单链表的插入"></a>单链表的插入</h4><p>我们先来看一种比较原始的插入方式：</p><p><img src="/posts/Above-All/t-Implementation-Based-on-Structs/Insert.png" alt="Insert"></p><p>由上图可知，如果要再节点p的后面插入一个新的节点temp，需要完成以下几件事：</p><ul><li>修改节点p中指向下一个节点的指针，使其指向新节点temp的地址</li><li>修改节点temp中指向下一个节点的指针，使其指向原来在p后面的节点的地址</li></ul><blockquote><p>看到了吗？链表的操作本质上就是对指针的操作！</p></blockquote><p>因此，我们可以给出插入新节点的第一个函数 <code>insertAfter</code>，实现在当前节点current后面插入新的节点，节点值是value。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insertAfter</span><span class="hljs-params">(ListNode* current, <span class="hljs-type">int</span> value)</span> </span>&#123;<br>        <span class="hljs-comment">// If the current node is null, return or throw an exception</span><br>        <span class="hljs-keyword">if</span> (current == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">invalid_argument</span>(<span class="hljs-string">&quot;Current node is null&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// Create a new node</span><br>        ListNode* newNode = <span class="hljs-keyword">new</span> ListNode&#123;value, current-&gt;next&#125;;<br>        <span class="hljs-comment">// Insert the new node after the current node</span><br>        current-&gt;next = newNode;<br>        size++;<br>    &#125;<br></code></pre></td></tr></table></figure><h5 id="Modify①插入到第一个节点"><a href="#Modify①插入到第一个节点" class="headerlink" title="Modify①插入到第一个节点"></a>Modify①插入到第一个节点</h5><p>这个问题非常好解决，相当于更换了链表的头结点，只需要更改插入节点的引用即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insertAtHead</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> </span>&#123;<br>        <span class="hljs-comment">// Set the reference of the new node to the reference of the sentinel node</span><br>        ListNode* newNode = <span class="hljs-keyword">new</span> ListNode&#123;value, sentinel-&gt;next&#125;;<br>        <span class="hljs-comment">// Change the reference of the sentinel node because the first element of the list has changed</span><br>        sentinel-&gt;next = newNode;<br>        size++;<br>    &#125;<br></code></pre></td></tr></table></figure><h5 id="Modify②如何更加的高效？（配合查找）"><a href="#Modify②如何更加的高效？（配合查找）" class="headerlink" title="Modify②如何更加的高效？（配合查找）"></a>Modify②如何更加的高效？（配合查找）</h5><p>如果我们现在需要插入一个新节点使新节点的索引为3，应该怎么办？那我们需要先遍历节点直到达到目标节点，然后再调用<code>insertAfter</code>函数进行目标的插入，当然，如果索引为0，直接<code>insertAtHead</code>即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insertAtPosition</span><span class="hljs-params">(<span class="hljs-type">int</span> value, <span class="hljs-type">int</span> position)</span> </span>&#123;<br>        <span class="hljs-comment">// If the position is 0 or the list is empty, insert at the head</span><br>        <span class="hljs-keyword">if</span> (position == <span class="hljs-number">0</span> || sentinel-&gt;next == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-built_in">insertAtHead</span>(value);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        ListNode* current = sentinel-&gt;next;<br>        <span class="hljs-type">int</span> currentPosition = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// Set a pointer to start the traversal</span><br><br>        <span class="hljs-comment">// Find the node before the insertion position</span><br>        <span class="hljs-keyword">while</span> (current-&gt;next != <span class="hljs-literal">nullptr</span> &amp;&amp; currentPosition &lt; position - <span class="hljs-number">1</span>) &#123;<br>            current = current-&gt;next;<br>            currentPosition++;<br>        &#125;<br><br>        <span class="hljs-comment">// If the position exceeds the end of the list, insert at the end</span><br>        <span class="hljs-keyword">if</span> (currentPosition &lt; position - <span class="hljs-number">1</span>) &#123;<br>            ListNode* newNode = <span class="hljs-keyword">new</span> ListNode&#123;value, <span class="hljs-literal">nullptr</span>&#125;;<br>            current-&gt;next = newNode;<br>            size++;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// Insert the new node</span><br>            <span class="hljs-comment">// current represents the node at index n-1, inserting after it achieves the desired index</span><br>            <span class="hljs-built_in">insertAfter</span>(current, value);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h5 id="Modify③直接在尾部插入"><a href="#Modify③直接在尾部插入" class="headerlink" title="Modify③直接在尾部插入"></a>Modify③直接在尾部插入</h5><p>这里提供了一种比较方便的插入函数，当然我们在定义结构体时也定义了size来维护结构体中的节点个数，因此也可以通过<code>insertAtPosition</code>来实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// Insert directly at the end</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insertAtEnd</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (sentinel-&gt;next == <span class="hljs-literal">nullptr</span>) &#123;<br>            ListNode* newNode = <span class="hljs-keyword">new</span> ListNode&#123;value, <span class="hljs-literal">nullptr</span>&#125;;<br>            sentinel-&gt;next = newNode;<br>            size++;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        ListNode* current = sentinel-&gt;next;<br>        <span class="hljs-keyword">while</span> (current-&gt;next != <span class="hljs-literal">nullptr</span>) &#123;<br>            current = current-&gt;next;<br>        &#125;<br>        <span class="hljs-comment">// Traverse to the last node</span><br>        <span class="hljs-comment">// Create a new node</span><br>        ListNode* newNode = <span class="hljs-keyword">new</span> ListNode&#123;value, <span class="hljs-literal">nullptr</span>&#125;;<br>        current-&gt;next = newNode;<br>        size++;<br>    &#125;<br></code></pre></td></tr></table></figure><p>因此，我们实现了链表的插入操作的函数，用于不同的功能：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//插入函数</span><br>    <span class="hljs-comment">// 在链表头部插入节点</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insertAtHead</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> </span>&#123;<br>        Node* newNode = <span class="hljs-keyword">new</span> Node&#123;value, head&#125;; <span class="hljs-comment">// 使用初始化列表来初始化新节点</span><br>        head = newNode;<br>    &#125;<br><br>    <span class="hljs-comment">// 在指定节点之后插入新节点</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insertAfter</span><span class="hljs-params">(Node* current, <span class="hljs-type">int</span> value)</span> </span>&#123;<br>        <span class="hljs-comment">// 如果当前节点为空，直接返回或抛出异常</span><br>        <span class="hljs-keyword">if</span> (current == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">invalid_argument</span>(<span class="hljs-string">&quot;Current node is null&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 创建新节点</span><br>        Node* newNode = <span class="hljs-keyword">new</span> Node&#123;value, current-&gt;next&#125;;<br>        <span class="hljs-comment">// 将新节点插入到当前节点之后</span><br>        current-&gt;next = newNode;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insertAtPosition</span><span class="hljs-params">(<span class="hljs-type">int</span> value, <span class="hljs-type">int</span> position)</span> </span>&#123;<br>        <span class="hljs-comment">// 如果位置是0或链表为空，则在头部插入</span><br>        <span class="hljs-keyword">if</span> (position == <span class="hljs-number">0</span> || head == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-built_in">insertAtHead</span>(value);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        Node* current = head;<br>        <span class="hljs-type">int</span> currentPosition = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//设置一个指针，开始执行遍历</span><br>    <br>    <br>        <span class="hljs-comment">// 找到插入位置的前一个节点</span><br>        <span class="hljs-keyword">while</span> (current-&gt;next != <span class="hljs-literal">nullptr</span> &amp;&amp; currentPosition &lt; position - <span class="hljs-number">1</span>) &#123;<br>            current = current-&gt;next;<br>            currentPosition++;<br>        &#125;<br><br>        <span class="hljs-comment">// 如果位置超出了链表的末尾，则在末尾插入</span><br>        <span class="hljs-keyword">if</span> (currentPosition &lt; position - <span class="hljs-number">1</span>) &#123;<br>            Node* newNode = <span class="hljs-keyword">new</span> Node&#123;value, <span class="hljs-literal">nullptr</span>&#125;;<br>            current-&gt;next = newNode;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 插入新节点</span><br>            <span class="hljs-comment">//current代表的是n-1索引上的节点，插入到他的后面就是需要达到的目标索引</span><br>            <span class="hljs-built_in">insertAfter</span>(current, value);<br>        &#125;<br>    &#125;<br>    <br></code></pre></td></tr></table></figure><h4 id="单链表的删除"><a href="#单链表的删除" class="headerlink" title="单链表的删除"></a>单链表的删除</h4><p><img src="/posts/Above-All/t-Implementation-Based-on-Structs/erase.png" alt="erase"></p><p>原理和单链表的插入大同小异：</p><ul><li>将<code>delPtr</code>前面的一个节点p的引用更改，使其直接指向后面的一个节点即可</li><li>但是在删除时，要额外关注头和尾的特殊情况<ul><li>如果是第一个元素，则需要更改头结点的对应的值</li><li>如果是尾部元素，直接将上一个元素的应用设置为空指针即可</li></ul></li><li><strong>一定要注意delete！！！</strong></li></ul><p>我们先来看一下比较基础的功能实现：删除末尾的元素，思路如下：</p><ul><li>首先遍历数组走到最后一个元素<ul><li>由于链表非连续的物理结构的特点，其遍历的过程的复杂度会高于数组，达到了O（n）的时间复杂度。</li></ul></li><li>修改倒数第二个元素的引用为空指针</li><li><code>delete</code>掉最后一个元素的内存</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// Delete the last element of the list</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deletetheend</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (sentinel-&gt;next == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// Empty list</span><br><br>        ListNode* current = sentinel-&gt;next;<br>        ListNode* prev = sentinel;<br><br>        <span class="hljs-keyword">while</span> (current-&gt;next != <span class="hljs-literal">nullptr</span>) &#123;<br>            prev = current;<br>            current = current-&gt;next;<br>        &#125;<br>        <span class="hljs-comment">// At this point, current is the last element of the list</span><br>        prev-&gt;next = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">delete</span> current;<br>        size--;<br>    &#125;<br></code></pre></td></tr></table></figure><p>上面的代码已经实现了链表的遍历功能，因此稍微更改一下，便可以实现更多的删除功能。</p><blockquote><p>万变不离其宗，修改前一个的引用，删除后一个。要做的只有这两件事！</p></blockquote><h5 id="Modify①-根据值删除"><a href="#Modify①-根据值删除" class="headerlink" title="Modify① 根据值删除"></a>Modify① 根据值删除</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deleteNode</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (sentinel-&gt;next == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// Empty list</span><br><br>        ListNode* current = sentinel-&gt;next;<br>        ListNode* prev = sentinel;<br><br>        <span class="hljs-keyword">while</span> (current != <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">if</span> (current-&gt;val == key) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            prev = current;<br>            current = current-&gt;next;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (current == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// Node does not exist</span><br><br>        prev-&gt;next = current-&gt;next;<br>        <span class="hljs-keyword">delete</span> current;<br>        size--;<br>    &#125;<br></code></pre></td></tr></table></figure><h5 id="Modify②-根据索引删除"><a href="#Modify②-根据索引删除" class="headerlink" title="Modify② 根据索引删除"></a>Modify② 根据索引删除</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deletetheplace</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (sentinel-&gt;next == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// Empty list</span><br><br>        ListNode* current = sentinel-&gt;next;<br>        ListNode* prev = sentinel;<br>        <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span> (current != <span class="hljs-literal">nullptr</span> &amp;&amp; count &lt; index) &#123;<br>            prev = current;<br>            current = current-&gt;next;<br>            count++;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (count &lt; index) &#123;<br>            <span class="hljs-comment">// Index is too large, no corresponding index</span><br>            <span class="hljs-keyword">return</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// Then current is the node at the target index</span><br>            prev-&gt;next = current-&gt;next;<br>            <span class="hljs-keyword">delete</span> current;<br>            size--;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h4 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h4><p><strong>遍历，插入和删除是链表基本操作中最基本的三个操作，现在我们可以轻而易举地实现其他对链表的操作了。</strong></p><h5 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h5><p>返回特定索引值的val值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">at</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> </span>&#123;<br>        ListNode* current = sentinel-&gt;next;<br>        <span class="hljs-comment">// At this point, current points to the address of the first element of the list</span><br>        <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (count &gt;= size) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">out_of_range</span>(<span class="hljs-string">&quot;Out of range&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">while</span> (count &lt; index) &#123;<br>                current = current-&gt;next;<br>                count++;<br>            &#125;<br>            <span class="hljs-comment">// At this point, current points to the element at the target index</span><br>            <span class="hljs-keyword">return</span> current-&gt;val;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h5 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h5><p>修改特定索引值的val值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> index,<span class="hljs-type">int</span> replacement)</span></span>&#123;<br>        ListNode* current = sentinel-&gt;next;<br>        <span class="hljs-comment">// At this point, current points to the address of the first element of the list</span><br>        <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (count &gt;= size) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">out_of_range</span>(<span class="hljs-string">&quot;Out of range&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">while</span> (count &lt; index) &#123;<br>                current = current-&gt;next;<br>                count++;<br>            &#125;<br>            <span class="hljs-comment">// At this point, current points to the element at the target index</span><br>            current-&gt;val=replacement;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><blockquote><p>以上两个功能的实现本质上都是先通过链表的遍历找到目标索引所对应的内存（current），然后再在已经找到的内存块上做操作。</p></blockquote><h5 id="按值查找"><a href="#按值查找" class="headerlink" title="按值查找"></a>按值查找</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>        ListNode* current = sentinel-&gt;next;<br>        <span class="hljs-comment">// At this point, current points to the address of the first element of the list</span><br>        <span class="hljs-keyword">while</span> (current != <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">if</span> (current-&gt;val == target) &#123;<br>                <span class="hljs-keyword">return</span> count;<br>            &#125;<br>            count++;<br>            current = current-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><h5 id="打印列表（可视化）"><a href="#打印列表（可视化）" class="headerlink" title="打印列表（可视化）"></a>打印列表（可视化）</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printList</span><span class="hljs-params">()</span> </span>&#123;<br>        ListNode* current = sentinel-&gt;next;<br>        <span class="hljs-keyword">while</span> (current != <span class="hljs-literal">nullptr</span>) &#123;<br>            std::cout &lt;&lt; current-&gt;val &lt;&lt; <span class="hljs-string">&quot; -&gt; &quot;</span>;<br>            current = current-&gt;next;<br>        &#125;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;NULL&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br></code></pre></td></tr></table></figure><h5 id="置空检查"><a href="#置空检查" class="headerlink" title="置空检查"></a>置空检查</h5><p>判断链表是否有元素</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// Check if the list is empty</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isempty</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (sentinel-&gt;next == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="Outlook"><a href="#Outlook" class="headerlink" title="Outlook"></a>Outlook</h3><p>Congratulations！现在你已经实现了链表所有的基本操作，包括<strong>初始化，遍历，插入，删除，索引，修改，按值查找，打印等等</strong>。你可以使用自己写的链表去完成一些更加强大的功能！下面是一些展望和未来可以继续改进的方向：</p><ul><li>优化压缩代码，精简复杂度</li><li>将代码改写成OOP的形势，写成头文件</li><li>实现一些更加高级的功能<ul><li>链表的合并</li><li>链表的翻转</li><li>链表的计数</li><li>It’s up to you!</li></ul></li></ul><h2 id="All-codes"><a href="#All-codes" class="headerlink" title="All codes"></a>All codes</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @Author: Xiyuan Yang   xiyuan_yang@outlook.com</span><br><span class="hljs-comment"> * @Date: 2024-12-08 10:28:07</span><br><span class="hljs-comment"> * @LastEditors: Xiyuan Yang   xiyuan_yang@outlook.com</span><br><span class="hljs-comment"> * @LastEditTime: 2024-12-08 13:48:56</span><br><span class="hljs-comment"> * @FilePath: \CODE_for_Vscode\C++_project\Linked_list_copy.cpp</span><br><span class="hljs-comment"> * @Description: </span><br><span class="hljs-comment"> * Do you code and make progress today?</span><br><span class="hljs-comment"> * Copyright (c) 2024 by Xiyuan Yang, All Rights Reserved. </span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ListNode</span> &#123;<br>    <span class="hljs-type">int</span> val;<br>    ListNode *next;<br>    <span class="hljs-built_in">ListNode</span>(<span class="hljs-type">int</span> value = <span class="hljs-number">0</span>, ListNode *next = <span class="hljs-literal">nullptr</span>) : <span class="hljs-built_in">val</span>(value), <span class="hljs-built_in">next</span>(next) &#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">LinkedList</span> &#123;<br>    <span class="hljs-comment">// By default, construct a sentinel node that does not store any value, and its reference points to the first element of the list</span><br>    <span class="hljs-comment">// Initially, it points to nullptr</span><br>    ListNode* sentinel;<br>    <span class="hljs-type">int</span> size = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// Constructor: Initialize the sentinel node, allocate memory on the heap for it</span><br>    <span class="hljs-built_in">LinkedList</span>(): <span class="hljs-built_in">sentinel</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>()), <span class="hljs-built_in">size</span>(<span class="hljs-number">0</span>) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Created successfully&quot;</span> &lt;&lt; endl;<br>    &#125;;<br><br>    <span class="hljs-comment">// Destructor: Iteratively delete all nodes (including the memory pointed to by the sentinel node initially)</span><br>    <span class="hljs-comment">// Once the sentinel points to a null pointer, the destruction process is complete</span><br>    ~<span class="hljs-built_in">LinkedList</span>() &#123;<br>        <span class="hljs-keyword">while</span> (sentinel != <span class="hljs-literal">nullptr</span>) &#123;<br>            ListNode* temp = sentinel;<br>            sentinel = sentinel-&gt;next;<br>            <span class="hljs-keyword">delete</span> temp;<br>        &#125;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Destroyed successfully&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-comment">// Four insertion functions</span><br>    <span class="hljs-comment">// Insert a node at the head of the list</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insertAtHead</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> </span>&#123;<br>        <span class="hljs-comment">// Set the reference of the new node to the reference of the sentinel node</span><br>        ListNode* newNode = <span class="hljs-keyword">new</span> ListNode&#123;value, sentinel-&gt;next&#125;;<br>        <span class="hljs-comment">// Change the reference of the sentinel node because the first element of the list has changed</span><br>        sentinel-&gt;next = newNode;<br>        size++;<br>    &#125;<br><br>    <span class="hljs-comment">// Insert a new node after the specified node</span><br>    <span class="hljs-comment">// current represents the node after which you want to insert</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insertAfter</span><span class="hljs-params">(ListNode* current, <span class="hljs-type">int</span> value)</span> </span>&#123;<br>        <span class="hljs-comment">// If the current node is null, return or throw an exception</span><br>        <span class="hljs-keyword">if</span> (current == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">invalid_argument</span>(<span class="hljs-string">&quot;Current node is null&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// Create a new node</span><br>        ListNode* newNode = <span class="hljs-keyword">new</span> ListNode&#123;value, current-&gt;next&#125;;<br>        <span class="hljs-comment">// Insert the new node after the current node</span><br>        current-&gt;next = newNode;<br>        size++;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insertAtPosition</span><span class="hljs-params">(<span class="hljs-type">int</span> value, <span class="hljs-type">int</span> position)</span> </span>&#123;<br>        <span class="hljs-comment">// If the position is 0 or the list is empty, insert at the head</span><br>        <span class="hljs-keyword">if</span> (position == <span class="hljs-number">0</span> || sentinel-&gt;next == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-built_in">insertAtHead</span>(value);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        ListNode* current = sentinel-&gt;next;<br>        <span class="hljs-type">int</span> currentPosition = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// Set a pointer to start the traversal</span><br><br>        <span class="hljs-comment">// Find the node before the insertion position</span><br>        <span class="hljs-keyword">while</span> (current-&gt;next != <span class="hljs-literal">nullptr</span> &amp;&amp; currentPosition &lt; position - <span class="hljs-number">1</span>) &#123;<br>            current = current-&gt;next;<br>            currentPosition++;<br>        &#125;<br><br>        <span class="hljs-comment">// If the position exceeds the end of the list, insert at the end</span><br>        <span class="hljs-keyword">if</span> (currentPosition &lt; position - <span class="hljs-number">1</span>) &#123;<br>            ListNode* newNode = <span class="hljs-keyword">new</span> ListNode&#123;value, <span class="hljs-literal">nullptr</span>&#125;;<br>            current-&gt;next = newNode;<br>            size++;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// Insert the new node</span><br>            <span class="hljs-comment">// current represents the node at index n-1, inserting after it achieves the desired index</span><br>            <span class="hljs-built_in">insertAfter</span>(current, value);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// Insert directly at the end</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insertAtEnd</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (sentinel-&gt;next == <span class="hljs-literal">nullptr</span>) &#123;<br>            ListNode* newNode = <span class="hljs-keyword">new</span> ListNode&#123;value, <span class="hljs-literal">nullptr</span>&#125;;<br>            sentinel-&gt;next = newNode;<br>            size++;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        ListNode* current = sentinel-&gt;next;<br>        <span class="hljs-keyword">while</span> (current-&gt;next != <span class="hljs-literal">nullptr</span>) &#123;<br>            current = current-&gt;next;<br>        &#125;<br>        <span class="hljs-comment">// Traverse to the last node</span><br>        <span class="hljs-comment">// Create a new node</span><br>        ListNode* newNode = <span class="hljs-keyword">new</span> ListNode&#123;value, <span class="hljs-literal">nullptr</span>&#125;;<br>        current-&gt;next = newNode;<br>        size++;<br>    &#125;<br><br>    <span class="hljs-comment">// Delete operation</span><br>    <span class="hljs-comment">// Delete the node with the specified value</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deleteNode</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (sentinel-&gt;next == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// Empty list</span><br><br>        ListNode* current = sentinel-&gt;next;<br>        ListNode* prev = sentinel;<br><br>        <span class="hljs-keyword">while</span> (current != <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">if</span> (current-&gt;val == key) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            prev = current;<br>            current = current-&gt;next;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (current == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// Node does not exist</span><br><br>        prev-&gt;next = current-&gt;next;<br>        <span class="hljs-keyword">delete</span> current;<br>        size--;<br>    &#125;<br><br>    <span class="hljs-comment">// Delete the last element of the list</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deletetheend</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (sentinel-&gt;next == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// Empty list</span><br><br>        ListNode* current = sentinel-&gt;next;<br>        ListNode* prev = sentinel;<br><br>        <span class="hljs-keyword">while</span> (current-&gt;next != <span class="hljs-literal">nullptr</span>) &#123;<br>            prev = current;<br>            current = current-&gt;next;<br>        &#125;<br>        <span class="hljs-comment">// At this point, current is the last element of the list</span><br>        prev-&gt;next = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">delete</span> current;<br>        size--;<br>    &#125;<br><br>    <span class="hljs-comment">// Delete the element at a specific index in the list</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deletetheplace</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (sentinel-&gt;next == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// Empty list</span><br><br>        ListNode* current = sentinel-&gt;next;<br>        ListNode* prev = sentinel;<br>        <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span> (current != <span class="hljs-literal">nullptr</span> &amp;&amp; count &lt; index) &#123;<br>            prev = current;<br>            current = current-&gt;next;<br>            count++;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (count &lt; index) &#123;<br>            <span class="hljs-comment">// Index is too large, no corresponding index</span><br>            <span class="hljs-keyword">return</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// Then current is the node at the target index</span><br>            prev-&gt;next = current-&gt;next;<br>            <span class="hljs-keyword">delete</span> current;<br>            size--;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> index,<span class="hljs-type">int</span> replacement)</span></span>&#123;<br>        ListNode* current = sentinel-&gt;next;<br>        <span class="hljs-comment">// At this point, current points to the address of the first element of the list</span><br>        <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (count &gt;= size) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">out_of_range</span>(<span class="hljs-string">&quot;Out of range&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">while</span> (count &lt; index) &#123;<br>                current = current-&gt;next;<br>                count++;<br>            &#125;<br>            <span class="hljs-comment">// At this point, current points to the element at the target index</span><br>            current-&gt;val=replacement;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// List search</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">at</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> </span>&#123;<br>        ListNode* current = sentinel-&gt;next;<br>        <span class="hljs-comment">// At this point, current points to the address of the first element of the list</span><br>        <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (count &gt;= size) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">out_of_range</span>(<span class="hljs-string">&quot;Out of range&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">while</span> (count &lt; index) &#123;<br>                current = current-&gt;next;<br>                count++;<br>            &#125;<br>            <span class="hljs-comment">// At this point, current points to the element at the target index</span><br>            <span class="hljs-keyword">return</span> current-&gt;val;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>        ListNode* current = sentinel-&gt;next;<br>        <span class="hljs-comment">// At this point, current points to the address of the first element of the list</span><br>        <span class="hljs-keyword">while</span> (current != <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">if</span> (current-&gt;val == target) &#123;<br>                <span class="hljs-keyword">return</span> count;<br>            &#125;<br>            count++;<br>            current = current-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// Print list content</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printList</span><span class="hljs-params">()</span> </span>&#123;<br>        ListNode* current = sentinel-&gt;next;<br>        <span class="hljs-keyword">while</span> (current != <span class="hljs-literal">nullptr</span>) &#123;<br>            std::cout &lt;&lt; current-&gt;val &lt;&lt; <span class="hljs-string">&quot; -&gt; &quot;</span>;<br>            current = current-&gt;next;<br>        &#125;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;NULL&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-comment">// Check if the list is empty</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isempty</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (sentinel-&gt;next == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    LinkedList thelklist;<br>    cout &lt;&lt; thelklist.<span class="hljs-built_in">isempty</span>() &lt;&lt; endl;<br>    thelklist.<span class="hljs-built_in">insertAtEnd</span>(<span class="hljs-number">6</span>);<br>    thelklist.<span class="hljs-built_in">insertAtEnd</span>(<span class="hljs-number">5</span>);<br>    thelklist.<span class="hljs-built_in">insertAtEnd</span>(<span class="hljs-number">3</span>);<br>    thelklist.<span class="hljs-built_in">insertAfter</span>(thelklist.sentinel, <span class="hljs-number">2</span>);<br>    thelklist.<span class="hljs-built_in">insertAtHead</span>(<span class="hljs-number">11</span>);<br>    thelklist.<span class="hljs-built_in">insertAtPosition</span>(<span class="hljs-number">7</span>, <span class="hljs-number">4</span>);<br>    thelklist.<span class="hljs-built_in">deleteNode</span>(<span class="hljs-number">2</span>);<br>    thelklist.<span class="hljs-built_in">deletetheend</span>();<br>    thelklist.<span class="hljs-built_in">deletetheplace</span>(<span class="hljs-number">3</span>);<br>    cout &lt;&lt; thelklist.<span class="hljs-built_in">isempty</span>() &lt;&lt; endl;<br>    cout &lt;&lt; thelklist.<span class="hljs-built_in">search</span>(<span class="hljs-number">6</span>) &lt;&lt; endl;<br>    cout &lt;&lt; thelklist.<span class="hljs-built_in">search</span>(<span class="hljs-number">2</span>) &lt;&lt; endl;<br>    thelklist.<span class="hljs-built_in">printList</span>();<br>    cout &lt;&lt; thelklist.size &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><p>改良后的代码将会放在我的github仓库，敬请期待~</p></blockquote><h2 id="Extensions1-Linked-List-of-both-sides"><a href="#Extensions1-Linked-List-of-both-sides" class="headerlink" title="Extensions1 Linked-List-of-both-sides"></a>Extensions1 Linked-List-of-both-sides</h2><p>接下来我们来看双链表。单链表的遍历操作是效率比较低的，达到了O（n）的时间复杂度。同时单链表还有一个致命的缺陷：<strong>单链表只能够实现单向的遍历</strong>，因为节点无法获取其前继节点的地址。</p><p>因此，我们需要对链表进行强化，从单链表延伸出<strong>双向链表</strong>：</p><ul><li>每个节点需要储存<strong>前驱结点</strong>和<strong>后继节点</strong>的地址。</li><li>增加了<strong>尾节点</strong>（和<strong>头结点</strong>异曲同工）<ul><li>头结点的前继指针为<code>nullptr</code></li><li>尾节点的后继指针为<code>nullptr</code></li></ul></li></ul><p>由于篇幅限制，我们不再详细解释双链表的OOP实现（或者结构体实现），下面笔者简单的介绍一下双链表中的<strong>插入</strong>操作如何实现：</p><ul><li>动态分配一个新的节点<code>inserted</code></li><li>遍历到需要插入到的位置，即插入到<code>current</code>这个指针指向的节点后面<ul><li>current也可能是头指针</li></ul></li><li>更新<code>inserted</code>的指针的前驱结点的值（<code>current</code>的地址）</li><li>更新<code>inserted</code>的指针的后继结点的值（<code>current</code>的后继结点）</li><li>更新<code>current</code>的后继结点的值为当前<code>inserted</code>的地址。</li></ul><div class="note note-warning">            <p>在自己构造函数实现的时候，一定要注意<strong>每一步的操作顺序！！！</strong>例如在这里2,3两步的顺序就不可以调换，否则<code>current</code>后继结点的值会被抹去，导致<strong>链表中断</strong>。</p>          </div><p>优化后，双链表便有了双向遍历的能力。同时，双链表在<strong>插入和删除</strong>等操作上也具有更高的便利性。例如，在访问某个节点的时候需要删除该节点，则对应单链表而言，需要<strong>从头开始遍历到这个节点的前驱结点</strong>，然后将后继节点和前驱结点直接建立联系。（<strong>本质原因：单链表的设计只允许单向的遍历操作，不可以走回头路</strong>）</p><p>但是，在双链表中，我可以<strong>直接获取特定节点的前驱结点和后继结点的地址</strong>，可以直接进行删除操作。</p><h2 id="Extensions2-Bidirectional-circular-linked-lists"><a href="#Extensions2-Bidirectional-circular-linked-lists" class="headerlink" title="Extensions2 Bidirectional circular linked lists"></a>Extensions2 Bidirectional circular linked lists</h2><p><strong>循环链表</strong>很大的不同之处在于<strong>不再需要设置头尾节点</strong>。但是，为了保证与双向链表的兼容性，可以保留头尾节点，而是<strong>将头结点的前驱结点的地址设置为尾节点的地址，将尾节点的后继结点的地址设置为头结点的地址</strong>。（这样就进需要修改两个值便可以将双向链表升级为<strong>双向循环链表</strong>）。</p><blockquote><p>但是这种方式有一种弊端就是链表成环后，<strong>头结点和尾节点并不储存有效的信息，比较的冗余</strong>。</p></blockquote><p>因此，一般更通用的做法是不设置头结点和尾节点，这样只要讨论<strong>空链表的特殊性</strong>，其他操作也能够正常的完成。</p><p>[推荐这一篇博客，不过是C语言的](<a href="https://www.cnblogs.com/wyfm/p/18533925">数据结构_链表_单向循环链表 &amp; 双向链表的初始化、插入、删除、修改、查询打印（基于C语言实现） - 逸風明 - 博客园</a>)</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p>《C++程序设计——思想与方法》</p><p>《Hello 算法》</p><p>《数据结构：思想和实现》</p><p><a href="https://www.hello-algo.com/">Hello 算法</a></p><blockquote><p>THE END</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tutorial</tag>
      
      <tag>C/C++</tag>
      
      <tag>Finished</tag>
      
      <tag>Linked list</tag>
      
      <tag>Structs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Dynamic-Memory-and-Classes</title>
    <link href="/posts/Dynamic-Memory-and-Classes/"/>
    <url>/posts/Dynamic-Memory-and-Classes/</url>
    
    <content type="html"><![CDATA[<h1 id="C-Primer-Plus-Tutorial-12"><a href="#C-Primer-Plus-Tutorial-12" class="headerlink" title="C++ Primer Plus Tutorial-12"></a>C++ Primer Plus Tutorial-12</h1><h1 id="面向对象编程教程——Section②"><a href="#面向对象编程教程——Section②" class="headerlink" title="面向对象编程教程——Section②"></a>面向对象编程教程——Section②</h1><center><p style="color: red;"><b><font size=6.5>Chapter 12 Dynamic-Memory-and-Classes</font></b></p></center><center><p style="color: red;"><b><font size=6.5>动态内存和类</font></b></p></center><p>【写在前面的话】</p><p><a href="https://xiyuanyang-code.github.io/posts/C-plus-plus-Primer-Plus-tutorial/">C++ Primer Plus Tutorial</a></p><p><a href="https://xiyuanyang-code.github.io/tags/OOP/">系列文章</a></p><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>本章将重点放在如何对<strong>自定义类和对象</strong>谨慎地使用<strong>动态内存分配</strong>，以及内存管理的相关知识。首先从一个代码示例StringBad讲起，分析因为C++自带的隐式复制构造函数导致<strong>按值传递</strong>和<strong>按址传递</strong>发生冲突而导致程序无法正确输出，并以此为教材介绍了如何<strong>显式</strong>地定义<strong>复制构造函数和赋值运算符</strong>，并给出了修改后的String类的类定义和使用示范。接着，文章聚焦于在类中使用动态内存的易错点，包括new和delete的一一对应问题。最后，文章分析了使用动态内存分配在设计类和对象过程中的应用：<strong>设置合理的返回对象</strong>和<strong>使用指向对象的指针</strong>，同时介绍了动态内存管理的一些高级操作，包括<strong>正确地使用析构函数</strong>和<strong>使用定位new运算符</strong>。</p><blockquote><p>This chapter focuses on how to <strong>cautiously use dynamic memory allocation with</strong> <strong>custom classes and objects</strong>, along with related knowledge on memory management. It begins with a code example, StringBad, to analyze how the implicit copy constructor provided by C++ leads to conflicts between <strong>pass-by-value</strong> and <strong>pass-by-reference</strong>, resulting in incorrect program output. Using this example as a teaching tool, the chapter introduces how to <strong>explicitly</strong> define <strong>copy constructors and assignment operators</strong>, and provides an updated class definition and usage demonstration for the String class. Next, the article focuses on common pitfalls when using dynamic memory in classes, including the one-to-one correspondence issue between new and delete. Finally, the chapter discusses the application of dynamic memory allocation in the design of classes and objects: <strong>setting appropriate return objects</strong> and <strong>using pointers to objects</strong>, while also introducing some advanced operations in dynamic memory management, such as <strong>correctly using destructors</strong> and <strong>using placement new operator</strong>.</p><p><strong>Key words: OOP, Dynamic Memory, C++, Classes</strong></p></blockquote><h2 id="Introduction：C-中的特殊成员函数"><a href="#Introduction：C-中的特殊成员函数" class="headerlink" title="Introduction：C++中的特殊成员函数"></a>Introduction：C++中的特殊成员函数</h2><h3 id="示例代码（stringbad类的实现）"><a href="#示例代码（stringbad类的实现）" class="headerlink" title="示例代码（stringbad类的实现）"></a>示例代码（stringbad类的实现）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// strngbad.h -- flawed string class definition</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> STRNGBAD_H_</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> STRNGBAD_H_</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">StringBad</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">char</span> * str;                <span class="hljs-comment">// pointer to string</span><br>    <span class="hljs-type">int</span> len;                   <span class="hljs-comment">// length of string</span><br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> num_strings;    <span class="hljs-comment">// number of objects</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">StringBad</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> * s); <span class="hljs-comment">// constructor</span><br>    <span class="hljs-built_in">StringBad</span>();               <span class="hljs-comment">// default constructor</span><br>    ~<span class="hljs-built_in">StringBad</span>();              <span class="hljs-comment">// destructor</span><br><span class="hljs-comment">// friend function</span><br>    <span class="hljs-keyword">friend</span> std::ostream &amp; <span class="hljs-keyword">operator</span>&lt;&lt;(std::ostream &amp; os, <span class="hljs-type">const</span> StringBad &amp; st);<br>&#125;;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// strngbad.cpp -- StringBad class methods</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span>                    <span class="hljs-comment">// string.h for some</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;strngbad.h&quot;</span></span><br><span class="hljs-keyword">using</span> std::cout;<br><br><span class="hljs-comment">// initializing static class member</span><br><span class="hljs-type">int</span> StringBad::num_strings = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// class methods</span><br><br><span class="hljs-comment">// construct StringBad from C string</span><br>StringBad::<span class="hljs-built_in">StringBad</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> * s)<br>&#123;<br>    len = std::<span class="hljs-built_in">strlen</span>(s);             <span class="hljs-comment">// set size</span><br>    str = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[len + <span class="hljs-number">1</span>];          <span class="hljs-comment">// allot storage</span><br>    std::<span class="hljs-built_in">strcpy</span>(str, s);              <span class="hljs-comment">// initialize pointer</span><br>    num_strings++;                    <span class="hljs-comment">// set object count</span><br>    cout &lt;&lt; num_strings &lt;&lt; <span class="hljs-string">&quot;: \&quot;&quot;</span> &lt;&lt; str<br>         &lt;&lt; <span class="hljs-string">&quot;\&quot; object created\n&quot;</span>;    <span class="hljs-comment">// For Your Information</span><br>&#125;<br><br>StringBad::<span class="hljs-built_in">StringBad</span>()                <span class="hljs-comment">// default constructor</span><br>&#123;<br>    len = <span class="hljs-number">4</span>;<br>    str = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-number">4</span>];<br>    std::<span class="hljs-built_in">strcpy</span>(str, <span class="hljs-string">&quot;C++&quot;</span>);          <span class="hljs-comment">// default string</span><br>    num_strings++;<br>    cout &lt;&lt; num_strings &lt;&lt; <span class="hljs-string">&quot;: \&quot;&quot;</span> &lt;&lt; str<br>         &lt;&lt; <span class="hljs-string">&quot;\&quot; default object created\n&quot;</span>;  <span class="hljs-comment">// FYI</span><br>&#125;<br><br>StringBad::~<span class="hljs-built_in">StringBad</span>()               <span class="hljs-comment">// necessary destructor</span><br>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;\&quot;&quot;</span> &lt;&lt; str &lt;&lt; <span class="hljs-string">&quot;\&quot; object deleted, &quot;</span>;    <span class="hljs-comment">// FYI</span><br>    --num_strings;                    <span class="hljs-comment">// required</span><br>    cout &lt;&lt; num_strings &lt;&lt; <span class="hljs-string">&quot; left\n&quot;</span>; <span class="hljs-comment">// FYI</span><br>    <span class="hljs-keyword">delete</span> [] str;                    <span class="hljs-comment">// required</span><br>&#125;<br><br>std::ostream &amp; <span class="hljs-keyword">operator</span>&lt;&lt;(std::ostream &amp; os, <span class="hljs-type">const</span> StringBad &amp; st)<br>&#123;<br>    os &lt;&lt; st.str;<br>    <span class="hljs-keyword">return</span> os; <br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// vegnews.cpp -- using new and delete with classes</span><br><span class="hljs-comment">// compile with strngbad.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> std::cout;<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;strngbad.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">callme1</span><span class="hljs-params">(StringBad &amp;)</span></span>;  <span class="hljs-comment">// pass by reference</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">callme2</span><span class="hljs-params">(StringBad)</span></span>;    <span class="hljs-comment">// pass by value</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">using</span> std::endl;<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Starting an inner block.\n&quot;</span>;<br>        <span class="hljs-function">StringBad <span class="hljs-title">headline1</span><span class="hljs-params">(<span class="hljs-string">&quot;Celery Stalks at Midnight&quot;</span>)</span></span>;<br>        <span class="hljs-function">StringBad <span class="hljs-title">headline2</span><span class="hljs-params">(<span class="hljs-string">&quot;Lettuce Prey&quot;</span>)</span></span>;<br>        <span class="hljs-function">StringBad <span class="hljs-title">sports</span><span class="hljs-params">(<span class="hljs-string">&quot;Spinach Leaves Bowl for Dollars&quot;</span>)</span></span>;<br>        cout &lt;&lt; <span class="hljs-string">&quot;headline1: &quot;</span> &lt;&lt; headline1 &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">&quot;headline2: &quot;</span> &lt;&lt; headline2 &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">&quot;sports: &quot;</span> &lt;&lt; sports &lt;&lt; endl;<br>        <span class="hljs-built_in">callme1</span>(headline1);<br>        cout &lt;&lt; <span class="hljs-string">&quot;headline1: &quot;</span> &lt;&lt; headline1 &lt;&lt; endl;<br>        <span class="hljs-built_in">callme2</span>(headline2);<br>        cout &lt;&lt; <span class="hljs-string">&quot;headline2: &quot;</span> &lt;&lt; headline2 &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Initialize one object to another:\n&quot;</span>;<br>        StringBad sailor = sports;<br>        cout &lt;&lt; <span class="hljs-string">&quot;sailor: &quot;</span> &lt;&lt; sailor &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Assign one object to another:\n&quot;</span>;<br>        StringBad knot;<br>        knot = headline1;<br>        cout &lt;&lt; <span class="hljs-string">&quot;knot: &quot;</span> &lt;&lt; knot &lt;&lt; endl; <br>        cout &lt;&lt; <span class="hljs-string">&quot;Exiting the block.\n&quot;</span>;<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-string">&quot;End of main()\n&quot;</span>;<br>    <span class="hljs-comment">// std::cin.get();</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">callme1</span><span class="hljs-params">(StringBad &amp; rsb)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;String passed by reference:\n&quot;</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;    \&quot;&quot;</span> &lt;&lt; rsb &lt;&lt; <span class="hljs-string">&quot;\&quot;\n&quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">callme2</span><span class="hljs-params">(StringBad sb)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;String passed by value:\n&quot;</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;    \&quot;&quot;</span> &lt;&lt; sb &lt;&lt; <span class="hljs-string">&quot;\&quot;\n&quot;</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>以上代码实现了一个对字符串类<code>StringBad</code>类的声明与定义，代码示例参见注释，不做解释。</p><p>以下是原书给出的输出示例：</p><p><img src="/posts/Above-All/mory-and-Classes/input1.png"></p><p><img src="/posts/Above-All/mory-and-Classes/input2.png" alt="Output"></p><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p>通过输出可以大致判断<code>stringbad</code>类出现奇怪问题的原因可能如下：</p><ul><li>静态变量<code>num_strings</code>出现了负值，说明在程序中<strong>使用析构函数的次数</strong>多于<strong>使用构造函数的次数</strong></li><li>出现了<strong>非标准字符</strong>，说明字符串在传递过程中的值出现了问题。</li></ul><h3 id="问题分析1"><a href="#问题分析1" class="headerlink" title="问题分析1"></a>问题分析1</h3><p>在上述代码中，存在<strong>两个构造函数</strong>，分别对应有参数和无参数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++">StringBad::<span class="hljs-built_in">StringBad</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> * s)<br>&#123;<br>    len = std::<span class="hljs-built_in">strlen</span>(s);             <span class="hljs-comment">// set size</span><br>    str = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[len + <span class="hljs-number">1</span>];          <span class="hljs-comment">// allot storage</span><br>    std::<span class="hljs-built_in">strcpy</span>(str, s);              <span class="hljs-comment">// initialize pointer</span><br>    num_strings++;                    <span class="hljs-comment">// set object count</span><br>    cout &lt;&lt; num_strings &lt;&lt; <span class="hljs-string">&quot;: \&quot;&quot;</span> &lt;&lt; str<br>         &lt;&lt; <span class="hljs-string">&quot;\&quot; object created\n&quot;</span>;    <span class="hljs-comment">// For Your Information</span><br>&#125;<br><br>StringBad::<span class="hljs-built_in">StringBad</span>()                <span class="hljs-comment">// default constructor</span><br>&#123;<br>    len = <span class="hljs-number">4</span>;<br>    str = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-number">4</span>];<br>    std::<span class="hljs-built_in">strcpy</span>(str, <span class="hljs-string">&quot;C++&quot;</span>);          <span class="hljs-comment">// default string</span><br>    num_strings++;<br>    cout &lt;&lt; num_strings &lt;&lt; <span class="hljs-string">&quot;: \&quot;&quot;</span> &lt;&lt; str<br>         &lt;&lt; <span class="hljs-string">&quot;\&quot; default object created\n&quot;</span>;  <span class="hljs-comment">// FYI</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这是析构函数的定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++">StringBad::~<span class="hljs-built_in">StringBad</span>()               <span class="hljs-comment">// necessary destructor</span><br>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;\&quot;&quot;</span> &lt;&lt; str &lt;&lt; <span class="hljs-string">&quot;\&quot; object deleted, &quot;</span>;    <span class="hljs-comment">// FYI</span><br>    --num_strings;                    <span class="hljs-comment">// required</span><br>    cout &lt;&lt; num_strings &lt;&lt; <span class="hljs-string">&quot; left\n&quot;</span>; <span class="hljs-comment">// FYI</span><br>    <span class="hljs-keyword">delete</span> [] str;                    <span class="hljs-comment">// required</span><br>&#125;<br></code></pre></td></tr></table></figure><p>以上三个函数定义是都没有忘记对静态成员变量<code>num_strings</code>的操作（++&#x2F;–）。因此，原因①可以被更加规范地表述为：<strong>在程序运行中使用显式定义的构造函数的次数少于使用析构函数的次数</strong>，换句话说，程序使用了<strong>第三种构造函数</strong>，这个“第三种构造函数”为程序自动生成，因此没有对<code>num_strings</code>的++操作，导致负值的出现。（毕竟在作用域中每个对象只能构造一次，析构一次，两者的数量应该是相等的。）</p><p>程序中一共涉及到5个对象，这是他们的构造方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">StringBad <span class="hljs-title">headline1</span><span class="hljs-params">(<span class="hljs-string">&quot;Celery Stalks at Midnight&quot;</span>)</span></span>;<br><span class="hljs-function">StringBad <span class="hljs-title">headline2</span><span class="hljs-params">(<span class="hljs-string">&quot;Lettuce Prey&quot;</span>)</span></span>;<br><span class="hljs-function">StringBad <span class="hljs-title">sports</span><span class="hljs-params">(<span class="hljs-string">&quot;Spinach Leaves Bowl for Dollars&quot;</span>)</span></span>;<br><br>StringBad sailor = sports;<br><br>StringBad knot;<br>knot = headline1;<br></code></pre></td></tr></table></figure><p>前三个对象，<code>headline1</code>，<code>headline2</code>，<code>sports</code>都是有函数定义中<code>StringBad::StringBad(const char * s)</code>的构造函数进行构造；最后一个<code>knot</code>使用默认构造函数<code>StringBad::StringBad()</code>进行构造，因此，问题出现在<code>StringBad sailor = sports</code>上。</p><blockquote><p>sailor和knot的初始化很像，但程序处理的方式完全不同。knot在使用<strong>默认构造函数</strong>构造后用headline1进行赋值；而sailor对象使用了一种名叫<strong>复制构造函数</strong>的构造方式！</p></blockquote><h4 id="复制构造函数：隐藏的“第三者”"><a href="#复制构造函数：隐藏的“第三者”" class="headerlink" title="复制构造函数：隐藏的“第三者”"></a>复制构造函数：隐藏的“第三者”</h4><h5 id="复制构造函数的声明"><a href="#复制构造函数的声明" class="headerlink" title="复制构造函数的声明"></a>复制构造函数的声明</h5><p>sailor的构造函数原型等价于如下语句：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">StringBad sailor = <span class="hljs-built_in">StringBad</span> (sports);<br><span class="hljs-comment">//相当于把sailor的副本拷贝给sailor</span><br></code></pre></td></tr></table></figure><p>这里的<code>StringBad()</code>就是C++自动提供的<strong>复制构造函数</strong>，用于<strong>将一个对象复制到一个新创建的对象的初始化中</strong>，注意，是<strong>初始化不是赋值！！！</strong>knot对象的赋值操作和复制构造函数无关（后文会讲到，使用的是<code>赋值运算符</code>），因为对knot的初始化操作已经在上一行代码使用默认构造函数完成了。</p><p>下面是复制构造函数的原型，它<strong>接受一个指向类对象的常量引用作为参数</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">Class_name</span>(<span class="hljs-type">const</span> Class_name &amp;);<br><br><span class="hljs-built_in">StringBad</span>(<span class="hljs-type">const</span> StringBad &amp;);<br></code></pre></td></tr></table></figure><h5 id="复制构造函数的使用场景"><a href="#复制构造函数的使用场景" class="headerlink" title="复制构造函数的使用场景"></a>复制构造函数的使用场景</h5><p>复制构造函数的使用非常常见，尤其在<strong>将新对象与现有对象之间建立联系的时候</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">StringBad <span class="hljs-title">sailor</span><span class="hljs-params">(sports)</span></span>;<br>StringBad sailor=sports;<br>StringBad sailor = <span class="hljs-built_in">StringBad</span> (sports);<br>StringBad *sailor = <span class="hljs-keyword">new</span> <span class="hljs-built_in">StringBad</span>(sports); <br><span class="hljs-comment">//以上四种初始化方式等价，都会使用复制构造函数</span><br></code></pre></td></tr></table></figure><p>更深入地讲，当函数<strong>按值传递对象或返回对象时</strong>，会使用复制构造函数创建原始对象的一个副本作为临时对象，然后将<strong>临时对象的内容赋给要被初始化的对象</strong>（第四种初始化方式所赋值的是所创建的匿名对象的指针）。</p><p>例如程序中的 <code>callme2()</code>函数使用按值传递，会创建一个副本（<strong>这里和函数的形参实参传递本质是相同的</strong>），因此会使用复制构造函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">callme2</span><span class="hljs-params">(StringBad sb)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;String passed by value:\n&quot;</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;    \&quot;&quot;</span> &lt;&lt; sb &lt;&lt; <span class="hljs-string">&quot;\&quot;\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="复制构造函数的功能"><a href="#复制构造函数的功能" class="headerlink" title="复制构造函数的功能"></a>复制构造函数的功能</h5><p>默认的复制构造函数<strong>逐个复制非静态成员（成员复制也称为浅复制）</strong>，复制的是成员的值。  </p><ul><li><p>补充：显式使用复制构造函数提供了对对象复制行为的精细控制，因此也被称作<strong>深拷贝</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span>* data;<br>    <span class="hljs-built_in">MyClass</span>() &#123; data = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">0</span>); &#125;<br>    ~<span class="hljs-built_in">MyClass</span>() &#123; <span class="hljs-keyword">delete</span> data; &#125;<br>    <br>    <span class="hljs-comment">// 显式的复制构造函数</span><br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">const</span> MyClass&amp; other) &#123;<br>        <span class="hljs-comment">// 深拷贝</span><br>        data = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(*other.data);<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    MyClass a;<br>    *a.data = <span class="hljs-number">10</span>;<br>    MyClass b = a; <span class="hljs-comment">// 调用复制构造函数</span><br>    <span class="hljs-comment">// 现在b.data指向一个新的int，其值为10</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>显式声明</strong>：如果你不希望编译器生成默认的复制构造函数，可以通过在类中声明一个私有的复制构造函数并将其标记为<code>delete</code>来阻止默认复制构造函数的生成。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 其他成员函数和变量...</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">const</span> MyClass&amp;) = <span class="hljs-keyword">delete</span>; <span class="hljs-comment">// 阻止默认复制构造函数的生成</span><br>&#125;;<br></code></pre></td></tr></table></figure></li></ul><h4 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h4><p>在了解的复制构造函数后，就不难理解为何静态变量<code>num_strings</code>出现了负值了。在主程序 <code>vegnews.cpp</code> 中，有一下代码用到了隐式的复制构造函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">callme2</span>(headline2);<br>StringBad sailor = sports;<br><span class="hljs-comment">//使用隐式复制构造函数两次，因此计数器会出现-2，problems solved!</span><br></code></pre></td></tr></table></figure><blockquote><p>问题的解决方式已经在上文给出，构建显式构造函数。</p></blockquote><h3 id="问题分析2"><a href="#问题分析2" class="headerlink" title="问题分析2"></a>问题分析2</h3><p>接下来我们将重点放在 <code>字符串乱码</code>的问题上。</p><h4 id="还是复制构造函数的锅！"><a href="#还是复制构造函数的锅！" class="headerlink" title="还是复制构造函数的锅！"></a>还是复制构造函数的锅！</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">StringBad sailor = sports;<br></code></pre></td></tr></table></figure><p>上文提到，隐式复制构造函数奉行<strong>按值传递</strong>的基本思想，而这对于字符串成员而言是非常危险。因为C风格字符串的本质就是<code>char</code>数组，或者说指向<code>char</code>类型的特殊指针。</p><p>因此，在使用隐式复制构造函数时，<code>sports.str</code>将自己的<strong>值</strong>复制给了<code>sailor.str</code>。<strong>此时这两个字符串（指向char类型的指针）指向了同一块内存！</strong>，因此，当释放其中一个对象时，被调用的析构函数会执行下面的操作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">delete</span> [] str;<br></code></pre></td></tr></table></figure><p>在这个程序中，<code>sailor</code>先于 <code>sports</code>被析构函数调用，因此，<code>sailor.str</code>会先被<code>delete</code>掉，这样，**<code>sports.str</code>就变成了“无家可归”的悬挂指针**，后续生成乱码也就很好理解了。</p><p>更严重地，在后续<code>delete``sports.str</code>的时候，相当于程序对同一块内存连续delete两次，这会导致程序的异常终止。</p><h4 id="solution-1"><a href="#solution-1" class="headerlink" title="solution"></a>solution</h4><p>按值传递更加直观，易于理解，但是，一旦程序涉及于指针和内存管理相关的操作时，<strong>按值传递和按址传递（指针）会产生冲突</strong>。因此，手动构建一个显式的复制构造函数迫在眉睫。</p><p>这是原书给出的显示复制构造函数（深拷贝），手动使用 <code>strcpy</code>函数实现字符串的拷贝（按址拷贝）。</p><p><img src="/posts/Above-All/mory-and-Classes/3.png" alt="Explicit Copy Constructor"></p><h3 id="问题还未被解决…"><a href="#问题还未被解决…" class="headerlink" title="问题还未被解决…"></a>问题还未被解决…</h3><p>我们已经解决了因为<strong>隐式复制构造函数</strong>带来的一些问题，其中，问题②主要是因为浅拷贝的<strong>赋值操作</strong>导致的<strong>按值传递与按址传递的冲突</strong>。请看下面的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++">StringBad sailor = sports;<br><br>StringBad knot;<br>knot = headline1;<br></code></pre></td></tr></table></figure><p><code>sailor</code>使用复制构造函数，将<code>sports</code>对象的临时拷贝<strong>赋值</strong>给<code>sailor</code>完成初始化。<code>knot</code>在初始化时使用了默认构造函数，但是也免不了<code>knot = headline1</code>中对其的<strong>赋值操作</strong>，<strong>按值传递与按址传递的冲突</strong>仍然存在！</p><p><img src="/posts/Above-All/mory-and-Classes/input2.png" alt="Output"></p><p>输出示例验证了我们的猜想，在析构时，<code>knot</code>先被<code>delete</code>，因此在最后<code>delete</code> <code>headline1</code>时，字符串呈现乱码。也就是说，<strong>C++默认的对对象的赋值运算符依旧使用按值传递</strong>，即<strong>类重载赋值运算符</strong>。下面是这种运算符的函数原型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">Class_name &amp; Class_name::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Class_name &amp;)<br></code></pre></td></tr></table></figure><p>因此，解决问题的方式也显而易见了：手动定义赋值运算符的重载，和复制构造函数的定义基本相同。书中实现了运算符重载的代码示例：</p><p><img src="/posts/Above-All/mory-and-Classes/4.png" alt="Explicit Overloading of Assignment Operator"></p><h3 id="特殊成员函数"><a href="#特殊成员函数" class="headerlink" title="特殊成员函数"></a>特殊成员函数</h3><p>StringBad 类的问题是由特殊成员函数引起的。这些成员函数是自动定义的，就 StringBad 而言，这些函数的行为与类设计不符。具体地说， C++自动提供了下面这些成员函数：</p><ul><li><strong>默认构造函数，如果没有定义构造函数；</strong></li><li><strong>默认析构函数，如果没有定义；</strong></li><li><strong>复制构造函数，如果没有定义；</strong></li><li><strong>赋值运算符，如果没有定义；</strong></li><li><strong>地址运算符，如果没有定义。</strong>（读者可以自行查阅，就是取址运算符）</li></ul><p>更准确地说，编译器将生成上述最后三个函数的定义——如果程序使用对象的方式要求这样做。例如，如果您将一个对象赋给另一个对象，编译器将提供赋值运算符的定义。</p><h3 id="From-StringBad-to-String"><a href="#From-StringBad-to-String" class="headerlink" title="From StringBad to String"></a>From StringBad to String</h3><p>这就是C++风格的string类的实现！请阅读教材的12.2节，其简单介绍了string类的相关成员函数的定义，受篇幅限制，本博客不再讨论本节内容。对于使用者而言，只需要了解string类的接口足矣，但对于一位优秀的OOP学习者而言，但阅读书中代码，甚至尝试自己实现是锻炼自己OOP能力的一大有力武器。</p><p>此处只给出书中的源代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// string1.h -- fixed and augmented string class definition</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> STRING1_H_</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> STRING1_H_</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> std::ostream;<br><span class="hljs-keyword">using</span> std::istream;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">char</span> * str;             <span class="hljs-comment">// pointer to string</span><br>    <span class="hljs-type">int</span> len;                <span class="hljs-comment">// length of string</span><br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> num_strings; <span class="hljs-comment">// number of objects</span><br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> CINLIM = <span class="hljs-number">80</span>;  <span class="hljs-comment">// cin input limit</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// constructors and other methods</span><br>    <span class="hljs-built_in">String</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> * s); <span class="hljs-comment">// constructor</span><br>    <span class="hljs-built_in">String</span>();               <span class="hljs-comment">// default constructor</span><br>    <span class="hljs-built_in">String</span>(<span class="hljs-type">const</span> String &amp;); <span class="hljs-comment">// copy constructor</span><br>    ~<span class="hljs-built_in">String</span>();              <span class="hljs-comment">// destructor</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">length</span> <span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> len; &#125;<br><span class="hljs-comment">// overloaded operator methods    </span><br>    String &amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> String &amp;);<br>    String &amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *);<br>    <span class="hljs-type">char</span> &amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> i);<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> &amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> i) <span class="hljs-type">const</span>;<br><span class="hljs-comment">// overloaded operator friends</span><br>    <span class="hljs-keyword">friend</span> <span class="hljs-type">bool</span> <span class="hljs-built_in">operator</span>&lt;(<span class="hljs-type">const</span> String &amp;st, <span class="hljs-type">const</span> String &amp;st2);<br>    <span class="hljs-keyword">friend</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&gt;(<span class="hljs-type">const</span> String &amp;st1, <span class="hljs-type">const</span> String &amp;st2);<br>    <span class="hljs-keyword">friend</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> String &amp;st, <span class="hljs-type">const</span> String &amp;st2);<br>    <span class="hljs-keyword">friend</span> ostream &amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp; os, <span class="hljs-type">const</span> String &amp; st);<br>    <span class="hljs-keyword">friend</span> istream &amp; <span class="hljs-keyword">operator</span>&gt;&gt;(istream &amp; is, String &amp; st);<br><span class="hljs-comment">// static function</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">HowMany</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// string1.cpp -- String class methods</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span>                 <span class="hljs-comment">// string.h for some</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;string1.h&quot;</span>               <span class="hljs-comment">// includes &lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> std::cin;<br><span class="hljs-keyword">using</span> std::cout;<br><br><span class="hljs-comment">// initializing static class member</span><br><br><span class="hljs-type">int</span> String::num_strings = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// static method</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">String::HowMany</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> num_strings;<br>&#125;<br><br><span class="hljs-comment">// class methods</span><br>String::<span class="hljs-built_in">String</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> * s)     <span class="hljs-comment">// construct String from C string</span><br>&#123;<br>    len = std::<span class="hljs-built_in">strlen</span>(s);          <span class="hljs-comment">// set size</span><br>    str = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[len + <span class="hljs-number">1</span>];       <span class="hljs-comment">// allot storage</span><br>    std::<span class="hljs-built_in">strcpy</span>(str, s);           <span class="hljs-comment">// initialize pointer</span><br>    num_strings++;                 <span class="hljs-comment">// set object count</span><br>&#125;<br><br>String::<span class="hljs-built_in">String</span>()                   <span class="hljs-comment">// default constructor</span><br>&#123;<br>    len = <span class="hljs-number">4</span>;<br>    str = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-number">1</span>];<br>    str[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;\0&#x27;</span>;                 <span class="hljs-comment">// default string</span><br>    num_strings++;<br>&#125;<br><br>String::<span class="hljs-built_in">String</span>(<span class="hljs-type">const</span> String &amp; st)<br>&#123;<br>    num_strings++;             <span class="hljs-comment">// handle static member update</span><br>    len = st.len;              <span class="hljs-comment">// same length</span><br>    str = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span> [len + <span class="hljs-number">1</span>];  <span class="hljs-comment">// allot space</span><br>    std::<span class="hljs-built_in">strcpy</span>(str, st.str);  <span class="hljs-comment">// copy string to new location</span><br>&#125;<br><br>String::~<span class="hljs-built_in">String</span>()                     <span class="hljs-comment">// necessary destructor</span><br>&#123;<br>    --num_strings;                    <span class="hljs-comment">// required</span><br>    <span class="hljs-keyword">delete</span> [] str;                    <span class="hljs-comment">// required</span><br>&#125;<br><br><span class="hljs-comment">// overloaded operator methods    </span><br><br>    <span class="hljs-comment">// assign a String to a String</span><br>String &amp; String::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> String &amp; st)<br>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;st)<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    <span class="hljs-keyword">delete</span> [] str;<br>    len = st.len;<br>    str = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[len + <span class="hljs-number">1</span>];<br>    std::<span class="hljs-built_in">strcpy</span>(str, st.str);<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><br>    <span class="hljs-comment">// assign a C string to a String</span><br>String &amp; String::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> <span class="hljs-type">char</span> * s)<br>&#123;<br>    <span class="hljs-keyword">delete</span> [] str;<br>    len = std::<span class="hljs-built_in">strlen</span>(s);<br>    str = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[len + <span class="hljs-number">1</span>];<br>    std::<span class="hljs-built_in">strcpy</span>(str, s);<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><br>    <span class="hljs-comment">// read-write char access for non-const String</span><br><span class="hljs-type">char</span> &amp; String::<span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> i)<br>&#123;<br>    <span class="hljs-keyword">return</span> str[i];<br>&#125;<br><br>    <span class="hljs-comment">// read-only char access for const String</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> &amp; String::<span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> i) <span class="hljs-type">const</span><br>&#123;<br>    <span class="hljs-keyword">return</span> str[i];<br>&#125;<br><br><span class="hljs-comment">// overloaded operator friends</span><br><br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> String &amp;st1, <span class="hljs-type">const</span> String &amp;st2)<br>&#123;<br>    <span class="hljs-keyword">return</span> (std::<span class="hljs-built_in">strcmp</span>(st<span class="hljs-number">1.</span>str, st<span class="hljs-number">2.</span>str) &lt; <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&gt;(<span class="hljs-type">const</span> String &amp;st1, <span class="hljs-type">const</span> String &amp;st2)<br>&#123;<br>    <span class="hljs-keyword">return</span> st2 &lt; st1;<br>&#125;<br><br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> String &amp;st1, <span class="hljs-type">const</span> String &amp;st2)<br>&#123;<br>    <span class="hljs-built_in">return</span> (std::<span class="hljs-built_in">strcmp</span>(st<span class="hljs-number">1.</span>str, st<span class="hljs-number">2.</span>str) == <span class="hljs-number">0</span>);<br>&#125;<br><br>    <span class="hljs-comment">// simple String output</span><br>ostream &amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp; os, <span class="hljs-type">const</span> String &amp; st)<br>&#123;<br>    os &lt;&lt; st.str;<br>    <span class="hljs-keyword">return</span> os; <br>&#125;<br><br>    <span class="hljs-comment">// quick and dirty String input</span><br>istream &amp; <span class="hljs-keyword">operator</span>&gt;&gt;(istream &amp; is, String &amp; st)<br>&#123;<br>    <span class="hljs-type">char</span> temp[String::CINLIM];<br>    is.<span class="hljs-built_in">get</span>(temp, String::CINLIM);<br>    <span class="hljs-keyword">if</span> (is)<br>        st = temp;<br>    <span class="hljs-keyword">while</span> (is &amp;&amp; is.<span class="hljs-built_in">get</span>() != <span class="hljs-string">&#x27;\n&#x27;</span>)<br>        <span class="hljs-keyword">continue</span>;<br>    <span class="hljs-keyword">return</span> is; <br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// sayings1.cpp -- using expanded String class</span><br><span class="hljs-comment">// compile with string1.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;string1.h&quot;</span> </span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> ArSize = <span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MaxLen =<span class="hljs-number">81</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">using</span> std::cout;<br>    <span class="hljs-keyword">using</span> std::cin;<br>    <span class="hljs-keyword">using</span> std::endl;<br>    String name;<br>    cout &lt;&lt;<span class="hljs-string">&quot;Hi, what&#x27;s your name?\n&gt;&gt; &quot;</span>;<br>    cin &gt;&gt; name;<br><br>    cout &lt;&lt; name &lt;&lt; <span class="hljs-string">&quot;, please enter up to &quot;</span> &lt;&lt; ArSize<br>        &lt;&lt; <span class="hljs-string">&quot; short sayings &lt;empty line to quit&gt;:\n&quot;</span>;<br>    String sayings[ArSize];     <span class="hljs-comment">// array of objects</span><br>    <span class="hljs-type">char</span> temp[MaxLen];          <span class="hljs-comment">// temporary string storage</span><br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; ArSize; i++)<br>    &#123;<br>        cout &lt;&lt; i<span class="hljs-number">+1</span> &lt;&lt; <span class="hljs-string">&quot;: &quot;</span>;<br>        cin.<span class="hljs-built_in">get</span>(temp, MaxLen);<br>        <span class="hljs-keyword">while</span> (cin &amp;&amp; cin.<span class="hljs-built_in">get</span>() != <span class="hljs-string">&#x27;\n&#x27;</span>)<br>            <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span> (!cin || temp[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;\0&#x27;</span>)    <span class="hljs-comment">// empty line?</span><br>            <span class="hljs-keyword">break</span>;              <span class="hljs-comment">// i not incremented</span><br>        <span class="hljs-keyword">else</span><br>            sayings[i] = temp;  <span class="hljs-comment">// overloaded assignment</span><br>    &#125;<br>    <span class="hljs-type">int</span> total = i;              <span class="hljs-comment">// total # of lines read</span><br><br>    <span class="hljs-keyword">if</span> ( total &gt; <span class="hljs-number">0</span>)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Here are your sayings:\n&quot;</span>;<br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; total; i++)<br>            cout &lt;&lt; sayings[i][<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-string">&quot;: &quot;</span> &lt;&lt; sayings[i] &lt;&lt; endl;<br><br>        <span class="hljs-type">int</span> shortest = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> first = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; total; i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (sayings[i].<span class="hljs-built_in">length</span>() &lt; sayings[shortest].<span class="hljs-built_in">length</span>())<br>                shortest = i;<br>            <span class="hljs-keyword">if</span> (sayings[i] &lt; sayings[first])<br>                first = i;<br>        &#125;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Shortest saying:\n&quot;</span> &lt;&lt; sayings[shortest] &lt;&lt; endl;;<br>        cout &lt;&lt; <span class="hljs-string">&quot;First alphabetically:\n&quot;</span> &lt;&lt; sayings[first] &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">&quot;This program used &quot;</span>&lt;&lt; String::<span class="hljs-built_in">HowMany</span>() <br>             &lt;&lt; <span class="hljs-string">&quot; String objects. Bye.\n&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;No input! Bye.\n&quot;</span>;<br><span class="hljs-comment">// keep window open </span><br><span class="hljs-comment">/*    if (!cin)</span><br><span class="hljs-comment">        cin.clear();</span><br><span class="hljs-comment">    while (cin.get() != &#x27;\n&#x27;)</span><br><span class="hljs-comment">        continue; */</span> <br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="类中动态内存的使用"><a href="#类中动态内存的使用" class="headerlink" title="类中动态内存的使用"></a>类中动态内存的使用</h2><p>通过string类的实现，我们不难发现<strong>动态内存</strong>在类中的使用既便捷，又危险。下文总结了在类与对象定义过程中应当注意的易错点：</p><ul><li><p>使用<code>new</code>创建指针成员，应该在析构函数中使用<code>delete</code></p><ul><li><p><strong>注意点：尽量不要定义类中的静态指针成员，若需要请额外关注其生命周期！</strong></p></li><li><p>在C++中，如果你在类中定义了一个静态指针成员变量，你需要特别注意其生命周期的管理，因为静态成员变量在程序的整个生命周期内只存在一个实例。这意味着：</p><ol><li><strong>初始化</strong>：静态成员变量需要在类外进行初始化。</li><li><strong>内存管理</strong>：如果你使用了动态分配内存（例如，使用<code>new</code>关键字），你需要确保在程序结束之前手动释放这块内存。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span>* staticPointer;<br>&#125;;<br><br><span class="hljs-comment">// 类外初始化</span><br><span class="hljs-type">int</span>* MyClass::staticPointer = <span class="hljs-literal">nullptr</span>;<br></code></pre></td></tr></table></figure><ul><li><p><strong>程序结束之前</strong>：静态成员变量的生命周期与程序相同，因此在程序结束之前，你应该确保所有动态分配的内存被正确释放。这通常意味着在<code>main</code>函数结束之前或在某个全局清理函数中进行<code>delete</code>操作。</p></li><li><p><strong>自定义的清理函数</strong>：如果你希望在程序结束之前明确地控制删除静态成员变量的时间，你可以创建一个函数来执行清理操作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">cleanup</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">delete</span> MyClass::staticPointer;<br>    MyClass::staticPointer = <span class="hljs-literal">nullptr</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 程序运行...</span><br>    <span class="hljs-built_in">cleanup</span>(); <span class="hljs-comment">// 在程序结束前调用</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>使用智能指针</strong>：为了避免手动管理内存，可以考虑使用智能指针（例如<code>std::unique_ptr</code>或<code>std::shared_ptr</code>）来管理静态成员变量的生命周期。这样，内存管理将由智能指针自动处理：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">static</span> std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; staticPointer;<br>&#125;;<br><br><span class="hljs-comment">// 初始化</span><br>std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; MyClass::staticPointer = std::<span class="hljs-built_in">make_unique</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure><p>在这种情况下，你不需要手动<code>delete</code>，因为<code>unique_ptr</code>会在超出作用域时自动释放内存。</p></li><li><p><strong>避免重复删除</strong>：确保你不会多次<code>delete</code>同一个指针，因为这会导致未定义行为。</p></li><li><p>**检查指针是否为<code>nullptr</code>**：在删除静态指针前，检查它是否已经指向了有效的内存地址，防止对<code>nullptr</code>进行<code>delete</code>操作。</p></li></ul></li><li><p>推荐使用C++中的新的关键字<code>nullptr</code>（来替代C风格的<code>NULL</code>）</p></li></ul></li><li><p>注意C++中自动提供的若干<strong>特殊成员函数</strong></p><ul><li>默认构造函数</li><li>默认析构函数</li><li>（隐式）的复制构造函数</li><li>赋值运算符</li><li>地址运算符</li><li><strong>注意：如果你设计的类成员中存在指针等，请务必手动构建显式的成员函数！！！否则会因为按值传递和按址传递的冲突导致很多奇奇怪怪的问题（尤其在赋值和动态内存的手动管理上）</strong></li></ul></li><li><p><code>new</code>和<code>delete</code>很危险，但请踏出使用他们的第一步！</p></li></ul><p>例如，原书给出了三个定义构造函数的实例：</p><p><img src="/posts/Above-All/mory-and-Classes/example1.png"></p><p><img src="/posts/Above-All/mory-and-Classes/example2.png" alt="Standard Practices for Using Dynamic Memory"></p><h2 id="返回对象"><a href="#返回对象" class="headerlink" title="返回对象"></a>返回对象</h2><h3 id="返回类的引用"><a href="#返回类的引用" class="headerlink" title="返回类的引用"></a>返回类的引用</h3><p>在C++中，引用同样也是奉行“按址传递”思想的一大有力武器。在类中，返回引用不用拷贝一个类（这会消耗额外的内存），自然也不会调用复制构造函数。下文将介绍在类中返回引用的一些基础知识：</p><ul><li><p>使用<code>const</code>引用，效率更高，但同时需要注意匹配问题：</p><ul><li>如果形式参数是<code>const</code>对象的话，返回值也应该是<code>const</code>对象！</li></ul></li><li><p>返回指向非const对象的引用</p><ul><li>重载赋值运算符</li></ul><p>例如，我想实现一个连续赋值的操作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++">string s1=<span class="hljs-string">&quot;Hello world&quot;</span>;<br>string s2,s3;<br>s3=s2=s1;<br><span class="hljs-comment">//第三行代码等价于</span><br>s3=(s2=s1);<br></code></pre></td></tr></table></figure><p>首先执行赋值语句 <code>s2=s1</code>，问题来了，表达式的返回值是什么？对于基本数据类型而言，赋值表达式的返回类型是左操作数（即被赋值变量）的引用类型。例如，如果<code>a</code>是一个<code>int</code>变量，那么<code>a = b</code>的返回类型就是<code>int&amp;</code>。如果是自定义类，就需要我们 <strong>关注赋值运算符重载的返回类型、即返回一个自定义类的非const引用</strong>，示例代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 其他成员变量和成员函数...</span><br><br>    <span class="hljs-comment">// 赋值运算符重载</span><br>    MyClass&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> MyClass&amp; other) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;other) &#123; <span class="hljs-comment">// 自赋值检查，防止自我复制</span><br>            <span class="hljs-comment">// 执行实际的赋值操作</span><br>            <span class="hljs-comment">// 例如：</span><br>            <span class="hljs-comment">// this-&gt;data = other.data;</span><br>            <span class="hljs-comment">// ...</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>; <span class="hljs-comment">// 返回当前对象的引用</span><br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 私有成员变量</span><br>    <span class="hljs-type">int</span> data;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    MyClass a, b, c;<br>    <span class="hljs-comment">// 链式赋值</span><br>    a = b = c; <span class="hljs-comment">// 这将按预期工作</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><p>为什么是自身类型的非const引用？一方面，为了连续链式赋值的合法性，我们必须保证首先执行的赋值语句的返回值能够作为参数传入下一个赋值语句，例如在上面的代码中，首先执行的<code>s2=s1</code>，返回值是对s2的引用，而这正好能作为参数传入到下一个赋值语句（将<code>s2</code>的值传递给<code>s3</code>，在这里是s2的引用）。另一方面，由于赋值会改变对象的值，因此不可以使用const引用，故返回一个<strong>自身类型的非const引用</strong>。</p></blockquote><ul><li><code>&lt;&lt;</code>运算符</li></ul><p>这其实和赋值运算符的本质差不多，运算符的本质还是一个<strong>函数</strong>，所以运算（表达式）一定会有返回值（<strong>这个观点非常重要，对我们后续学习运算符重载有很大的帮助</strong>）。我们知道，<strong>流输出运算符的返回值是对流对象的引用</strong>，例如<code>cout&lt;&lt;&quot;Hello&quot;&lt;&lt;&quot;World&quot;;</code>返回的对象是<code>std::ostream&amp;</code>。</p><blockquote><p>还记得第一堂C++课的时候笔者接触到cin和cout，感叹其功能强大之处。但在之后的coding过程中，各种花里胡哨的输入输出类型让笔者恼羞成怒，甚至在一段时间内换回了C风格的<code>printf()</code>和<code>scanf()</code>。但是随着学习的深入，当我们对<strong>流</strong>和引用，类，对象等C++的新概念有了更深刻的理解之后，我们便能体会到cin和cout的强大究竟是如何实现的！</p></blockquote></li></ul><h3 id="返回局部变量：返回对象"><a href="#返回局部变量：返回对象" class="headerlink" title="返回局部变量：返回对象"></a>返回局部变量：返回对象</h3><p>考虑到局部变量的作用域，我们不应该在函数中返回一个局部变量的引用（否则会产生悬挂指针等非常严重的问题）。因此，我们需要<strong>返回一个对象</strong>。看下面的代码示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++">Vector Vector::operater+(<span class="hljs-type">const</span> Vector &amp; b) <span class="hljs-type">const</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">Vector</span>(x+b.x,y+b.y);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Vector</code>（向量）相信大家不陌生，在这里重载了算数运算符<code>+</code>，将两个矢量的和储存在一个新的临时对象中，作为函数的返回值之后再进行相关的赋值操作，最后被丢弃。<strong>在这里会不可避免的使用到复制构造函数，所以务必小心。</strong></p><p>为了保证安全性，可以返回一个<strong>const 对象</strong>，这样可以保证生成的临时对象的值不会被赋值运算符修改。</p><h2 id="使用指向对象的指针"><a href="#使用指向对象的指针" class="headerlink" title="使用指向对象的指针"></a>使用指向对象的指针</h2><h3 id="基本用法回顾"><a href="#基本用法回顾" class="headerlink" title="基本用法回顾"></a>基本用法回顾</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++">  <span class="hljs-comment">// use pointers to keep track of shortest, first strings</span><br>      String * shortest = &amp;sayings[<span class="hljs-number">0</span>]; <span class="hljs-comment">// initialize to first object</span><br>      String * first = &amp;sayings[<span class="hljs-number">0</span>];<br>      <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; total; i++)<br>      &#123;<br>          <span class="hljs-keyword">if</span> (sayings[i].<span class="hljs-built_in">length</span>() &lt; shortest-&gt;<span class="hljs-built_in">length</span>())<br>              shortest = &amp;sayings[i];<br>          <span class="hljs-keyword">if</span> (sayings[i] &lt; *first)     <span class="hljs-comment">// compare values</span><br>              first = &amp;sayings[i];     <span class="hljs-comment">// assign address</span><br>      &#125;<br>      cout &lt;&lt; <span class="hljs-string">&quot;Shortest saying:\n&quot;</span> &lt;&lt; * shortest &lt;&lt; endl;<br>      cout &lt;&lt; <span class="hljs-string">&quot;First alphabetically:\n&quot;</span> &lt;&lt; * first &lt;&lt; endl;<br><br>      <span class="hljs-built_in">srand</span>(<span class="hljs-built_in">time</span>(<span class="hljs-number">0</span>));<br>      <span class="hljs-type">int</span> choice = <span class="hljs-built_in">rand</span>() % total; <span class="hljs-comment">// pick index at random</span><br><br><br><br>  <span class="hljs-comment">// use new to create, initialize new String object</span><br>      String * favorite = <span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(sayings[choice]);<br><span class="hljs-comment">//这里会调用相应的构造函数</span><br>      cout &lt;&lt; <span class="hljs-string">&quot;My favorite saying:\n&quot;</span> &lt;&lt; *favorite &lt;&lt; endl;<br>      <span class="hljs-keyword">delete</span> favorite;<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>      cout &lt;&lt; <span class="hljs-string">&quot;Not much to say, eh?\n&quot;</span>;<br>  cout &lt;&lt; <span class="hljs-string">&quot;Bye.\n&quot;</span>;<br></code></pre></td></tr></table></figure><p>代码的第一部分是指向对象指针的常见用法，包括<code>-&gt;</code>运算符，常见的取址和解引用运算。代码的第二部分涉及到<code>new</code>和<code>delete</code>操作。</p><h3 id="一些高级用法"><a href="#一些高级用法" class="headerlink" title="一些高级用法"></a>一些高级用法</h3><h4 id="何时使用析构函数？"><a href="#何时使用析构函数？" class="headerlink" title="何时使用析构函数？"></a>何时使用析构函数？</h4><p><img src="/posts/Above-All/mory-and-Classes/%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0.png" alt="析构函数"></p><p>在下述情况下析构函数将被调用（参见图 12.4）。</p><ul><li>如果对象是动态变量，则当<strong>执行完定义该对象的程序块</strong>时，将调用该对象的析构函数。</li><li>如果对象是<strong>静态变量（外部、静态、静态外部或来自名称空间）</strong>，则在程序结束时将调用对象的析构函数。</li><li>如果对象是用 new 创建的，则仅当您<strong>显式使用 delete 删除对象</strong>时，其析构函数才会被调用。</li></ul><p>例如在上面的例子中，一共定义了三个基于<code>Act</code>类的对象：<code>nice</code>（全局变量，与程序共存亡）、<code>pt</code>（使用new定义的一个指向Act类的指针）、<code>up</code>（在一个代码块中定义的自动局部变量）</p><p><strong>注意！</strong></p><ul><li><p>如果析构函数通过对指针类成员使用 delete 来释放内存，则每个构造函数都应当使用 new 来初始化指针，或将它设置为空指针。</p><blockquote><p>如果类的析构函数使用<code>delete</code>来释放指针成员，那么意味着这个指针成员在对象的生命周期内被认为是指向动态分配的内存的。为了确保在对象被销毁时不会尝试删除一个未初始化的指针，每个构造函数都应该使用<code>new</code>来为指针成员分配内存，或者将指针成员初始化为<code>nullptr</code>（在C++11及以后的版本中使用<code>nullptr</code>，之前的版本使用<code>NULL</code>或<code>0</code>）</p></blockquote></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyClass</span>() : <span class="hljs-built_in">data</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">42</span>)) &#123;&#125; <span class="hljs-comment">// 初始化指针成员</span><br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">int</span> val) : <span class="hljs-built_in">data</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(val)) &#123;&#125; <span class="hljs-comment">// 另一种初始化方式</span><br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">MyClass</span><span class="hljs-params">(<span class="hljs-type">bool</span> flag)</span> : data(nullptr) &#123;</span>&#125; <span class="hljs-comment">// 将指针设置为空指针</span><br>    ~<span class="hljs-built_in">MyClass</span>() &#123;<br>        <span class="hljs-keyword">delete</span> data;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span>* data;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h4 id="定位new运算符"><a href="#定位new运算符" class="headerlink" title="定位new运算符"></a>定位new运算符</h4><h5 id="什么是定位new运算符？"><a href="#什么是定位new运算符？" class="headerlink" title="什么是定位new运算符？"></a>什么是定位new运算符？</h5><p><strong>定位new运算符</strong>（Placement New Operator）是C++中一种特殊的<code>new</code>运算符，它允许你将对象构造在预先分配好的内存位置上，而不像常规的<code>new</code>那样动态分配内存。这在某些情况下特别有用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">void</span>* memory = ...; <span class="hljs-comment">// 预先分配好的内存</span><br>SomeType* obj = <span class="hljs-built_in">new</span> (memory) <span class="hljs-built_in">SomeType</span>(arguments); <span class="hljs-comment">// 构造对象在预先分配的内存上</span><br></code></pre></td></tr></table></figure><p>这里的<code>memory</code>是一个指向已经分配好的内存的指针，<code>SomeType</code>是你的类或类型，<code>arguments</code>是传递给构造函数的参数。</p><ol><li><p><strong>不分配内存</strong>：定位new不会分配新的内存，它只是在<strong>给定的内存位置上调用构造函数来初始化对象</strong>。</p></li><li><p><strong>手动内存管理</strong>：使用定位new意味着你必须手动管理内存的生命周期，包括确保内存是在定位new之前分配的，并且在对象不再需要时正确地调用析构函数。</p></li><li><p><strong>异常安全性</strong>：如果构造函数抛出异常，定位new不会自动释放内存，因为它没有分配新的内存。你需要手动处理异常情况。</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">int</span> val) : <span class="hljs-built_in">value</span>(val) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Constructing MyClass with value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;<br>    &#125;<br>    ~<span class="hljs-built_in">MyClass</span>() &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Destructing MyClass with value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-type">int</span> value;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 预先分配一块内存</span><br>    <span class="hljs-type">char</span>* buffer = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-built_in">sizeof</span>(MyClass)];<br>    <br>    <span class="hljs-comment">// 使用定位new在预先分配的内存上构造对象</span><br>    MyClass* obj = <span class="hljs-built_in">new</span> (buffer) <span class="hljs-built_in">MyClass</span>(<span class="hljs-number">42</span>);<br>    <br>    <span class="hljs-comment">// 使用对象</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Object value: &quot;</span> &lt;&lt; obj-&gt;value &lt;&lt; std::endl;<br>    <br>    <span class="hljs-comment">// 手动调用析构函数</span><br>    obj-&gt;~<span class="hljs-built_in">MyClass</span>();<br>    <br>    <span class="hljs-comment">// 释放预先分配的内存</span><br>    <span class="hljs-keyword">delete</span>[] buffer;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="定位new运算符的使用注意事项"><a href="#定位new运算符的使用注意事项" class="headerlink" title="定位new运算符的使用注意事项"></a>定位new运算符的使用注意事项</h5><p>下面的程序对普通的<code>new</code>使用和<code>定位new运算符</code>的使用进行了比较，并归纳出使用<code>定位new运算符</code>的常见易错点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// placenew1.cpp  -- new, placement new, no delete</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;new&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> BUF = <span class="hljs-number">512</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">JustTesting</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>    string words;<br>    <span class="hljs-type">int</span> number;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">JustTesting</span>(<span class="hljs-type">const</span> string &amp; s = <span class="hljs-string">&quot;Just Testing&quot;</span>, <span class="hljs-type">int</span> n = <span class="hljs-number">0</span>) <br>    &#123;words = s; number = n; cout &lt;&lt; words &lt;&lt; <span class="hljs-string">&quot; constructed\n&quot;</span>; &#125;<br>    <span class="hljs-comment">//默认构造函数</span><br>    ~<span class="hljs-built_in">JustTesting</span>() &#123; cout &lt;&lt; words &lt;&lt; <span class="hljs-string">&quot; destroyed\n&quot;</span>;&#125;<br>    <span class="hljs-comment">//析构函数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Show</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; cout &lt;&lt; words &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; number &lt;&lt; endl;&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">char</span> * buffer = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[BUF];       <span class="hljs-comment">// get a block of memory</span><br><br>    JustTesting *pc1, *pc2;<br><br>    pc1 = <span class="hljs-built_in">new</span> (buffer) JustTesting;      <span class="hljs-comment">// place object in buffer</span><br>    pc2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">JustTesting</span>(<span class="hljs-string">&quot;Heap1&quot;</span>, <span class="hljs-number">20</span>);  <span class="hljs-comment">// place object on heap（直接在堆上分配内存）</span><br>    <br>    cout &lt;&lt; <span class="hljs-string">&quot;Memory block addresses:\n&quot;</span> &lt;&lt; <span class="hljs-string">&quot;buffer: &quot;</span>&lt;&lt; (<span class="hljs-type">void</span> *) buffer &lt;&lt; <span class="hljs-string">&quot;    heap: &quot;</span> &lt;&lt; pc2 &lt;&lt;endl;<br>    <span class="hljs-comment">//void*使buffer被强制转换成通用指针使其打印地址而不是字符串的值</span><br>    <br>    cout &lt;&lt; <span class="hljs-string">&quot;Memory contents:\n&quot;</span>;<br>    cout &lt;&lt; pc1 &lt;&lt; <span class="hljs-string">&quot;: &quot;</span>;<br>    pc1-&gt;<span class="hljs-built_in">Show</span>();<br>    cout &lt;&lt; pc2 &lt;&lt; <span class="hljs-string">&quot;: &quot;</span>;<br>    pc2-&gt;<span class="hljs-built_in">Show</span>();<br><br>    JustTesting *pc3, *pc4;<br>    pc3 = <span class="hljs-built_in">new</span> (buffer) <span class="hljs-built_in">JustTesting</span>(<span class="hljs-string">&quot;Bad Idea&quot;</span>, <span class="hljs-number">6</span>);<br>    pc4 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">JustTesting</span>(<span class="hljs-string">&quot;Heap2&quot;</span>, <span class="hljs-number">10</span>);<br>    cout &lt;&lt; <span class="hljs-string">&quot;Memory contents:\n&quot;</span>;<br>    cout &lt;&lt; pc3 &lt;&lt; <span class="hljs-string">&quot;: &quot;</span>;<br>    pc3-&gt;<span class="hljs-built_in">Show</span>();<br>    cout &lt;&lt; pc4 &lt;&lt; <span class="hljs-string">&quot;: &quot;</span>;<br>    pc4-&gt;<span class="hljs-built_in">Show</span>();<br>    <br>    <span class="hljs-keyword">delete</span> pc2;                          <span class="hljs-comment">// free Heap1         </span><br>    <span class="hljs-keyword">delete</span> pc4;                          <span class="hljs-comment">// free Heap2</span><br>    <span class="hljs-keyword">delete</span> [] buffer;                    <span class="hljs-comment">// free buffer</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;Done\n&quot;</span>;<br>    <span class="hljs-comment">// std::cin.get();</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>输出示例：</strong></p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">Just Testing constructed</span><br><span class="hljs-attribute">Heap1 constructed</span><br><span class="hljs-attribute">Memory block addresses</span><span class="hljs-punctuation">:</span><br><span class="hljs-attribute">buffer</span><span class="hljs-punctuation">:</span> <span class="hljs-string">0xf61e80    heap: 0xf62090</span><br><span class="hljs-attribute">Memory contents</span><span class="hljs-punctuation">:</span><br><span class="hljs-attribute">0xf61e80</span><span class="hljs-punctuation">:</span> <span class="hljs-string">Just Testing, 0</span><br><span class="hljs-attribute">0xf62090</span><span class="hljs-punctuation">:</span> <span class="hljs-string">Heap1, 20</span><br><span class="hljs-attribute">Bad Idea constructed</span><br><span class="hljs-attribute">Heap2 constructed</span><br><span class="hljs-attribute">Memory contents</span><span class="hljs-punctuation">:</span><br><span class="hljs-attribute">0xf61e80</span><span class="hljs-punctuation">:</span> <span class="hljs-string">Bad Idea, 6</span><br><span class="hljs-attribute">0xf620c0</span><span class="hljs-punctuation">:</span> <span class="hljs-string">Heap2, 10</span><br>Heap1 destroyed<br>Heap2 destroyed<br>Done<br></code></pre></td></tr></table></figure><p><strong>①覆盖问题</strong></p><p>尝试读懂代码的执行逻辑并观察输出示例，我们不难发现 <code>Just Testing</code>（pc1，调用了默认构造函数）和 <code>Bad Idea</code>（pc3，调用了显式构造函数和复制构造函数）两块存储的内存是相同的，都是 <code>buffer: 0xf61e80</code>的内存。</p><p>这会带来一个比较严重的问题，我们的初衷是在分配好的内存块上同时储存pc1和pc3两个指针指向的对象的内存，但是新对象（pc3指向的对象）<strong>在程序中覆盖掉了原来pc1所指向的对象，导致值的丢失</strong>。例如，如果我在代码的44行后加上<code>pc1-&gt;Show();</code>输出的结果会是<code>Bad Idea, 6</code>，原来pc1指向的对象的值已经被覆盖。</p><p>因此，程序员必须手动管理定位new运算符，使不同的指针指向不同区域的内存，互不冲突。修改方式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">pc1=<span class="hljs-built_in">new</span>(buffer) JustTesting;<br>pc3=<span class="hljs-built_in">new</span>(buffer+<span class="hljs-built_in">sizeof</span>(JustTesting)) <span class="hljs-built_in">JustTesting</span>(<span class="hljs-string">&quot;Better idea&quot;</span>,<span class="hljs-number">6</span>);<br></code></pre></td></tr></table></figure><p>在定义pc3的时候，加上了<code>sizeof(JustTesting)</code>，保证了两块被分配的内存不会产生重叠。</p><p><strong>②何时delete？</strong></p><p><strong>使用定位new运算符分配的内存在delete时要格外的小心！</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">delete</span> pc2;                          <span class="hljs-comment">// free Heap1         </span><br><span class="hljs-keyword">delete</span> pc4;                          <span class="hljs-comment">// free Heap2</span><br><span class="hljs-keyword">delete</span> [] buffer;                    <span class="hljs-comment">// free buffer</span><br>cout &lt;&lt; <span class="hljs-string">&quot;Done\n&quot;</span>;<br></code></pre></td></tr></table></figure><p>源代码中<code>delete</code>掉了所有动态分配的内存，包括p2，p4。p1，p3由于使用了定位new运算符，因此在delete掉buffer的内存指定区域后，p1，p3自然也就被delete掉了。这并不难理解，但是请注意以下操作是非法的！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">delete</span> pc2;                          <span class="hljs-comment">// free Heap1         </span><br><span class="hljs-keyword">delete</span> pc4;                          <span class="hljs-comment">// free Heap2</span><br><span class="hljs-keyword">delete</span> pc1;<span class="hljs-comment">//INVALID!</span><br><span class="hljs-keyword">delete</span> pc3;<span class="hljs-comment">//INVALID!</span><br></code></pre></td></tr></table></figure><p>原书中这一段讲的非常清楚并且直白，直接贴上来：</p><p>原因在于 delete 可与常规 new 运算符配合使用，但<strong>不能与定位 new 运算符配合使用</strong>。例如，指针 pc3 没有收到 new 运算符返回的地址，因此 <strong>delete pc3 将导致运行阶段错误</strong>。在另一方面，指针pc1 指向的地址与 buffer 相同， 但 buffer 是使用 new []初始化的，因此必须使用 delete [ ]而不是 delete来释放。即使 buffer 是使用 new 而不是 new []初始化的， delete pc1 也将释放 buffer，而不是 pc1。这是因为 new&#x2F;delete 系统知道已分配的 512 字节块 buffer，但对定位 new 运算符对该内存块做了何种处理一无所知。  </p><blockquote><p>总之一句话：<strong>不能混着用</strong>！</p></blockquote><p>那么，如何只delete我们定义的pc1和pc3而不delete掉整块buffer内存呢？我们可以<strong>显示地为定位new运算符创建的对象调用析构函数，销毁指定的对象。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++">pc3 = <span class="hljs-built_in">new</span> (buffer + <span class="hljs-built_in">sizeof</span> (JustTesting))<br>            <span class="hljs-built_in">JustTesting</span>(<span class="hljs-string">&quot;Better Idea&quot;</span>, <span class="hljs-number">6</span>);<br>pc4 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">JustTesting</span>(<span class="hljs-string">&quot;Heap2&quot;</span>, <span class="hljs-number">10</span>);<br><br>cout &lt;&lt; <span class="hljs-string">&quot;Memory contents:\n&quot;</span>;<br>cout &lt;&lt; pc3 &lt;&lt; <span class="hljs-string">&quot;: &quot;</span>;<br>pc3-&gt;<span class="hljs-built_in">Show</span>();<br>cout &lt;&lt; pc4 &lt;&lt; <span class="hljs-string">&quot;: &quot;</span>;<br>pc4-&gt;<span class="hljs-built_in">Show</span>();<br><br><span class="hljs-keyword">delete</span> pc2;           <span class="hljs-comment">// free Heap1         </span><br><span class="hljs-keyword">delete</span> pc4;           <span class="hljs-comment">// free Heap2</span><br><span class="hljs-comment">// explicitly destroy placement new objects</span><br>pc3-&gt;~<span class="hljs-built_in">JustTesting</span>();  <span class="hljs-comment">// destroy object pointed to by pc3</span><br>pc1-&gt;~<span class="hljs-built_in">JustTesting</span>();  <span class="hljs-comment">// destroy object pointed to by pc1</span><br><span class="hljs-comment">//这样的操作保证了我可以只delete两个指针指向的动态内存，但不delete掉buffer内存</span><br><span class="hljs-keyword">delete</span> [] buffer;     <span class="hljs-comment">// free buffer</span><br></code></pre></td></tr></table></figure><h2 id="ADT-for-queue"><a href="#ADT-for-queue" class="headerlink" title="ADT for queue"></a>ADT for queue</h2><p>因为篇幅限制，本博客不再转载这部分内容，而将其移动到<code>数据结构和算法部分</code>更新~</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li>《C++ Primer Plus》</li></ul><blockquote><p>THE END 2024&#x2F;12&#x2F;7</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Code</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tutorial</tag>
      
      <tag>C/C++</tag>
      
      <tag>OOP</tag>
      
      <tag>C++ Primer Plus</tag>
      
      <tag>Dynamic Memory</tag>
      
      <tag>Finished</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AI-indepth-reading-AlexNet</title>
    <link href="/posts/AI-indepth-reading-AlexNet/"/>
    <url>/posts/AI-indepth-reading-AlexNet/</url>
    
    <content type="html"><![CDATA[<h1 id="ImageNet-Classification-with-Deep-Convolutional-Neural-Networks"><a href="#ImageNet-Classification-with-Deep-Convolutional-Neural-Networks" class="headerlink" title="ImageNet Classification with Deep Convolutional Neural Networks"></a>ImageNet Classification with Deep Convolutional Neural Networks</h1><p>【写在前面的话】</p><p>本文是AI论文精读计划的第一篇！在本频道中我将采用<strong>双语</strong>模式力求用准确且逻辑清晰的语言复述表达论文作者的核心观点和细节实现，同时配上一些配图。希望大家喜欢</p><p>今天分享的文章是 <a href="https://dl.acm.org/doi/10.1145/3065386">ImageNet Classification with Deep Convolutional Neural Networks</a>，作者是 <a href="https://dl.acm.org/doi/10.1145/3065386#">Alex Krizhevsky</a> ， <a href="https://dl.acm.org/doi/10.1145/3065386#">Ilya Sutskever</a> 和 <a href="https://dl.acm.org/doi/10.1145/3065386#">Geoffrey E. Hinton</a> （今年诺奖得主）。<strong>这篇文章创新性地将卷积神经网络高效地应用到图像识别领域，在当年的ILSVRC比赛中以极大的优势斩获头名，同时也掀起了神经网络复兴和深度学习的浪潮。</strong></p><blockquote><p>This is the first article in our <strong>In-Depth Reading of AI Papers</strong> series! In this channel, I will use a <strong>bilingual</strong> approach to restate and explain the core ideas and implementation details of the paper’s authors with accuracy and clear logic, accompanied by some illustrations. I hope you enjoy it.</p><p>Today’s paper is “<a href="https://dl.acm.org/doi/10.1145/3065386">ImageNet Classification with Deep Convolutional Neural Networks</a>“, authored by <a href="https://dl.acm.org/doi/10.1145/3065386#">Alex Krizhevsky</a>, <a href="https://dl.acm.org/doi/10.1145/3065386#">Ilya Sutskever</a>, and <a href="https://dl.acm.org/doi/10.1145/3065386#">Geoffrey E. Hinton</a> (this year’s Nobel Prize winner). <strong>This article innovatively and efficiently applied convolutional neural networks to the field of image recognition, winning first place in the ILSVRC competition that year by a significant margin, and sparked the resurgence of neural networks and the wave of deep learning.</strong></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Frontier and Classic Papers in AI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Convolutional Neural Networks</tag>
      
      <tag>Artificial Intelligence</tag>
      
      <tag>AlexNet</tag>
      
      <tag>Image Clssification</tag>
      
      <tag>Deep Learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Introduction-to-OOP</title>
    <link href="/posts/Introduction-to-OOP/"/>
    <url>/posts/Introduction-to-OOP/</url>
    
    <content type="html"><![CDATA[<h1 id="Introduction-to-OOP"><a href="#Introduction-to-OOP" class="headerlink" title="Introduction to OOP"></a>Introduction to OOP</h1><h1 id="C-Primer-Plus-Tutorial-10-11"><a href="#C-Primer-Plus-Tutorial-10-11" class="headerlink" title="C++ Primer Plus Tutorial-10&#x2F;11"></a>C++ Primer Plus Tutorial-10&#x2F;11</h1><h1 id="面向对象编程教程——Section①"><a href="#面向对象编程教程——Section①" class="headerlink" title="面向对象编程教程——Section①"></a>面向对象编程教程——Section①</h1><center><p style="color: red;"><b><font size=6.5>Chapter 10/11 Object Oriented Programming</font></b></p></center><center><p style="color: red;"><b><font size=6.5>面向对象编程引论</font></b></p></center><p>【写在前面的话】</p><p><a href="https://xiyuanyang-code.github.io/posts/C-plus-plus-Primer-Plus-tutorial/">C++ Primer Plus Tutorial</a></p><p><a href="https://xiyuanyang-code.github.io/tags/OOP/">系列文章</a></p><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>欢迎来到<strong>面向对象编程</strong>的世界！首先文章将会向你介绍在面向对象编程中四个最核心的精神：<strong>封装、继承、多态和抽象</strong>，并对面向对象所涉及的知识做一个总体性的概览。接下来，你将系统学习到什么是<strong>类和对象</strong>，以及如何创建并使用自己的类和对象。文章的内容涵盖<strong>构造函数</strong>的四种定义、<strong>析构函数</strong>的使用、<strong>静态和动态</strong>数据成员以及成员函数、<strong>友元函数</strong>、<strong>const函数</strong>的用法、<strong>this指针</strong>以及类的自动类型转换等知识。</p><p>Welcome to the world of <strong>Object-Oriented Programming (OOP)</strong>! This article will first introduce you to the four core principles of OOP: <strong>Encapsulation, Inheritance, Polymorphism, and Abstraction</strong>, and provide an overview of the knowledge involved in OOP. Next, you will systematically learn what <strong>classes and objects</strong> are, and how to create and use your own classes and objects. The article covers topics such as the four definitions of <strong>constructors</strong>, the use of <strong>destructors</strong>, <strong>static</strong> and <strong>dynamic</strong> data members and member functions, <strong>friend functions</strong>, the usage of const functions, the <strong><code>this</code></strong> pointer, and <strong>automatic type conversion of classes</strong>, among others.</p><p><strong>Key words: OOP, constructors, destructors, this pointer, friend functions</strong></p><h2 id="常见知识点概览"><a href="#常见知识点概览" class="headerlink" title="常见知识点概览"></a>常见知识点概览</h2><blockquote><p>在这个部分，我们将先对OOP的基本概念做一个系统性的梳理和总结。如果你是第一次接触面向对象，建议看完 <code>The Art of Object Oriented Programming</code>后跳转到对应内容处学习，最后再来看总结。</p></blockquote><h3 id="1-The-Art-of-Object-Oriented-Programming"><a href="#1-The-Art-of-Object-Oriented-Programming" class="headerlink" title="1. The Art of Object Oriented Programming"></a>1. The Art of Object Oriented Programming</h3><p>什么是面向对象编程？这是C++引入的一个<strong>新的特性</strong>。它是一种程序设计范式，它将现实世界的事物抽象成<strong>对象</strong>，通过封装、继承、多态和抽象等机制，使得代码更加模块化、易维护和可扩展。在OOP中，<strong>对象</strong>是类的实例，代表了具体的实体，它包含了属性（数据）和方法（操作）。这些对象通过交互来实现程序的功能。</p><p>初学者在入门OOP时，往往会感觉到非常的不适应，因为面向对象的语法规则艰深晦涩，并且创建类和对象需要注意到很多很多的细节，稍不留神便报错满天飞。<strong>经过2个月的OOP学习</strong>，笔者认为初学OOP最忌讳的就是将重点放在记忆语法规则上，而应该<strong>将重点放在面向对象的四个基本精神：封装、继承、多态、抽象</strong>，以此为出发点，尝试在实践中创建自己的类，并运用的过程中同步熟悉语法规则。</p><div class="note note-primary">            <p><strong>封装（Encapsulation）</strong>：</p><ul><li>封装是将数据和操作数据的方法（成员函数）包装在一个单一的单元（类）中，隐藏类的内部实现细节，只暴露必要的<strong>接口</strong>。</li><li>封装在保证数据安全性的同时，也允许了代码的后续生长。</li></ul><p><strong>继承（Inheritance）</strong>：</p><ul><li>继承允许一个类（子类）获得另一个类（基类或父类）的属性和方法，从而实现代码的复用和层次结构的建立。</li></ul><p><strong>多态（Polymorphism）</strong>：</p><ul><li>多态指的是同一个接口可以有多种不同的实现方式。C++通过虚函数和重载实现多态。</li></ul><p><strong>抽象（Abstraction）</strong>：</p><ul><li>抽象是将复杂的现实世界简化成计算机程序可以处理的模型。通过定义抽象类（含有纯虚函数的类），可以强制子类实现某些方法。</li></ul>          </div><h3 id="2-类和对象"><a href="#2-类和对象" class="headerlink" title="2. 类和对象"></a>2. 类和对象</h3><p><strong>类（Class）</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> m_value; <span class="hljs-comment">// 私有成员变量</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">int</span> val) : <span class="hljs-built_in">m_value</span>(val) &#123;&#125; <span class="hljs-comment">// 构造函数</span><br>    ~<span class="hljs-built_in">MyClass</span>() &#123;&#125; <span class="hljs-comment">// 析构函数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setValue</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> </span>&#123; m_value = val; &#125; <span class="hljs-comment">// 成员函数</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getValue</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> m_value; &#125; <span class="hljs-comment">// const成员函数</span><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><strong>构造函数</strong>：初始化对象的成员变量。</li><li><strong>析构函数</strong>：当对象被销毁时执行清理工作。</li><li><strong>成员函数</strong>：操作类的数据成员。</li></ul><p><strong>对象（Object）</strong>：</p><ul><li>对象是类的实例化。通过类定义来创建对象。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">MyClass <span class="hljs-title">obj</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>; <span class="hljs-comment">// 创建一个MyClass的对象</span><br></code></pre></td></tr></table></figure><h3 id="3-继承"><a href="#3-继承" class="headerlink" title="3. 继承"></a>3. 继承</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Base&quot;</span>; &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123; <span class="hljs-comment">// 公有继承</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Derived&quot;</span>; &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><strong>公有继承</strong>：子类可以继承基类的公有和保护成员。</li><li><strong>私有继承</strong>：子类只能继承基类的保护成员，基类的公有成员变为私有。</li><li><strong>保护继承</strong>：子类可以继承基类的保护成员，基类的公有成员变为保护。</li></ul><h3 id="4-多态"><a href="#4-多态" class="headerlink" title="4. 多态"></a>4. 多态</h3><p><strong>虚函数（Virtual Functions）</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Base&quot;</span>; &#125; <span class="hljs-comment">// 虚函数</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Derived&quot;</span>; &#125; <span class="hljs-comment">// 重写虚函数</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Base* b = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Derived</span>();<br>    b-&gt;<span class="hljs-built_in">display</span>(); <span class="hljs-comment">// 输出：Derived</span><br>    <span class="hljs-keyword">delete</span> b;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>纯虚函数</strong>：<code>virtual void func() = 0;</code> 定义了接口，但不提供实现，必须在派生类中实现。</li></ul><h3 id="5-抽象类和接口"><a href="#5-抽象类和接口" class="headerlink" title="5. 抽象类和接口"></a>5. 抽象类和接口</h3><ul><li>包含纯虚函数的类称为抽象类，不能直接实例化，必须通过继承来实现。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">double</span> <span class="hljs-title">area</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">// 纯虚函数</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> : <span class="hljs-keyword">public</span> Shape &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">double</span> radius;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Circle</span>(<span class="hljs-type">double</span> r) : <span class="hljs-built_in">radius</span>(r) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">area</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-number">3.14159</span> * radius * radius; &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="6-封装和访问控制"><a href="#6-封装和访问控制" class="headerlink" title="6. 封装和访问控制"></a>6. 封装和访问控制</h3><ul><li><strong>公有（public）</strong>：任何代码都可以访问。</li><li><strong>私有（private）</strong>：只能在类内部访问。</li><li><strong>保护（protected）</strong>：在类和派生类中可以访问。</li></ul><h3 id="7-构造函数和析构函数"><a href="#7-构造函数和析构函数" class="headerlink" title="7. 构造函数和析构函数"></a>7. 构造函数和析构函数</h3><ul><li><strong>构造函数</strong>：用于初始化对象。</li><li><strong>析构函数</strong>：用于清理对象资源。</li></ul><h3 id="8-友元（Friend）"><a href="#8-友元（Friend）" class="headerlink" title="8. 友元（Friend）"></a>8. 友元（Friend）</h3><ul><li>友元函数或类可以访问类的私有和保护成员，但这打破了封装性，应谨慎使用。</li></ul><h3 id="9-静态成员"><a href="#9-静态成员" class="headerlink" title="9. 静态成员"></a>9. 静态成员</h3><ul><li><strong>静态成员变量</strong>：共享所有对象的单一实例。</li><li><strong>静态成员函数</strong>：不与任何对象实例关联，只能访问静态成员。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> count;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">incrementCount</span><span class="hljs-params">()</span> </span>&#123; count++; &#125;<br>&#125;;<br><br><span class="hljs-type">int</span> MyClass::count = <span class="hljs-number">0</span>; <span class="hljs-comment">// 静态成员变量的定义和初始化</span><br></code></pre></td></tr></table></figure><h3 id="10-运算符重载"><a href="#10-运算符重载" class="headerlink" title="10. 运算符重载"></a>10. 运算符重载</h3><ul><li>允许自定义类支持标准运算符。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Complex</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">double</span> real, imag;<br>    Complex <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Complex&amp; other) &#123;<br>        <span class="hljs-keyword">return</span> Complex&#123;real + other.real, imag + other.imag&#125;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="Cha-10-对象和类"><a href="#Cha-10-对象和类" class="headerlink" title="Cha 10 对象和类"></a>Cha 10 对象和类</h1><h2 id="数据成员"><a href="#数据成员" class="headerlink" title="数据成员"></a>数据成员</h2><ul><li>一般来说，私有数据成员存储信息，共有成员函数（方法）提供访问数据的唯一途径。（除了<strong>友元函数</strong>）</li></ul><h2 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h2><h3 id="静态成员和静态成员函数"><a href="#静态成员和静态成员函数" class="headerlink" title="静态成员和静态成员函数"></a>静态成员和静态成员函数</h3><div class="note note-primary">            <p>静态成员函数（<code>static</code> member function）是类中的一种特殊成员函数，它与类的对象无关，而是与类本身相关。静态成员函数的主要作用和特点有：</p><ol><li><strong>不依赖于类的对象</strong></li></ol><p>静态成员函数可以在没有实例化对象的情况下调用，因为它不需要访问类的实例成员（非静态成员）。它只能访问类的静态成员变量和其他静态成员函数。静态成员函数不隐式地接收 <code>this</code> 指针，这使得它不能访问非静态成员。</p><ol start="2"><li><strong>访问和操作静态成员</strong></li></ol><p>静态成员函数只能访问静态成员变量和其他静态成员函数。静态成员变量属于类本身，而不是类的某个特定对象。因此，静态成员函数通常用于操作或管理类的静态数据。</p><ol start="3"><li><strong>实例化时不需要对象</strong></li></ol><p>静态成员函数可以通过类名直接调用，而不需要创建类的对象。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> staticVar;<br><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">staticMethod</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Static method called, staticVar = &quot;</span> &lt;&lt; staticVar &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-type">int</span> MyClass::staticVar = <span class="hljs-number">10</span>;<span class="hljs-comment">//静态数据成员需要再类外定义</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    MyClass::<span class="hljs-built_in">staticMethod</span>();  <span class="hljs-comment">// 调用静态成员函数</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>staticMethod()</code> 是静态成员函数，我们通过 <code>MyClass::staticMethod()</code> 直接调用它，而没有创建 <code>MyClass</code> 的对象。</p><ol start="4"><li><strong>用于实现类级别的功能</strong></li></ol><p>静态成员函数适用于那些不依赖于类对象的功能，通常用于实现类级别的操作。例如：</p><ul><li><strong>工具函数</strong>：可以作为与类的对象无关的实用功能，如数学计算、日志记录等。</li><li><strong>工厂方法</strong>：用于创建对象的工厂方法，通常返回类的实例（但不一定需要依赖于实例化对象）。</li><li><strong>共享资源的管理</strong>：静态成员函数可以用于管理类的静态资源，如数据库连接池、缓存等。</li></ul><ol start="5"><li><strong>内存优化</strong></li></ol><p>静态成员函数可以在程序中只存在一个副本，而不需要为每个对象都创建一份。这对内存管理有一定优化作用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Counter</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> count;  <span class="hljs-comment">// 静态成员变量</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Counter</span>() &#123;<br>        count++;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">getCount</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-comment">// 静态成员函数</span><br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 静态成员变量定义</span><br><span class="hljs-type">int</span> Counter::count = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Counter c1, c2;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Object count: &quot;</span> &lt;&lt; Counter::<span class="hljs-built_in">getCount</span>() &lt;&lt; std::endl;  <span class="hljs-comment">// 输出 2</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>count</code> 是一个静态成员变量，它用于记录 <code>Counter</code> 类的对象的数量。<code>getCount()</code> 是静态成员函数，它通过类名调用，返回静态变量 <code>count</code> 的值。</p><p>静态成员函数主要用于：</p><ul><li>不依赖于对象的类级别操作。</li><li>操作和访问静态成员数据。</li><li>在不实例化对象的情况下执行类相关的功能。</li></ul><p>它们是面向类而不是面向实例的，通常用于实现与类的对象无关的逻辑。</p>          </div><div class="note note-primary">            <h3 id="关于const成员函数"><a href="#关于const成员函数" class="headerlink" title="关于const成员函数"></a>关于const成员函数</h3><h5 id="关于const-成员函数的参数问题"><a href="#关于const-成员函数的参数问题" class="headerlink" title="关于const 成员函数的参数问题"></a>关于const 成员函数的参数问题</h5><p>在C++中，<code>const</code>成员函数是一个特别的成员函数，<strong>它保证了该函数不会修改对象的成员变量</strong>。以下是关于<code>const</code>成员函数的一些关键点：</p><ul><li><code>const</code>成员函数在函数声明末尾加上<code>const</code>关键字。例如：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-comment">// 函数体</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>目的</strong></p><ul><li><strong>保证不修改对象状态</strong>：<code>const</code>成员函数确保函数不会修改调用它的对象的非静态数据成员。这有助于确保对象在调用这些函数时保持不变。</li><li><strong>增强代码的可读性和维护性</strong>：通过明确表示函数不会改变对象的状态，提高了代码的清晰度，使开发者更容易理解和使用这些函数。</li><li><strong>支持const对象</strong>：<code>const</code>成员函数可以被<code>const</code>对象调用，因为它保证不会修改对象。</li></ul><p><strong>使用场景</strong></p><ul><li><strong>访问器（Getter）</strong>：通常，<code>const</code>成员函数用于只读访问对象的成员变量。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getValue</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> m_value;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>常量成员函数</strong>：任何不修改对象状态的操作都可以被声明为<code>const</code>。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPositive</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> m_value &gt; <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意事项</strong></p><ul><li><strong>不能修改非静态成员变量</strong>：在<code>const</code>成员函数内，尝试修改非静态成员变量会导致编译错误。</li><li><strong>可以修改<code>mutable</code>成员</strong>：<code>mutable</code>关键字可以用于声明一个成员变量，即使在<code>const</code>成员函数内也可以修改它。</li><li><strong>隐式<code>this</code>指针的类型</strong>：在<code>const</code>成员函数中，<code>this</code>指针的类型是<code>const MyClass*</code>，因此不能通过<code>this</code>来修改对象。</li><li><strong>重载</strong>：<code>const</code>和非<code>const</code>版本的同名成员函数可以共存，编译器会根据调用对象的<code>const</code>性来选择调用哪个版本。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getValue</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> m_value;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span>&amp; <span class="hljs-title">getValue</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> m_value;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> m_value;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    MyClass obj;<br>    <span class="hljs-type">const</span> MyClass constObj;<br><br>    <span class="hljs-comment">// 调用非const版本</span><br>    obj.<span class="hljs-built_in">getValue</span>() = <span class="hljs-number">10</span>;<br><br>    <span class="hljs-comment">// 调用const版本</span><br>    <span class="hljs-type">int</span> val = constObj.<span class="hljs-built_in">getValue</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>指针和引用</strong>：在<code>const</code>成员函数中，返回成员变量的指针或引用也必须是<code>const</code>的，以防止通过这些指针或引用修改对象。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">int</span>* <span class="hljs-title">getPointer</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> &amp;m_value;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>静态成员函数</strong>：<code>static</code>成员函数不涉及<code>this</code>指针，因此它们天生就是<code>const</code>的。</li></ul><p><code>const</code>成员函数是C++中增强代码安全性和可读性的重要工具，通过它们，开发者可以明确地表达函数对对象状态的影响，帮助避免不必要的副作用，同时也使代码更易于维护和使用。</p><p>是的，<code>const</code>成员函数可以有形参。<code>const</code>关键字只影响函数对对象自身状态的修改能力，并不限制函数是否可以接受参数。以下是一些关于<code>const</code>成员函数如何处理参数的说明：</p><h5 id="接受参数的const成员函数"><a href="#接受参数的const成员函数" class="headerlink" title="接受参数的const成员函数"></a>接受参数的<code>const</code>成员函数</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">const</span> std::string&amp; str)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-comment">// 函数体</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>在这个例子中：</p><ul><li><code>doSomething</code>是一个<code>const</code>成员函数。</li><li>它接受两个参数：一个<code>int</code>类型的<code>x</code>和一个<code>const std::string</code>类型的引用<code>str</code>。</li><li>函数体中不能修改<code>MyClass</code>对象的任何非静态成员变量。</li></ul><p><strong>参数的类型</strong></p><ul><li><strong>非<code>const</code>参数</strong>：你可以传递非<code>const</code>类型的参数给<code>const</code>成员函数，因为这些参数是函数的局部副本或引用，不影响对象的状态。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> <span class="hljs-type">const</span> </span>&#123;<br>    x = <span class="hljs-number">10</span>; <span class="hljs-comment">// 修改的是局部变量，不影响对象状态</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>引用和指针参数</strong>：<code>const</code>成员函数可以接受<code>const</code>或非<code>const</code>的引用或指针作为参数，但如果是<code>const</code>引用或指针，则不能通过它们修改所指向的对象。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; str)</span> <span class="hljs-type">const</span> </span>&#123;<br>    <span class="hljs-comment">// str不能被修改，但可以通过非const成员函数修改str指向的对象</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">(std::string* str)</span> <span class="hljs-type">const</span> </span>&#123;<br>    <span class="hljs-comment">// str可以被重新赋值，但不能通过str修改str指向的对象</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="const成员函数的限制"><a href="#const成员函数的限制" class="headerlink" title="const成员函数的限制"></a><code>const</code>成员函数的限制</h5><p>虽然<code>const</code>成员函数可以有形参，但有以下限制：</p><ul><li><strong>不能修改对象的非静态成员变量</strong>：这是<code>const</code>成员函数的核心原则。</li><li><strong>不能调用非<code>const</code>成员函数</strong>：因为非<code>const</code>成员函数可能修改对象的状态。</li><li><strong>可以修改<code>mutable</code>成员变量</strong>：<code>mutable</code>关键字允许在<code>const</code>成员函数中修改特定的成员变量。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        m_mutableVar = <span class="hljs-number">1</span>; <span class="hljs-comment">// 可以修改mutable变量</span><br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">mutable</span> <span class="hljs-type">int</span> m_mutableVar;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><strong>可以修改局部变量</strong>：在<code>const</code>成员函数内定义的局部变量可以被修改，因为它们不影响对象的状态。</li></ul><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p><code>const</code>成员函数可以接受任何类型的参数，包括<code>const</code>和非<code>const</code>的参数。<code>const</code>关键字的作用是确保函数不会修改对象的状态，而不影响函数如何处理其参数。通过这种方式，<code>const</code>成员函数既能提供只读的接口，又能灵活地处理传入的参数。</p>          </div><h2 id="类的构造函数"><a href="#类的构造函数" class="headerlink" title="类的构造函数"></a>类的构造函数</h2><h3 id="构造函数的初始化列表"><a href="#构造函数的初始化列表" class="headerlink" title="构造函数的初始化列表"></a>构造函数的初始化列表</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++">Test::<span class="hljs-built_in">Test</span>(<span class="hljs-type">int</span> lh, <span class="hljs-type">int</span> rh):<span class="hljs-built_in">low</span>(lh),<span class="hljs-built_in">high</span>(rh)&#123;<br><span class="hljs-comment">//其他成员的初始化</span><br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-primary">            <p><strong>必须使用初始化列表的情况：</strong></p><p>在 C++ 中，初始化列表通常用于在类的构造函数中初始化成员变量。虽然可以在构造函数的主体中赋值，但在某些情况下，必须使用初始化列表。以下是几个常见的情况：</p><ol><li><strong>常量成员变量（<code>const</code>）</strong></li></ol><p>常量成员变量必须在对象构造时初始化，并且只能通过初始化列表进行初始化。因为常量成员变量在构造函数体内不能被赋值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> x;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">int</span> val) : <span class="hljs-built_in">x</span>(val) &#123;&#125;  <span class="hljs-comment">// 必须使用初始化列表</span><br>&#125;;<br></code></pre></td></tr></table></figure><ol start="2"><li><strong>引用成员变量</strong></li></ol><p>引用成员变量也只能通过初始化列表来初始化，因为引用一旦绑定到某个对象，就不能再改变。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span>&amp; ref;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">int</span>&amp; r) : <span class="hljs-built_in">ref</span>(r) &#123;&#125;  <span class="hljs-comment">// 引用成员必须通过初始化列表初始化</span><br>&#125;;<br></code></pre></td></tr></table></figure><ol start="3"><li><strong>基类的构造函数</strong></li></ol><p>如果你的类有一个继承自基类的成员，那么在派生类的构造函数中，必须通过初始化列表来调用基类的构造函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Base</span>(<span class="hljs-type">int</span> x) &#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Derived</span>(<span class="hljs-type">int</span> x) : <span class="hljs-built_in">Base</span>(x) &#123;&#125;  <span class="hljs-comment">// 必须通过初始化列表调用基类构造函数</span><br>&#125;;<br></code></pre></td></tr></table></figure><ol start="4"><li><strong>初始化动态分配的资源（如智能指针）</strong></li></ol><p>对于一些成员变量（如<code>std::unique_ptr</code>或<code>std::shared_ptr</code>），你可以在初始化列表中进行初始化，避免多次赋值，保证对象在构造时即拥有正确的资源。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; ptr;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">int</span> val) : <span class="hljs-built_in">ptr</span>(std::<span class="hljs-built_in">make_unique</span>&lt;<span class="hljs-type">int</span>&gt;(val)) &#123;&#125;  <span class="hljs-comment">// 使用初始化列表</span><br>&#125;;<br></code></pre></td></tr></table></figure><ol start="5"><li><strong>成员变量的非默认构造</strong></li></ol><p>如果类的成员变量没有提供默认构造函数，则必须在初始化列表中进行初始化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; v;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyClass</span>() : <span class="hljs-built_in">v</span>(<span class="hljs-number">10</span>, <span class="hljs-number">5</span>) &#123;&#125;  <span class="hljs-comment">// 初始化列表用于指定成员变量的初始化</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>尽管你可以在构造函数体内初始化一些成员变量，但对于常量成员、引用成员、基类构造函数调用以及没有默认构造函数的成员变量，必须通过初始化列表进行初始化。使用初始化列表能提高性能，并且在某些情况下（例如常量或引用成员）是唯一有效的选择。</p>          </div><h3 id="类内初始化"><a href="#类内初始化" class="headerlink" title="类内初始化"></a>类内初始化</h3><p>设置对象的初值是由构造函数完成的。如果类中没有定义构造函数，编译器会提供一个默认构造函数，即用数据成员类型的默认构造函数初始化数据成员，一般情况下都是随机数。</p><p>C++11 提供了一个称为类内初始化的功能，可以在类定义时为数据成员指定初值。如果构造函数没有为这个数据成员赋值，那么该数据成员的初值即为类定义时指定的初值。类内初始化可以使用&#x3D;的初始化形式，也可以使用大括号括起来的直接初始化形式，但不能使用小括号。</p><p><strong>类内初始化只适用于动态成员函数，静态成员函数的定义必须在类外！</strong></p><h3 id="委托构造"><a href="#委托构造" class="headerlink" title="委托构造"></a>委托构造</h3><p>有时某个构造函数的一部分工作与另外一个构造函数完全相同，那么完成这部分工作的语句必须在两个构造函数中都出现。例如，希望 DoubleArray 对象定义时能同时给出数组的初值，则需要增加一个如下的构造函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">DoubleArray</span>(<span class="hljs-type">int</span> lh, <span class="hljs-type">double</span> a[], <span class="hljs-type">int</span> size): <span class="hljs-built_in">low</span>(lh), <span class="hljs-built_in">high</span>(lh + size <span class="hljs-number">-1</span>) <br>&#123;<br>    storage = <span class="hljs-keyword">new</span> <span class="hljs-type">double</span>[size];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; ++i)<br>        storage[i] = a[i];<br>&#125;<br></code></pre></td></tr></table></figure><p>这个构造函数除了 for 语句之外， 其他工作与 DoubleArray(int lh, int rh)完全相同。 为了避免重复写这些语句， C++11 <strong>允许一个构造函数调用另一个构造函数</strong>，即委托构造。</p><p>委托构造函数有一个<strong>初始化列表</strong>和一个<strong>函数体</strong>。初始化列表只有唯一的入口，即被调用的构造函数。函数体完成额外的初始化工作。上面的构造函数可以定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">DoubleArray</span>(<span class="hljs-type">int</span> lh, <span class="hljs-type">double</span> a[], <span class="hljs-type">int</span> size):<span class="hljs-built_in">DoubleArray</span>(lh, lh + size - <span class="hljs-number">1</span>)<br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; ++i)<br>    storage[i] = a[i];<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>在类的继承中，派生类的构造函数的基本原理就是<strong>使用委托构造调用基类的构造函数</strong>。</p></blockquote><h3 id="复制构造函数"><a href="#复制构造函数" class="headerlink" title="复制构造函数"></a>复制构造函数</h3><p>笔者花了一整篇博客的篇幅讲解复制构造函数，包括<strong>隐式</strong>的复制构造函数和<strong>显式定义</strong>的复制构造函数。</p><p><a href="https://xiyuanyang-code.github.io/posts/Dynamic-Memory-and-Classes/">博客地址</a></p><h3 id="移动构造函数"><a href="#移动构造函数" class="headerlink" title="移动构造函数"></a>移动构造函数</h3><div class="note note-primary">            <p><strong>移动构造函数</strong>（Move Constructor）是 C++11 引入的一种特殊构造函数，用于实现对象的”移动语义”。它的作用是通过转移资源所有权，而不是复制资源，来高效地构造一个新对象。移动构造函数通常用于在对象的生命周期结束时，避免不必要的资源复制，从而提高程序的性能。</p><p>移动构造函数的主要任务是将一个<strong>临时对象的资源</strong>（如动态分配的内存、文件句柄等）“转移”到新的对象中，而不是进行深拷贝(<strong>这是复制构造函数的工作</strong>)。通过这种方式，移动构造函数能够避免重复的资源分配和复制操作，从而提高效率。</p><p>移动构造函数通常具有以下形式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyClass</span>(MyClass&amp;&amp; other) <span class="hljs-keyword">noexcept</span> &#123;<br>        <span class="hljs-comment">// 转移资源所有权</span><br>        <span class="hljs-keyword">this</span>-&gt;data = other.data;<br>        other.data = <span class="hljs-literal">nullptr</span>;  <span class="hljs-comment">// 将原对象的资源置为空（防止析构时释放）</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>其中 <code>MyClass&amp;&amp; other</code> 是一个<strong>右值引用</strong>，表示传入的对象是一个临时对象（或可以被安全地移动的对象）。<code>noexcept</code> 表示该函数不会抛出异常，通常对于移动构造函数是一个良好的实践。</p><p> <strong>何时使用移动构造函数</strong></p><ul><li><strong>当对象是临时对象时</strong>：临时对象可以安全地进行资源转移（移动），而不需要进行复制。</li><li><strong>当对象的资源不再需要时</strong>：比如，在函数返回时，一个对象的资源可以被“移走”，避免无谓的复制。</li></ul><p><strong>与拷贝（复制）构造函数的区别</strong></p><ul><li><strong>拷贝构造函数</strong>：会创建新对象并复制源对象的所有数据（深拷贝），这对于某些数据结构（如动态内存分配）可能非常昂贵。</li><li><strong>移动构造函数</strong>：通过转移资源的所有权来构造对象，不需要进行昂贵的复制操作，效率更高。</li></ul><p><strong>移动构造函数的实现细节</strong></p><ul><li>通常，移动构造函数会转移所有资源，并将原对象的资源置为空或有效的”无资源”状态，以防止析构函数错误地释放资源。</li><li>移动构造函数的实现通常需要保证“资源管理”的正确性，避免双重释放等问题。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; data;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyClass</span>() = <span class="hljs-keyword">default</span>;  <span class="hljs-comment">// 默认构造函数</span><br><br>    <span class="hljs-comment">// 移动构造函数</span><br>    <span class="hljs-built_in">MyClass</span>(MyClass&amp;&amp; other) <span class="hljs-keyword">noexcept</span> : <span class="hljs-built_in">data</span>(std::<span class="hljs-built_in">move</span>(other.data)) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Move constructor called!&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addData</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> </span>&#123;<br>        data.<span class="hljs-built_in">push_back</span>(value);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printData</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : data) &#123;<br>            std::cout &lt;&lt; v &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>        std::cout &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    MyClass obj1;<br>    obj<span class="hljs-number">1.</span><span class="hljs-built_in">addData</span>(<span class="hljs-number">1</span>);<br>    obj<span class="hljs-number">1.</span><span class="hljs-built_in">addData</span>(<span class="hljs-number">2</span>);<br><br>    <span class="hljs-comment">// 使用移动构造函数创建新对象</span><br>    MyClass obj2 = std::<span class="hljs-built_in">move</span>(obj1);  <span class="hljs-comment">// 调用移动构造函数</span><br>    obj<span class="hljs-number">2.</span><span class="hljs-built_in">printData</span>();  <span class="hljs-comment">// 打印 obj2 的数据</span><br>    obj<span class="hljs-number">1.</span><span class="hljs-built_in">printData</span>();  <span class="hljs-comment">// obj1 现在是空的</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs delphi">Move <span class="hljs-function"><span class="hljs-keyword">constructor</span> <span class="hljs-title">called</span>!</span><br><span class="hljs-function">1 2</span><br></code></pre></td></tr></table></figure><ul><li>在 <code>obj2 = std::move(obj1)</code> 语句中，<code>obj1</code> 被“移动”到 <code>obj2</code> 中，调用了移动构造函数。</li><li><code>obj1</code> 之后没有持有原来数据的所有权，因此它的内容变为空。</li></ul><p> <strong>使用 <code>std::move</code></strong></p><p><code>std::move</code> 不是一个真正的“移动”操作，它只是将其参数转换为右值引用，使得移动构造函数或移动赋值运算符可以被调用。因此，当你希望使用移动构造函数时，通常会显式调用 <code>std::move</code>。</p><p> <strong>何时自动调用移动构造函数</strong></p><p>移动构造函数通常在以下情况下自动调用：</p><ul><li><strong>返回值优化（RVO）</strong>：函数返回局部对象时。</li><li><strong>标准容器的元素转移</strong>：例如，在将对象插入 <code>std::vector</code>、<code>std::list</code> 等容器时，容器可以通过移动构造函数来高效地管理内存。</li></ul><p><strong>移动构造函数的最佳实践</strong></p><ul><li><strong>确保移动构造函数不会抛出异常</strong>：通常应该声明为 <code>noexcept</code>，以便提高编译器的优化能力。</li><li><strong>使被移动的对象处于有效但空的状态</strong>：例如，将指针置为空或清空容器中的元素。</li></ul>          </div><h3 id="构造函数相关小结"><a href="#构造函数相关小结" class="headerlink" title="构造函数相关小结"></a>构造函数相关小结</h3><ul><li>可以通过函数重载创建多个同名函数，条件是每个函数的特征标（参数列表）都不同。</li><li>构造函数没有声明类型。</li><li>默认构造函数：①无参数（系统默认）② 手动为<strong>每一个形参</strong>添加默认值</li></ul><h2 id="类的析构函数"><a href="#类的析构函数" class="headerlink" title="类的析构函数"></a>类的析构函数</h2><p>析构函数没有返回值也没有返回类型！</p><h3 id="类析构的顺序"><a href="#类析构的顺序" class="headerlink" title="类析构的顺序"></a>类析构的顺序</h3><p>在 C++ 中，对象的析构顺序由其作用域（或生命周期）决定。析构过程通常遵循<strong>逆构造顺序</strong>，即从最内层的局部对象开始，依次向外层对象进行析构。下面是一些常见的情况和详细的析构顺序说明。</p><ol><li><strong>局部对象的析构顺序</strong></li></ol><p>在函数中，局部对象的析构顺序通常遵循<strong>后创建先销毁</strong>的原则。也就是说，局部对象按照它们创建的反向顺序进行析构。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;A created&quot;</span> &lt;&lt; std::endl; &#125;<br>    ~<span class="hljs-built_in">A</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;A destroyed&quot;</span> &lt;&lt; std::endl; &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">B</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;B created&quot;</span> &lt;&lt; std::endl; &#125;<br>    ~<span class="hljs-built_in">B</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;B destroyed&quot;</span> &lt;&lt; std::endl; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">example</span><span class="hljs-params">()</span> </span>&#123;<br>    A a;<br>    B b;<br>    <span class="hljs-comment">// 在这个函数结束时，a 和 b 的析构顺序是：b -&gt; a</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">example</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">A</span> created<br><span class="hljs-selector-tag">B</span> created<br><span class="hljs-selector-tag">B</span> destroyed<br><span class="hljs-selector-tag">A</span> destroyed<br></code></pre></td></tr></table></figure><p><strong>解析</strong>：</p><ul><li>在 <code>example</code> 函数中，<code>a</code> 和 <code>b</code> 是局部对象。<code>a</code> 在 <code>b</code> 之前创建，但 <code>b</code> 在 <code>a</code> 之后被销毁。这是因为析构顺序遵循“后创建，先销毁”的原则。</li></ul><ol start="2"><li><strong>类的成员变量的析构顺序</strong></li></ol><p>类的成员变量的析构顺序遵循它们在类定义中声明的顺序，而<strong>不是在构造函数中初始化的顺序</strong>。也就是说，无论成员变量的初始化顺序如何，它们的析构顺序总是按它们在类定义中的声明顺序进行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    A a;  <span class="hljs-comment">// a 在类中声明顺序较前</span><br>    B b;  <span class="hljs-comment">// b 在类中声明顺序较后</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyClass</span>() &#123;&#125;<br>    ~<span class="hljs-built_in">MyClass</span>() &#123;&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    MyClass obj;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">A</span> created<br><span class="hljs-selector-tag">B</span> created<br><span class="hljs-selector-tag">B</span> destroyed<br><span class="hljs-selector-tag">A</span> destroyed<br></code></pre></td></tr></table></figure><p><strong>解析</strong>：</p><ul><li>在 <code>MyClass</code> 的析构函数中，成员变量 <code>a</code> 会先析构，而 <code>b</code> 后析构，尽管 <code>b</code> 在构造函数中是后初始化的。</li></ul><ol start="3"><li><strong>栈上对象与堆上对象</strong></li></ol><ul><li><strong>栈上对象</strong>：在栈上分配的对象（即局部对象）会在它们的作用域结束时自动析构，顺序遵循“后创建，先销毁”。</li><li><strong>堆上对象</strong>：在堆上通过 <code>new</code> 创建的对象，需要<strong>显式调用 <code>delete</code> 来销毁</strong>。堆上的对象不会自动析构，它们的析构顺序完全取决于程序员手动调用 <code>delete</code> 的时机。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyClass</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;MyClass created&quot;</span> &lt;&lt; std::endl; &#125;<br>    ~<span class="hljs-built_in">MyClass</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;MyClass destroyed&quot;</span> &lt;&lt; std::endl; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    MyClass *ptr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">MyClass</span>();  <span class="hljs-comment">// 堆上对象</span><br>    <span class="hljs-keyword">delete</span> ptr;  <span class="hljs-comment">// 手动销毁堆上对象</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs monkey">My<span class="hljs-keyword">Class</span> <span class="hljs-title class_">created</span><br>My<span class="hljs-keyword">Class</span> <span class="hljs-title class_">destroyed</span><br></code></pre></td></tr></table></figure><p><strong>解析</strong>：</p><ul><li>堆上对象 <code>ptr</code> 只有在调用 <code>delete</code> 时才会被销毁。</li></ul><ol start="4"><li><strong>静态和全局对象的析构顺序</strong></li></ol><ul><li><p><strong>静态变量</strong>：程序中所有静态变量（包括全局静态变量和局部静态变量）会在<strong>程序结束时</strong>析构。它们的析构顺序通常是<strong>与定义顺序相反</strong>，也就是从后定义的静态变量先析构。</p><p>静态对象的析构时机通常由编译器的运行时环境管理（如 C++ 的静态对象析构）。</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;A created&quot;</span> &lt;&lt; std::endl; &#125;<br>    ~<span class="hljs-built_in">A</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;A destroyed&quot;</span> &lt;&lt; std::endl; &#125;<br>&#125;;<br><br>A a;  <span class="hljs-comment">// 静态对象</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Inside main&quot;</span> &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">A</span> created<br>Inside <span class="hljs-selector-tag">main</span><br><span class="hljs-selector-tag">A</span> destroyed<br></code></pre></td></tr></table></figure><p><strong>解析</strong>：</p><ul><li>静态对象 <code>a</code> 在 <code>main</code> 函数执行之前创建，在 <code>main</code> 执行完毕后销毁。静态对象的析构发生在程序退出时，通常在 <code>main</code> 返回之后。</li></ul><ol start="5"><li><strong>全局对象的析构顺序</strong></li></ol><p>全局对象的析构顺序遵循<strong>反向构造顺序</strong>，即程序的最后一个全局对象会最早被销毁。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;A created&quot;</span> &lt;&lt; std::endl; &#125;<br>    ~<span class="hljs-built_in">A</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;A destroyed&quot;</span> &lt;&lt; std::endl; &#125;<br>&#125;;<br><br>A a;  <span class="hljs-comment">// 全局对象</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Inside main&quot;</span> &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">A</span> created<br>Inside <span class="hljs-selector-tag">main</span><br><span class="hljs-selector-tag">A</span> destroyed<br></code></pre></td></tr></table></figure><p><strong>解析</strong>：</p><ul><li><code>a</code> 在 <code>main</code> 执行之前创建，并在程序退出时销毁。</li></ul><ol start="6"><li><strong>局部静态变量的析构顺序</strong></li></ol><p>局部静态变量的析构顺序在程序结束时由运行时系统管理，通常是在 <code>main</code> 执行完毕之后销毁。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">static</span> A a;  <span class="hljs-comment">// 局部静态变量</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">func</span>();  <span class="hljs-comment">// a 在第一次调用 func 时构造</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><ul><li><strong>局部对象</strong>：后创建，先销毁（按作用域顺序）。</li><li><strong>成员变量</strong>：按照类定义中的声明顺序析构，而非构造顺序。</li><li><strong>堆上对象</strong>：需要显式使用 <code>delete</code> 销毁。</li><li><strong>静态&#x2F;全局对象</strong>：按程序退出时的逆构造顺序销毁。</li></ul><p>对象的析构顺序<strong>遵循“后创建，先销毁”的原则</strong>，但具体情况会根据对象的类型（局部对象、成员变量、静态变量等）以及它们的生命周期有所不同。</p><h2 id="this-指针"><a href="#this-指针" class="headerlink" title="this 指针"></a>this 指针</h2><ul><li><p><code>this</code> 指针在 C++ 中是一个非常重要的概念，用于指向当前对象的内存地址。以下是关于 <code>this</code> 指针的一些关键点：</p><ol><li><p><strong>指向当前对象</strong>：</p><ul><li><code>this</code> 是一个指向当前对象的指针。每个非静态成员函数都隐式地包含一个 <code>this</code> 指针，它指向调用该成员函数的对象。</li></ul></li><li><p><strong>隐式传递</strong>：</p><ul><li>当调用一个对象的成员函数时，<code>this</code> 指针会自动作为第一个参数传递给该函数。实际上，编译器会在函数调用时将对象的地址作为参数传递给成员函数的 <code>this</code> 参数。</li></ul></li><li><p><strong>用途</strong>：</p><ul><li><p><strong>区分形参和成员变量</strong>：当成员函数的参数名与成员变量名相同的时候，可以使用 <code>this</code> 来明确地引用成员变量。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>    <span class="hljs-type">int</span> value;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setValue</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>-&gt;value = value; <span class="hljs-comment">// 使用 this 指针来访问成员变量</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p><strong>返回当前对象的引用</strong>：在成员函数中返回 <code>*this</code> 可以返回当前对象的引用，常用于链式调用。</p></li></ul></li><li><p><strong>注意事项</strong>：</p><ul><li><code>this</code> 指针在类内成员函数中是隐式的，不需要显式声明。</li><li><code>this</code> 指针的类型是 <code>类名* const</code>，意味着 <code>this</code> 本身是常量指针，即不能改变 <code>this</code> 指针指向的地址，但可以通过 <code>this</code> 修改对象的内容。</li></ul></li><li><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;The object&#x27;s address is: &quot;</span> &lt;&lt; <span class="hljs-keyword">this</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    A obj;<br>    obj.<span class="hljs-built_in">display</span>(); <span class="hljs-comment">// 打印对象 obj 的内存地址</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>静态成员函数</strong>：</p><ul><li>静态成员函数没有 <code>this</code> 指针，因为它们不与任何对象实例相关联，而是直接与类相关联。</li></ul></li></ol><p><code>this</code> 指针提供了一种方式，使得<strong>成员函数能够访问其所属的对象的成员变量和成员函数</strong>，增强了代码的可读性和可维护性，同时也提供了解决名称冲突的便利方法。</p></li><li><p>例：P297</p></li></ul><p><img src="/posts/Above-All/on-to-OOP/const.png" alt="This Pointer"></p><p>即需要一个指向“自身”的隐式指针——<strong>this 指针</strong>！</p><p>故缺失的代码为：<code>return *this</code></p><h3 id="有关this-指针的相关注意点"><a href="#有关this-指针的相关注意点" class="headerlink" title="有关this 指针的相关注意点"></a>有关this 指针的相关注意点</h3><ul><li><p>this指针指向调用对象，也可以使用const限定符</p></li><li><p>在C++中，<code>this</code>并不是一个关键词（keyword），而是一个保留字（reserved word）。这意味着：</p><ul><li><p><strong><code>this</code>的用途</strong>：<code>this</code>是一个指向当前对象的指针。在非静态成员函数中，<code>this</code>隐式地指向调用该函数的对象实例。它的主要用途包括：</p><ul><li>区分局部变量和成员变量。例如，如果成员变量和函数参数同名，可以使用<code>this-&gt;</code>来明确指代成员变量。</li><li>返回当前对象的引用或指针。例如，<code>return *this;</code>用于链式调用。</li></ul></li><li><p><strong>保留字</strong>：虽然<code>this</code>不是关键词，但它是保留给编译器使用的，不能用作其他用途（如变量名或函数名）。这确保了<code>this</code>在C++代码中具有特定的含义和用法。</p></li><li><p><strong>不可重新定义</strong>：由于<code>this</code>是保留字，程序员不能定义一个名为<code>this</code>的变量、函数或其他标识符。</p></li><li><p><strong>编译器支持</strong>：编译器会自动在成员函数中插入<code>this</code>指针的使用，使得成员函数知道它们是哪个对象的成员。</p></li></ul><p>因此，虽然<code>this</code>在C++中不是关键词，但它的用法和保留性质使得它在语言中扮演了一个特殊的角色，确保了面向对象编程中的对象身份的明确性。</p></li></ul><h2 id="对象数组"><a href="#对象数组" class="headerlink" title="对象数组"></a>对象数组</h2><ul><li>创建对象数组的格式和基本数组相同</li></ul><p><img src="/posts/Above-All/on-to-OOP/create.png" alt="构造函数"></p><p>也可以使用不同的构造函数</p><ul><li><strong>要创建类对象数组，必须应有类的默认构造函数（显示&amp;隐式）</strong>，因为在初始化对象数组的时候首先使用默认构造函数创建数组元素，接着再创建临时对象并对值进行覆盖。</li><li>针对对象数组，也可以使用指针</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">top = &amp;(top-&gt;<span class="hljs-built_in">topval</span>(stocks[st]));<br></code></pre></td></tr></table></figure><p>成员访问运算符的优先级高于取址运算符</p><h2 id="类作用域"><a href="#类作用域" class="headerlink" title="类作用域"></a>类作用域</h2><ul><li>要调用共有成员函数，必须通过对象！（静态成员除外）</li><li>可以使用成员访问运算符或作用域解析运算符（主要对于库函数）</li></ul><h3 id="类作用域运算符"><a href="#类作用域运算符" class="headerlink" title="类作用域运算符::"></a>类作用域运算符<code>::</code></h3><p>在C++中，作用域解析运算符（<code>::</code>）用于多种场景，以下是几种常见使用情况：</p><ol><li><p><strong>访问全局变量或函数</strong>：</p><ul><li><p>当局部变量与全局变量同名时，可以使用<code>::</code>来明确指定使用全局变量。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;  <span class="hljs-comment">// 全局变量</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">20</span>;  <span class="hljs-comment">// 局部变量</span><br>    std::cout &lt;&lt; ::a &lt;&lt; std::endl;  <span class="hljs-comment">// 输出全局变量a的值</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>访问命名空间中的成员</strong>：</p><ul><li><p>用于明确指定命名空间中的成员，避免命名冲突。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">namespace</span> MyNamespace &#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myFunction</span><span class="hljs-params">()</span></span>;<br>&#125;<br>MyNamespace::<span class="hljs-built_in">myFunction</span>();<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>访问类的静态成员</strong>：</p><ul><li><p>访问类的静态成员变量或静态成员函数时：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> count;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">staticMethod</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><span class="hljs-type">int</span> MyClass::count = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 定义并初始化静态成员变量</span><br>MyClass::<span class="hljs-built_in">staticMethod</span>();  <span class="hljs-comment">// 调用静态成员函数</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>基类成员的访问</strong>：</p><ul><li><p>当派生类与基类有同名的成员时，使用作用域解析运算符可以明确访问基类的成员：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Base::method()&quot;</span> &lt;&lt; std::endl; &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span> </span>&#123; <br>        Base::<span class="hljs-built_in">method</span>();  <span class="hljs-comment">// 调用基类的同名方法</span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Derived::method()&quot;</span> &lt;&lt; std::endl; <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>模板类中的静态成员</strong>：</p><ul><li><p>在模板类中，静态成员的定义需要使用作用域解析运算符：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TemplateClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">static</span> T value;<br>&#125;;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br>T TemplateClass&lt;T&gt;::value;  <span class="hljs-comment">// 定义静态成员</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>访问外部链接的变量或函数</strong>：</p><ul><li><p>当在不同的源文件中声明和定义变量或函数时，可以使用作用域解析运算符来明确链接到外部定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// file1.cpp</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> globalVar;<br><br><span class="hljs-comment">// file2.cpp</span><br><span class="hljs-type">int</span> ::globalVar = <span class="hljs-number">10</span>;  <span class="hljs-comment">// 定义全局变量</span><br></code></pre></td></tr></table></figure></li></ul></li></ol><p>作用域解析运算符在C++中是一个非常重要的工具，它帮助程序员明确指定变量、函数或类的作用域，避免命名冲突，增强代码的可读性和可维护性。</p><ul><li><p>有关静态成员</p><ul><li><p>访问类的静态成员可以不通过对象进行访问。静态成员是属于类本身而不是类实例的，因此可以直接通过类名访问。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> staticVar;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">staticMethod</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><span class="hljs-type">int</span> MyClass::staticVar = <span class="hljs-number">10</span>;  <span class="hljs-comment">// 静态成员变量的定义</span><br><br>MyClass::staticVar = <span class="hljs-number">20</span>;  <span class="hljs-comment">// 直接通过类名访问静态成员变量</span><br>MyClass::<span class="hljs-built_in">staticMethod</span>();  <span class="hljs-comment">// 直接通过类名调用静态成员函数</span><br><br></code></pre></td></tr></table></figure></li><li><p>静态成员（包括静态成员变量和静态成员函数）在C++中有一些常见的用途：</p></li></ul></li></ul><p>静态成员变量</p><ol><li><p><strong>计数器</strong>：</p><ul><li>用于跟踪类的实例数量。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> instanceCount;<br>    <span class="hljs-built_in">MyClass</span>() &#123; ++instanceCount; &#125;<br>    ~<span class="hljs-built_in">MyClass</span>() &#123; --instanceCount; &#125;<br>&#125;;<br><span class="hljs-type">int</span> MyClass::instanceCount = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 定义并初始化静态成员变量</span><br></code></pre></td></tr></table></figure></li><li><p><strong>共享数据</strong>：</p><ul><li>当需要在所有实例之间共享某些数据时。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Logger</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">static</span> std::string logFile;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">log</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; message)</span> </span>&#123;<br>        <span class="hljs-comment">// 向静态成员变量logFile记录日志</span><br>    &#125;<br>&#125;;<br>std::string Logger::logFile = <span class="hljs-string">&quot;log.txt&quot;</span>;<br></code></pre></td></tr></table></figure></li><li><p><strong>常量数据</strong>：</p><ul><li>定义类相关的常量信息。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MathConstants</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">double</span> PI = <span class="hljs-number">3.14159265358979323846</span>;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ol><h1 id="Cha-11-使用类"><a href="#Cha-11-使用类" class="headerlink" title="Cha 11 使用类"></a>Cha 11 使用类</h1><h2 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h2><p>友元函数（<strong>Friend Function</strong>）是 C++ 中的一种机制，允许一个函数（或类）访问另一个类的私有成员和保护成员。虽然友元函数可以访问类的私有和保护成员，但它本身并不是类的成员函数。友元函数通常用于操作一些类内部的细节，但它可能会引入一些需要注意的问题。</p><ul><li>让函数成为类的友元，可以赋予该函数与类的成员函数相同的访问权限（<strong>访问private</strong>）</li><li>例：将运算符重载编写成一个非成员函数</li><li>友元函数具有成员函数的权限，但<strong>作为非成员函数不能使用成员运算符进行调用</strong><ul><li>使用成员函数，可以使用构造函数，这更加高效</li></ul></li><li><strong>只有在函数声明的时候需要加上friend关键词，在函数定义时不可以</strong></li></ul><p><img src="/posts/Above-All/on-to-OOP/vector.png" alt="vector"></p><h3 id="友元函数和在成员函数中运算符重载的区别"><a href="#友元函数和在成员函数中运算符重载的区别" class="headerlink" title="友元函数和在成员函数中运算符重载的区别"></a>友元函数和在成员函数中运算符重载的区别</h3><p>在成员函数中实现运算符重载</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Complex</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    Complex <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Complex&amp; other) <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Complex</span>(real + other.real, imag + other.imag);<br>    &#125;<br>    <span class="hljs-comment">//成员函数重载运算符中，所需的参数数目比运算符使用的参数数目少一个，其中一个是被隐式传递的调用对象(this 指针)</span><br>    <span class="hljs-comment">// 其它成员函数和数据成员</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">double</span> real;<br>    <span class="hljs-type">double</span> imag;<br>&#125;;<br><br></code></pre></td></tr></table></figure><p>在非成员函数中实现运算符重载（友元函数）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Complex</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">double</span> real;<br>    <span class="hljs-type">double</span> imag;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Complex</span>(<span class="hljs-type">double</span> r = <span class="hljs-number">0.0</span>, <span class="hljs-type">double</span> i = <span class="hljs-number">0.0</span>) : <span class="hljs-built_in">real</span>(r), <span class="hljs-built_in">imag</span>(i) &#123;&#125;<br><br>    <span class="hljs-comment">// 声明友元函数</span><br>    <span class="hljs-keyword">friend</span> Complex <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Complex&amp; left, <span class="hljs-type">const</span> Complex&amp; right);<br>&#125;;<br><br></code></pre></td></tr></table></figure><h3 id="友元函数相比于成员函数的优势"><a href="#友元函数相比于成员函数的优势" class="headerlink" title="友元函数相比于成员函数的优势"></a>友元函数相比于成员函数的优势</h3><p>友元函数相对于成员函数具有一些特定的优势，尽管它们打破了类的封装原则，但这些优势在某些情境下是非常有用的：</p><ol><li><strong>操作符重载</strong></li></ol><p>友元函数常用于操作符重载，特别是当操作符需要访问两个不同类或类型的对象时。成员函数只能通过 <code>this</code> 指针访问当前对象的成员，而友元函数可以直接访问两个对象的私有成员。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Complex</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">double</span> real;<br>    <span class="hljs-type">double</span> imag;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// ... 其他成员函数 ...</span><br>    <span class="hljs-keyword">friend</span> Complex <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Complex&amp; a, <span class="hljs-type">const</span> Complex&amp; b);<br>&#125;;<br><br><span class="hljs-comment">// 友元函数定义</span><br>Complex <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Complex&amp; a, <span class="hljs-type">const</span> Complex&amp; b) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Complex</span>(a.real + b.real, a.imag + b.imag);<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li><strong>提高代码的可读性和简洁性</strong></li></ol><ul><li><strong>全局函数</strong>：友元函数可以作为全局函数，这在某些情况下可以使代码更易于理解和维护。例如，上面的 <code>operator+</code> 作为友元函数，使得加法操作看起来更自然，不需要通过对象调用。</li><li><strong>避免不必要的成员函数</strong>：有时，某些操作并不适合作为类的一部分，但仍然需要访问类的私有成员。友元函数可以提供这种访问，而不需要增加类的成员函数。</li></ul><ol start="3"><li><strong>对称性</strong></li></ol><ul><li>友元函数可以提供操作的对称性。例如，在 <code>operator==</code> 的情况下，如果是成员函数，<code>a == b</code> 和 <code>b == a</code> 可能需要不同的实现，而友元函数可以使这两个操作等价。</li></ul><ol start="4"><li><strong>减少this指针的使用</strong></li></ol><ul><li>友元函数没有隐式的 <code>this</code> 指针，这在某些情况下可以提高效率，因为不需要额外的参数传递。</li></ul><ol start="5"><li><strong>访问私有成员而不改变类的接口</strong></li></ol><ul><li>如果你需要一个函数访问类的数据，但不想将这个函数作为类的成员（因为它不属于类的逻辑部分），友元函数可以让你实现这一点，而不改变类的公共接口。</li></ul><ol start="6"><li><strong>跨类访问</strong></li></ol><ul><li>友元函数可以被多个类声明为友元，从而允许<strong>这些类之间共享数据，而不需要通过公共接口或继承</strong>。</li></ul><ol start="7"><li><strong>设计模式的实现</strong></li></ol><ul><li>在一些设计模式中，如桥接模式、适配器模式等，友元函数可以帮助实现跨类协作，而无需暴露类的内部实现细节。</li></ul><p><strong>注意事项</strong>：</p><p>尽管友元函数有这些优势，但它们也有一些潜在的缺点：</p><ul><li><strong>打破封装</strong>：友元函数允许非成员函数访问类的私有成员，可能会破坏类的封装性。</li><li><strong>代码维护</strong>：友元关系可能会使代码的维护变得复杂，因为它增加了类的依赖性。</li><li><strong>滥用</strong>：如果不谨慎使用，友元函数可能会导致代码的可读性和结构性下降。</li></ul><p>因此，在使用友元函数时，应该谨慎考虑是否真的需要这种访问权限，并尽量限制友元函数的数量和范围，以保持类的封装性和代码的清晰度。</p><h2 id="友元类"><a href="#友元类" class="headerlink" title="友元类"></a>友元类</h2><p>在 C++ 中，<code>friend</code> 是一种特殊的机制，它允许某些函数或类访问其他类的私有成员。<code>friend</code> 主要有两种形式：<strong>友元函数</strong> 和 <strong>友元类</strong>。这两种机制在设计某些复杂系统时非常有用，可以让不同类之间进行密切的合作，同时保持类内部的封装性。</p><p><strong>友元类</strong> 是一个类，它被声明为某个类的友元类。友元类的成员函数可以访问该类的私有成员。这种机制通常用于设计两个紧密相关的类，它们需要互相访问私有数据，但又不希望暴露给外部。</p><p><strong>友元类的基本语法</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setA</span><span class="hljs-params">(A&amp; obj)</span></span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> x;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> val) : <span class="hljs-built_in">x</span>(val) &#123;&#125;<br><br>    <span class="hljs-comment">// 声明 B 为友元类</span><br>    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>;<br>&#125;;<br><br><span class="hljs-comment">// B 是 A 的友元类，可以访问 A 的私有成员</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">B::setA</span><span class="hljs-params">(A&amp; obj)</span> </span>&#123;<br>    obj.x = <span class="hljs-number">100</span>;  <span class="hljs-comment">// 直接访问 A 的私有成员</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">A <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br>    B b;<br>    b.<span class="hljs-built_in">setA</span>(a);  <span class="hljs-comment">// B 可以访问 A 的私有成员</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>友元类的应用场景</strong></p><ul><li><strong>设计复杂系统</strong>：友元类的使用可以让两个类之间共享数据和功能，而不暴露这些数据给其他类。例如，在某些库中，可能有一个类负责管理资源（如内存管理），另一个类负责使用这些资源。为了实现高效和紧密的合作，这两个类可能需要互相访问对方的私有成员，这时可以将其中一个类声明为友元类。</li><li><strong>实现成员共享</strong>：友元类通常用于需要相互访问成员数据的类，特别是在某些算法和数据结构的实现中，如链表、树、图等。</li></ul><p><strong>友元类的设计示例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Engine</span>;  <span class="hljs-comment">// 前向声明</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    Engine* engine;  <span class="hljs-comment">// Engine 对象是 Car 的私有成员</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Car</span>() : <span class="hljs-built_in">engine</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br><br>    <span class="hljs-comment">// 声明 Engine 为友元类</span><br>    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Engine</span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Engine</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> horsepower;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Engine</span>(<span class="hljs-type">int</span> hp) : <span class="hljs-built_in">horsepower</span>(hp) &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setCarEngine</span><span class="hljs-params">(Car&amp; car)</span> </span>&#123;<br>        car.engine = <span class="hljs-keyword">this</span>;  <span class="hljs-comment">// Engine 可以访问 Car 的私有成员</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showCarEngineInfo</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Car engine horsepower: &quot;</span> &lt;&lt; horsepower &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>Engine</code> 类被声明为 <code>Car</code> 类的友元类，使得 <code>Engine</code> 类能够访问 <code>Car</code> 类的私有成员。</p><h4 id="友元类与继承"><a href="#友元类与继承" class="headerlink" title="友元类与继承"></a><strong>友元类与继承</strong></h4><p>友元类与继承之间有一些特别的关系。虽然子类继承了父类的公共和保护成员，但<strong>友元关系不被继承</strong>。也就是说，如果<strong>某个类是另一个类的友元类，它并不能自动成为其子类的友元类</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> value;<br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> val) : <span class="hljs-built_in">value</span>(val) &#123;&#125;<br>    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>;  <span class="hljs-comment">// B 是 A 的友元类</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> : <span class="hljs-keyword">public</span> A &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">C</span>(<span class="hljs-type">int</span> val) : <span class="hljs-built_in">A</span>(val) &#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showValue</span><span class="hljs-params">(A&amp; obj)</span> </span>&#123;<br>        std::cout &lt;&lt; obj.value &lt;&lt; std::endl;  <span class="hljs-comment">// B 可以访问 A 的私有成员</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">A <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br>    B b;<br>    b.<span class="hljs-built_in">showValue</span>(a);  <span class="hljs-comment">// 正常，B 可以访问 A 的私有成员</span><br><br>    <span class="hljs-function">C <span class="hljs-title">c</span><span class="hljs-params">(<span class="hljs-number">20</span>)</span></span>;<br>    <span class="hljs-comment">// b.showValue(c);  // 错误，C 没有继承 B 对 A 的友元关系</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的例子中，<code>B</code> 是 <code>A</code> 的友元类，但 <code>C</code> 并没有继承 <code>B</code> 对 <code>A</code> 的友元关系，因此 <code>B</code> 无法访问 <code>C</code> 的私有成员。</p><h4 id="友元与封装"><a href="#友元与封装" class="headerlink" title="友元与封装"></a><strong>友元与封装</strong></h4><p>尽管 <code>friend</code> 允许类外部的函数和类访问私有成员，但它仍然保持了一定的封装性。在设计时，应注意不要过度使用友元关系，因为过多的友元可能会破坏类的封装性，增加类之间的耦合度，导致维护困难。</p><ul><li><strong>适度使用友元</strong>：只有在确实需要类之间紧密合作时，才应考虑使用友元关系。尤其是当某些函数需要访问类的内部细节时，友元函数和友元类可以提供非常强大的功能。</li><li><strong>减少友元的使用</strong>：不推荐随意将大量的类或函数声明为友元，尽量保持类的封装性，使其更具独立性和可维护性。</li></ul><blockquote><p>我们会在 <a href="https://xiyuanyang-code.github.io/posts/Code-Reuse-in-OOP/">这篇博客</a> 中花更多的篇幅介绍友元类。</p></blockquote><h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">operator</span>[op](argument-list)&#123;<br>    <span class="hljs-comment">//运算符重载的具体实现细节</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>运算符重载也可以看做是OOP<strong>多态</strong>精神的一部分，标准库中每个运算符都有自己的定义，现在我们在此基础之上新定义新的语法规则。</p></blockquote><p><img src="/posts/Above-All/on-to-OOP/operator.png" alt="operator"></p><ul><li><p>可以实现运算符重载的运算符</p></li><li><p>重载运算符的性质</p><ul><li>必须有一个操作数是用户定义的类型</li><li>不能违反运算符原来的句法规则（包括优先级）</li><li>不能创建新的运算符</li></ul></li></ul><p>下文给出了对<code>Rational</code>类的相关运算符重载：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rational</span> &#123;<br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-type">int</span> num;<br>        <span class="hljs-type">int</span> den;<br>            <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ReductFraction</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">Rational</span>(<span class="hljs-type">int</span> n = <span class="hljs-number">0</span>, <span class="hljs-type">int</span> d = <span class="hljs-number">1</span>) &#123; <br>            num = n; den = d; <br>            <span class="hljs-built_in">ReductFraction</span>();<br>        &#125;<br>        Rational <span class="hljs-keyword">operator</span> + (<span class="hljs-type">const</span> Rational &amp;r1) <span class="hljs-type">const</span>; <span class="hljs-comment">//+运算符重载</span><br>        Rational <span class="hljs-keyword">operator</span> * (<span class="hljs-type">const</span> Rational &amp;r1) <span class="hljs-type">const</span>; <span class="hljs-comment">//*运算符重载</span><br>        <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt; (<span class="hljs-type">const</span> Rational &amp;r1) <span class="hljs-type">const</span>; <span class="hljs-comment">//&lt;运算符重载</span><br>        <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> == (<span class="hljs-type">const</span> Rational &amp;r1) <span class="hljs-type">const</span>; <span class="hljs-comment">//==运算符重载</span><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; cout &lt;&lt; num &lt;&lt; <span class="hljs-string">&#x27;/&#x27;</span> &lt;&lt; den;&#125;<br>&#125;;<br><span class="hljs-comment">//重载了+ *运算，返回一个本类型的对象</span><br><span class="hljs-comment">//这里不用返回一个对本类型对象的引用，因为是临时变量，进行按值传递（如果涉及到指针需要重载赋值运算符，稍后会讲到）</span><br>Rational Rational::<span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Rational &amp;r1) <span class="hljs-type">const</span><br>&#123;<br>    Rational tmp;<br>    tmp.num = num * r<span class="hljs-number">1.</span>den + r<span class="hljs-number">1.</span>num * den;<br>    tmp.den = den * r<span class="hljs-number">1.</span>den;<br>    tmp.<span class="hljs-built_in">ReductFraction</span>();<br>    <span class="hljs-keyword">return</span> tmp;<br>&#125;<br>Rational Rational::<span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Rational &amp;r1) <span class="hljs-type">const</span><br>&#123;<br>    Rational tmp;<br>    tmp.num = num * r<span class="hljs-number">1.</span>num;<br>    tmp.den = den * r<span class="hljs-number">1.</span>den;<br>    tmp.<span class="hljs-built_in">ReductFraction</span>();<br>    <span class="hljs-keyword">return</span> tmp;<br>&#125;<br><span class="hljs-comment">//重载了关系运算符，需要返回一个bool值</span><br><span class="hljs-type">bool</span> Rational::<span class="hljs-keyword">operator</span> &lt; (<span class="hljs-type">const</span> Rational &amp;r1) <span class="hljs-type">const</span><br>&#123;<br>    <span class="hljs-keyword">return</span> num * r<span class="hljs-number">1.</span>den &lt; den * r<span class="hljs-number">1.</span>num;<br>&#125;<br><span class="hljs-type">bool</span> Rational::<span class="hljs-keyword">operator</span> == (<span class="hljs-type">const</span> Rational &amp;r1) <span class="hljs-type">const</span><br>&#123;<br>    <span class="hljs-keyword">return</span> num == r<span class="hljs-number">1.</span>num &amp;&amp; den == r<span class="hljs-number">1.</span>den;<br>&#125;<br></code></pre></td></tr></table></figure><p>运算符重载本质上是一个<strong>函数</strong>，他有对应的返回值。（例如重载赋值运算符需要返回一个bool值，重载加法运算符需要返回一个类）编译时， 编译器将 <code>r3 = r1 + r2</code> 解释成 <code>r3 = r1.operator+(r2)</code>， <code>r3 = r1 * r2</code> 解释成 <code>r3 = r1.operator*(r2)</code>， <code>r1 == r2</code> 解释成 <code>r1.operator==(r2)</code>， <code>r1 &lt; r3</code> 解释成 <code>r1.operator&lt;(r3)</code>。   </p><p>如何理解<code>r3 = r1.operator+(r2)</code>？你可以把<code>operator+</code>当成是一种函数名，对象<code>r1</code>调用自己的方法<code>operator+()</code>函数，函数的参数列表是<code>r2</code>（一个对本类型对象的<code>const</code>引用）。</p><p>这 4 个运算符也可以重载成全局函数。由于重载函数主要是对对象的数据成员进行操作，而在一般的类定义中，数据成员都被定义成私有的。因此，当运算符被重载成全局函数时，通常将<strong>此重载函数设为类的友元函数，便于访问类的私有数据成员</strong>。  （在后文关于友元函数的章节会涉及）</p><p>大多数运算符都可以重载成成员函数或全局函数。但是<strong>赋值运算符（ &#x3D;）、下标运算符（ []）、函数调用运算符（ ()）必须重载成成员函数</strong>，因为这些运算符的<strong>第一个运算对象必须是相应类的对象</strong>，定义成成员函数可以保证第一个运算对象的正确性。如果第一个运算对象不是相应类的对象，编译器能检查出此错误。 具有<strong>赋值意义的运算符（如复合的赋值运算符以及++和–） 不一定非要重载为成员函数，但建议重载为成员函数</strong>。具有两个运算对象且计算结果会产生一个新对象的运算符建议重载为<strong>全局函数</strong>，如 +、 -、 &gt;等，这样可以使应用更加灵活。  </p><h3 id="赋值运算符的重载"><a href="#赋值运算符的重载" class="headerlink" title="赋值运算符的重载"></a>赋值运算符的重载</h3><p>**<a href="https://xiyuanyang-code.github.io/posts/Dynamic-Memory-and-Classes/">类和动态内存分配</a>**，建议阅读以获得更好的上下文体验。</p><p>简单来说，在类中的默认赋值运算符执行的是<strong>浅拷贝</strong>的过程，将每一个数据成员的<strong>值</strong>拷贝给另一个类中对应的数据成员。而对于<strong>指针成员</strong>，指针成员的值是指向的一块<strong>内存地址</strong>，而并非<strong>指向变量的值</strong>！这就会导致赋值的两个对象的指针数据成员指向了同一块内存，都具有对这块内存的<strong>修改权限</strong>。同时，如果使用动态内存分配，很有可能对delete掉同一块内存两次，产生错误。</p><p><strong>因此，赋值运算符的重载本质上就是对指针等特殊情况特殊处理，进行“深拷贝”</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++">MyClass&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> MyClass&amp; other) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;other)  <span class="hljs-comment">// 防止自我赋值</span><br>            <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br><br>        <span class="hljs-comment">// 先释放当前对象的资源</span><br>        <span class="hljs-keyword">delete</span> data;<br><br>        <span class="hljs-comment">// 分配新的内存并复制数据</span><br>        data = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(*(other.data));<br><br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;  <span class="hljs-comment">// 返回左操作数的引用</span><br>    &#125;<br></code></pre></td></tr></table></figure><p>在C++中，<strong>赋值是一种运算</strong>，赋值运算语句的返回值是左边（左值）被赋值的对象的值。因此，<strong>赋值运算符必须返回对左边对象的引用，即返回一个左值。</strong></p><blockquote><p>这样做允许了<code>a=b=c</code>的链式赋值操作，在流输入输出运算过程中也是如此。</p></blockquote><p>与移动构造类似， C++11 提出了<strong>移动赋值</strong>的概念，让左边的对象直接接管右边临时对象的资源，以提高赋值过程的时间性能。移动赋值的右值是临时对象，因此它的<strong>形式参数是同类对象的右值引用</strong>，返回值是<strong>当前对象的引用</strong>。例如，为 DoubleArray 类增加一个移动赋值运算符重载函数，其定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++">DoubleArray &amp;DoubleArray::<span class="hljs-keyword">operator</span>=(DoubleArray &amp;&amp; a) &#123;<br>    <span class="hljs-keyword">delete</span> [] storage;<br>    low = a.low;<br>    high = a.high;<br>    storage = a.storage;<br>    a.storage = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>函数首先释放左边对象的空间，然后直接接管右边对象的空间，就不再需要复制数组元素了。</p><h3 id="下标运算符的重载"><a href="#下标运算符的重载" class="headerlink" title="下标运算符的重载"></a>下标运算符的重载</h3><p>下标运算符是一个二元运算符，第一个运算数是<strong>操作对象</strong>，第二个运算数是<strong>下标值</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdexcept&gt;</span>  <span class="hljs-comment">// 为了抛出异常</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyArray</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span>* data;<span class="hljs-comment">//一个int指针（当数组用）</span><br>    <span class="hljs-type">size_t</span> size;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 构造函数</span><br>    <span class="hljs-built_in">MyArray</span>(<span class="hljs-type">size_t</span> s) : <span class="hljs-built_in">size</span>(s) &#123;<br>        data = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[size];<br>    &#125;<br><br>    <span class="hljs-comment">// 析构函数</span><br>    ~<span class="hljs-built_in">MyArray</span>() &#123;<br>        <span class="hljs-keyword">delete</span>[] data;<br>    &#125;<br><br>    <span class="hljs-comment">// 非常量版本的下标运算符重载（允许修改元素）</span><br>    <span class="hljs-type">int</span>&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">size_t</span> index) &#123;<br>        <span class="hljs-keyword">if</span> (index &gt;= size) &#123;<br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">out_of_range</span>(<span class="hljs-string">&quot;Index out of range&quot;</span>);<br>            <span class="hljs-comment">//进行越界检查</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> data[index];<br>    &#125;<br><br>    <span class="hljs-comment">// 常量版本的下标运算符重载（不允许修改元素）</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">size_t</span> index) <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">if</span> (index &gt;= size) &#123;<br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">out_of_range</span>(<span class="hljs-string">&quot;Index out of range&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> data[index];<br>    &#125;<br><br>    <span class="hljs-comment">// 获取数组大小</span><br>    <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">getSize</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> size;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">MyArray <span class="hljs-title">arr</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span></span>;  <span class="hljs-comment">// 创建一个包含 5 个整数的数组</span><br><br>    <span class="hljs-comment">// 使用下标运算符修改元素</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-built_in">getSize</span>(); ++i) &#123;<br>        arr[i] = i * <span class="hljs-number">10</span>;  <span class="hljs-comment">// 设置 arr[0] = 0, arr[1] = 10, arr[2] = 20, ...</span><br>    &#125;<br><br>    <span class="hljs-comment">// 使用下标运算符读取元素</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-built_in">getSize</span>(); ++i) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;arr[&quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;] = &quot;</span> &lt;&lt; arr[i] &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-comment">// 访问常量对象</span><br>    <span class="hljs-function"><span class="hljs-type">const</span> MyArray <span class="hljs-title">constArr</span><span class="hljs-params">(<span class="hljs-number">3</span>)</span></span>;<br>    <span class="hljs-comment">// constArr[0] = 100;  // 错误：常量对象不能修改</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;constArr[0] = &quot;</span> &lt;&lt; constArr[<span class="hljs-number">0</span>] &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="函数调用运算符的重载"><a href="#函数调用运算符的重载" class="headerlink" title="函数调用运算符的重载"></a>函数调用运算符的重载</h3><p>C++将函数调用也作为一种运算。 函数调用运算符()是一个二元运算符。第一个运算对象是<strong>函数名</strong>，第二个参数是<strong>函数的形式参数表</strong>，运算结果是<strong>函数的返回值</strong>。如果一个类重载了函数调用运算符，就可以把<strong>这个类的对象当作函数</strong>来使用。因为是把当前类的对象当作函数使用，所以()运算的第一个运算数是当前类的对象， C++规定函数调用运算符必须重载成成员函数。</p><p>例如，我有数组类<code>array</code>和数组类对象<code>arr</code>，如果我在<code>array</code>中重载了函数调用运算符，那么<code>arr(1,2)</code>这种操作就是合法的，即<strong>对象名就是函数名！</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Multiplier</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> factor;  <span class="hljs-comment">// 乘数</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 构造函数：初始化 factor</span><br>    <span class="hljs-built_in">Multiplier</span>(<span class="hljs-type">int</span> f) : <span class="hljs-built_in">factor</span>(f) &#123;&#125;<br><br>    <span class="hljs-comment">// 重载函数调用运算符</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> factor * value;  <span class="hljs-comment">// 返回值乘以 factor</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 创建一个 Multiplier 对象，乘数为 5</span><br>    <span class="hljs-function">Multiplier <span class="hljs-title">multiplyBy5</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span></span>;<br><br>    <span class="hljs-comment">// 使用重载的函数调用运算符进行计算</span><br>    <span class="hljs-type">int</span> result = <span class="hljs-built_in">multiplyBy5</span>(<span class="hljs-number">10</span>);  <span class="hljs-comment">// 相当于 multiplyBy5.operator()(10)</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Result: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;  <span class="hljs-comment">// 输出：50</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="和-运算符的重载"><a href="#和-运算符的重载" class="headerlink" title="++和--运算符的重载"></a><code>++</code>和<code>--</code>运算符的重载</h3><p> <code>++</code>和<code>--</code>都是一元运算符，它们可被重载成成员函数或友元函数。但因为这两个运算符改变了运算对象的状态，所以更倾向于将它们作为成员函数。在考虑重载</p><p><code>++</code>和<code>--</code>运算符时，必须注意一个问题。 <code>++</code>和<code>--</code>既可以作为前缀使用，也可以作为后缀使用。而且这两种用法的结果是不一样的：作为前缀使用时，运算结果是修改以后的对象引用；作为后缀使用时，运算结果是修改以前的对象值。为了与内置类型一致，重载后的<code>++</code>和<code>--</code>也应具有这个特性。为此，对于<code>++</code>和<code>--</code>运算，每个运算符必须<strong>提供两个重载函数：一个处理前缀运算；另一个处理后缀运算</strong>。</p><p>但问题是，处理++的两个重载函数的原型除了返回类型不同之外，其他是完全相同的，处理–的两个重载函数也是如此。而仅返回类型不同的两个函数无法形成重载函数。</p><p>为了解决这个问题， C++规定<strong>后缀运算符重载函数接收一个额外的（即无用的） int 型的形式参数</strong>。使用后缀运算符时，编译器用 0 作为这个参数的值。当编译器看到一个前缀表示的++或–时，调用正常重载的这个函数。如果看到的是一个后缀表示的++或–，则<strong>调用有一个额外参数的重载函数</strong>。这样就把前缀和后缀的重载函数区分开了。</p><h4 id="前缀"><a href="#前缀" class="headerlink" title="前缀"></a>前缀</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> value;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 构造函数</span><br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">int</span> v) : <span class="hljs-built_in">value</span>(v) &#123;&#125;<br><br>    <span class="hljs-comment">// 前缀 ++ 运算符重载</span><br>    MyClass&amp; <span class="hljs-keyword">operator</span>++() &#123;<br>        ++value;  <span class="hljs-comment">// 增加成员变量 value</span><br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;  <span class="hljs-comment">// 返回当前对象的引用</span><br>    &#125;<br><br>    <span class="hljs-comment">// 前缀 -- 运算符重载</span><br>    MyClass&amp; <span class="hljs-keyword">operator</span>--() &#123;<br>        --value;  <span class="hljs-comment">// 减少成员变量 value</span><br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;  <span class="hljs-comment">// 返回当前对象的引用</span><br>    &#125;<br><br>    <span class="hljs-comment">// 显示值</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Value: &quot;</span> &lt;&lt; value &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">MyClass <span class="hljs-title">obj</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br>    obj.<span class="hljs-built_in">display</span>();<br><br>    ++obj;  <span class="hljs-comment">// 前缀++ 运算符</span><br>    obj.<span class="hljs-built_in">display</span>();<br><br>    --obj;  <span class="hljs-comment">// 前缀-- 运算符</span><br>    obj.<span class="hljs-built_in">display</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><div class="note note-primary">            <p><strong>注意：前缀运算符的返回值是一个对本对象的引用</strong>，这样可以使运算符在连续调用时进行链式操作（例如：<code>++(++obj)</code>）</p>          </div><h4 id="后缀"><a href="#后缀" class="headerlink" title="后缀"></a>后缀</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> value;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 构造函数</span><br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">int</span> v) : <span class="hljs-built_in">value</span>(v) &#123;&#125;<br><br>    <span class="hljs-comment">// 后缀 ++ 运算符重载</span><br>    MyClass <span class="hljs-keyword">operator</span>++(<span class="hljs-type">int</span>) &#123;<br>        MyClass temp = *<span class="hljs-keyword">this</span>;  <span class="hljs-comment">// 保存当前值</span><br>        ++value;  <span class="hljs-comment">// 增加成员变量 value</span><br>        <span class="hljs-keyword">return</span> temp;  <span class="hljs-comment">// 返回原对象</span><br>    &#125;<br><br>    <span class="hljs-comment">// 后缀 -- 运算符重载</span><br>    MyClass <span class="hljs-keyword">operator</span>--(<span class="hljs-type">int</span>) &#123;<br>        MyClass temp = *<span class="hljs-keyword">this</span>;  <span class="hljs-comment">// 保存当前值</span><br>        --value;  <span class="hljs-comment">// 减少成员变量 value</span><br>        <span class="hljs-keyword">return</span> temp;  <span class="hljs-comment">// 返回原对象</span><br>    &#125;<br><br>    <span class="hljs-comment">// 显示值</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Value: &quot;</span> &lt;&lt; value &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">MyClass <span class="hljs-title">obj</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br>    obj.<span class="hljs-built_in">display</span>();<br><br>    obj++;  <span class="hljs-comment">// 后缀++ 运算符</span><br>    obj.<span class="hljs-built_in">display</span>();<br><br>    obj--;  <span class="hljs-comment">// 后缀-- 运算符</span><br>    obj.<span class="hljs-built_in">display</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><div class="note note-primary">            <p>注意：</p><ul><li>后缀运算符的参数列表多了一个<code>int</code>，这是C++用于区分前缀后缀的方式</li><li>后缀运算符重载的返回类型是<strong>值</strong>（会使用到赋值运算符），因此并不能返回对一个局部变量的<strong>引用</strong>。<ul><li><strong>实际上，编译器在执行<code>i++</code>的时候，也是先创建一个副本作为i的初始值，然后执行自增操作后返回副本的值，接着副本被销毁</strong>。</li><li>这种机制导致了**<code>i++</code>所需的计算开销会高于<code>++i</code>**，尤其当i是自己定义的对象或其他内存占比比较大的数据类型时。</li></ul></li></ul>          </div><h3 id="输入-输出运算符的重载"><a href="#输入-输出运算符的重载" class="headerlink" title="输入&#x2F;输出运算符的重载"></a>输入&#x2F;输出运算符的重载</h3><h4 id="重新认识运算符"><a href="#重新认识运算符" class="headerlink" title="重新认识&lt;&lt;和&gt;&gt;运算符"></a>重新认识<code>&lt;&lt;</code>和<code>&gt;&gt;</code>运算符</h4><p>在笔者的第一堂C++启蒙课上，笔者便体会到了<strong>流操作</strong>的精妙和便捷。（相比于<code>printf()</code>和<code>scanf()</code>的冗长语法）但是，当时笔者只是把<code>cin/cout</code>当做一个普通的函数来使用，并不知道其背后深层次的原理。下面，我们先来重新认识一下cin&#x2F;cout的真面目。</p><h5 id="istream和ostream"><a href="#istream和ostream" class="headerlink" title="istream和ostream"></a><code>istream</code>和<code>ostream</code></h5><p>在 C++ 中，<strong>流类（如 <code>std::istream</code> 和 <code>std::ostream</code>）是处理输入输出操作的核心类</strong>，它们为程序提供了与数据流进行交互的功能。这些类是 C++ 标准库的一部分，用于简化与文件、控制台、字符串等设备的交互。</p><p><img src="/posts/Above-All/on-to-OOP/iostream.png" alt="iostream"></p><ol><li><strong><code>std::istream</code> 类</strong></li></ol><p><code>std::istream</code> 类是用于处理输入操作的类，提供了从输入流中读取数据的功能。它是所有输入流类（如 <code>cin</code>）的基类。</p><ul><li><strong>构造函数</strong>：<code>std::istream</code> 的构造函数可以用来打开文件或初始化输入流。</li><li>成员函数<ul><li><code>operator&gt;&gt;</code>：流提取运算符，用于从流中提取数据。</li><li><code>get()</code>：用于读取一个字符或一行数据。</li><li><code>read()</code>：从流中读取特定数量的字符。</li><li><code>eof()</code>：检查是否到达文件结束标志。</li><li><code>fail()</code>：检查流是否进入失败状态。</li></ul></li></ul><ol start="2"><li><strong><code>std::ostream</code> 类</strong></li></ol><p><code>std::ostream</code> 类是用于处理输出操作的类，提供了将数据写入输出流的功能。它是所有输出流类（如 <code>cout</code>）的基类。</p><ul><li><p><strong>构造函数</strong>：<code>std::ostream</code> 的构造函数用于打开输出流或初始化输出流。</p></li><li><p>成员函数</p><ul><li><code>operator&lt;&lt;</code>：流插入运算符，用于将数据插入到流中。</li><li><code>put()</code>：用于向流中写入一个字符。</li><li><code>write()</code>：用于向流中写入特定数量的字符。</li><li><code>flush()</code>：强制输出缓冲区内容，确保数据立即写入流。</li><li><code>endl</code>：插入一个换行符并刷新输出流。</li></ul></li></ul><ol start="3"><li><strong>继承结构</strong></li></ol><p><code>std::istream</code> 和 <code>std::ostream</code> 类本身都继承自 <code>std::ios</code> 类，它们共享一些基本的输入输出功能。<code>std::ios</code> 类提供了管理流状态的功能，比如检查是否处于错误状态、是否已到达文件末尾等。</p><ul><li><strong><code>std::ios</code> 类</strong>：<code>std::ios</code> 是 <code>std::istream</code> 和 <code>std::ostream</code> 的基类，负责流的基本状态管理（如错误标志、格式控制等）。<ul><li><code>std::ios::good()</code>: 检查流是否处于良好状态。</li><li><code>std::ios::eof()</code>: 检查流是否到达文件末尾。</li><li><code>std::ios::fail()</code>: 检查流是否处于失败状态。</li></ul></li></ul><ol start="4"><li><strong>常见的派生类</strong></li></ol><ul><li>**<code>std::ifstream</code>**：<code>std::ifstream</code> 是 <code>std::istream</code> 的派生类，用于处理文件输入。它提供了从文件读取数据的功能。</li><li>**<code>std::ofstream</code>**：<code>std::ofstream</code> 是 <code>std::ostream</code> 的派生类，用于处理文件输出。它提供了将数据写入文件的功能。</li><li>**<code>std::stringstream</code>**：<code>std::stringstream</code> 是 <code>std::istream</code> 和 <code>std::ostream</code> 的派生类，允许在内存中处理字符串流。它既可以用于输入也可以用于输出。</li></ul><h5 id="cin和cout"><a href="#cin和cout" class="headerlink" title="cin和cout"></a><code>cin</code>和<code>cout</code></h5><p><code>cin</code> 和 <code>cout</code> 是 C++ 标准库中<strong>预定义的输入和输出流对象</strong>，它们是由流类（如 <code>istream</code> 和 <code>ostream</code>）创建的全局对象，用于进行数据的输入和输出。</p><ul><li><strong><code>cin</code>（标准输入流对象）</strong>：<code>cin</code> 是一个全局的输入流对象，属于 <code>std::istream</code> 类，通常用于从标准输入（如键盘）获取数据。</li><li><strong><code>cout</code>（标准输出流对象）</strong>：<code>cout</code> 是一个全局的输出流对象，属于 <code>std::ostream</code> 类，通常用于将数据输出到标准输出（如显示器）。</li></ul><div class="note note-danger">            <p><strong>是的，cin&#x2F;cout根本不是函数，而是对象！！！</strong></p>          </div><h5 id="运算符"><a href="#运算符" class="headerlink" title="&lt;&lt;和&gt;&gt;运算符"></a><code>&lt;&lt;</code>和<code>&gt;&gt;</code>运算符</h5><p>这些运算符实际上是被重载的，它们不是内置运算符，而是通过重载来定义流操作的行为。</p><ul><li>**流插入运算符 <code>&lt;&lt;</code>**：被 <code>std::ostream</code> 类重载，用于将数据插入到输出流中。当你写 <code>cout &lt;&lt; x;</code> 时，实际上是调用了 <code>std::ostream</code> 类的 <code>operator&lt;&lt;</code> 函数。</li><li>**流提取运算符 <code>&gt;&gt;</code>**：被 <code>std::istream</code> 类重载，用于从输入流中提取数据。当你写 <code>cin &gt;&gt; x;</code> 时，实际上是调用了 <code>std::istream</code> 类的 <code>operator&gt;&gt;</code> 函数。</li></ul><p>流插入运算符&lt;&lt;是一个二元运算符。例如，表达式 cout &lt;&lt; x 的运算符两侧分别是 cout 和 x， x 是一个整型变量， cout 是输出流类 <code>ostream</code> 的对象。 &lt;&lt;运算符将右边对象的值转换成文本形式插入左边的输出流对象， 执行结果是左边的输出流对象的引用。对于 cout &lt;&lt; x，运算结果为对象 cout。正因为&lt;&lt;运算的结果是左边对象的引用，所以允许执行 <code>cout &lt;&lt; x &lt;&lt; y</code> 等的操作。因为&lt;&lt;是左结合的，所以上述表达式先执行 <code>cout &lt;&lt; x</code>，执行的结果是对象 cout，然后执行 <code>cout &lt;&lt; y</code>。</p><h4 id="在自定义类中重载运算符"><a href="#在自定义类中重载运算符" class="headerlink" title="在自定义类中重载&lt;&lt;和&gt;&gt;运算符"></a>在自定义类中重载<code>&lt;&lt;</code>和<code>&gt;&gt;</code>运算符</h4><p>由于第一个参数是<code>ostream/istream</code> 类的对象，因此<strong>流插入运算符不能重载成成员函数，必须重载成全局函数，流输出运算符也是如此</strong>。</p><p>为什么？在 C++ 中，<strong>成员函数的第一个参数通常是隐式的 <code>this</code> 指针</strong>，指向当前对象。因此，成员函数可以通过 <code>this</code> 指针访问对象的成员变量和其他成员函数。也就是说，只有运算符的第一个参数是可以被<strong>this指针指向的，才能够被定义为类内的成员函数</strong>，否则必须被<strong>定义为友元函数</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> x, y;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 构造函数</span><br>    <span class="hljs-built_in">Point</span>(<span class="hljs-type">int</span> x = <span class="hljs-number">0</span>, <span class="hljs-type">int</span> y = <span class="hljs-number">0</span>) : <span class="hljs-built_in">x</span>(x), <span class="hljs-built_in">y</span>(y) &#123;&#125;<br><br>    <span class="hljs-comment">// 重载 &lt;&lt; 运算符</span><br>    <span class="hljs-keyword">friend</span> ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; os, <span class="hljs-type">const</span> Point&amp; p);<br>    <span class="hljs-comment">//参数中第一个对象是ostream类的对象（相当于cout）</span><br>&#125;;<br><br><span class="hljs-comment">// 重载 &lt;&lt; 运算符</span><br>ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; os, <span class="hljs-type">const</span> Point&amp; p) &#123;<br>    os &lt;&lt; <span class="hljs-string">&quot;(&quot;</span> &lt;&lt; p.x &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; p.y &lt;&lt; <span class="hljs-string">&quot;)&quot;</span>;<br>    <span class="hljs-keyword">return</span> os;  <span class="hljs-comment">// 返回 ostream 引用，以便链式调用</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">Point <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)</span></span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Point: &quot;</span> &lt;&lt; p &lt;&lt; endl;  <span class="hljs-comment">// 调用重载的 &lt;&lt; 运算符</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> x, y;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 构造函数</span><br>    <span class="hljs-built_in">Point</span>(<span class="hljs-type">int</span> x = <span class="hljs-number">0</span>, <span class="hljs-type">int</span> y = <span class="hljs-number">0</span>) : <span class="hljs-built_in">x</span>(x), <span class="hljs-built_in">y</span>(y) &#123;&#125;<br><br>    <span class="hljs-comment">// 重载 &gt;&gt; 运算符</span><br>    <span class="hljs-keyword">friend</span> istream&amp; <span class="hljs-keyword">operator</span>&gt;&gt;(istream&amp; is, Point&amp; p);<br>    <span class="hljs-comment">//参数中第一个对象是istream类的对象（相当于cin）</span><br>&#125;;<br><br><span class="hljs-comment">// 重载 &gt;&gt; 运算符</span><br>istream&amp; <span class="hljs-keyword">operator</span>&gt;&gt;(istream&amp; is, Point&amp; p) &#123;<br>    is &gt;&gt; p.x &gt;&gt; p.y;  <span class="hljs-comment">// 从输入流中读取数据到成员变量</span><br>    <span class="hljs-keyword">return</span> is;  <span class="hljs-comment">// 返回 istream 引用，以便链式调用</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">Point <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)</span></span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Enter coordinates for the point (x y): &quot;</span>;<br>    cin &gt;&gt; p;  <span class="hljs-comment">// 调用重载的 &gt;&gt; 运算符</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;You entered point: &quot;</span> &lt;&lt; p &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>相关注意点：</strong></p><ul><li>注意返回类型是对<code>istream</code>或<code>ostream</code>的引用。</li></ul><h2 id="矢量类的实现"><a href="#矢量类的实现" class="headerlink" title="矢量类的实现"></a>矢量类的实现</h2><p>在下文给出了<strong>矢量类vector</strong>的实现（不是STL的那个vector）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// vect.h -- Vector class with &lt;&lt;, mode state</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> VECTOR_H_</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> VECTOR_H_</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">namespace</span> VECTOR<br>&#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Vector</span><br>    &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Mode</span> &#123;RECT, POL&#125;;<br>    <span class="hljs-comment">// RECT for rectangular, POL for Polar modes</span><br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-type">double</span> x;          <span class="hljs-comment">// horizontal value</span><br>        <span class="hljs-type">double</span> y;          <span class="hljs-comment">// vertical value</span><br>        <span class="hljs-type">double</span> mag;        <span class="hljs-comment">// length of vector</span><br>        <span class="hljs-type">double</span> ang;        <span class="hljs-comment">// direction of vector in degrees</span><br>        Mode mode;         <span class="hljs-comment">// RECT or POL</span><br>        <span class="hljs-comment">//状态成员</span><br>    <span class="hljs-comment">// private methods for setting values</span><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set_mag</span><span class="hljs-params">()</span></span>;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set_ang</span><span class="hljs-params">()</span></span>;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set_x</span><span class="hljs-params">()</span></span>;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set_y</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">Vector</span>();<br>        <span class="hljs-built_in">Vector</span>(<span class="hljs-type">double</span> n1, <span class="hljs-type">double</span> n2, Mode form = RECT);<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reset</span><span class="hljs-params">(<span class="hljs-type">double</span> n1, <span class="hljs-type">double</span> n2, Mode form = RECT)</span></span>;<br>        ~<span class="hljs-built_in">Vector</span>();<br>        <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">xval</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<span class="hljs-keyword">return</span> x;&#125;       <span class="hljs-comment">// report x value</span><br>        <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">yval</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<span class="hljs-keyword">return</span> y;&#125;       <span class="hljs-comment">// report y value</span><br>        <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">magval</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<span class="hljs-keyword">return</span> mag;&#125;   <span class="hljs-comment">// report magnitude</span><br>        <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">angval</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<span class="hljs-keyword">return</span> ang;&#125;   <span class="hljs-comment">// report angle</span><br>        <span class="hljs-comment">//这四个报告函数是内联函数</span><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">polar_mode</span><span class="hljs-params">()</span></span>;                    <span class="hljs-comment">// set mode to POL</span><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rect_mode</span><span class="hljs-params">()</span></span>;                     <span class="hljs-comment">// set mode to RECT</span><br>    <span class="hljs-comment">// operator overloading</span><br>        Vector <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Vector &amp; b) <span class="hljs-type">const</span>;<br>        Vector <span class="hljs-keyword">operator</span>-(<span class="hljs-type">const</span> Vector &amp; b) <span class="hljs-type">const</span>;<br>        Vector <span class="hljs-keyword">operator</span>-() <span class="hljs-type">const</span>;<br>        Vector <span class="hljs-keyword">operator</span>*(<span class="hljs-type">double</span> n) <span class="hljs-type">const</span>;<br>    <span class="hljs-comment">// friends</span><br>        <span class="hljs-keyword">friend</span> Vector <span class="hljs-keyword">operator</span>*(<span class="hljs-type">double</span> n, <span class="hljs-type">const</span> Vector &amp; a);<br>        <span class="hljs-keyword">friend</span> std::ostream &amp; <span class="hljs-keyword">operator</span>&lt;&lt;(std::ostream &amp; os, <span class="hljs-type">const</span> Vector &amp; v);<br>    &#125;;<br><br>&#125;   <span class="hljs-comment">// end namespace VECTOR</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// vect.cpp -- methods for the Vector class</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;vect.h&quot;</span>   <span class="hljs-comment">// includes &lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> std::sqrt;<br><span class="hljs-keyword">using</span> std::sin;<br><span class="hljs-keyword">using</span> std::cos;<br><span class="hljs-keyword">using</span> std::atan;<br><span class="hljs-keyword">using</span> std::atan2;<br><span class="hljs-keyword">using</span> std::cout;<br><br><span class="hljs-keyword">namespace</span> VECTOR<br>&#123;<br>    <span class="hljs-comment">// compute degrees in one radian</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">double</span> Rad_to_deg = <span class="hljs-number">45.0</span> / <span class="hljs-built_in">atan</span>(<span class="hljs-number">1.0</span>);<br>    <span class="hljs-comment">// should be about 57.2957795130823</span><br><br>    <span class="hljs-comment">// private methods</span><br>    <span class="hljs-comment">// calculates magnitude from x and y</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Vector::set_mag</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        mag = <span class="hljs-built_in">sqrt</span>(x * x + y * y);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Vector::set_ang</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (x == <span class="hljs-number">0.0</span> &amp;&amp; y == <span class="hljs-number">0.0</span>)<br>            ang = <span class="hljs-number">0.0</span>;<br>        <span class="hljs-keyword">else</span><br>            ang = <span class="hljs-built_in">atan2</span>(y, x);<br>    &#125;<br><br>    <span class="hljs-comment">// set x from polar coordinate</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Vector::set_x</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        x = mag * <span class="hljs-built_in">cos</span>(ang);<br>    &#125;<br><br>    <span class="hljs-comment">// set y from polar coordinate</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Vector::set_y</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        y = mag * <span class="hljs-built_in">sin</span>(ang);<br>    &#125;<br><br>    <span class="hljs-comment">// public methods</span><br>    Vector::<span class="hljs-built_in">Vector</span>()             <span class="hljs-comment">// default constructor</span><br>    &#123;<br>        x = y = mag = ang = <span class="hljs-number">0.0</span>;<br>        mode = RECT;<br>    &#125;<br><br>    <span class="hljs-comment">// construct vector from rectangular coordinates if form is r</span><br>    <span class="hljs-comment">// (the default) or else from polar coordinates if form is p</span><br>    Vector::<span class="hljs-built_in">Vector</span>(<span class="hljs-type">double</span> n1, <span class="hljs-type">double</span> n2, Mode form)<br>    &#123;<br>        mode = form;<br>        <span class="hljs-keyword">if</span> (form == RECT)<br>         &#123;<br>             x = n1;<br>             y = n2;<br>             <span class="hljs-built_in">set_mag</span>();<br>             <span class="hljs-built_in">set_ang</span>();<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (form == POL)<br>        &#123;<br>             mag = n1;<br>             ang = n2 / Rad_to_deg;<br>             <span class="hljs-built_in">set_x</span>();<br>             <span class="hljs-built_in">set_y</span>();<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>             cout &lt;&lt; <span class="hljs-string">&quot;Incorrect 3rd argument to Vector() -- &quot;</span>;<br>             cout &lt;&lt; <span class="hljs-string">&quot;vector set to 0\n&quot;</span>;<br>             x = y = mag = ang = <span class="hljs-number">0.0</span>;<br>             mode = RECT;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// reset vector from rectangular coordinates if form is</span><br>    <span class="hljs-comment">// RECT (the default) or else from polar coordinates if</span><br>    <span class="hljs-comment">// form is POL</span><br>    <span class="hljs-type">void</span> Vector:: <span class="hljs-built_in">reset</span>(<span class="hljs-type">double</span> n1, <span class="hljs-type">double</span> n2, Mode form)<br>    &#123;<br>        mode = form;<br>        <span class="hljs-keyword">if</span> (form == RECT)<br>         &#123;<br>             x = n1;<br>             y = n2;<br>             <span class="hljs-built_in">set_mag</span>();<br>             <span class="hljs-built_in">set_ang</span>();<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (form == POL)<br>        &#123;<br>             mag = n1;<br>             ang = n2 / Rad_to_deg;<br>             <span class="hljs-built_in">set_x</span>();<br>             <span class="hljs-built_in">set_y</span>();<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>             cout &lt;&lt; <span class="hljs-string">&quot;Incorrect 3rd argument to Vector() -- &quot;</span>;<br>             cout &lt;&lt; <span class="hljs-string">&quot;vector set to 0\n&quot;</span>;<br>             x = y = mag = ang = <span class="hljs-number">0.0</span>;<br>             mode = RECT;<br>        &#125;<br>    &#125;<br><br>    Vector::~<span class="hljs-built_in">Vector</span>()    <span class="hljs-comment">// destructor</span><br>    &#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Vector::polar_mode</span><span class="hljs-params">()</span>    <span class="hljs-comment">// set to polar mode</span></span><br><span class="hljs-function">    </span>&#123;<br>        mode = POL;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Vector::rect_mode</span><span class="hljs-params">()</span>     <span class="hljs-comment">// set to rectangular mode</span></span><br><span class="hljs-function">    </span>&#123;<br>        mode = RECT;<br>    &#125;<br><br>    <span class="hljs-comment">// operator overloading</span><br>    <span class="hljs-comment">// add two Vectors</span><br>    Vector Vector::<span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Vector &amp; b) <span class="hljs-type">const</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Vector</span>(x + b.x, y + b.y);<br>    &#125;<br><br>    <span class="hljs-comment">// subtract Vector b from a</span><br>    Vector Vector::<span class="hljs-keyword">operator</span>-(<span class="hljs-type">const</span> Vector &amp; b) <span class="hljs-type">const</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Vector</span>(x - b.x, y - b.y);<br>    &#125;<br><br>    <span class="hljs-comment">// reverse sign of Vector</span><br>    Vector Vector::<span class="hljs-keyword">operator</span>-() <span class="hljs-type">const</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Vector</span>(-x, -y);<br>    &#125;<br><br>    <span class="hljs-comment">// multiply vector by n</span><br>    Vector Vector::<span class="hljs-keyword">operator</span>*(<span class="hljs-type">double</span> n) <span class="hljs-type">const</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Vector</span>(n * x, n * y);<br>    &#125;<br><br>    <span class="hljs-comment">// friend methods</span><br>    <span class="hljs-comment">// multiply n by Vector a</span><br>    Vector <span class="hljs-keyword">operator</span>*(<span class="hljs-type">double</span> n, <span class="hljs-type">const</span> Vector &amp; a)<br>    &#123;<br>        <span class="hljs-keyword">return</span> a * n;<br>    &#125;<br><br>    <span class="hljs-comment">// display rectangular coordinates if mode is RECT,</span><br>    <span class="hljs-comment">// else display polar coordinates if mode is POL</span><br>    std::ostream &amp; <span class="hljs-keyword">operator</span>&lt;&lt;(std::ostream &amp; os, <span class="hljs-type">const</span> Vector &amp; v)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (v.mode == Vector::RECT)<br>             os &lt;&lt; <span class="hljs-string">&quot;(x,y) = (&quot;</span> &lt;&lt; v.x &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; v.y &lt;&lt; <span class="hljs-string">&quot;)&quot;</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (v.mode == Vector::POL)<br>        &#123;<br>             os &lt;&lt; <span class="hljs-string">&quot;(m,a) = (&quot;</span> &lt;&lt; v.mag &lt;&lt; <span class="hljs-string">&quot;, &quot;</span><br>                 &lt;&lt; v.ang * Rad_to_deg &lt;&lt; <span class="hljs-string">&quot;)&quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>             os &lt;&lt; <span class="hljs-string">&quot;Vector object mode is invalid&quot;</span>;<br>        <span class="hljs-keyword">return</span> os; <br>    &#125;<br><br>&#125;  <span class="hljs-comment">// end namespace VECTOR</span><br><br></code></pre></td></tr></table></figure><h2 id="类的自动转换和强制类型转换"><a href="#类的自动转换和强制类型转换" class="headerlink" title="类的自动转换和强制类型转换"></a>类的自动转换和强制类型转换</h2><p>对于基本数据类型：使用自动转换和强制类型转换。</p><h3 id="类的自动类型转换"><a href="#类的自动类型转换" class="headerlink" title="类的自动类型转换"></a>类的自动类型转换</h3><p>类之间的自动类型转换通常通过 <strong>构造函数</strong> 或 <strong>转换运算符</strong> 来实现。这种转换在 C++ 中是自动发生的，当目标类型的构造函数或转换运算符能接收源类型时，编译器会自动进行转换。</p><p>例如，如果一个类具有一个接受 <code>int</code> 类型的构造函数或转换运算符，当你尝试将 <code>int</code> 类型的对象赋值给该类的对象时，编译器会自动调用该构造函数或转换运算符。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> value;<br><br>    <span class="hljs-comment">// 构造函数，可以从 int 转换为 MyClass</span><br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">int</span> val) : <span class="hljs-built_in">value</span>(val) &#123;&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    MyClass obj = <span class="hljs-number">10</span>;  <span class="hljs-comment">// 自动调用 MyClass(int) 构造函数</span><br>    cout &lt;&lt; obj.value &lt;&lt; endl;  <span class="hljs-comment">// 输出 10</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的代码中，<code>int</code> 被自动转换为 <code>MyClass</code> 对象，这依赖于 <code>MyClass</code> 的构造函数。</p><ul><li><p><strong>可以将类定义成基本类型或与另一个类相关，使得从一种类型强制转换到另一种类型是有意义的</strong></p><ul><li>例：利用构造函数（但只有一个参数，其余均默认）</li></ul></li><li><p>类的隐式转换</p><ul><li>int可以先转换成double类型，再被转换成自定义的类（可能会带来安全隐患）：<strong>二步转换</strong>（<strong>无二义性</strong>）</li></ul></li><li><p>使用<code>exlpicit</code>关键词可以关闭自动转换（只允许显示转换）</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Stonewt</span><span class="hljs-params">(<span class="hljs-type">double</span> lbs)</span></span><br></code></pre></td></tr></table></figure><p><img src="/posts/Above-All/on-to-OOP/explicit.png" alt="explicit"></p><ul><li><p>转换函数：将类转换为基本的数据类型</p><ul><li><p>声明：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">typeName</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">int</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">double</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure></li><li><p>定义</p></li></ul><p><img src="/posts/Above-All/on-to-OOP/definition.png" alt="definition"></p><ul><li>优化：进行显示转换</li></ul><p><img src="/posts/Above-All/on-to-OOP/modification.png" alt="modification"></p><ul><li><strong>警告：使用过多的转换函数可能会导致二义性冲突</strong>。</li></ul></li></ul><div class="note note-info">            <h3 id="补充知识：五种强制类型转换"><a href="#补充知识：五种强制类型转换" class="headerlink" title="补充知识：五种强制类型转换"></a>补充知识：五种强制类型转换</h3><p>在 C++ 中，强制类型转换（也称为显式类型转换）允许程序员显式地转换一种类型到另一种类型。强制类型转换提供了比自动类型转换更大的灵活性，但也带来一定的风险，因为不当的转换可能会导致程序出错或行为未定义。</p><p>C++ 提供了 <strong>四种类型转换操作符</strong>，它们比传统的 C 风格转换更具类型安全性和可维护性。具体来说，C++ 强制类型转换包括：</p><ol><li><strong>C 风格类型转换</strong>（<code>(type)expression</code>）</li><li><strong><code>static_cast</code></strong></li><li><strong><code>dynamic_cast</code></strong></li><li><strong><code>const_cast</code></strong></li><li><strong><code>reinterpret_cast</code></strong></li></ol><p>下面分别介绍这五种类型转换方式。</p><h4 id="1-C-风格类型转换（C-style-Cast）"><a href="#1-C-风格类型转换（C-style-Cast）" class="headerlink" title="1. C 风格类型转换（C-style Cast）"></a>1. <strong>C 风格类型转换（C-style Cast）</strong></h4><p><strong>语法</strong>：<code>(new_type)expression</code></p><p>这是最基本、最传统的类型转换方式，类似于 C 语言中的类型转换方式。它可以进行大多数类型转换，包括基本类型之间的转换和类类型之间的转换。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">double</span> b = (<span class="hljs-type">double</span>)a;  <span class="hljs-comment">// 强制将 int 转换为 double</span><br>std::cout &lt;&lt; b &lt;&lt; std::endl;  <span class="hljs-comment">// 输出 10.0</span><br></code></pre></td></tr></table></figure><ul><li><strong>优点</strong>：语法简单，易于使用。</li><li><strong>缺点</strong>：没有类型安全检查，不容易发现错误。由于它能进行多种转换（例如基本类型转换、类类型转换等），可能会导致意外的转换行为。</li></ul><hr><h4 id="2-static-cast"><a href="#2-static-cast" class="headerlink" title="2. static_cast"></a>2. <strong><code>static_cast</code></strong></h4><p><strong>语法</strong>：<code>static_cast&lt;new_type&gt;(expression)</code></p><p><code>static_cast</code> 是 C++ 提供的一种类型安全的强制类型转换方式。它通常用于：</p><ul><li>基本类型之间的转换。</li><li><strong>类层次结构中，向上或向下转换（在没有多态的情况下）</strong>；</li><li>其他兼容类型之间的转换。</li></ul><p><code>static_cast</code> 是 <strong>类型安全的</strong>，它会在编译时检查类型是否兼容，因此可以避免一些常见的转换错误。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">double</span> a = <span class="hljs-number">3.14</span>;<br><span class="hljs-type">int</span> b = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(a);  <span class="hljs-comment">// 强制将 double 转换为 int</span><br>std::cout &lt;&lt; b &lt;&lt; std::endl;  <span class="hljs-comment">// 输出 3</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Base&quot;</span> &lt;&lt; std::endl; &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Derived&quot;</span> &lt;&lt; std::endl; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Base* basePtr = <span class="hljs-keyword">new</span> Derived;<br>    Derived* derivedPtr = <span class="hljs-built_in">static_cast</span>&lt;Derived*&gt;(basePtr);  <span class="hljs-comment">// 向下转型</span><br>    derivedPtr-&gt;<span class="hljs-built_in">show</span>();  <span class="hljs-comment">// 输出 &quot;Derived&quot;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>优点</strong>：类型检查在编译时完成，能确保类型兼容性。</li><li><strong>缺点</strong>：如果转换不合理，<code>static_cast</code> 会导致编译错误。</li></ul><hr><h4 id="3-dynamic-cast"><a href="#3-dynamic-cast" class="headerlink" title="3. dynamic_cast"></a>3. <strong><code>dynamic_cast</code></strong></h4><p><strong>语法</strong>：<code>dynamic_cast&lt;new_type&gt;(expression)</code></p><p><code>dynamic_cast</code> 用于<strong>处理类类型的转换，尤其是在类之间存在继承关系时</strong>。它通常用于：</p><ul><li>向下转型（从基类指针或引用转换为派生类指针或引用）。</li><li>进行 <strong>RTTI（运行时类型识别）</strong> 检查，用于多态类（具有虚函数的类）之间的转换。</li><li>对于指针或引用，<code>dynamic_cast</code> 会在运行时检查类型是否安全，如果类型不兼容，则会返回 <code>nullptr</code>（对于指针）或抛出 <code>std::bad_cast</code> 异常（对于引用）。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Base&quot;</span> &lt;&lt; std::endl; &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Derived&quot;</span> &lt;&lt; std::endl; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Base* basePtr = <span class="hljs-keyword">new</span> Derived;<br>    Derived* derivedPtr = <span class="hljs-built_in">dynamic_cast</span>&lt;Derived*&gt;(basePtr);  <span class="hljs-comment">// 向下转型</span><br>    <span class="hljs-keyword">if</span> (derivedPtr) &#123;<br>        derivedPtr-&gt;<span class="hljs-built_in">show</span>();  <span class="hljs-comment">// 输出 &quot;Derived&quot;</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Conversion failed&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于不安全的转换，<code>dynamic_cast</code> 会返回 <code>nullptr</code>（指针转换）或抛出异常（引用转换）。</p><ul><li><strong>优点</strong>：提供了运行时类型检查，避免不安全的类型转换。</li><li><strong>缺点</strong>：只能用于类类型（具有虚函数的类），并且运行时有一定的性能开销。</li></ul><hr><h4 id="4-const-cast"><a href="#4-const-cast" class="headerlink" title="4. const_cast"></a>4. <strong><code>const_cast</code></strong></h4><p><strong>语法</strong>：<code>const_cast&lt;new_type&gt;(expression)</code></p><p><code>const_cast</code> 用于添加或移除对象的 <strong>const</strong> 属性。它允许程序修改一个原本是 <code>const</code> 的对象，或者从 <code>const</code> 类型的指针&#x2F;引用获取非 <code>const</code> 类型的指针&#x2F;引用。</p><ul><li>移除 <code>const</code> 属性：通常用于修改本来是常量的对象，或者修改 <code>const</code> 指针所指向的内容。</li><li>添加 <code>const</code> 属性：较少使用，通常用于将非 <code>const</code> 对象传递给接受 <code>const</code> 类型参数的函数。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span>* p = <span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">int</span>*&gt;(&amp;a);  <span class="hljs-comment">// 移除 const 属性</span><br>*p = <span class="hljs-number">20</span>;  <span class="hljs-comment">// 修改常量对象的值</span><br>std::cout &lt;&lt; a &lt;&lt; std::endl;  <span class="hljs-comment">// 输出 20</span><br></code></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：这种转换非常危险，因为它绕过了 <code>const</code> 修饰符的保护，可能会导致未定义行为。如果原对象是 <code>const</code>，通过 <code>const_cast</code> 进行修改是不合法的。</p></blockquote><ul><li><strong>优点</strong>：可以显式地修改 <code>const</code> 对象的 <code>const</code> 属性，满足特殊需求。</li><li><strong>缺点</strong>：滥用 <code>const_cast</code> 可能会破坏程序的 <strong>const-correctness</strong>，导致潜在的 bug 和未定义行为。</li></ul><hr><h4 id="5-reinterpret-cast"><a href="#5-reinterpret-cast" class="headerlink" title="5. reinterpret_cast"></a>5. <strong><code>reinterpret_cast</code></strong></h4><p><strong>语法</strong>：<code>reinterpret_cast&lt;new_type&gt;(expression)</code></p><p><code>reinterpret_cast</code> 用于极低级别的转换，它允许程序员强制转换几乎任何类型到任何其他类型，甚至是完全不相关的类型。它是最强大的类型转换方式，但也最危险，因为它可能破坏内存布局并导致未定义行为。</p><ul><li>常用于指针类型的转换。</li><li>对于完全不相关的类型，<code>reinterpret_cast</code> 可能会导致程序崩溃。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">void</span>* ptr = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">void</span>*&gt;(&amp;a);  <span class="hljs-comment">// 将 int* 转换为 void*</span><br>std::cout &lt;&lt; *<span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">int</span>*&gt;(ptr) &lt;&lt; std::endl;  <span class="hljs-comment">// 输出 10</span><br></code></pre></td></tr></table></figure><ul><li><strong>优点</strong>：极其灵活，能够在底层进行类型转换，适用于底层操作和与硬件、操作系统接口的交互。</li><li><strong>缺点</strong>：几乎没有类型安全保障，可能导致程序崩溃，或者出现未定义行为，使用时要非常小心。</li></ul><hr><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h4><p>C++ 提供了五种类型转换方式，各自有其特定的使用场景和优缺点：</p><ol><li><strong>C 风格类型转换</strong>：简单但缺乏类型安全，适合快速开发，但不推荐用于复杂的程序中。</li><li>**<code>static_cast</code>**：类型安全，适用于基本类型和兼容类型的转换，是常见的类型转换方式。</li><li>**<code>dynamic_cast</code>**：主要用于类类型转换，并进行运行时类型检查，确保安全，适合多态类型。</li><li>**<code>const_cast</code>**：用于移除或添加 <code>const</code> 属性，通常在需要修改 <code>const</code> 对象时使用，但要小心避免滥用。</li><li>**<code>reinterpret_cast</code>**：低级别的转换，允许对几乎所有类型进行转换，但极其危险，应该谨慎使用。</li></ol><p>在实际开发中，尽量避免过度使用强制类型转换，特别是 <code>reinterpret_cast</code> 和 <code>const_cast</code>，它们可能破坏类型安全。更推荐使用 <code>static_cast</code> 和 <code>dynamic_cast</code>，它们提供了更好的类型安全性和可维护性。</p>          </div><h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>终于结束啦！本章主要聚焦在类和对象的使用上，在下一篇博客中，我们将会将重点转移到一个令人又爱又恨的东西上：<strong>动态内存分配</strong>！</p>]]></content>
    
    
    <categories>
      
      <category>Code</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tutorial</tag>
      
      <tag>C/C++</tag>
      
      <tag>OOP</tag>
      
      <tag>C++ Primer Plus</tag>
      
      <tag>Finished</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C-plus-plus-Primer-Plus-tutorial</title>
    <link href="/posts/C-plus-plus-Primer-Plus-tutorial/"/>
    <url>/posts/C-plus-plus-Primer-Plus-tutorial/</url>
    
    <content type="html"><![CDATA[<h1 id="C-Primer-Plus-tutorial"><a href="#C-Primer-Plus-tutorial" class="headerlink" title="C++ Primer Plus tutorial"></a>C++ Primer Plus tutorial</h1><h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>笔者又来开新坑啦！</p><p>之前看到一个很讽刺的笑话：<strong>大多数国内高校学生学到的C++只是C语言+cin&#x2F;cout</strong>。这当然只是一句玩笑话，但很深刻地反映出对于C++精髓<strong>面向对象编程</strong>的忽视。</p><p>这是有理可依的：<strong>编程语言的学习本身就和传统的课堂授课模式存在较大的出入</strong>，编程重视实践，枯燥的语法讲解如同天书一般晦涩难懂，更不用提OOP所涉及的都是比较大规模的项目工程，如果只是在课堂上乏味地讲解“什么是析构函数，什么是继承，什么是多态···”，很容易将C++学成死记硬背的无聊学科。</p><p>因此，笔者在课堂学习之余，<strong>同步学习了世界经典C++教材——《C++ Primer Plus》的相关内容</strong>。经典不愧为经典！</p><p>但是，针对我个人而言，我认为C++ Primer Plus有以下问题：（其实也不算是问题啦，就是和普通在校大学生存在一些“冲突”）</p><ul><li>一共678页，并且全是密密麻麻的字，阅读周期长，读完需要很大的意志力（对于自学者）。</li><li>由于翻译等种种的原因，在很多地方的解释并不清晰（作为一本C++的入门书籍体量有些大了，而且涉及到很多专业的名词，看得让人头大）</li></ul><p>因此，笔者希望通过博客的方式，记录自己的C++ Primer Plus学习笔记，并上传到网络上供一同学习的小伙伴参考。</p><p>博客立志于：</p><ul><li>记录自己的C++学习过程</li><li>对本人认为的C++学习中的一些重难点做一些额外的解释</li><li>尝试用简单清晰的语言梳理逻辑脉络</li></ul><h2 id="更新内容范围"><a href="#更新内容范围" class="headerlink" title="更新内容范围"></a>更新内容范围</h2><ul><li><strong>Chapter10 对象和类</strong></li><li><strong>Chapter11 使用类</strong></li><li><strong>Chapter12 类和动态内存分配</strong></li><li><strong>Chapter13 类继承</strong></li><li><strong>Chapter14 代码重用</strong></li><li><strong>Chapter15 友元，异常和其他</strong></li><li><strong>Chapter16 string类的标准模板库</strong></li></ul><p>（目前更新计划主要分布在OOP的章节，之后的其他章节看情况更新~）</p><h2 id="实际更新的目录"><a href="#实际更新的目录" class="headerlink" title="实际更新的目录"></a>实际更新的目录</h2><p><a href="https://xiyuanyang-code.github.io/tags/OOP/">系列文章</a></p><div class="note note-info">            <h3 id="Introduction-to-OOP"><a href="#Introduction-to-OOP" class="headerlink" title="Introduction to OOP"></a>Introduction to OOP</h3><p>欢迎来到<strong>面向对象编程</strong>的世界！首先文章将会向你介绍在面向对象编程中四个最核心的精神：<strong>封装、继承、多态和抽象</strong>，并对面向对象所涉及的知识做一个总体性的概览。接下来，你将系统学习到什么是<strong>类和对象</strong>，以及如何创建并使用自己的类和对象。文章的内容涵盖<strong>构造函数</strong>的四种定义、<strong>析构函数</strong>的使用、<strong>静态和动态</strong>数据成员以及成员函数、<strong>友元函数</strong>、<strong>const函数</strong>的用法、<strong>this指针</strong>以及类的自动类型转换等知识。</p><p>Welcome to the world of <strong>Object-Oriented Programming (OOP)</strong>! This article will first introduce you to the four core principles of OOP: <strong>Encapsulation, Inheritance, Polymorphism, and Abstraction</strong>, and provide an overview of the knowledge involved in OOP. Next, you will systematically learn what <strong>classes and objects</strong> are, and how to create and use your own classes and objects. The article covers topics such as the four definitions of <strong>constructors</strong>, the use of <strong>destructors</strong>, <strong>static</strong> and <strong>dynamic</strong> data members and member functions, <strong>friend functions</strong>, the usage of const functions, the <strong><code>this</code></strong> pointer, and <strong>automatic type conversion of classes</strong>, among others.</p><p><strong>Key words: OOP, constructors, destructors, this pointer, friend functions</strong></p><h3 id="Dynamic-Memory-and-Class"><a href="#Dynamic-Memory-and-Class" class="headerlink" title="Dynamic Memory and Class"></a>Dynamic Memory and Class</h3><p>本章将重点放在如何对<strong>自定义类和对象</strong>谨慎地使用<strong>动态内存分配</strong>，以及内存管理的相关知识。首先从一个代码示例StringBad讲起，分析因为C++自带的隐式复制构造函数导致<strong>按值传递</strong>和<strong>按址传递</strong>发生冲突而导致程序无法正确输出，并以此为教材介绍了如何<strong>显式</strong>地定义<strong>复制构造函数和赋值运算符</strong>，并给出了修改后的String类的类定义和使用示范。接着，文章聚焦于在类中使用动态内存的易错点，包括new和delete的一一对应问题。最后，文章分析了使用动态内存分配在设计类和对象过程中的应用：<strong>设置合理的返回对象</strong>和<strong>使用指向对象的指针</strong>，同时介绍了动态内存管理的一些高级操作，包括<strong>正确地使用析构函数</strong>和<strong>使用定位new运算符</strong>。</p><p>This chapter focuses on how to <strong>cautiously use dynamic memory allocation with</strong> <strong>custom classes and objects</strong>, along with related knowledge on memory management. It begins with a code example, StringBad, to analyze how the implicit copy constructor provided by C++ leads to conflicts between <strong>pass-by-value</strong> and <strong>pass-by-reference</strong>, resulting in incorrect program output. Using this example as a teaching tool, the chapter introduces how to <strong>explicitly</strong> define <strong>copy constructors and assignment operators</strong>, and provides an updated class definition and usage demonstration for the String class. Next, the article focuses on common pitfalls when using dynamic memory in classes, including the one-to-one correspondence issue between new and delete. Finally, the chapter discusses the application of dynamic memory allocation in the design of classes and objects: <strong>setting appropriate return objects</strong> and <strong>using pointers to objects</strong>, while also introducing some advanced operations in dynamic memory management, such as <strong>correctly using destructors</strong> and <strong>using placement new operator</strong>.</p><p><strong>Key words: OOP, Dynamic Memory, C++, Classes</strong></p><h3 id="Class-Inheritance"><a href="#Class-Inheritance" class="headerlink" title="Class Inheritance"></a>Class Inheritance</h3><p>在本文中，你将学到面向对象编程中的又一个核心思想：<strong>继承与多态</strong>。本文从一个基本的基类讲起并延伸到派生类的定义和基本使用，探讨<strong>派生类和基类的特殊关系</strong>。接下来本文深入继承的原理，介绍在多态公有继承中的<strong>is-a</strong>关系和虚函数，已经动态联编和静态联编的基本知识。接着本文介绍了<strong>抽象基类</strong>的使用以及在派生类中使用<strong>动态内存分配</strong>的注意事项。最后本文对OOP的基本精神——封装、继承与多态和相关基础知识做了梳理。</p><p>In this article, you will learn another core concept in object-oriented programming: <strong>inheritance and polymorphism</strong>. The article begins with a basic base class and extends to the definition and basic usage of derived classes, <strong>exploring the special relationship between derived and base classes</strong>. Next, the article delves into the principles of inheritance, introducing the <strong>is-a</strong> relationship in polymorphic public inheritance, virtual functions, and the basics of dynamic and static binding. Then, the article discusses the use of <strong>abstract base classes</strong> to improve efficiency, as well as considerations for using <strong>dynamic memory allocation in derived classes</strong>. Finally, the article summarizes the fundamental principles of OOP—encapsulation, inheritance, and polymorphism—along with related foundational knowledge.</p><p><strong>Key words: OOP, Class Inheritance, Abstract Base Classes, Polymorphism</strong></p><h3 id="Code-Reuse-in-OOP"><a href="#Code-Reuse-in-OOP" class="headerlink" title="Code Reuse in OOP"></a>Code Reuse in OOP</h3><p>C++的一个主要目标是促进代码重用。公有继承是实现这种目标的机制之一，但并不是唯一的机制。本章将介绍其他方法，其中之一是使用这样的类成员：本身是另一个类的对象。这种方法称为<strong>包含（containment）、组合（composition）或层次化（layering）</strong>。另一种方法是使用私有或保护继承。通常，<strong>包含、私有继承和保护继承</strong>用于实现 <strong>has-a</strong> 关系，即新的类将包含另一个类的对象。多重继承使得能够使用两个或更多的基类派生出新的类，将基类的功能组合在一起。同时，本章将介绍<strong>类模板</strong>——另一种重用代码的方法。类模板使我们能够使用通用术语定义类，然后使用模板来创建针对特定类型定义的特殊类。</p><p>One of the main goals of C++ is to promote code reuse. <strong>Public inheritance</strong> is one of the mechanisms to achieve this goal, but not the only one. This chapter will introduce other methods, one of which is to use class members that are themselves objects of another class. This method is called <strong>containment</strong>, <strong>composition, or layering</strong>. Another method is to use <strong>private or protected inheritance</strong>. Generally, containment, private inheritance, and protected inheritance are used to implement the <strong>has - a relationship</strong>, that is, the new class will contain an object of another class. Multiple inheritance enables new classes to be derived from two or more base classes, combining the functionality of the base classes.At the same time, this chapter will introduce <strong>class templates</strong> - another method of reusing code. Class templates enable us to define classes in general terms and then use the templates to create special classes defined for specific types.</p><p><strong>Key words: Public Inheritance, Containment, class template, composition</strong></p>          </div><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>本博客系列使用的大部分代码都摘自《C++ Primer Plus》。</p>]]></content>
    
    
    <categories>
      
      <category>Code</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Announcement</tag>
      
      <tag>C/C++</tag>
      
      <tag>OOP</tag>
      
      <tag>C++ Primer Plus</tag>
      
      <tag>Finished</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Above-All</title>
    <link href="/posts/Above-All/"/>
    <url>/posts/Above-All/</url>
    
    <content type="html"><![CDATA[<h1 id="Welcome-To-My-Blog"><a href="#Welcome-To-My-Blog" class="headerlink" title="Welcome To My Blog !"></a>Welcome To My Blog !</h1><h2 id="写在前面的话"><a href="#写在前面的话" class="headerlink" title="写在前面的话"></a>写在前面的话</h2><p>这部分的内容和 <a href="https://xiyuanyang-code.github.io/above/">Intro</a> 的部分相同，主要是对本人博客的更新动机，更新目标和更新内容做一个总体性的概览~可自行跳转观看。</p><h2 id="Before-The-Blog"><a href="#Before-The-Blog" class="headerlink" title="Before The Blog"></a>Before The Blog</h2><p>三个月前，我通过偶然的机会了解到前 OpenAI 研究副总裁，主管GPT模型安全的杰出华人女性，<strong>翁荔(Lilian Weng)<strong>。她提出了著名的</strong>Agent 配方：Agent&#x3D;LLM+Memory+planning skills+tool use</strong>。在当今的GPT时代，她可谓是功不可没。</p><p>在OpenAI对她的独家专访<a href="https://openai.com/index/the-power-of-continuous-learning/">The power of continuous learning</a>中，她提到：</p><blockquote><p>I believe in the power of learning and it is never too late to learn. Maintaining my personal blog is a good way to keep this curiosity going and learn about new progress in the deep learning community regularly. I also encourage my team to keep on learning, whether related or unrelated to their current projects. Ideas in different topics or fields can often inspire new ideas and broaden the potential solution space.</p><p>I’m also a strong believer in teamwork. If everyone shines in their best strength, we will get 1+1 &gt; 2. Meanwhile, we might often run into “dirty” work and personally I’m very willing to take on those tasks, because as long as that’s the biggest blocker or that task can add the biggest value into the project, nothing should be considered “dirty” or “trivial.” I encourage people around me to do the same, being a team player and working together to expedite the team productivity.</p><p>我相信学习的力量，学习永远不会太迟。维护个人博客是一个保持好奇心，定期了解深度学习社区新进展的好方法。我也鼓励我的团队不断学习，无论是否与他们当前的项目相关。不同主题或领域的想法常常能激发新的灵感，并拓宽潜在的解决方案空间。</p><p>我也是团队合作的坚定信徒。如果每个人都能在自己最擅长的领域发光，我们就能实现1+1大于2。同时，我们可能会碰到一些“脏活”，而我个人非常愿意承担这些任务，因为只要那是最大的障碍，或者那项任务能为项目带来最大的价值，就没有什么是“脏活”或“琐事”。我鼓励周围的人也这样做，成为团队的一员，共同努力提高团队的生产力。</p></blockquote><p><img src="https://images.ctfassets.net/kftzwdyauwt9/e3357d5a-b177-4b3a-1edf79a7f2dc/ca1f3418cd72b4eb84c9d1a09dfffc7f/stangel-2022-0421.jpg?w=3840&q=90&fm=webp" alt="Lilian Weng&#39;s interview"></p><p>图源：<a href="https://openai.com/index/the-power-of-continuous-learning/">The power of continuous learning | OpenAI</a>   Photo: Jake Stangel</p><blockquote><p>PS：这个姐姐好漂亮~</p></blockquote><p>这与<strong>费曼学习法（Feynman Technique）</strong>可谓是不谋而合：</p><blockquote><p>1.Identify the subject. Write down everything you know about the topic.</p><p>2.Teach it to a child. If you can teach a concept to a child, you’re way ahead of the game.</p><p>3.Identify your knowledge gaps. This is the point where the real learning happens.</p><p>4.Organize + simplify + Tell a story. Start to tell your story.</p></blockquote><p>此时，刚刚步入大学校园3个月的笔者，由于深受高中优绩主义和应试思想的遗风荼毒，对大学生活和计算机学科的学习颇具不适应的疲态。学习的知识如此海量，却无法依靠应试和做题进行巩固，该如何是好？</p><p>或许<strong>上文已经给出了答案。</strong></p><center><p><font size=6><b><p style="color:red;">我要创建自己的博客!</p></b></font></p></center><p>无论是传统的做题刷卷，还是博客，亦或是“费曼学习法”，本质上都是<strong>强化训练人脑在吸收新知识后的有效输出过程</strong>：当你能很流畅地给出一道数学题的若干种证明方法时，能逻辑清晰地将所学的知识穿成逻辑链条或思维导图，呈现在博客中为他人所吸收时，你便通过<strong>有效的对外做功输出</strong>很好地巩固了所学的知识。同时，知识的不断沉淀也带来了莫大的成就感。</p><p>但是，写一篇博客，可不仅仅是打打字那么简单。</p><p>不知各位在高中写议论文的时候有没有一种“咬牙切齿”的感觉，就是<strong>我想到的≠我实际构思好的≠我输出的≠我希望所表达的</strong>，甚至于，很多时候我们心中所谓的灵感只是<strong>乍现的只言片语的碎片</strong>，距离成为一篇逻辑清晰，内容详实且有创新性的博客文章还有很长的路要走。这便是博客写作的难点，也是<strong>我希望通过个人博客来训练的最重要的内容：将心里的灵感进行有效的输出，力求逻辑性和学术的专业性。</strong></p><h2 id="About-the-Blog"><a href="#About-the-Blog" class="headerlink" title="About the Blog"></a>About the Blog</h2><p><strong>Xiyuan Yang’s Blog</strong>，创建于<strong>2024年11月19日</strong>。</p><p>以下是自我简介（摘自<a href="https://xiyuanyang-code.github.io/about/">About - Xiyuan Yang’s Blog</a>）：</p><blockquote><p>Greetings! I am <strong>Xiyuan Yang (杨希渊)</strong>, currently pursuing an undergraduate degree in Artificial Intelligence at Shanghai Jiao Tong University. With a longstanding aspiration to become a programmer, I am passionate about leveraging technology to make a meaningful impact on the world. Through my personal website, I aim to share a collection of my blogs and learning notes with you. Some of these entries will be presented as a series, updated at irregular intervals. Additionally, I will offer insights into my personal observations and reflections on life. I hope your visit here is both enjoyable and enriching!</p></blockquote><blockquote><p><strong>My email:</strong></p><ul><li><p><a href="mailto:xiyuan__yang@outlook.com">xiyuan__yang@outlook.com</a></p></li><li><p><a href="mailto:yangxiyuan@sjtu.edu.cn">yangxiyuan@sjtu.edu.cn</a></p><p>Feel free to contact me!</p></li></ul></blockquote><blockquote><p>VENI VIDI VICI</p></blockquote><p>这个博客的更新内容将随着笔者后续的专业课程的学习同步进行，<strong>旨在分享笔者在学习过程中学到的有意思的专业知识，力求在博客输出的过程中培养自己的逻辑思维和表达能力</strong>，不过更新时间，更新内容，更新篇幅<strong>将会完全随机</strong>。</p><p>本博客部署在github的静态网站上，轮子使用<code>Hexo</code>的<code>Fluid</code>的模版，配置环境还是比较简单的，下面贴出一些相关的网址，有相同爱好的童鞋可以参考借鉴一下：</p><ul><li><a href="https://github.com/xiyuanyang-code">xiyuanyang-code (Xiyuan Yang)我的Github主页</a></li><li><a href="https://github.com/xiyuanyang-code/xiyuanyang-code.github.io">xiyuanyang-code&#x2F;xiyuanyang-code.github.io我的博客Github仓库</a></li><li><a href="https://github.com/fluid-dev/hexo-theme-fluid">fluid-dev&#x2F;hexo-theme-fluid-Design theme for Hexo Fluid的Github官方仓库</a></li><li><a href="https://fluid-dev.github.io/hexo-fluid-docs/guide/">配置指南 | Hexo Fluid 用户手册</a></li><li><a href="https://fluid-dev.github.io/hexo-fluid-docs/start/">开始使用 | Hexo Fluid 用户手册</a></li></ul><p>有关博客的具体更新内容，请详见<code>Goals and Plans of Updates</code>部分~</p><h2 id="Goals-and-Plans-of-Updates"><a href="#Goals-and-Plans-of-Updates" class="headerlink" title="Goals and Plans of Updates"></a>Goals and Plans of Updates</h2><h3 id="更新的主要内容"><a href="#更新的主要内容" class="headerlink" title="更新的主要内容"></a>更新的主要内容</h3><p>笔者更新的主要内容包括：（<strong>草拟</strong>）</p><ul><li>编程语言的语法学习<ul><li>C&#x2F;C++</li><li>Python<ul><li>语法</li><li>Anaconda</li><li>一些常见的库</li></ul></li><li>HTML&#x2F;Javascript</li><li>Bash&#x2F;Shell</li></ul></li><li>一些常用的工具教程<ul><li>LaTeX</li><li>命令行</li><li>Git</li><li>Vim编辑器</li><li>Linux和服务器（主要和深度学习相关）<ul><li>Linux常见命令</li><li>Tmux</li><li>SSH远程连接</li></ul></li></ul></li><li>[CS]算法<ul><li>数据结构</li><li>算法</li><li>计算机四大件</li></ul></li><li>AI专业课<ul><li>机器学习</li><li>强化学习</li><li>深度学习<ul><li>Pytorch</li></ul></li></ul></li><li>AI前沿&amp;经典论文精读</li><li><del>一些晦涩难懂的</del>数学课</li><li>发发牢骚</li></ul><h3 id="具体的分类（实时更新）"><a href="#具体的分类（实时更新）" class="headerlink" title="具体的分类（实时更新）"></a>具体的分类（实时更新）</h3><ul><li><strong>Code</strong></li><li><strong>Math</strong></li><li><strong>Efficient Tools</strong></li><li><strong>Algorithm</strong></li><li><strong>Frontier and Classic Papers in AI</strong></li><li><strong>AI Core Courses</strong></li></ul><h3 id="具体的标签（实时更新）"><a href="#具体的标签（实时更新）" class="headerlink" title="具体的标签（实时更新）"></a>具体的标签（实时更新）</h3><p>见 <a href="https://xiyuanyang-code.github.io/tags/">Tags</a> 页。</p><h2 id="Several-Pages"><a href="#Several-Pages" class="headerlink" title="Several Pages"></a>Several Pages</h2><p>以下是对本博客若干基本页面的介绍：</p><ul><li><h4 id="Home"><a href="#Home" class="headerlink" title="Home"></a>Home</h4></li><li><h4 id="Intro（你现在在的地方）"><a href="#Intro（你现在在的地方）" class="headerlink" title="Intro（你现在在的地方）"></a><strong>Intro</strong>（你现在在的地方）</h4></li><li><h4 id="Archives（文章）"><a href="#Archives（文章）" class="headerlink" title="Archives（文章）"></a>Archives（文章）</h4></li><li><h4 id="Categories（分类页）"><a href="#Categories（分类页）" class="headerlink" title="Categories（分类页）"></a>Categories（分类页）</h4></li><li><h4 id="Tags（标签页）"><a href="#Tags（标签页）" class="headerlink" title="Tags（标签页）"></a>Tags（标签页）</h4></li><li><h4 id="About（关于作者）"><a href="#About（关于作者）" class="headerlink" title="About（关于作者）"></a>About（关于作者）</h4></li><li><h4 id="FAQ（一些常见的问题）"><a href="#FAQ（一些常见的问题）" class="headerlink" title="FAQ（一些常见的问题）"></a>FAQ（一些常见的问题）</h4></li><li><h4 id="Resume（Academic-CV-of-the-Author）"><a href="#Resume（Academic-CV-of-the-Author）" class="headerlink" title="Resume（Academic CV of the Author）"></a>Resume（<strong>Academic CV of the Author</strong>）</h4></li></ul><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p><a href="https://github.com/lilianweng">lilianweng (Lilian)的github主页</a></p><p> <a href="https://lilianweng.github.io/">Lil’Log（翁荔的博客）</a></p><p><a href="https://openai.com/index/the-power-of-continuous-learning/">The power of continuous learning | OpenAI</a></p><p><a href="https://github.com/xiyuanyang-code">https://github.com/xiyuanyang-code</a></p><p><a href="https://github.com/xiyuanyang-code/xiyuanyang-code.github.io">https://github.com/xiyuanyang-code/xiyuanyang-code.github.io</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Announcement</tag>
      
      <tag>Updating</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Algorithm_tutorial_section1</title>
    <link href="/posts/Algorithm-tutorial-section1/"/>
    <url>/posts/Algorithm-tutorial-section1/</url>
    
    <content type="html"><![CDATA[<h1 id="Algorithm-tutorial-section1"><a href="#Algorithm-tutorial-section1" class="headerlink" title="Algorithm_tutorial_section1"></a>Algorithm_tutorial_section1</h1><p>【写在前面的话】</p><p>​本文是笔者自己算法课程的学习笔记，目前的学习内容主要是算法和数据结构基础（提前自学，笔者会在大一下学期系统学习），学习途径和资源主要是 <a href="https://www.hello-algo.com/">Hello 算法</a>（一本非常易入门的算法书！非常推荐！）。因此，<strong>此文章是Algorithm_tutorial的第一篇博客~，且大部分内容来自Hello算法原书，原创部分属于少数，笔者在此处只是按照自己的知识体系进行归纳总结并且尝试记录下来。</strong>希望大家都能愉快地开启自己的算法学习之旅~</p><h1 id="Algorithm-Section1-Introduction"><a href="#Algorithm-Section1-Introduction" class="headerlink" title="Algorithm.Section1 Introduction"></a>Algorithm.Section1 Introduction</h1><p>Introduction：</p><ul><li>迭代与递归</li><li>时间复杂度</li><li>空间复杂度</li><li>数据结构的物理结构</li></ul><h2 id="一、算法-复杂度分析"><a href="#一、算法-复杂度分析" class="headerlink" title="一、算法 复杂度分析"></a>一、算法 复杂度分析</h2><p>​由于实际测试具有较大的局限性，因此我们可以考虑仅通过一些计算来评估算法的效率。这种估算方法被称为渐近复杂度分析（asymptotic complexity analysis），简称复杂度分析。</p><p>​复杂度分析能够体现算法运行所需的时间和空间资源与输入数据大小之间的关系。<strong>它描述了随着输入数据大小的增加，算法执行所需时间和空间的增长趋势</strong>。这个定义有些拗口，我们可以将其分为三个重点来理解。</p><ul><li>“<strong>时间和空间资源</strong>”分别对应时间复杂度（time complexity）和空间复杂度（space complexity）。</li><li>“随着输入数据大小的增加”意味着复杂度反映了算法运行效率与输入数据体量之间的关系。</li><li>“<strong>时间和空间的增长趋势</strong>”表示复杂度分析关注的不是运行时间或占用空间的具体值，而是时间或空间增长的“快慢”。（<strong>一种趋势！</strong>）</li></ul><h3 id="迭代与递归"><a href="#迭代与递归" class="headerlink" title="@迭代与递归"></a>@迭代与递归</h3><p><strong>迭代：自下而上，小问题积累成大问题</strong></p><p><strong>递归：自上而下，大问题拆解成小问题</strong></p><p>程序实现重复代码块执行的两种方式：</p><ul><li><p>迭代（for循环，while循环）</p></li><li><p>递归</p></li></ul><p>​递归（recursion）是一种算法策略，通过函数调用自身来解决问题。它主要包含两个阶段。</p><ol><li><strong>递</strong>：程序不断深入地调用自身，通常传入更小或更简化的参数，直到达到“终止条件”。</li><li><strong>归</strong>：触发“终止条件”后，程序从最深层的递归函数开始逐层返回，汇聚每一层的结果。</li></ol><p>​而从实现的角度看，递归代码主要包含三个要素。</p><ol><li><strong>终止条件</strong>：用于决定什么时候由“递”转“归”。</li><li><strong>递归调用</strong>：对应“递”，函数调用自身，通常输入更小或更简化的参数。</li><li><strong>返回结果</strong>：对应“归”，将当前递归层级的结果返回至上一层。</li></ol><p><strong>有关递归的时间问题和空间问题</strong></p><p>​递归函数每次调用自身时，系统都会为新开启的函数分配内存，以存储局部变量、调用地址和其他信息等。这将导致两方面的结果。</p><ul><li><p>函数的上下文数据都存储在称为“<strong>栈帧空间</strong>”的内存区域中，直至函数返回后才会被释放。因此，<strong>递归通常比迭代更加耗费内存空间</strong>。（需要控制递归深度，否则过深的递归会导致栈的溢出错误）</p></li><li><p><strong>有关栈帧空间</strong>：</p></li><li><p>栈帧空间是指在程序执行过程中，为每个函数调用分配的一块内存区域，用于存储该函数的局部变量、参数、返回地址以及其他控制信息。每次函数被调用时，都会在调用栈上创建一个新的栈帧，这个栈帧的生命周期与函数的执行周期相同。</p><ol><li><strong>返回地址</strong>：当函数调用完成后，程序需要知道从哪里继续执行，因此返回地址会被压入栈帧中。</li><li><strong>参数</strong>：函数调用时传递给被调用函数的参数也会存储在栈帧中。</li><li><strong>局部变量</strong>：函数内部定义的局部变量会占用栈帧空间。</li><li><strong>控制信息</strong>：包括指向上一个栈帧的指针（帧指针），用于维护调用链。</li></ol><p><strong>栈帧的工作机制</strong></p><ul><li><strong>入栈</strong>：当一个函数被调用时，首先将参数和返回地址压入栈中，然后分配空间给局部变量，形成新的栈帧。</li><li><strong>出栈</strong>：当函数执行完毕时，局部变量和参数的空间被释放，返回地址被弹出，程序控制流转回调用该函数的位置。</li></ul><p><strong>栈帧的优点</strong></p><ul><li><strong>自动管理</strong>：栈帧由系统自动管理，无需手动分配和释放内存。</li><li><strong>高效性</strong>：由于栈的后进先出特性，内存分配和释放速度非常快。</li></ul></li><li><p>递归调用函数会产生额外的开销。<strong>因此递归通常比循环的时间效率更低</strong>。</p></li><li><p><strong>使用尾递归</strong>可以优化递归的效率（系统无需保存函数上一级的上下文）</p></li></ul><p><strong>有关递归树</strong></p><p>我们在函数内递归调用了两个函数，<strong>这意味着从一个调用产生了两个调用分支</strong>。如图 2-6 所示，这样不断递归调用下去，最终将产生一棵层数为 n 的递归树（recursion tree）。</p><p><img src="https://www.hello-algo.com/chapter_computational_complexity/iteration_and_recursion.assets/recursion_tree.png" alt="斐波那契数列的递归树"></p><blockquote><p>这种递归树可以达到指数阶的时间复杂度。</p></blockquote><p><strong>一定要理解递归的核心思想：分治！</strong></p><p>从本质上看，递归体现了“将问题分解为更小子问题”的思维范式，这种分治策略至关重要。</p><ul><li>从算法角度看，<strong>搜索、排序、回溯、分治、动态规划</strong>等许多重要算法策略直接或间接地应用了这种思维方式。</li><li>从数据结构角度看，<strong>递归天然适合处理链表、树和图的相关问题</strong>，因为它们非常适合用分治思想进行分析。</li></ul><p><strong>迭代和递归的本质与内在联系</strong></p><p>以上述递归函数为例，求和操作在递归的“归”阶段进行。这意味着<strong>最初被调用的函数实际上是最后完成其求和操作</strong>的，<strong>这种工作机制与栈的“先入后出”原则异曲同工</strong>。</p><p>事实上，“<strong>调用栈</strong>”和“<strong>栈帧空间</strong>”这类递归术语已经暗示了递归与栈之间的密切关系。</p><ol><li><strong>递</strong>：当函数被调用时，系统会在“调用栈”上为该函数分配新的栈帧，用于<strong>存储函数的局部变量、参数、返回地址</strong>等数据。</li><li><strong>归</strong>：当函数完成执行并返回时，对应的栈帧会被从“调用栈”上移除，恢复之前函数的执行环境。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">for_loop_recur</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;使用迭代模拟递归&quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 使用一个显式的栈来模拟系统调用栈</span><br>    stack = []<br>    res = <span class="hljs-number">0</span><br>    <span class="hljs-comment"># 递：递归调用</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>):<br>        <span class="hljs-comment"># 通过“入栈操作”模拟“递”</span><br>        stack.append(i)<br>    <span class="hljs-comment"># 归：返回结果</span><br>    <span class="hljs-keyword">while</span> stack:<br>        <span class="hljs-comment"># 通过“出栈操作”模拟“归”</span><br>        res += stack.pop()<br>    <span class="hljs-comment"># res = 1+2+3+...+n</span><br>    <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="@时间复杂度"></a>@时间复杂度</h3><ul><li><strong>常数</strong>时间复杂度</li><li><strong>线性</strong>时间复杂度</li><li><strong>平方</strong>时间复杂度</li><li><strong>指数阶</strong>时间复杂度<ul><li>递归树的一分为二</li></ul></li><li><strong>对数阶</strong>时间复杂度<ul><li>每轮缩减到一半</li><li>也会出现在递归树中（经典例题：快速幂计算）</li></ul></li><li><strong>线性对数阶</strong>时间复杂度（<code>O(nlogn)</code>）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">linear_log_recur</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;线性对数阶&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">if</span> n &lt;= <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    <span class="hljs-comment"># 一分为二，子问题的规模减小一半</span><br>    count = linear_log_recur(n // <span class="hljs-number">2</span>) + linear_log_recur(n // <span class="hljs-number">2</span>)<br>    <span class="hljs-comment"># 与C++不同，//表示地板出发（整数截断）</span><br>    <span class="hljs-comment"># 当前子问题包含 n 个操作</span><br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>        count += <span class="hljs-number">1</span><br>    <span class="hljs-comment"># 代表当前需要执行的n次操作</span><br>    <span class="hljs-keyword">return</span> count<br></code></pre></td></tr></table></figure><p><img src="https://www.hello-algo.com/chapter_computational_complexity/time_complexity.assets/time_complexity_logarithmic_linear.png" alt="线性对数阶的时间复杂度"></p><ul><li><strong>阶乘阶</strong>时间复杂度</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">factorial_recur</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;阶乘阶（递归实现）&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    count = <span class="hljs-number">0</span><br>    <span class="hljs-comment"># 从 1 个分裂出 n 个</span><br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>        count += factorial_recur(n - <span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> count<br></code></pre></td></tr></table></figure><p><img src="https://www.hello-algo.com/chapter_computational_complexity/time_complexity.assets/time_complexity_factorial.png" alt="阶乘阶的时间复杂度"></p><p>时间复杂度的分类：</p><ul><li>最差时间复杂度</li><li>最佳时间复杂度</li></ul><blockquote><p>以上两个时间复杂度均与数据的分布存在联系，具有偶然性</p></blockquote><ul><li>平均时间复杂度</li></ul><p>符号表示：</p><p>时间复杂度的符号表示法主要有三种：<code>O</code>、<code>Ω</code> 和 <code>Θ</code>，它们分别表示算法在不同情况下的性能表现。</p><ol><li><p><strong>大 O 表示法 (O(f(n)))</strong>：</p><ul><li>描述：表示算法在<strong>最坏情况下的时间复杂度</strong>。</li><li>用途：用于描述算法的上界，即算法的执行时间不会超过某个函数的增长速度。</li><li>示例：如果一个算法的时间复杂度是 (O(n^2))，意味着在最坏情况下，算法的执行时间最多是输入规模的平方。</li></ul></li><li><p><strong>大 Ω 表示法 (Ω(f(n)))</strong>：</p><ul><li>描述：表示算法在<strong>最好情况下的时间复杂度</strong>。</li><li>用途：用于描述算法的下界，即算法的执行时间至少是某个函数的增长速度。</li><li>示例：如果一个算法的时间复杂度是 (Ω(n))，意味着在最好情况下，算法的执行时间至少是输入规模的线性增长。</li></ul></li><li><p><strong>大 Θ 表示法 (Θ(f(n)))</strong>：</p><ul><li>描述：表示算法在<strong>平均情况下的时间复杂度</strong>。</li><li>用途：用于描述算法的确界，即算法的执行时间既不会超过某个函数的上界，也不会低于某个函数的下界。</li><li>示例：如果一个算法的时间复杂度是 (Θ(n \log n))，意味着在所有情况下，算法的执行时间大致是输入规模的 (n \log n) 级别。</li></ul></li></ol><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="@空间复杂度"></a>@空间复杂度</h3><p>算法在运行过程中使用的内存空间主要包括以下几种。</p><ul><li><strong>输入空间</strong>：用于存储算法的输入数据。</li><li><strong>暂存空间</strong>：用于存储算法在运行过程中的变量、对象、函数上下文等数据。</li><li><strong>输出空间</strong>：用于存储算法的输出数据。</li></ul><p>一般情况下，空间复杂度的统计范围是“<strong>暂存空间”加上“输出空间”</strong>。</p><p>暂存空间可以进一步划分为三个部分。</p><ul><li><strong>暂存数据</strong>：用于保存算法运行过程中的各种常量、变量、对象等。</li><li><strong>栈帧空间</strong>：用于保存调用函数的上下文数据。系统在每次调用函数时都会在栈顶部创建一个栈帧，函数返回后，栈帧空间会被释放。</li><li><strong>指令空间</strong>：用于保存编译后的程序指令，在实际统计中通常忽略不计。</li></ul><p>在分析一段程序的空间复杂度时，<strong>我们通常统计暂存数据、栈帧空间和输出数据三部分</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;类&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, x: <span class="hljs-built_in">int</span></span>):<br>        <span class="hljs-variable language_">self</span>.val: <span class="hljs-built_in">int</span> = x              <span class="hljs-comment"># 节点值</span><br>        <span class="hljs-variable language_">self</span>.<span class="hljs-built_in">next</span>: Node | <span class="hljs-literal">None</span> = <span class="hljs-literal">None</span>  <span class="hljs-comment"># 指向下一节点的引用</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">function</span>() -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;函数&quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 执行某些操作...</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">algorithm</span>(<span class="hljs-params">n</span>) -&gt; <span class="hljs-built_in">int</span>:  <span class="hljs-comment"># 输入数据</span><br>    A = <span class="hljs-number">0</span>                 <span class="hljs-comment"># 暂存数据（常量，一般用大写字母表示）</span><br>    b = <span class="hljs-number">0</span>                 <span class="hljs-comment"># 暂存数据（变量）</span><br>    node = Node(<span class="hljs-number">0</span>)        <span class="hljs-comment"># 暂存数据（对象）</span><br>    c = function()        <span class="hljs-comment"># 栈帧空间（调用函数）</span><br>    <span class="hljs-keyword">return</span> A + b + c      <span class="hljs-comment"># 输出数据</span><br></code></pre></td></tr></table></figure><p>​而与时间复杂度不同的是，<strong>我们通常只关注最差空间复杂度</strong>。这是因为内存空间是一项硬性要求，我们必须确保在所有输入数据下都有足够的内存空间预留。</p><ul><li>以最差输入数据为准</li><li>以算法运行的<strong>峰值内存</strong>（注意不是累积量）为准</li></ul><p>一些常见的空间复杂度：</p><ul><li><p>常数阶空间复杂度</p><ul><li>在循环中初始化变量或调用函数而占用的内存，在进入下一循环后就会被释放，因此不会累积占用空间，空间复杂度还是<code>O(1)</code>。</li></ul></li><li><p>线性阶空间复杂度</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">linear</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span></span>):<br>    <span class="hljs-string">&quot;&quot;&quot;线性阶&quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 长度为 n 的列表占用 O(n) 空间</span><br>    nums = [<span class="hljs-number">0</span>] * n<br>    <span class="hljs-comment"># 长度为 n 的哈希表占用 O(n) 空间</span><br>    hmap = <span class="hljs-built_in">dict</span>[<span class="hljs-built_in">int</span>, <span class="hljs-built_in">str</span>]()<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>        hmap[i] = <span class="hljs-built_in">str</span>(i)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">linear_recur</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span></span>):<br>    <span class="hljs-string">&quot;&quot;&quot;线性阶（递归实现）&quot;&quot;&quot;</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;递归 n =&quot;</span>, n)<br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span><br>    linear_recur(n - <span class="hljs-number">1</span>)<br>    <span class="hljs-comment"># 在达到最深的递归深度的时候，会有n个变量n（涉及到局部变量）</span><br></code></pre></td></tr></table></figure></li><li><p>平方阶空间复杂度</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">quadratic</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span></span>):<br>    <span class="hljs-string">&quot;&quot;&quot;平方阶&quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 二维列表占用 O(n^2) 空间</span><br>    num_matrix = [[<span class="hljs-number">0</span>] * n <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br></code></pre></td></tr></table></figure><ul><li><p><code>num_matrix</code>：这是一个变量名，用于存储生成的二维矩阵。</p><p><code>[[0] * n for _ in range(n)]</code>：这是一个列表生成式，用于创建一个包含 <code>n</code> 个子列表的列表，每个子列表包含 <code>n</code> 个元素。</p><ul><li><code>[0] * n</code>：这一部分创建一个包含 <code>n</code> 个 <code>0</code> 的列表。例如，如果 <code>n</code> 是 <code>3</code>，则生成 <code>[0, 0, 0]</code>。</li><li><code>for _ in range(n)</code>：这一部分用于重复创建上述的子列表 <code>n</code> 次。<code>_</code> 是一个惯用的变量名，表示循环变量在循环体内未被使用。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">quadratic_recur</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;平方阶（递归实现）&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">if</span> n &lt;= <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    <span class="hljs-comment"># 数组 nums 长度为 n, n-1, ..., 2, 1</span><br>    nums = [<span class="hljs-number">0</span>] * n<br>    <span class="hljs-keyword">return</span> quadratic_recur(n - <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure></li></ul></li><li><p>指数阶空间复杂度（二叉树）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">build_tree</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span></span>) -&gt; TreeNode | <span class="hljs-literal">None</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;指数阶（建立满二叉树）&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>    root = TreeNode(<span class="hljs-number">0</span>)<br>    root.left = build_tree(n - <span class="hljs-number">1</span>)<br>    root.right = build_tree(n - <span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> root<br></code></pre></td></tr></table></figure><p><img src="https://www.hello-algo.com/chapter_computational_complexity/space_complexity.assets/space_complexity_exponential.png" alt="满二叉树产生的指数阶空间复杂度"></p></li><li><p>对数阶空间复杂度</p></li></ul><p>对数阶空间复杂度（(O(\log n))）在算法中并不如其他复杂度（如常数、线性、平方等）常见，因为对数阶通常与递归深度相关联。以下是一些可能具有对数阶空间复杂度的常见算法和场景：</p><ol><li><p><strong>递归算法</strong>：</p><ul><li><strong>二分查找</strong>：在递归实现中，二分查找的空间复杂度是 (O(\log n))，因为递归调用栈的深度是对数级别的。</li><li><strong>快速排序</strong>：在最优情况下（即每次分区都能将数组均匀分割），快速排序的递归深度是 (O(\log n))，因此空间复杂度也是 (O(\log n))。</li><li><strong>归并排序</strong>：尽管归并排序的时间复杂度是 (O(n \log n))，其递归实现的空间复杂度可以是 (O(\log n))（不包括用于存储结果的额外数组）。</li></ul><h3 id="快速排序（Quick-Sort）"><a href="#快速排序（Quick-Sort）" class="headerlink" title="快速排序（Quick Sort）"></a>快速排序（Quick Sort）</h3><p>快速排序是一种分而治之的排序算法。它的基本思想是选择一个基准元素（pivot），然后将数组分成两个子数组，一个包含所有小于基准元素的元素，另一个包含所有大于基准元素的元素，然后递归地对这两个子数组进行排序。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">quick_sort</span>(<span class="hljs-params">arr</span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(arr) &lt;= <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span> arr<br>    <span class="hljs-keyword">else</span>:<br>        pivot = arr[<span class="hljs-built_in">len</span>(arr) // <span class="hljs-number">2</span>]<br>        left = [x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> arr <span class="hljs-keyword">if</span> x &lt; pivot]<br>        middle = [x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> arr <span class="hljs-keyword">if</span> x == pivot]<br>        right = [x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> arr <span class="hljs-keyword">if</span> x &gt; pivot]<br>        <span class="hljs-keyword">return</span> quick_sort(left) + middle + quick_sort(right)<br><br><span class="hljs-comment"># 示例使用</span><br>arr = [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">10</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Original array:&quot;</span>, arr)<br>sorted_arr = quick_sort(arr)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Sorted array:&quot;</span>, sorted_arr)<br></code></pre></td></tr></table></figure><h3 id="归并排序（Merge-Sort）"><a href="#归并排序（Merge-Sort）" class="headerlink" title="归并排序（Merge Sort）"></a>归并排序（Merge Sort）</h3><p>归并排序也是一种分而治之的排序算法。它的基本思想是将数组分成两个子数组，对这两个子数组分别进行排序，然后将排序后的子数组合并成一个有序的数组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">merge_sort</span>(<span class="hljs-params">arr</span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(arr) &lt;= <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span> arr<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">merge</span>(<span class="hljs-params">left, right</span>):<br>        result = []<br>        i = j = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> i &lt; <span class="hljs-built_in">len</span>(left) <span class="hljs-keyword">and</span> j &lt; <span class="hljs-built_in">len</span>(right):<br>            <span class="hljs-keyword">if</span> left[i] &lt; right[j]:<br>                result.append(left[i])<br>                i += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                result.append(right[j])<br>                j += <span class="hljs-number">1</span><br>        result.extend(left[i:])<br>        result.extend(right[j:])<br>        <span class="hljs-keyword">return</span> result<br><br>    mid = <span class="hljs-built_in">len</span>(arr) // <span class="hljs-number">2</span><br>    left = merge_sort(arr[:mid])<br>    right = merge_sort(arr[mid:])<br>    <span class="hljs-keyword">return</span> merge(left, right)<br><br><span class="hljs-comment"># 示例使用</span><br>arr = [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">10</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Original array:&quot;</span>, arr)<br>sorted_arr = merge_sort(arr)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Sorted array:&quot;</span>, sorted_arr)<br></code></pre></td></tr></table></figure><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><ul><li><p><strong>快速排序</strong>：</p><ul><li>选择一个基准元素（pivot）。</li><li>将数组分成三个部分：小于基准的部分、等于基准的部分和大于基准的部分。</li><li>递归地对小于基准和大于基准的部分进行排序。</li><li>合并结果。</li></ul></li><li><p><strong>归并排序</strong>：</p><ul><li>将数组分成两半。</li><li>递归地对每一半进行排序。</li><li>合并两个排序后的子数组。</li></ul></li></ul><p>这两种排序算法都是经典的分而治之算法，具有较好的性能和广泛的应用。</p></li><li><p><strong>平衡树的数据结构</strong>：</p><ul><li><strong>平衡二叉搜索树（如 AVL 树、红黑树）</strong>：这些数据结构在执行插入、删除和查找操作时的递归深度通常是 (O(\log n))，因此在某些实现中，可能会有 (O(\log n)) 的空间复杂度，主要用于递归调用栈。</li></ul></li><li><p><strong>迭代算法</strong>：</p><ul><li>某些迭代算法在实现中可能会使用一个栈来模拟递归，从而使得其空间复杂度为 (O(\log n))。例如，某些树遍历算法在深度优先搜索时可能使用栈来存储路径信息。</li></ul></li></ol><p>需要注意的是，空间复杂度为 (O(\log n)) 的算法通常涉及递归调用或需要存储某些对数数量的信息。这种复杂度通常与算法的递归深度或树结构的高度相关。</p><p><strong>循环与递归在空间复杂度上的差异</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">function</span>() -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-comment"># 执行某些操作</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">loop</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span></span>):<br>    <span class="hljs-string">&quot;&quot;&quot;循环的空间复杂度为 O(1)&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>        function()<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">recur</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span></span>):<br>    <span class="hljs-string">&quot;&quot;&quot;递归的空间复杂度为 O(n)&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span><br>    <span class="hljs-keyword">return</span> recur(n - <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>函数 <code>loop()</code> 和 <code>recur()</code> 的时间复杂度都为 O(n) ，但空间复杂度不同。</p><ul><li>函数 <code>loop()</code> 在循环中调用了 n 次 <code>function()</code> ，每轮中的 <code>function()</code> 都返回并释放了栈帧空间，因此空间复杂度仍为 O(1) 。</li><li>递归函数 <code>recur()</code> 在运行过程中会同时存在 n 个未返回的 <code>recur()</code> ，从而占用 O(n) 的栈帧空间。</li></ul><h2 id="二、数据结构"><a href="#二、数据结构" class="headerlink" title="二、数据结构"></a>二、数据结构</h2><p>数组，链表，栈，队列，哈希表，树，堆，图</p><h3 id="数据结构的物理结构"><a href="#数据结构的物理结构" class="headerlink" title="@数据结构的物理结构"></a>@数据结构的物理结构</h3><p>如图 3-3 所示，<strong>物理结构反映了数据在计算机内存中的存储方式</strong>，可分为连续空间存储（数组）和分散空间存储（链表）。物理结构从底层决定了数据的访问、更新、增删等操作方法，两种物理结构在时间效率和空间效率方面呈现出互补的特点。</p><p><img src="https://www.hello-algo.com/chapter_data_structure/classification_of_data_structure.assets/classification_phisical_structure.png" alt="连续空间存储与分散空间存储"></p><p>连续空间存储（数组）</p><ul><li><strong>定义</strong>：连续空间存储是指数据元素在内存中连续排列，数组是这种存储方式的典型代表。</li><li><strong>优点</strong>：<ul><li><strong>快速访问</strong>：由于数组元素是连续存储的，可以通过索引直接访问任意元素，时间复杂度为 O(1)。</li><li><strong>空间局部性</strong>：连续存储有助于缓存命中率，因为访问一个元素后，后续访问相邻元素时，可能已经在缓存中。</li></ul></li><li><strong>缺点</strong>：<ul><li><strong>插入和删除操作效率低</strong>：在数组中插入或删除元素通常需要移动其他元素以保持数据的连续性，时间复杂度为 <em>O</em>(<em>n</em>)。</li><li><strong>固定大小</strong>：数组的大小在创建时确定，扩展数组的大小需要重新分配内存并复制数据。</li></ul></li></ul><p>分散空间存储（链表）</p><ul><li><strong>定义</strong>：分散空间存储是指数据元素在内存中不必连续排列，链表是这种存储方式的典型代表。</li><li><strong>优点</strong>：<ul><li><strong>动态大小</strong>：链表可以方便地进行动态内存分配，允许在运行时灵活地增加或减少元素。</li><li><strong>高效插入和删除</strong>：在链表中，插入和删除元素只需调整指针，而不需要移动其他元素，时间复杂度为 <em>O</em>(1)（在已知位置的情况下）。</li></ul></li><li><strong>缺点</strong>：<ul><li><strong>访问速度慢</strong>：由于链表元素存储在非连续的内存位置，访问某个特定元素需要从头遍历链表，时间复杂度为 <em>O</em>(<em>n</em>)。</li><li><strong>额外空间开销</strong>：链表需要额外的存储空间来存储指针（如前驱和后继指针），这增加了内存使用量。</li></ul></li></ul><p>互补特点</p><ul><li><strong>数组</strong>适合需要频繁随机访问的场景，如需要快速读取大量数据但不经常修改数据的情况。</li><li><strong>链表</strong>适合需要频繁插入和删除操作的场景，如实现动态数据结构（例如队列、栈）时。</li></ul><p>值得说明的是，<strong>所有数据结构都是基于数组、链表或二者的组合实现的</strong>。例如，栈和队列既可以使用数组实现，也可以使用链表实现；而哈希表的实现可能同时包含数组和链表。</p><ul><li><strong>基于数组可实现</strong>：栈、队列、哈希表、树、堆、图、矩阵、张量（维度 ≥3 的数组）等。</li><li><strong>基于链表可实现</strong>：栈、队列、哈希表、树、堆、图等。</li></ul><p>​哈希表底层是数组，而为了解决哈希冲突，我们可能会使用“链式地址”（后续“哈希冲突”章节会讲）：数组中每个桶指向一个链表，当链表长度超过一定阈值时，又可能被转化为树（通常为红黑树）。</p><p>​从存储的角度来看，哈希表的底层是数组，其中每一个桶槽位可能包含一个值，也可能包含一个链表或一棵树。因此，哈希表可能同时包含线性数据结构（数组、链表）和非线性数据结构（树）。</p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tutorial</tag>
      
      <tag>C/C++</tag>
      
      <tag>Time and Space Complexity</tag>
      
      <tag>Recursion</tag>
      
      <tag>Hello-algorithm-tutorial</tag>
      
      <tag>Finished</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LaTeX-tutorial</title>
    <link href="/posts/LaTeX-tutorial/"/>
    <url>/posts/LaTeX-tutorial/</url>
    
    <content type="html"><![CDATA[<h1 id="About-LaTeX"><a href="#About-LaTeX" class="headerlink" title="About LaTeX"></a>About LaTeX</h1><p>​听说过LaTeX吗？亦或是老师突然要求你们使用LaTeX进行写论文，自己面对奇奇怪怪的复杂代码毫无头绪，下不去手？</p><p><strong>需要提前准备的内容</strong>：</p><ul><li>无</li></ul><p><strong>如果你是</strong>：</p><ul><li>纯LaTeX新手，从零开始接触LaTeX；</li><li>纯路人，想学习LaTeX技巧；</li><li>想要支持作者的帅哥美女❥(^_-)；</li></ul><p>那恭喜你来对地方了！在这篇文章中，<strong>你将学习到以下内容</strong>：</p><ul><li>一段LaTeX的历史和一位伟人；</li><li>掌握LaTeX的最基本原理；</li><li>如何从零开始构建第一篇LaTeX文档，并按需进行个性化的修改；</li><li>尝试接触一些LaTeX的高级功能（Optional）；</li><li>获得一些精进LaTeX技能包的方法和途径；</li></ul><p><strong>准备好了吗？</strong> 在接下来的时光里，就让我们一起走进LaTeX的世界。</p><p><img src="/posts/LaTeX-tutorial/LaTeX.png" alt="LaTeX"></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://en.wikipedia.org/wiki/TeX">TeX - Wikipedia</a></p><p><a href="https://en.wikipedia.org/wiki/LaTeX">LaTeX - Wikipedia</a></p><p><a href="https://www.overleaf.com/">Overleaf, Online LaTeX Editor</a></p><p><a href="https://www.latex-project.org/">LaTeX - A document preparation system</a></p><h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1 Introduction"></a>1 Introduction</h2><p><strong>又来到了讲故事环节，可跳过</strong></p><p>​在开始我们今天的话题之前，我想先向各位介绍一位老先生，<a href="https://en.wikipedia.org/wiki/Donald_Knuth">Donald Knuth</a>。</p><p><img src="/posts/LaTeX-tutorial/Knuth.jpg" alt="Donald Knuth"></p><p>​先来看看他到底有多牛逼，这是维基百科对这位老爷爷（还没有去世哦）的评价：He is the 1974 recipient of <strong>the <a href="https://en.wikipedia.org/wiki/Acm_Turing_award">ACM Turing Award</a></strong>, informally considered the <a href="https://en.wikipedia.org/wiki/Nobel_Prize">Nobel Prize</a> of computer science. Knuth has been called the “<strong>father of the <a href="https://en.wikipedia.org/wiki/Analysis_of_algorithms">analysis of algorithms</a></strong>“。 <a href="https://en.wikipedia.org/wiki/Donald_Knuth">原文</a></p><p>​ACM图灵奖不必多说，能拿奖的都是计算机科学领域大牛中的大牛，他甚至还有第二个称号，<strong>the father of the analysis of algorithms</strong>, 算法分析之父！更不可思议的是，他的主要贡献竟然是一系列至今尚未完篇的鸿篇巨著：*<a href="https://en.wikipedia.org/wiki/The_Art_of_Computer_Programming">The Art of Computer Programming</a>*。<strong>计算机程序设计艺术</strong>，简称TAOCP，是关于计算机程序设计之七卷本著作。作者并因此获得美国计算机协会1974年<a href="https://zh.wikipedia.org/wiki/%E5%9B%BE%E7%81%B5%E5%A5%96">图灵奖</a>。</p><blockquote><p>对我来说，读完这本书不仅花了好几个月，而且还要求我有极高的自律性。如果你能读完这本书，不妨给我发个简历。——Bill Gates</p></blockquote><p>​这一套书涵盖了计算机领域几乎所有的底层知识，目录如下：</p><p><img src="/posts/LaTeX-tutorial/theartofprogramming.png" alt="TAOCP"></p><p><a href="https://zh.wikipedia.org/zh-cn/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%89%BA%E6%9C%AF">链接指路：计算机程序设计艺术</a></p><p>​这本书的具体内容我们不做过多的介绍，那这位老者和LaTeX有什么关系呢？<strong>他是LaTeX的前身——TeX的发明者！</strong></p><p>​维基百科在这一块写的比较含蓄哈哈哈：</p><blockquote><p>In 1977, he decided to spend some time <strong>creating something more suitable</strong>. Eight years later, he returned with <a href="https://en.wikipedia.org/wiki/TeX">TEX</a>, which is currently used for all volumes.</p></blockquote><p>什么是<strong>something more suitable</strong>？Maybe the LaTeX！</p><h2 id="2-LaTeX"><a href="#2-LaTeX" class="headerlink" title="2 LaTeX"></a>2 LaTeX</h2><p>​举一个非常简单的例子，你想在word文档中输入这样一个公式：</p><p><img src="/posts/LaTeX-tutorial/QianJianTec1732279187844.png" alt="Gradient Descent"></p><blockquote><p>这是机器学习中梯度下降的基本数学原理。</p></blockquote><p>​我们来看看word是怎么编辑公式的：</p><p><img src="/posts/LaTeX-tutorial/word.png" alt="How does Microsoft Word handle it?"></p><p>​Word等文字编辑器始终秉持着一种<strong>所见即所得</strong>的思想，我打出一个字符，这个字符就实时的反映在我的文本文档中，至于图片缩放，表格插入，文字大小，排版，以及以上所涉及的数学符号等等，在word中虽然能实现，但是调试的时间成本非常高，难度非常大，而且十分的低效！笔者在高中时期曾经有过写数学小论文卡在编辑公式和统一插入图片的格式等细枝末节的小事上的惨痛的回忆。(不过好像现在word也支持LaTeX了)</p><p>​但是在LaTeX中，我们可以利用下面的代码生成：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\begin</span>&#123;aligned&#125;<br><span class="hljs-keyword">\theta</span><span class="hljs-built_in">_</span>&#123;j&#125;:=<span class="hljs-keyword">\theta</span><span class="hljs-built_in">_</span>&#123;j&#125;- <span class="hljs-built_in">&amp;</span> <span class="hljs-keyword">\alpha</span> <span class="hljs-keyword">\frac</span>&#123;<span class="hljs-keyword">\partial</span>&#125;&#123;<span class="hljs-keyword">\partial</span> <span class="hljs-keyword">\theta</span><span class="hljs-built_in">_</span>&#123;j&#125;&#125; J(<span class="hljs-keyword">\theta</span>) <span class="hljs-keyword">\\</span><br><span class="hljs-keyword">\frac</span>&#123;<span class="hljs-keyword">\partial</span>&#125;&#123;<span class="hljs-keyword">\partial</span> <span class="hljs-keyword">\theta</span><span class="hljs-built_in">_</span>&#123;j&#125;&#125; J(<span class="hljs-keyword">\theta</span>) <span class="hljs-built_in">&amp;</span> =<span class="hljs-keyword">\frac</span>&#123;<span class="hljs-keyword">\partial</span>&#125;&#123;<span class="hljs-keyword">\partial</span> <span class="hljs-keyword">\theta</span><span class="hljs-built_in">_</span>&#123;j&#125;&#125; <span class="hljs-keyword">\frac</span>&#123;1&#125;&#123;2&#125;<span class="hljs-keyword">\left</span>(h<span class="hljs-built_in">_</span>&#123;<span class="hljs-keyword">\theta</span>&#125;(x)-y<span class="hljs-keyword">\right</span>)<span class="hljs-built_in">^</span>&#123;2&#125; <span class="hljs-keyword">\\</span><br><span class="hljs-built_in">&amp;</span> =2 <span class="hljs-keyword">\cdot</span> <span class="hljs-keyword">\frac</span>&#123;1&#125;&#123;2&#125;<span class="hljs-keyword">\left</span>(h<span class="hljs-built_in">_</span>&#123;<span class="hljs-keyword">\theta</span>&#125;(x)-y<span class="hljs-keyword">\right</span>) <span class="hljs-keyword">\cdot</span> <span class="hljs-keyword">\frac</span>&#123;<span class="hljs-keyword">\partial</span>&#125;&#123;<span class="hljs-keyword">\partial</span> <span class="hljs-keyword">\theta</span><span class="hljs-built_in">_</span>&#123;j&#125;&#125;<span class="hljs-keyword">\left</span>(h<span class="hljs-built_in">_</span>&#123;<span class="hljs-keyword">\theta</span>&#125;(x)-y<span class="hljs-keyword">\right</span>) <span class="hljs-keyword">\\</span><br><span class="hljs-built_in">&amp;</span> =<span class="hljs-keyword">\left</span>(h<span class="hljs-built_in">_</span>&#123;<span class="hljs-keyword">\theta</span>&#125;(x)-y<span class="hljs-keyword">\right</span>) <span class="hljs-keyword">\cdot</span> <span class="hljs-keyword">\frac</span>&#123;<span class="hljs-keyword">\partial</span>&#125;&#123;<span class="hljs-keyword">\partial</span> <span class="hljs-keyword">\theta</span><span class="hljs-built_in">_</span>&#123;j&#125;&#125;<span class="hljs-keyword">\left</span>(<span class="hljs-keyword">\sum</span><span class="hljs-built_in">_</span>&#123;i=0&#125;<span class="hljs-built_in">^</span>&#123;n&#125; <span class="hljs-keyword">\theta</span><span class="hljs-built_in">_</span>&#123;i&#125; x<span class="hljs-built_in">_</span>&#123;i&#125;-y<span class="hljs-keyword">\right</span>) <span class="hljs-keyword">\\</span><br><span class="hljs-built_in">&amp;</span> =<span class="hljs-keyword">\left</span>(h<span class="hljs-built_in">_</span>&#123;<span class="hljs-keyword">\theta</span>&#125;(x)-y<span class="hljs-keyword">\right</span>) x<span class="hljs-built_in">_</span>&#123;j&#125;<br><span class="hljs-keyword">\end</span>&#123;aligned&#125;<br></code></pre></td></tr></table></figure><p>​完全看不懂是不是？没关系，这就是<strong>LaTeX的精髓</strong>：<strong>将可视化的文本编辑转化成一种严谨的代码语言</strong>，当你学会并且快速上手之后，你便会越来越体会到LaTeX在学术写作上的强大之处。</p><h2 id="3-LaTeX-入门"><a href="#3-LaTeX-入门" class="headerlink" title="3 LaTeX 入门"></a>3 LaTeX 入门</h2><p>​由上面的示例我们可以看出，<strong>LaTeX可以生成极为精美的文档，涵盖公式，表格，图片等等各种形式（你甚至可以用来做PPT！后面会讲到）</strong>，但代价就是<strong>LaTeX牺牲了市面上主流文本编辑器的”所见即所得”的思想</strong>，将所有文字和图片的生成都转化为了一种规则和<strong>编程语言</strong>，初学者入门可能会很吃力，但相信我，熟练后你会爱上他的！</p><h3 id="3-1-开始你的第一篇LaTeX文档！"><a href="#3-1-开始你的第一篇LaTeX文档！" class="headerlink" title="3.1 开始你的第一篇LaTeX文档！"></a>3.1 开始你的第一篇LaTeX文档！</h3><p>​万事万物第一步：配环境！一般来说有两种方式：</p><ul><li>本地环境配置：<a href="https://www.tug.org/texlive/">TeX Live - TeX Users Group</a>。需要安装textlive，后续可以集成在vscode中使用，具体的操作方法比较繁琐，读者可以自行搜索，网上有很多保姆级的环境搭建教程。（<strong>不推荐，个人建议是等上手熟悉了之后再考虑是否安装，配环境报错真的能把人给烦死</strong>）</li><li><strong>推荐在线LaTeX网站：</strong>使用LaTeX在线网站，例如<a href="https://www.overleaf.com/">Overleaf</a>，国内有些高校也会开通自己的LaTeX平台。在线网站更加轻量化，隐藏了配置环境的细节，注册一个账号就可以使用，<strong>非常推荐新手小白使用！</strong></li><li>在接下来的新手教程中，我们将全程在<a href="https://www.overleaf.com/">Overleaf</a>上进行演示，请登录网站并注册好你的账号。（使用免费版即可）</li></ul><h3 id="3-2-建立一个模版LaTeX"><a href="#3-2-建立一个模版LaTeX" class="headerlink" title="3.2 建立一个模版LaTeX"></a>3.2 建立一个模版LaTeX</h3><p>​对新手而言，<strong>快速上手熟悉LaTeX比了解LaTeX背后的原理重要的多</strong>。因此，我们将会从一个模版LaTeX出发，从实操慢慢过渡到原理的讲解。</p><p><img src="/posts/LaTeX-tutorial/s1.png" alt="Choose a template"></p><p>​点击左上角的new project——然后有四个选项：</p><ul><li><p>Blank project（完全的空文本）</p></li><li><p>Example Project（模版）</p></li><li><p>Upload Project（上传本地项目，通常是压缩包形式）</p></li><li><p>Import Project（从Github引入）</p><p>在这里我们选择Example Project。输入自己的Project Name(建议英文)。我在这里输入的是Hello world。</p></li></ul><h3 id="3-3-探索LaTeX模版！"><a href="#3-3-探索LaTeX模版！" class="headerlink" title="3.3 探索LaTeX模版！"></a>3.3 探索LaTeX模版！</h3><p><img src="/posts/LaTeX-tutorial/image_9.png" alt="Hello world!"></p><p>​当你看到一只经典的绿色小青蛙时，恭喜你，你已经成功创建了第一个LaTeX文档！</p><blockquote><p>没有看到？试试点一下右上侧绿色的<strong>Recompile</strong>按钮试试看，可能要等一会。</p></blockquote><p>​简单介绍一下各模块都是干啥用的：</p><ul><li>最左边：文件栏和<strong>File Outline</strong><ul><li>文件栏可以理解为<strong>一个存放这个LaTeX文档所有资源的文件夹</strong>。我们现在中间所打开的就是文件夹中的<strong>main.tex</strong>文件，这也是LaTeX文档的核心部分。还有一些附属的资源也会存放在文件栏中，包括插入的图片，还有参考文献(.bib)。目前大家知道这些就足够了。</li><li>File Outline 不必多说，展示文章大纲的地方。</li></ul></li><li>正中间：文本编辑区，也就是敲代码的地方。</li><li>最右边：视图区：当你点击<strong>Recompile</strong>的按钮之后，<strong>编译器</strong>（点击左上方的menu可以查看，<strong>新手不要随便改变这一项！</strong>）会根据main.tex的代码以及一些附属文件（例如frog.jpg）生成最终的LaTeX文档（PDF），在右侧可以预览，也可以导出保存。</li></ul><p><img src="/posts/LaTeX-tutorial/image_11.png" alt="The Compiler"></p><ul><li>上方一栏的一些工具看名字应该就知道是干什么的了，和普通的文本编辑器差不太多，都是一些附加功能，读者可以自己来探索。</li></ul><h3 id="3-4-进入main-tex"><a href="#3-4-进入main-tex" class="headerlink" title="3.4 进入main.tex"></a>3.4 进入main.tex</h3><p>​接下来，让我们把重点放在main.tex的代码上。</p><h4 id="3-4-1-整体架构"><a href="#3-4-1-整体架构" class="headerlink" title="3.4.1 整体架构"></a>3.4.1 整体架构</h4><p>​一篇标准的LaTeX代码架构如下：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-comment">% 这是一行注释，不会对代码产生任何影响</span><br><span class="hljs-keyword">\documentclass</span>&#123;article&#125;<br><span class="hljs-comment">%导言区（相当于前期的准备工作）</span><br><span class="hljs-keyword">\begin</span>&#123;document&#125;<br><span class="hljs-comment">%正文（文章内容）</span><br><span class="hljs-keyword">\end</span>&#123;document&#125;<br><span class="hljs-comment">% \end&#123;document&#125;代表着main.tex的结尾，相当于C++的return 0;这个语句后面不要加上任何的东西！（因为加了也没有任何意义）</span><br></code></pre></td></tr></table></figure><p>​<code>\</code>在LaTeX中是非常重要的一个字符，类似于C&#x2F;C++中的转义字符，在后面跟着的都是<strong>LaTeX的关键词和命令</strong>（会有代码高亮），我们<strong>重点学习的内容</strong>就是<strong>这些命令代表什么意思，以及如何使用这些命令</strong>。</p><p>​首先，我们来介绍LaTeX中的<strong>导言区</strong>，即<code>\begin&#123;document&#125;</code>之前的部分。</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\documentclass</span>&#123;article&#125;<br><span class="hljs-comment">%这行代码指定了文档的类型为 article，即文章类型。LaTeX 中有几种文档类型（如 report、book 等），article 是最常用的一种，适用于论文、报告、演讲稿等。</span><br></code></pre></td></tr></table></figure><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs LaTeX"><span class="hljs-comment">% Language setting</span><br><span class="hljs-comment">% Replace `english&#x27; with e.g. `spanish&#x27; to change the document language</span><br><span class="hljs-keyword">\usepackage</span>[english]&#123;babel&#125;<br><span class="hljs-comment">% Useful packages</span><br><span class="hljs-keyword">\usepackage</span>&#123;amsmath&#125;<br><span class="hljs-keyword">\usepackage</span>&#123;graphicx&#125;<br><span class="hljs-keyword">\usepackage</span>[colorlinks=true, allcolors=blue]&#123;hyperref&#125;<br></code></pre></td></tr></table></figure><p>​在LaTeX，几乎所有的高级操作都是建立在<strong>导入宏包</strong>的基础之上的，类似于C++中的#include和Python中的import，导入宏包可以让你的LaTeX代码变的更加强大。在此处导入的三个常用宏包分别用于数学公式(amsmath)，图形处理(graphix)和引用(hyperref)。<br>​在之后的学习过程中，你可以根据需求自己导入特定的宏包，不过别担心，后面会具体教你怎么做的。</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\title</span>&#123;Your Paper&#125;<br><span class="hljs-keyword">\author</span>&#123;You&#125;<br><span class="hljs-comment">% 作者的信息和文章标题，这一块也可以自己魔改（属于高级功能）</span><br></code></pre></td></tr></table></figure><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\begin</span>&#123;document&#125;<br><span class="hljs-comment">%正文</span><br><span class="hljs-keyword">\end</span>&#123;document&#125;<br></code></pre></td></tr></table></figure><p>​夹在<code>\begin&#123;document&#125;</code>和<code>\end&#123;document&#125;</code>之间的是文章的正文部分，<strong>任何你想在最后PDF出现的内容，无论是图片，文字，都需要在<code>\begin&#123;document&#125;</code>和<code>\end&#123;document&#125;</code>之间通过命令表达出来！</strong>接下来我们来重点介绍正文部分。</p><h4 id="3-4-2-正文部分①——文字"><a href="#3-4-2-正文部分①——文字" class="headerlink" title="3.4.2 正文部分①——文字"></a>3.4.2 正文部分①——文字</h4><blockquote><p>在这里为了方便演示，我创建了一个新的空白文档，所以和LaTeX模版之间存在差异。读者可以先尝试理解这些指令都代表着什么功能，然后回到自己的template中尝试“读懂”他！也可以自己尝试修改一些内容看看最后生成的文档有什么不同~</p></blockquote><p>正文的代码开始看不懂了？别着急，先来看看我写的简化版的</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\begin</span>&#123;document&#125;<br><span class="hljs-keyword">\maketitle</span><br><br><span class="hljs-keyword">\begin</span>&#123;abstract&#125;<br>Your abstract.<br><span class="hljs-keyword">\end</span>&#123;abstract&#125;<br><span class="hljs-keyword">\section</span>&#123;introducccction&#125;<br><span class="hljs-keyword">\section</span>&#123;Part1&#125;<br><span class="hljs-keyword">\subsection</span>&#123;hello&#125;<br>Hello, this is a test file.<br>is this a new paragraph?<br><br>is this a new paragraph?<br><span class="hljs-keyword">\subsection</span>&#123;world!&#125;<br><span class="hljs-keyword">\subsubsection</span>&#123;hahah&#125;<br><span class="hljs-keyword">\subsubsection</span>&#123;hahahahahah&#125;<br>i know you are very smart!<br><span class="hljs-keyword">\section</span>&#123;Part22&#125;<br><span class="hljs-keyword">\begin</span>&#123;enumerate&#125;<br>    <span class="hljs-keyword">\item</span> this is the firrst point<br>    <span class="hljs-keyword">\item</span> this is the 2nd points<br><span class="hljs-keyword">\end</span>&#123;enumerate&#125;<br><span class="hljs-keyword">\section</span>&#123;p3&#125;<br><span class="hljs-keyword">\section</span>&#123;Conclusion&#125;<br><br><span class="hljs-keyword">\end</span>&#123;document&#125;<br></code></pre></td></tr></table></figure><p>包含一些必要的文件准备工作，这份PDF输出如下：</p><p><img src="/posts/LaTeX-tutorial/image_12.png" alt="The Output"></p><blockquote><p>为了让展示变得更加清晰，我故意拼错了许多单词，请勿模仿！</p></blockquote><ul><li><p><code>\maketitle</code>命令首先输出文章的标题（包括作者信息和时间），不要删除。</p></li><li><p>摘要（abstract）</p><ul><li>论文的一个组成部分，由<code>\begin&#123;abstract&#125;</code>和<code>\end&#123;abstract&#125;</code>包裹。</li></ul></li><li><p><code>\section</code>,<code>\subsection</code>,<code>\subsubsection</code></p><ul><li>类似于论文中1,2,3级小标题的概念，读者可以将代码中的文字和最终输出在PDF中的位置对应起来，应该很快就能够理解。</li><li>这就是LaTeX的强大之处，可能用起来没有word可视化，但是他省去了很多文字排版以及大小调整优化的工作，实际上大大地提高了工作效率。</li></ul></li><li><p>正文</p><ul><li><p>文章中<em>i know you are very smart!</em> 和<em>Hello, this is a test file. is this a new paragraph?</em> 都是正文语句。</p></li><li><p><strong>缩进</strong>：LaTeX默认模版中首段不缩进，第二段才缩进，如果想更改这个设置，可以在导言区加入命令：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\usepackage</span>&#123;indentfirst&#125;<br><span class="hljs-comment">% 这是你加入的第一个宏包！快来compile一下看看有什么变化吧！</span><br></code></pre></td></tr></table></figure><p><img src="/posts/LaTeX-tutorial/image_13.png" alt="Indient"></p><p>你会发现，第一段也缩进啦！</p></li><li><p><strong>换行</strong>：</p><ul><li><p>第一个雷点：<strong>在源代码中换行并不代表真的换行了！</strong>比如第一个is this a new paragraph和Hello, this is a test file.分属两行，但他们实际输出上只在一行上面。</p></li><li><p>最简单的换行方法：<strong>直接在段落中添加一个空行，即按下两个回车键</strong>，这样就能成功实现换行。</p><p><strong>以下内容新手自动跳过！</strong></p></li><li><p>使用<code>\\</code>换行，一种更紧凑的写法（但有风险）</p></li></ul><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs LaTeX">This is the first line.<span class="hljs-keyword">\\</span><br>This is the second line.<br></code></pre></td></tr></table></figure><ul><li>其他换行方法：都是通过一些命令实现，可以作补充了解</li></ul><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs latex">This is the first line.<br><span class="hljs-keyword">\newline</span><br>This is the second line.<br><span class="hljs-comment">% 类比的，你应该就知道命令</span><br><span class="hljs-keyword">\newpage</span><br><span class="hljs-comment">% 是什么意思了吧！</span><br></code></pre></td></tr></table></figure><p>注意，使用<code>\\</code>和<code>\newline</code>进行强制换行时，两行之间没有额外的垂直间距！格式会有差异，<strong>建议非必要不要使用强制换行符</strong>。</p><p><img src="/posts/LaTeX-tutorial/image_14.png" alt="Using Newline Carefully"></p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-comment">% 一些补充命令：</span><br><br><span class="hljs-comment">%有垂直间距的换行</span><br>This is the first line.<br><span class="hljs-keyword">\vspace</span>&#123;1cm&#125;<br><br>This is the second line.<br><br><span class="hljs-comment">%无垂直间距的换行</span><br>This is the first line.<br><span class="hljs-keyword">\noindent</span><br><br>This is the second line without extra space.<br><br></code></pre></td></tr></table></figure><p><img src="/posts/LaTeX-tutorial/image_15.png" alt="Some advanced techniques"></p></li></ul></li><li><p><code>enumerate</code></p><ul><li>中文翻译“枚举”，用于文章中生成小标号，不作为小标题出现</li></ul><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\section</span>&#123;Part22&#125;<br><span class="hljs-keyword">\begin</span>&#123;enumerate&#125;<br>    <span class="hljs-keyword">\item</span> this is the firrst point<br>    <span class="hljs-keyword">\item</span> this is the 2nd points<br><span class="hljs-keyword">\end</span>&#123;enumerate&#125;<br><span class="hljs-comment">% 注意一个begin对应一个end，不然会报错！</span><br></code></pre></td></tr></table></figure><p><img src="/posts/LaTeX-tutorial/image_16.png" alt="Enumerate"></p><ul><li>可以和一些指令搭配使用，例如加粗<code>\textbf&#123;&#125;</code>等等。</li></ul></li><li><p>文本美化：</p><blockquote><p>这里的命令都是比较简单的，大家可以自行尝试~</p></blockquote><ul><li>加粗命令</li></ul><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\textbf</span>&#123;This text is bold.&#125;<br></code></pre></td></tr></table></figure><ul><li>斜线命令</li></ul><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\textit</span>&#123;This text is italic.&#125;<br></code></pre></td></tr></table></figure><ul><li>下划线命令</li></ul><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\underline</span>&#123;This text is underlined.&#125;<br></code></pre></td></tr></table></figure><ul><li>等宽字体</li></ul><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\texttt</span>&#123;This text is in typewriter font.&#125;<br></code></pre></td></tr></table></figure></li></ul><p>​<strong>Congratulations！到现在为止，你已经能够处理一篇最基本的latex的90%的内容了！你学习了如何编辑正文中的文字部分（这常常占了文章的大头，不是吗？）</strong></p><p>​接下来的旅程会变的更复杂，也更有趣，我们将继续向我们的latex中添加更多有趣的东西！</p><h4 id="3-4-3-正文部分②——图片和图表"><a href="#3-4-3-正文部分②——图片和图表" class="headerlink" title="3.4.3 正文部分②——图片和图表"></a>3.4.3 正文部分②——图片和图表</h4><p>​数据可视化在一篇论文中是非常重要的。因此，你需要再适当的位置添加你的图表！</p><ul><li>插入图片</li><li>插入统计图</li><li>插入统计表</li></ul><h4 id="3-4-4-正文部分③——数学公式"><a href="#3-4-4-正文部分③——数学公式" class="headerlink" title="3.4.4 正文部分③——数学公式"></a>3.4.4 正文部分③——数学公式</h4><h2 id="4-LaTeX精进"><a href="#4-LaTeX精进" class="headerlink" title="4 LaTeX精进"></a>4 LaTeX精进</h2><h3 id="4-1-坏了，报错了！"><a href="#4-1-坏了，报错了！" class="headerlink" title="4.1 坏了，报错了！"></a>4.1 坏了，报错了！</h3><h3 id="4-2-导入特定的宏包"><a href="#4-2-导入特定的宏包" class="headerlink" title="4.2 导入特定的宏包"></a>4.2 导入特定的宏包</h3><h3 id="4-3-Advanced-Methods"><a href="#4-3-Advanced-Methods" class="headerlink" title="4.3 Advanced Methods"></a>4.3 Advanced Methods</h3><h3 id="4-4-自定义？"><a href="#4-4-自定义？" class="headerlink" title="4.4 自定义？"></a>4.4 自定义？</h3><h3 id="4-5-网站指南"><a href="#4-5-网站指南" class="headerlink" title="4.5 网站指南"></a>4.5 网站指南</h3><h2 id="5-Conclusion-and-Outlook"><a href="#5-Conclusion-and-Outlook" class="headerlink" title="5 Conclusion and Outlook"></a>5 Conclusion and Outlook</h2><p>（2024.11.22）笔者累啦，之后会更新的！</p>]]></content>
    
    
    <categories>
      
      <category>Efficient Tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tutorial</tag>
      
      <tag>LaTeX</tag>
      
      <tag>Updating</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Life-musings</title>
    <link href="/posts/Life-musings/"/>
    <url>/posts/Life-musings/</url>
    
    <content type="html"><![CDATA[<h1 id="Life-Musings"><a href="#Life-Musings" class="headerlink" title="Life-Musings"></a>Life-Musings</h1><p><strong>生活随想录</strong></p><h2 id="2024-11-19"><a href="#2024-11-19" class="headerlink" title="2024.11.19"></a>2024.11.19</h2><p>第一篇文章！</p><h2 id="2024-12-4"><a href="#2024-12-4" class="headerlink" title="2024.12.4"></a>2024.12.4</h2><p>数分期中考试</p><p>好难好难呜呜呜</p><h2 id="2024-12-18"><a href="#2024-12-18" class="headerlink" title="2024.12.18"></a>2024.12.18</h2><p>临近期末周，workload确实上来了。</p><p>心心念念一学期的导师分配终于尘埃落定了，也算是分配上心仪的导师了。欣喜之中又带着一点焦虑…</p><p>之后继续努力吧~</p>]]></content>
    
    
    
    <tags>
      
      <tag>life</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/posts/hello-world/"/>
    <url>/posts/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
  
  
  <entry>
    <title>resume</title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[<div class="markdown-body">    Hello, I'm Xiyuan Yang!    </div>]]></content>
    
  </entry>
  
  
  
  <entry>
    <title>above</title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[<div class="markdown-body"><h1 id="Welcome-To-My-Blog"><a href="#Welcome-To-My-Blog" class="headerlink" title="Welcome To My Blog !"></a>Welcome To My Blog !</h1><h2 id="Before-The-Blog"><a href="#Before-The-Blog" class="headerlink" title="Before The Blog"></a>Before The Blog</h2><p>三个月前，我通过偶然的机会了解到前 OpenAI 研究副总裁，主管GPT模型安全的杰出华人女性，<strong>翁荔(Lilian Weng)<strong>。她提出了著名的</strong>Agent 配方：Agent&#x3D;LLM+Memory+planning skills+tool use</strong>。在当今的GPT时代，她可谓是功不可没。</p><p>在OpenAI对她的独家专访<a href="https://openai.com/index/the-power-of-continuous-learning/">The power of continuous learning</a>中，她提到：</p><blockquote><p>I believe in the power of learning and it is never too late to learn. Maintaining my personal blog is a good way to keep this curiosity going and learn about new progress in the deep learning community regularly. I also encourage my team to keep on learning, whether related or unrelated to their current projects. Ideas in different topics or fields can often inspire new ideas and broaden the potential solution space.</p><p>I’m also a strong believer in teamwork. If everyone shines in their best strength, we will get 1+1 &gt; 2. Meanwhile, we might often run into “dirty” work and personally I’m very willing to take on those tasks, because as long as that’s the biggest blocker or that task can add the biggest value into the project, nothing should be considered “dirty” or “trivial.” I encourage people around me to do the same, being a team player and working together to expedite the team productivity.</p><p>我相信学习的力量，学习永远不会太迟。维护个人博客是一个保持好奇心，定期了解深度学习社区新进展的好方法。我也鼓励我的团队不断学习，无论是否与他们当前的项目相关。不同主题或领域的想法常常能激发新的灵感，并拓宽潜在的解决方案空间。</p><p>我也是团队合作的坚定信徒。如果每个人都能在自己最擅长的领域发光，我们就能实现1+1大于2。同时，我们可能会碰到一些“脏活”，而我个人非常愿意承担这些任务，因为只要那是最大的障碍，或者那项任务能为项目带来最大的价值，就没有什么是“脏活”或“琐事”。我鼓励周围的人也这样做，成为团队的一员，共同努力提高团队的生产力。</p></blockquote><p><img src="https://images.ctfassets.net/kftzwdyauwt9/e3357d5a-b177-4b3a-1edf79a7f2dc/ca1f3418cd72b4eb84c9d1a09dfffc7f/stangel-2022-0421.jpg?w=3840&q=90&fm=webp" alt="Lilian Weng&#39;s interview"></p><p>图源：<a href="https://openai.com/index/the-power-of-continuous-learning/">The power of continuous learning | OpenAI</a>   Photo: Jake Stangel</p><blockquote><p>PS：这个姐姐好漂亮~</p></blockquote><p>这与<strong>费曼学习法（Feynman Technique）</strong>可谓是不谋而合：</p><blockquote><p>1.Identify the subject. Write down everything you know about the topic.</p><p>2.Teach it to a child. If you can teach a concept to a child, you’re way ahead of the game.</p><p>3.Identify your knowledge gaps. This is the point where the real learning happens.</p><p>4.Organize + simplify + Tell a story. Start to tell your story.</p></blockquote><p>此时，刚刚步入大学校园3个月的笔者，由于深受高中优绩主义和应试思想的遗风荼毒，对大学生活和计算机学科的学习颇具不适应的疲态。学习的知识如此海量，却无法依靠应试和做题进行巩固，该如何是好？</p><p>或许<strong>上文已经给出了答案。</strong></p><center><p><font size=6><b><p style="color:red;">我要创建自己的博客!</p></b></font></p></center><p>无论是传统的做题刷卷，还是博客，亦或是“费曼学习法”，本质上都是<strong>强化训练人脑在吸收新知识后的有效输出过程</strong>：当你能很流畅地给出一道数学题的若干种证明方法时，能逻辑清晰地将所学的知识穿成逻辑链条或思维导图，呈现在博客中为他人所吸收时，你便通过<strong>有效的对外做功输出</strong>很好地巩固了所学的知识。同时，知识的不断沉淀也带来了莫大的成就感。</p><p>但是，写一篇博客，可不仅仅是打打字那么简单。</p><p>不知各位在高中写议论文的时候有没有一种“咬牙切齿”的感觉，就是<strong>我想到的≠我实际构思好的≠我输出的≠我希望所表达的</strong>，甚至于，很多时候我们心中所谓的灵感只是<strong>乍现的只言片语的碎片</strong>，距离成为一篇逻辑清晰，内容详实且有创新性的博客文章还有很长的路要走。这便是博客写作的难点，也是<strong>我希望通过个人博客来训练的最重要的内容：将心里的灵感进行有效的输出，力求逻辑性和学术的专业性。</strong></p><h2 id="About-the-Blog"><a href="#About-the-Blog" class="headerlink" title="About the Blog"></a>About the Blog</h2><p><strong>Xiyuan Yang’s Blog</strong>，创建于<strong>2024年11月19日</strong>。</p><p>以下是自我简介（摘自<a href="https://xiyuanyang-code.github.io/about/">About - Xiyuan Yang’s Blog</a>）：</p><blockquote><p>Greetings! I am <strong>Xiyuan Yang (杨希渊)</strong>, currently pursuing an undergraduate degree in Artificial Intelligence at Shanghai Jiao Tong University. With a longstanding aspiration to become a programmer, I am passionate about leveraging technology to make a meaningful impact on the world. Through my personal website, I aim to share a collection of my blogs and learning notes with you. Some of these entries will be presented as a series, updated at irregular intervals. Additionally, I will offer insights into my personal observations and reflections on life. I hope your visit here is both enjoyable and enriching!</p></blockquote><blockquote><p><strong>My email:</strong></p><ul><li><p><a href="mailto:xiyuan__yang@outlook.com">xiyuan__yang@outlook.com</a></p></li><li><p><a href="mailto:yangxiyuan@sjtu.edu.cn">yangxiyuan@sjtu.edu.cn</a></p><p>Feel free to contact me!</p></li></ul></blockquote><blockquote><p>VENI VIDI VICI</p></blockquote><p>这个博客的更新内容将随着笔者后续的专业课程的学习同步进行，<strong>旨在分享笔者在学习过程中学到的有意思的专业知识，力求在博客输出的过程中培养自己的逻辑思维和表达能力</strong>，不过更新时间，更新内容，更新篇幅<strong>将会完全随机</strong>。</p><p>本博客部署在github的静态网站上，轮子使用<code>Hexo</code>的<code>Fluid</code>的模版，配置环境还是比较简单的，下面贴出一些相关的网址，有相同爱好的童鞋可以参考借鉴一下：</p><ul><li><a href="https://github.com/xiyuanyang-code">xiyuanyang-code (Xiyuan Yang)我的Github主页</a></li><li><a href="https://github.com/xiyuanyang-code/xiyuanyang-code.github.io">xiyuanyang-code&#x2F;xiyuanyang-code.github.io我的博客Github仓库</a></li><li><a href="https://github.com/fluid-dev/hexo-theme-fluid">fluid-dev&#x2F;hexo-theme-fluid-Design theme for Hexo Fluid的Github官方仓库</a></li><li><a href="https://fluid-dev.github.io/hexo-fluid-docs/guide/">配置指南 | Hexo Fluid 用户手册</a></li><li><a href="https://fluid-dev.github.io/hexo-fluid-docs/start/">开始使用 | Hexo Fluid 用户手册</a></li></ul><p>有关博客的具体更新内容，请详见<code>Goals and Plans of Updates</code>部分~</p><h2 id="Goals-and-Plans-of-Updates"><a href="#Goals-and-Plans-of-Updates" class="headerlink" title="Goals and Plans of Updates"></a>Goals and Plans of Updates</h2><h3 id="更新的主要内容"><a href="#更新的主要内容" class="headerlink" title="更新的主要内容"></a>更新的主要内容</h3><p>笔者更新的主要内容包括：（<strong>草拟</strong>）</p><ul><li>编程语言的语法学习<ul><li>C&#x2F;C++</li><li>Python<ul><li>语法</li><li>Anaconda</li><li>一些常见的库</li></ul></li><li>HTML&#x2F;Javascript</li><li>Bash&#x2F;Shell</li></ul></li><li>一些常用的工具教程<ul><li>LaTeX</li><li>命令行</li><li>Git</li><li>Vim编辑器</li><li>Linux和服务器（主要和深度学习相关）<ul><li>Linux常见命令</li><li>Tmux</li><li>SSH远程连接</li></ul></li></ul></li><li>[CS]算法<ul><li>数据结构</li><li>算法</li><li>计算机四大件</li></ul></li><li>AI专业课<ul><li>机器学习</li><li>强化学习</li><li>深度学习<ul><li>Pytorch</li></ul></li></ul></li><li>AI前沿&amp;经典论文精读</li><li><del>一些晦涩难懂的</del>数学课</li><li>发发牢骚</li></ul><h3 id="具体的分类（实时更新）"><a href="#具体的分类（实时更新）" class="headerlink" title="具体的分类（实时更新）"></a>具体的分类（实时更新）</h3><ul><li><strong>Code</strong></li><li><strong>Math</strong></li><li><strong>Efficient Tools</strong></li><li><strong>Algorithm</strong></li><li><strong>Frontier and Classic Papers in AI</strong></li><li><strong>AI Core Courses</strong></li></ul><h3 id="具体的标签（实时更新）"><a href="#具体的标签（实时更新）" class="headerlink" title="具体的标签（实时更新）"></a>具体的标签（实时更新）</h3><p>见 <a href="https://xiyuanyang-code.github.io/tags/">Tags</a> 页。</p><h2 id="Several-Pages"><a href="#Several-Pages" class="headerlink" title="Several Pages"></a>Several Pages</h2><p>以下是对本博客若干基本页面的介绍：</p><ul><li><h4 id="Home"><a href="#Home" class="headerlink" title="Home"></a>Home</h4></li><li><h4 id="Intro（你现在在的地方）"><a href="#Intro（你现在在的地方）" class="headerlink" title="Intro（你现在在的地方）"></a><strong>Intro</strong>（你现在在的地方）</h4></li><li><h4 id="Archives（文章）"><a href="#Archives（文章）" class="headerlink" title="Archives（文章）"></a>Archives（文章）</h4></li><li><h4 id="Categories（分类页）"><a href="#Categories（分类页）" class="headerlink" title="Categories（分类页）"></a>Categories（分类页）</h4></li><li><h4 id="Tags（标签页）"><a href="#Tags（标签页）" class="headerlink" title="Tags（标签页）"></a>Tags（标签页）</h4></li><li><h4 id="About（关于作者）"><a href="#About（关于作者）" class="headerlink" title="About（关于作者）"></a>About（关于作者）</h4></li><li><h4 id="FAQ（一些常见的问题）"><a href="#FAQ（一些常见的问题）" class="headerlink" title="FAQ（一些常见的问题）"></a>FAQ（一些常见的问题）</h4></li><li><h4 id="Resume（Academic-CV-of-the-Author）"><a href="#Resume（Academic-CV-of-the-Author）" class="headerlink" title="Resume（Academic CV of the Author）"></a>Resume（<strong>Academic CV of the Author</strong>）</h4></li></ul><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p><a href="https://github.com/lilianweng">lilianweng (Lilian)的github主页</a></p><p> <a href="https://lilianweng.github.io/">Lil’Log（翁荔的博客）</a></p><p><a href="https://openai.com/index/the-power-of-continuous-learning/">The power of continuous learning | OpenAI</a></p><p><a href="https://github.com/xiyuanyang-code">https://github.com/xiyuanyang-code</a></p><p><a href="https://github.com/xiyuanyang-code/xiyuanyang-code.github.io">https://github.com/xiyuanyang-code/xiyuanyang-code.github.io</a></p><center><p><font size=6><b>欢迎大家常常来玩~&#128512&#128516&#128513</p></font></p></center><div/>]]></content>
    
  </entry>
  
  
  
  <entry>
    <title>about</title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[<p>Greetings! I am <strong>Xiyuan Yang (杨希渊)</strong>, currently pursuing an undergraduate degree in Artificial Intelligence at Shanghai Jiao Tong University. With a longstanding aspiration to become a programmer, I am passionate about leveraging technology to make a meaningful impact on the world. Through my personal website, I aim to share a collection of my blogs and learning notes with you. Some of these entries will be presented as a series, updated at irregular intervals. Additionally, I will offer insights into my personal observations and reflections on life. I hope your visit here is both enjoyable and enriching!</p><p><strong>My email:</strong></p><ul><li><p><a href="mailto:&#x78;&#x69;&#121;&#117;&#97;&#110;&#95;&#95;&#x79;&#97;&#x6e;&#x67;&#64;&#111;&#117;&#116;&#108;&#x6f;&#111;&#x6b;&#46;&#x63;&#111;&#x6d;">&#x78;&#x69;&#121;&#117;&#97;&#110;&#95;&#95;&#x79;&#97;&#x6e;&#x67;&#64;&#111;&#117;&#116;&#108;&#x6f;&#111;&#x6b;&#46;&#x63;&#111;&#x6d;</a></p></li><li><p><a href="mailto:&#121;&#x61;&#110;&#x67;&#x78;&#x69;&#x79;&#x75;&#97;&#110;&#x40;&#115;&#x6a;&#116;&#117;&#46;&#101;&#x64;&#x75;&#46;&#99;&#110;">&#121;&#x61;&#110;&#x67;&#x78;&#x69;&#x79;&#x75;&#97;&#110;&#x40;&#115;&#x6a;&#116;&#117;&#46;&#101;&#x64;&#x75;&#46;&#99;&#110;</a></p><p>Feel free to contact me!</p></li></ul><blockquote><p>VENI VIDI VICI</p></blockquote>]]></content>
    
  </entry>
  
  
  
  <entry>
    <title>FAQ</title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[<div class="markdown-body"><center><p><font size=6><b>FAQ~&#128512&#128516&#128513</b></p></font></p></center><p><strong>Found some issues or bugs in the blog? Feel free to contact the author.</strong></p><p><strong>My email:</strong></p><ul><li><p><a href="mailto:xiyuan__yang@outlook.com">xiyuan__yang@outlook.com</a></p></li><li><p><a href="mailto:yangxiyuan@sjtu.edu.cn">yangxiyuan@sjtu.edu.cn</a></p></li></ul><h1 id="FAQs"><a href="#FAQs" class="headerlink" title="FAQs"></a>FAQs</h1><h2 id="全是烂尾文章？"><a href="#全是烂尾文章？" class="headerlink" title="全是烂尾文章？"></a>全是烂尾文章？</h2><p>呜呜呜别骂了。。。博客的更新真的好花时间。。。一般来说，笔者会努力把前面的就坑全部填上再开新坑哒。</p><ul><li>一般在<code>Home</code>页写好摘要，设置好封面，Tags中标上<code>Finished</code>的文章就是已经完成不会大改的文章，可放心食用~</li><li>如果Tags标注是<code>Updating</code>，一般是一些声明性的文章，表示内容会时不时地更新。</li><li>如果是光秃秃的一片，说明亟需完工。🤡🤡🤡</li></ul><h2 id="关于评论系统"><a href="#关于评论系统" class="headerlink" title="关于评论系统"></a>关于评论系统</h2><p>评论系统算是笔者踩过的大坑之一，前后换了四五个评论系统，最后选择了强大的<code>giscus</code>提供支持。</p><p>相关网站：<a href="https://giscus.app/zh-CN">Giscus</a></p><p><strong>有关评论系统的使用：</strong></p><ul><li><p>需要自己的github账号</p><ul><li><a href="https://giscus.app/zh-CN">Giscus</a>的网站好像会被墙，导致评论区加载失败，请自行解决。</li></ul></li><li><p>之后使用就和正常的评论区没什么区别了，轻点喷~</p></li><li><p>相关的评论内容可以在我博客仓库的 <a href="https://github.com/xiyuanyang-code/xiyuanyang-code.github.io/discussions">Discussion</a> 页面找到。</p></li><li><p>目前只有文章页可以发表评论哦，有什么奇奇怪怪的问题可以给我发 <a href="https://github.com/xiyuanyang-code/xiyuanyang-code.github.io/issues">issue</a> 或者email 我。</p></li><li><p><strong>好像手机端没办法发表评论（我也不知道为什么）。</strong></p></li></ul><h2 id="更新频率？更新内容？"><a href="#更新频率？更新内容？" class="headerlink" title="更新频率？更新内容？"></a>更新频率？更新内容？</h2><p><a href="https://xiyuanyang-code.github.io/above/">参见这里</a></p><h2 id="有关博客的照片"><a href="#有关博客的照片" class="headerlink" title="有关博客的照片"></a>有关博客的照片</h2><p>在博客正文中使用的图片都会储存在<strong>图床</strong>中（除了引用别人的图片），网站 <strong><a href="https://img.tg/yangxiyuan/albums">IMG.TG</a></strong></p><blockquote><p>最后引用一下我的偶像的博客的FAQ的最后一个问题：</p><p>相关网址：<a href="https://lilianweng.github.io/faq/">lilianweng</a></p><p><strong>Q: How can you keep up blogging?</strong></p><p><strong>A:</strong> “Pain is inevitable but suffering is optional” — this is the first sentence of Haruki Murakami’s book <a href="https://www.goodreads.com/book/show/2195464.What_I_Talk_About_When_I_Talk_About_Running">“What I Talk About When I Talk About Running”</a>. I love that book. His altitude towards running is pretty much aligned with how I feel about maintaining this blog.</p></blockquote><div/><hr><h1 id="English-Version-FAQs"><a href="#English-Version-FAQs" class="headerlink" title="English Version FAQs"></a>English Version FAQs</h1><h2 id="Are-all-your-posts-incomplete"><a href="#Are-all-your-posts-incomplete" class="headerlink" title="Are all your posts incomplete?"></a>Are all your posts incomplete?</h2><p>Please don’t scold me… 😭 Maintaining and updating a blog takes a lot of time. Generally, I strive to finish old posts before starting new ones.</p><ul><li>Posts marked with <code>Finished</code> in the <em>Tags</em> section on the <code>Home</code> page, along with summaries and cover images, are complete and won’t undergo major changes. Feel free to enjoy them with peace of mind!</li><li>Posts marked with <code>Updating</code> in <em>Tags</em> are generally declarative in nature and are updated from time to time.</li><li>If a post has no tags at all, it’s a work in urgent need of completion. 🤡🤡🤡</li></ul><h2 id="About-the-Comment-System"><a href="#About-the-Comment-System" class="headerlink" title="About the Comment System"></a>About the Comment System</h2><p>The comment system has been one of the biggest challenges I’ve faced. After trying four or five systems, I finally settled on the robust support provided by <code>giscus</code>.</p><p>Relevant website: <a href="https://giscus.app/zh-CN">Giscus</a></p><p><strong>How to use the comment system:</strong></p><ul><li><p>You need your own GitHub account </p><ul><li>The <a href="https://giscus.app/">Giscus</a> website seems to be blocked, causing the comment section to fail to load. Please resolve this issue independently.</li></ul></li><li><p>Once logged in, using the comment section is no different from a regular comments platform—please be gentle with your critiques. 😉</p></li><li><p>Comments are linked to the <a href="https://github.com/xiyuanyang-code/xiyuanyang-code.github.io/discussions">Discussions</a> page in my blog’s GitHub repository.</p></li><li><p>Currently, only article pages allow comments. For unusual issues, you can send me an <a href="https://github.com/xiyuanyang-code/xiyuanyang-code.github.io/issues">issue</a> or email me.</p></li><li><p><strong>It seems that comments don’t work on mobile devices (I have no idea why).</strong></p></li></ul><h2 id="How-often-do-you-update-What-do-you-post"><a href="#How-often-do-you-update-What-do-you-post" class="headerlink" title="How often do you update? What do you post?"></a>How often do you update? What do you post?</h2><p><a href="https://xiyuanyang-code.github.io/above/">See this page</a> for more details.</p><h2 id="Pictures"><a href="#Pictures" class="headerlink" title="Pictures"></a>Pictures</h2><p>All images used in the body of the blog will be stored on the <strong>image hosting platform</strong> (except for images referenced from others), on the website <strong><a href="https://img.tg/yangxiyuan/albums">IMG.TG</a></strong>.</p><blockquote><p>Finally, here’s a quote from my idol’s FAQ page:</p><p>Relevant website: <a href="https://lilianweng.github.io/faq/">lilianweng</a></p><p><strong>Q: How can you keep up blogging?</strong></p><p><strong>A:</strong> “Pain is inevitable but suffering is optional” — This is the first sentence of Haruki Murakami’s book <a href="https://www.goodreads.com/book/show/2195464.What_I_Talk_About_When_I_Talk_About_Running">“What I Talk About When I Talk About Running”</a>. I love that book. His attitude toward running aligns closely with how I feel about maintaining this blog.</p></blockquote>]]></content>
    
  </entry>
  
  
  
</search>
