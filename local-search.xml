<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Class-Inheritance</title>
    <link href="/posts/Class-Inheritance/"/>
    <url>/posts/Class-Inheritance/</url>
    
    <content type="html"><![CDATA[<h1 id="C-Primer-Plus-Tutorial-13"><a href="#C-Primer-Plus-Tutorial-13" class="headerlink" title="C++ Primer Plus Tutorial-13"></a>C++ Primer Plus Tutorial-13</h1><center><p style="color: red;"><b><font size=6.5>Chapter 13 Class Inheritance</font></b></p></center><center><p style="color: red;"><b><font size=6.5>类的继承</font></b></p></center><p>【写在前面的话】</p><p><a href="https://xiyuanyang-code.github.io/posts/C-Primer-Plus-tutorial/">C++ Primer Plus Tutorial</a></p><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>在程序设计中，代码的重用是非常重要的，这一点在面向对象编程也不例外。一种最简单的“代码重用”是最简单的<code>Ctrl-C,Ctrl-V</code>程序员，手动修改代码实现重用（乐）。那么，我们如何在不修改代码的基础上实现代码（对于OOP而言，主要是类和对象）的重用呢？这便是<strong>类的继承</strong>：从已有的类（基类）将特征和方法继承给一个新的类（派生类）。同时，类的继承也保证了安全性，派生类可以提供新特性，甚至不需要访问源代码就可以派生出类，实现<strong>数据的封装</strong>。（这不正是OOP的核心和精髓吗）</p><p>接下来的一章，让我们走进类继承的世界。</p><p>在这章你将学到：</p><p>- </p><h2 id="Example-Base-class-and-derived-class"><a href="#Example-Base-class-and-derived-class" class="headerlink" title="Example: Base class and derived class"></a>Example: Base class and derived class</h2><p>文章首先给出一个比较简单的基类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// tabtenn0.h -- a table-tennis base class</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> TABTENN0_H_</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TABTENN0_H_</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> std::string;<br><span class="hljs-comment">// simple base class</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TableTennisPlayer</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>    string firstname;<br>    string lastname;<br>    <span class="hljs-type">bool</span> hasTable;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">TableTennisPlayer</span> (<span class="hljs-type">const</span> string &amp; fn = <span class="hljs-string">&quot;none&quot;</span>,<span class="hljs-type">const</span> string &amp; ln = <span class="hljs-string">&quot;none&quot;</span>, <span class="hljs-type">bool</span> ht = <span class="hljs-literal">false</span>);<br>    <span class="hljs-comment">//默认构造函数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Name</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-comment">//输出会员的姓名</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">HasTable</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> hasTable; &#125;;<br>    <span class="hljs-comment">//判断会员是否有球桌</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ResetTable</span><span class="hljs-params">(<span class="hljs-type">bool</span> v)</span> </span>&#123; hasTable = v; &#125;;<br>    <span class="hljs-comment">//重设球桌状态</span><br>&#125;;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//tabtenn0.cpp -- simple base-class methods</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;tabtenn0.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br>TableTennisPlayer::<span class="hljs-built_in">TableTennisPlayer</span> (<span class="hljs-type">const</span> string &amp; fn, <br>    <span class="hljs-type">const</span> string &amp; ln, <span class="hljs-type">bool</span> ht) : <span class="hljs-built_in">firstname</span>(fn),<span class="hljs-built_in">lastname</span>(ln), <span class="hljs-built_in">hasTable</span>(ht) &#123;&#125;<br>    <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TableTennisPlayer::Name</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>    std::cout &lt;&lt; lastname &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; firstname;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// usett0.cpp -- using a base class</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;tabtenn0.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">( <span class="hljs-type">void</span> )</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">using</span> std::cout;<br>    <span class="hljs-function">TableTennisPlayer <span class="hljs-title">player1</span><span class="hljs-params">(<span class="hljs-string">&quot;Chuck&quot;</span>, <span class="hljs-string">&quot;Blizzard&quot;</span>, <span class="hljs-literal">true</span>)</span></span>;<br>    <span class="hljs-function">TableTennisPlayer <span class="hljs-title">player2</span><span class="hljs-params">(<span class="hljs-string">&quot;Tara&quot;</span>, <span class="hljs-string">&quot;Boomdea&quot;</span>, <span class="hljs-literal">false</span>)</span></span>;<br>    player<span class="hljs-number">1.</span><span class="hljs-built_in">Name</span>();<br>    <span class="hljs-keyword">if</span> (player<span class="hljs-number">1.</span><span class="hljs-built_in">HasTable</span>())<br>        cout &lt;&lt; <span class="hljs-string">&quot;: has a table.\n&quot;</span>;<br>    <span class="hljs-keyword">else</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;: hasn&#x27;t a table.\n&quot;</span>;<br>    player<span class="hljs-number">2.</span><span class="hljs-built_in">Name</span>();<br>    <span class="hljs-keyword">if</span> (player<span class="hljs-number">2.</span><span class="hljs-built_in">HasTable</span>())<br>        cout &lt;&lt; <span class="hljs-string">&quot;: has a table&quot;</span>;<br>    <span class="hljs-keyword">else</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;: hasn&#x27;t a table.\n&quot;</span>;<br>    <span class="hljs-comment">// std::cin.get();</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>现在，我要在这个类的基础之上派生出一个新的类，来记录乒乓球运动员在比赛中的得分。</p><p>先来看写好的头文件，再来逐行解析：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// tabtenn1.h -- a table-tennis base class</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> TABTENN1_H_</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TABTENN1_H_</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> std::string;<br><span class="hljs-comment">// simple base class</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TableTennisPlayer</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>    string firstname;<br>    string lastname;<br>    <span class="hljs-type">bool</span> hasTable;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">TableTennisPlayer</span> (<span class="hljs-type">const</span> string &amp; fn = <span class="hljs-string">&quot;none&quot;</span>,<span class="hljs-type">const</span> string &amp; ln = <span class="hljs-string">&quot;none&quot;</span>, <span class="hljs-type">bool</span> ht = <span class="hljs-literal">false</span>);<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Name</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">HasTable</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> hasTable; &#125;;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ResetTable</span><span class="hljs-params">(<span class="hljs-type">bool</span> v)</span> </span>&#123; hasTable = v; &#125;;<br>&#125;;<br><br><span class="hljs-comment">// simple derived class</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RatedPlayer</span> : <span class="hljs-keyword">public</span> TableTennisPlayer<br>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> rating;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">RatedPlayer</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> r = <span class="hljs-number">0</span>, <span class="hljs-type">const</span> string &amp; fn = <span class="hljs-string">&quot;none&quot;</span>,<br>                 <span class="hljs-type">const</span> string &amp; ln = <span class="hljs-string">&quot;none&quot;</span>, <span class="hljs-type">bool</span> ht = <span class="hljs-literal">false</span>);<br>    <span class="hljs-built_in">RatedPlayer</span>(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> r, <span class="hljs-type">const</span> TableTennisPlayer &amp; tp);<br>    <span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title">Rating</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> rating; &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ResetRating</span> <span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> r)</span> </span>&#123;rating = r;&#125;<br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br></code></pre></td></tr></table></figure><p>很容易的看出，<code>RatedPlayer</code>是从<code>TableTennisPlayer</code>派生出来的派生类。最基本的语法定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">RatedPlayer</span> : <span class="hljs-keyword">public</span> TableTennisPlayer<br>&#123;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-comment">//your Declaration here</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//your Declaration here</span><br>&#125;;<br><br></code></pre></td></tr></table></figure><p>冒号指出 <code>RatedPlayer</code> 类的基类是 <code>TableTennisplayer</code> 类。上述特殊的声明头表明 <code>TableTennisPlayer</code> 是一个<strong>公有基类</strong>，这被称为<strong>公有派生</strong>。<strong>派生类对象包含基类对象</strong>。使用公有派生，<strong>基类的公有成员将成为派生类的公有成员</strong>；<strong>基类的私有部分也将成为派生类的一部分</strong>，但只能通过基类的公有和保护方法访问（稍后将介绍保护成员）。</p><p><code>Ratedplayer</code>对象将具有以下特征：</p><ul><li>派生类对象存储了基类的数据成员（派生类继承了基类的实现）；</li><li>派生类对象可以使用基类的方法（派生类继承了基类的接口）。</li></ul><blockquote><p>派生类就像基类的“儿子”，子承父业，可以直接继承父亲的所有遗产。</p></blockquote><p>这是<strong>继承</strong>的部分，同时，派生类也可以实现自己的新方法和新成员，这也在3~6行的代码处定义。</p><ul><li>派生类<strong>需要</strong>自己的构造函数（<strong>这很重要！</strong>）</li><li>派生类可以添加额外的数据方法和数据成员。</li></ul><h3 id="派生类的构造函数：访问权限的考虑"><a href="#派生类的构造函数：访问权限的考虑" class="headerlink" title="派生类的构造函数：访问权限的考虑"></a>派生类的构造函数：访问权限的考虑</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">RatedPlayer</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> r = <span class="hljs-number">0</span>, <span class="hljs-type">const</span> string &amp; fn = <span class="hljs-string">&quot;none&quot;</span>,<br>             <span class="hljs-type">const</span> string &amp; ln = <span class="hljs-string">&quot;none&quot;</span>, <span class="hljs-type">bool</span> ht = <span class="hljs-literal">false</span>);<br><span class="hljs-built_in">RatedPlayer</span>(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> r, <span class="hljs-type">const</span> TableTennisPlayer &amp; tp);<br></code></pre></td></tr></table></figure><p>上文代码是派生类中实现的两个构造函数，可以看出，构造函数要同时定义<strong>原有基类的数据成员和新添加的数据成员</strong>（第一个构造函数）。当然，偷懒一点也是可以的，可以在构造函数中使用到<strong>基类的对象</strong>（第二个构造函数）。</p><p>但是，构造函数的设计并不是像想象的那么简单。前文的<code>Introduction</code>讲过，派生类甚至可以在不访问基类的情况下实现继承。实际上，<strong>派生类不可以直接访问基类的私有成员，而必须通过基类定义的方法进行访问（和外部的函数一样，只能通过接口进行访问）</strong>，换句话来说，<strong>派生类构造函数必须使用基类构造函数</strong>。</p><h4 id="第一种构造函数"><a href="#第一种构造函数" class="headerlink" title="第一种构造函数"></a>第一种构造函数</h4><p>这点就显得非常矛盾了，因为从上文第一个构造函数的视角看过去，我们貌似<strong>给派生类的每一个私有成员提供了数据，貌似可以直接访问所有的私有成员，包括基类和派生类</strong>。实际上，并不是这样，下面我们来详细解释这一点。</p><p>我们更进一步，给出第一个构造函数的声明和定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//函数声明</span><br><span class="hljs-built_in">RatedPlayer</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> r = <span class="hljs-number">0</span>, <span class="hljs-type">const</span> string &amp; fn = <span class="hljs-string">&quot;none&quot;</span>, <span class="hljs-type">const</span> string &amp; ln = <span class="hljs-string">&quot;none&quot;</span>, <span class="hljs-type">bool</span> ht = <span class="hljs-literal">false</span>);<br><br><span class="hljs-comment">//函数定义</span><br>RatedPlayer::<span class="hljs-built_in">RatedPlayer</span>(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> r, <span class="hljs-type">const</span> string &amp; fn,<span class="hljs-type">const</span> string &amp; ln, <span class="hljs-type">bool</span> ht) : <span class="hljs-built_in">TableTennisPlayer</span>(fn, ln, ht)<br>&#123;<br>    rating = r;<br>&#125;<br></code></pre></td></tr></table></figure><p>在创建派生类对象时，程序首先会创建<strong>基类对象</strong>。因此，在使用派生类对象的构造函数时，对应的基类对象已经存在。</p><blockquote><p>这很好理解，儿子出生之前，爸爸肯定得出生。</p></blockquote><p>理解了这一点后，我们再来看函数的定义，我们会发现很独特的一行，<code>TableTennisPlayer(fn, ln, ht)</code>。这行代码叫<strong>成员初始化列表</strong>，是可执行的代码，用来调用基类<code>TableTennisPlayer</code>的构造函数。<code>fn, ln, ht</code>作为三个形式参数，接受实参并将其本身传递给<code>TableTennisPlayer</code>构造函数的形式参数，后者将创建一个<strong>嵌套的基类对象</strong>（先创建爸爸），接着，进入派生类函数的函数体，完成对派生类对象的创建。（再创建儿子）</p><p>如果省略了成员初始化列表，那么程序会调用<strong>默认的构造函数</strong>创建一个基类对象，而无法使用显式的构造函数，程序就无法读取到我们希望赋给对象的数据。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//没有成员初始化列表的情况</span><br>RatedPlayer::<span class="hljs-built_in">RatedPlayer</span>(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> r, <span class="hljs-type">const</span> string &amp; fn,<span class="hljs-type">const</span> string &amp; ln, <span class="hljs-type">bool</span> ht) : <br>&#123;<br>    rating = r;<br>&#125;<br><br><span class="hljs-comment">//与下面的代码等效</span><br>RatedPlayer::<span class="hljs-built_in">RatedPlayer</span>(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> r, <span class="hljs-type">const</span> string &amp; fn,<span class="hljs-type">const</span> string &amp; ln, <span class="hljs-type">bool</span> ht) : <br><span class="hljs-built_in">TableTennisPlayer</span>()<br><span class="hljs-comment">//使用无参数的默认构造函数</span><br>&#123;<br>    rating = r;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="第二种构造函数"><a href="#第二种构造函数" class="headerlink" title="第二种构造函数"></a>第二种构造函数</h4><p>接下来，我们来看第二种更加简洁的构造函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//函数声明</span><br><span class="hljs-built_in">RatedPlayer</span>(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> r, <span class="hljs-type">const</span> TableTennisPlayer &amp; tp);<br><br><span class="hljs-comment">//函数定义</span><br>RatedPlayer::<span class="hljs-built_in">RatedPlayer</span>(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> r, <span class="hljs-type">const</span> TableTennisPlayer &amp; tp)<br>    : <span class="hljs-built_in">TableTennisPlayer</span>(tp)<br>&#123;<br>        rating=r;<br>&#125;<br><br><span class="hljs-comment">//函数定义的等价形式</span><br>RatedPlayer::<span class="hljs-built_in">RatedPlayer</span>(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> r, <span class="hljs-type">const</span> TableTennisPlayer &amp; tp)<br>    : <span class="hljs-built_in">TableTennisPlayer</span>(tp), <span class="hljs-built_in">rating</span>(r)<br>&#123;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>来看这里的初始化成员列表，传入的参数是一个<code>const TableTennisPlayer &amp;</code>类型，因此，系统会调用默认的<strong>复制构造函数</strong>（这是个很有趣的问题，我们在<a href="https://xiyuanyang-code.github.io/posts/Dynamic-Memory-and-Classes/">第十二章</a>的时候重点讨论了，这里使用默认的复制构造函数是不会产生任何问题的）。</p><p>当然，我们也可以对<strong>派生类成员使用初始化列表</strong>，在这种情况下，应该使用成员名而不是类名。</p><blockquote><p>释放对象的顺序与创建对象的顺序相反，即首先执行派生类的析构函数，然后自动调用基类的析构函数。  </p></blockquote><div class="note note-success">            <p><strong>小总结</strong>： 创建派生类对象时，程序首先<strong>调用基类构造函数</strong>，然后再<strong>调用派生类构造函数</strong>。基类构造函数负责初始化继承的数据成员；派生类构造函数主要用于初始化新增的数据成员。派生类的构造函数总是调用一个基类构造函数。可以使用初始化器列表语法指明要使用的基类构造函数，否则将使用默认的基类构造函数。派生类对象过期时，程序将首先调用派生类析构函数，然后再调用基类析构函数。</p>          </div><p>现在，我们可以给出派生类的全部函数定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//tabtenn1.cpp -- simple base-class methods</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;tabtenn1.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br>TableTennisPlayer::<span class="hljs-built_in">TableTennisPlayer</span> (<span class="hljs-type">const</span> string &amp; fn, <br>    <span class="hljs-type">const</span> string &amp; ln, <span class="hljs-type">bool</span> ht) : <span class="hljs-built_in">firstname</span>(fn),<span class="hljs-built_in">lastname</span>(ln), <span class="hljs-built_in">hasTable</span>(ht) &#123;&#125;<br>    <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TableTennisPlayer::Name</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>    std::cout &lt;&lt; lastname &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; firstname;<br>&#125;<br><br><span class="hljs-comment">// RatedPlayer methods</span><br>RatedPlayer::<span class="hljs-built_in">RatedPlayer</span>(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> r, <span class="hljs-type">const</span> string &amp; fn,<br>    <span class="hljs-type">const</span> string &amp; ln, <span class="hljs-type">bool</span> ht) : <span class="hljs-built_in">TableTennisPlayer</span>(fn, ln, ht)<br>&#123;<br>    rating = r;<br>&#125;<br><br>RatedPlayer::<span class="hljs-built_in">RatedPlayer</span>(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> r, <span class="hljs-type">const</span> TableTennisPlayer &amp; tp)<br>    : <span class="hljs-built_in">TableTennisPlayer</span>(tp), <span class="hljs-built_in">rating</span>(r)<br>&#123;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="使用派生类"><a href="#使用派生类" class="headerlink" title="使用派生类"></a>使用派生类</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// usett1.cpp -- using base class and derived class</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;tabtenn1.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">( <span class="hljs-type">void</span> )</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">using</span> std::cout;<br>    <span class="hljs-keyword">using</span> std::endl;<br>    <span class="hljs-function">TableTennisPlayer <span class="hljs-title">player1</span><span class="hljs-params">(<span class="hljs-string">&quot;Tara&quot;</span>, <span class="hljs-string">&quot;Boomdea&quot;</span>, <span class="hljs-literal">false</span>)</span></span>;<br>    <span class="hljs-function">RatedPlayer <span class="hljs-title">rplayer1</span><span class="hljs-params">(<span class="hljs-number">1140</span>, <span class="hljs-string">&quot;Mallory&quot;</span>, <span class="hljs-string">&quot;Duck&quot;</span>, <span class="hljs-literal">true</span>)</span></span>;<br>    rplayer<span class="hljs-number">1.</span><span class="hljs-built_in">Name</span>();          <span class="hljs-comment">// derived object uses base method</span><br>    <span class="hljs-keyword">if</span> (rplayer<span class="hljs-number">1.</span><span class="hljs-built_in">HasTable</span>())<br>        cout &lt;&lt; <span class="hljs-string">&quot;: has a table.\n&quot;</span>;<br>    <span class="hljs-keyword">else</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;: hasn&#x27;t a table.\n&quot;</span>;<br>    player<span class="hljs-number">1.</span><span class="hljs-built_in">Name</span>();           <span class="hljs-comment">// base object uses base method</span><br>    <span class="hljs-keyword">if</span> (player<span class="hljs-number">1.</span><span class="hljs-built_in">HasTable</span>())<br>        cout &lt;&lt; <span class="hljs-string">&quot;: has a table&quot;</span>;<br>    <span class="hljs-keyword">else</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;: hasn&#x27;t a table.\n&quot;</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Name: &quot;</span>;<br>    rplayer<span class="hljs-number">1.</span><span class="hljs-built_in">Name</span>();<br>    cout &lt;&lt; <span class="hljs-string">&quot;; Rating: &quot;</span> &lt;&lt; rplayer<span class="hljs-number">1.</span><span class="hljs-built_in">Rating</span>() &lt;&lt; endl;<br><span class="hljs-comment">// initialize RatedPlayer using TableTennisPlayer object</span><br>    <span class="hljs-function">RatedPlayer <span class="hljs-title">rplayer2</span><span class="hljs-params">(<span class="hljs-number">1212</span>, player1)</span></span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Name: &quot;</span>;<br>    rplayer<span class="hljs-number">2.</span><span class="hljs-built_in">Name</span>();<br>    cout &lt;&lt; <span class="hljs-string">&quot;; Rating: &quot;</span> &lt;&lt; rplayer<span class="hljs-number">2.</span><span class="hljs-built_in">Rating</span>() &lt;&lt; endl;<br>    <span class="hljs-comment">// std::cin.get();</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="派生类和基类的特殊关系"><a href="#派生类和基类的特殊关系" class="headerlink" title="派生类和基类的特殊关系"></a>派生类和基类的特殊关系</h3><p>用形象的话说，派生类是儿子，继承自基类（爸爸）的方法和数据成员。但是，基类又有自己的“隐私”，派生类是能通过公共接口实现对基类的访问，即无法直接访问其私有成员。</p><blockquote><p>派生类相当于一种<strong>在定义和结构上</strong>获得“权限”的类，权限在于可以直接继承基类所定义好的成员和方法（在定义层面的<strong>继承</strong>），但是<strong>在操作上</strong>，派生类并没有从基类处获得任何特权，不能访问的还是不能访问。</p></blockquote><p>从这条出发，我们可以归纳派生类和基类之间的特殊关系：</p><ul><li>派生类对象可以使用基类的方法，条件是<strong>方法不是私有的</strong>。</li><li><strong>基类指针可以在不进行显示转换的情况下指向派生类对象。</strong></li><li><strong>基类引用可以在不进行显示转换的情况下引用派生类对象。</strong></li></ul><h4 id="基类指针可以在不进行显示转换的情况下指向派生类对象"><a href="#基类指针可以在不进行显示转换的情况下指向派生类对象" class="headerlink" title="基类指针可以在不进行显示转换的情况下指向派生类对象"></a>基类指针可以在不进行显示转换的情况下指向派生类对象</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base class&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Derived class&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Derived d;<br>    Base* basePtr = &amp;d; <span class="hljs-comment">// 基类指针指向派生类对象</span><br>    basePtr-&gt;<span class="hljs-built_in">display</span>(); <span class="hljs-comment">// 输出: Derived class (多态行为)</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="基类引用可以在不进行显示转换的情况下引用派生类对象。"><a href="#基类引用可以在不进行显示转换的情况下引用派生类对象。" class="headerlink" title="基类引用可以在不进行显示转换的情况下引用派生类对象。"></a>基类引用可以在不进行显示转换的情况下引用派生类对象。</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base class&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Derived class&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Derived d;<br>    Base&amp; baseRef = d; <span class="hljs-comment">// 基类引用绑定到派生类对象</span><br>    baseRef.<span class="hljs-built_in">display</span>(); <span class="hljs-comment">// 输出: Derived class (多态行为)</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><p>注意关键词<code>virtual</code>，之后会讲到，否则会发生静态绑定现象。</p></blockquote><div class="note note-warning">            <ul><li>基类指针和引用只能调用基类方法，而不可以调用派生类的方法。<ul><li>因为派生类允许添加新的数据成员，如果允许调用会产生很多奇怪的问题。</li></ul></li><li>基类指针和应用可以指向派生类的对象<ul><li><a href="https://blog.csdn.net/goodgoodstudy___/article/details/124905482">这篇讲的很清楚</a></li><li>这里涉及到一些有关虚函数的知识点，暂时先跳过。</li></ul></li><li><strong>基类对象也可以被初始化（或被赋值）为派生类对象</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">RatedPlayer <span class="hljs-title">player1</span><span class="hljs-params">(<span class="hljs-number">1840</span>,<span class="hljs-string">&quot;o1&quot;</span>,<span class="hljs-string">&quot;Loaf&quot;</span>,<span class="hljs-literal">true</span>)</span></span>;<br><span class="hljs-function">TableTennisPlayer <span class="hljs-title">player2</span><span class="hljs-params">(player1)</span></span>;    <span class="hljs-comment">//VALID</span><br></code></pre></td></tr></table></figure><p>可以用<strong>引用兼容性</strong>的属性来解释这个问题，调用基类的构造函数时不存在匹配的构造函数，故会调用隐式复制构造函数<code>TableTennisPlayer(const TableTennisPlayer&amp;)</code>，形参是<strong>对基类的引用</strong>，<strong>可以在不进行显式转换的</strong>情况下引用派生类对象<code>player1</code>。因此，复制构造函数将嵌套在<code>player1</code>基类中的<code>TableTennisPlayer</code>赋值给了<code>player2</code>。</p>          </div>]]></content>
    
    
    <categories>
      
      <category>Code</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tutorial</tag>
      
      <tag>C/C++</tag>
      
      <tag>OOP</tag>
      
      <tag>C++ Primer Plus</tag>
      
      <tag>Dynamic Memory</tag>
      
      <tag>Finished</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode-Mistake-collection</title>
    <link href="/posts/Leetcode-Mistake-collection/"/>
    <url>/posts/Leetcode-Mistake-collection/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Mistake-collection"><a href="#Leetcode-Mistake-collection" class="headerlink" title="Leetcode-Mistake-collection"></a>Leetcode-Mistake-collection</h1><p>笔者又来开新坑啦！</p><h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>在笔者刚刚步入大一时（也就是这学期），仗着自己暑假为数不多的C语言语法存货，觉得学校C++的课程进度有些落后，便在网上寻寻觅觅，想通过<strong>刷题</strong>的方式提升自己的代码水平。</p><p>当在网上搜索“新手小白刷编程题什么网站上最好”，十有八九跳出来的都是<strong>Leetcode</strong>。确实，<a href="https://leetcode.cn/">Leetcode</a>可以算作是数一数二优秀的编程训练网站了，各种界面设计也很符合我的审美。（就像他自己说的，<strong>全球极客挚爱的技术成长平台</strong>）。但是，对于当时习惯于把所有代码全部放进一个臃肿的<code>main</code>函数的我来说，Leetcode犹如一座高不可攀的山峰，好不容易弄懂了什么叫<strong>函数封装</strong>，竭尽全力也没办法做出 <a href="https://leetcode.cn/problems/two-sum/">第一道题</a>。🤡</p><p>之后在看 <a href="https://www.hello-algo.com/chapter_hello_algo/">Hello 算法</a>的时候在序言看到了一段感同身受的话：</p><blockquote><p>两眼一抹黑地刷题似乎是最受欢迎的方法，简单、直接且有效。然而刷题就如同玩“扫雷”游戏，自学能力强的人能够顺利将地雷逐个排掉，而基础不足的人很可能被炸得满头是包，并在挫折中步步退缩。通读教材也是一种常见做法，但对于面向求职的人来说，毕业论文、投递简历、准备笔试和面试已经消耗了大部分精力，啃厚重的书往往变成了一项艰巨的挑战。</p></blockquote><p>回想自己Leetcode的刷题之旅，真的是<strong>痛并快乐着</strong>，痛在算法题冷酷无情，将你所有的bug暴露无遗，根本不给你侥幸的机会，快乐在钻研一道题后终于看见<strong>超过了100%的人</strong>，快乐在从一开始的举步维艰，到逐渐能够尝试黄色中档题，再到得心应手，心平气和。</p><p><strong>因此，我在此开坑，将自己过去，现在以及将来在Leetcode上所做的好题，错题，看到的优秀题解以及我自己整理一些笔记等等整理成博客的形式，一篇博客五道题，希望以此留作纪念，并能够给有相同志向的小伙伴们一点鼓励和指引。</strong></p><h2 id="内容（实时更新）"><a href="#内容（实时更新）" class="headerlink" title="内容（实时更新）"></a>内容（实时更新）</h2><h3 id="第一学期（主要以语法题和最基本的算法题为主）"><a href="#第一学期（主要以语法题和最基本的算法题为主）" class="headerlink" title="第一学期（主要以语法题和最基本的算法题为主）"></a>第一学期（主要以语法题和最基本的算法题为主）</h3><ul><li>基本语法题<ul><li>数组、引用和指针的相关操作</li><li>OOP</li><li>STL入门</li></ul></li><li>基本算法入门<ul><li>排序算法</li><li>分治算法</li><li>回溯算法和递归算法</li><li>动态规划</li><li>贪心算法</li></ul></li></ul><h3 id="第二学期（重点：数据结构）"><a href="#第二学期（重点：数据结构）" class="headerlink" title="第二学期（重点：数据结构）"></a>第二学期（重点：数据结构）</h3><p>（期待一波来年开春的疯狂更新~）</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://leetcode.cn/u/affectionate-hamiltonyhv/">我的Leetcode主页</a></p><p><a href="https://leetcode.cn/">Leetcode</a></p><p><a href="https://books.halfrost.com/leetcode/">Leetcode Cookbook</a></p><hr><blockquote><p>English Version</p></blockquote><h1 id="Starting-a-New-Adventure-Again"><a href="#Starting-a-New-Adventure-Again" class="headerlink" title="Starting a New Adventure Again!"></a>Starting a New Adventure Again!</h1><h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><p>When I first started university (this semester), armed with my limited knowledge of C language syntax from a short summer learning stint, I felt the pace of my C++ course at school was a bit slow. So, I searched online for ways to improve my coding skills through <strong>problem-solving practice</strong>.</p><p>When looking up “best websites for beginners to practice coding,” <strong>LeetCode</strong> popped up in most results. Indeed, <a href="https://leetcode.cn/">LeetCode</a> is one of the best programming training platforms, and its interface design aligns perfectly with my aesthetic (as they call themselves, <strong>“The beloved tech growth platform for geeks worldwide”</strong>). However, for someone like me who used to put all the code into one bloated <code>main</code> function, LeetCode seemed like an insurmountable mountain. After finally understanding what <strong>function encapsulation</strong> was, I still couldn’t manage to solve <a href="https://leetcode.cn/problems/two-sum/">the first problem</a>. 🤡</p><p>While reading <a href="https://www.hello-algo.com/chapter_hello_algo/">Hello Algorithm</a>, I came across a sentiment in the preface that resonated deeply with me:</p><blockquote><p>Diving blindly into problem-solving is perhaps the most popular method—it’s simple, direct, and effective. However, it’s like playing a “Minesweeper” game: self-learners with a strong foundation can defuse the mines one by one, while those lacking fundamentals might get blown up and retreat in frustration. Reading textbooks is another common approach, but for job seekers, writing theses, submitting resumes, and preparing for tests and interviews consume most of their energy, making heavy textbooks a daunting challenge.</p></blockquote><p>Looking back on my LeetCode journey, it truly has been a mix of <strong>pain and joy</strong>. The pain lies in the ruthless nature of algorithm problems, exposing all your bugs without mercy, leaving no room for luck. The joy comes from finally solving a problem and seeing <strong>“outperformed 100% of users”</strong>, from struggling with initial problems to tackling mid-level yellow questions, and eventually solving problems calmly and confidently.</p><p><strong>That’s why I’m starting this series—to document the good problems, mistakes, excellent solutions, and notes from my past, present, and future LeetCode journey in the form of blog posts. Each post will include five problems, serving as a record and hopefully providing encouragement and guidance to like-minded peers.</strong></p><hr><h2 id="Content-Updated-in-Real-Time"><a href="#Content-Updated-in-Real-Time" class="headerlink" title="Content (Updated in Real-Time)"></a>Content (Updated in Real-Time)</h2><h3 id="First-Semester-Primarily-syntax-and-basic-algorithm-problems"><a href="#First-Semester-Primarily-syntax-and-basic-algorithm-problems" class="headerlink" title="First Semester (Primarily syntax and basic algorithm problems)"></a>First Semester (Primarily syntax and basic algorithm problems)</h3><ul><li><strong>Basic Syntax Problems</strong><ul><li>Array, reference, and pointer operations</li><li>OOP (Object-Oriented Programming)</li><li>Intro to STL (Standard Template Library)</li></ul></li><li><strong>Basic Algorithms</strong><ul><li>Sorting algorithms</li><li>Divide-and-conquer</li><li>Backtracking and recursion</li><li>Dynamic programming</li><li>Greedy algorithms</li></ul></li></ul><h3 id="Second-Semester-Focus-Data-Structures"><a href="#Second-Semester-Focus-Data-Structures" class="headerlink" title="Second Semester (Focus: Data Structures)"></a>Second Semester (Focus: Data Structures)</h3><p><em>(Looking forward to some crazy updates next spring!)</em></p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://leetcode.cn/u/affectionate-hamiltonyhv/">My LeetCode Profile</a></li><li><a href="https://leetcode.cn/">LeetCode</a></li><li><a href="https://books.halfrost.com/leetcode/">LeetCode Cookbook</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Announcement</tag>
      
      <tag>C/C++</tag>
      
      <tag>Leetcode notes</tag>
      
      <tag>algorithm</tag>
      
      <tag>Finished</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linked-List-Implementation-Based-on-Structs</title>
    <link href="/posts/Linked-List-Implementation-Based-on-Structs/"/>
    <url>/posts/Linked-List-Implementation-Based-on-Structs/</url>
    
    <content type="html"><![CDATA[<h1 id="Linked-List-Implementation-Based-on-Structs"><a href="#Linked-List-Implementation-Based-on-Structs" class="headerlink" title="Linked List Implementation Based on Structs"></a>Linked List Implementation Based on Structs</h1><p>封面插图截自 <a href="https://www.hello-algo.com/">Hello 算法</a></p><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><blockquote><p>这篇博客从0开始实现了如何<strong>使用结构体完成链表</strong>这一数据结构，并且实现了链表的插入，删除，遍历，查找等基本操作</p><p>This blog starts from scratch to demonstrate how to <strong>implement a linked list data structure using structs</strong>, covering the basic operations including insertion, deletion, traversal, and searching.</p></blockquote><h2 id="Concept"><a href="#Concept" class="headerlink" title="Concept"></a>Concept</h2><p>数组经常用于同类型数据的储存，但是数组规模必须在使用前确定（<strong>连续的顺序数据结构</strong>），这样会带来空间的浪费和诸多不利。但<strong>链表（Linked List）</strong>可以实现在增加元素的时候按需动态分配新的内存，实现了一种<strong>非连续存储</strong>。</p><p><img src="https://www.hello-algo.com/chapter_array_and_linkedlist/array.assets/array_definition.png" alt="数组定义与存储方式"></p><p><img src="https://www.hello-algo.com/chapter_array_and_linkedlist/linked_list.assets/linkedlist_definition.png" alt="链表定义与存储方式"></p><blockquote><p>以上两图节选自 <a href="https://www.hello-algo.com/chapter_array_and_linkedlist/array/">Hello 算法：数组和链表</a></p></blockquote><p>对于数据的存储，最常见的一项操作就是<strong>遍历数据类型中的所有（或者）部分元素</strong>，数组通过指针的<strong>自增操作</strong>实现遍历，但受限于非线性的存储方式，链表无法实现这一点。因此，为了能够达到和数组相同的遍历功能，链表中的每一个元素（或被称为<strong>节点</strong>），都需要一块内存来专门存储<strong>指向下一个元素的节点</strong>。</p><h2 id="Categories"><a href="#Categories" class="headerlink" title="Categories"></a>Categories</h2><ul><li><strong>单向链表</strong>：即前面介绍的普通链表。单向链表的节点包含值和指向下一节点的引用两项数据。我们将首个节点称为头节点，将最后一个节点称为<strong>尾节点</strong>，尾节点指向**空 <code>None</code>**（最后一个节点的节点指针指向空指针） 。</li><li><strong>环形链表</strong>：如果我们令单向链表的尾节点指向头节点（首尾相接），则得到一个环形链表。在环形链表中，任意节点都可以视作头节点。<ul><li>环形列表也可以分为双循环链表和单循环链表</li></ul></li><li><strong>双向链表</strong>：与单向链表相比，双向链表记录了两个方向的引用。<strong>双向链表的节点定义同时包含指向后继节点（下一个节点）和前驱节点（上一个节点）的引用（指针）</strong>。相较于单向链表，双向链表更具灵活性，可以朝两个方向遍历链表，但相应地也需要占用更多的内存空间。</li></ul><p><img src="https://www.hello-algo.com/chapter_array_and_linkedlist/linked_list.assets/linkedlist_common_types.png" alt="Categories"></p><p>图片来源：<a href="https://www.hello-algo.com/chapter_array_and_linkedlist/linked_list/#423">4.2  链表 - Hello 算法</a></p><h2 id="Definition-and-Implementaition"><a href="#Definition-and-Implementaition" class="headerlink" title="Definition and Implementaition"></a>Definition and Implementaition</h2><p>链表的每个节点由两个部分组成：<strong>数据元素本身和指向下一节点的指针。</strong>以下以单链表的相关操作为例：</p><h3 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">linkNode</span>&#123;<br>    datatype data;、<br>    <span class="hljs-comment">//datatype可以为任何一种数据类型，用来描述数据元素的本身的值</span><br>    linkNode* next;<br>&#125;;<br></code></pre></td></tr></table></figure><p>①<code>datatype</code>除了可以是一些<strong>基本数据类型</strong>，例如<code>int</code>，<code>double</code>等之外，也可以是<strong>自定义的非基本数据类型。</strong>例如，可以定义单链表的数据元素为另一个结构体类型的变量，则<code>datatype</code>需要相对应的改变。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node1</span>&#123;<br>    <span class="hljs-type">int</span> thenum;<br>    Node1 *next;<br>&#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node2</span>&#123;<br>    Node1 data;<br>    Node2 *next;<br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    Node1 *linklist1;<br>    <span class="hljs-comment">//定义了一个单链表</span><br>    Node2 *linklist2;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>②next是<strong>指向下一节点的指针</strong>，因此数据类型就是<strong>指向自身类型（自身结构体）</strong>，这种结构被称为<strong>自引用结构</strong>。</p><h3 id="Operations"><a href="#Operations" class="headerlink" title="Operations"></a>Operations</h3><p>对于基本数据结构，我们往往会关注一些基本的“<strong>操作</strong>”，例如插入，修改，删除，排序，访问（遍历）等等。这是数据结构走向算法的具体实现（一个从抽象到具象的过程），同时，由于每一种数据结构实现的底层原理有所不同，其具体的操作的方法和复杂度、优劣势等也各不相同。下文将介绍<strong>链表的创建，插入，访问，删除等基本操作通过结构体实现的底层原理</strong>，并给出一些具体的应用。</p><p>链表由于其自身<strong>非连续的物理结构特征</strong>，<strong>比数组占用更多的内存空间（用来存储下一个节点的地址），但是更加的灵活，扩展性强。</strong>如此结构使链表相比于数组具有更快的插入和删除元素的速度，但是牺牲了访问遍历元素的复杂度。</p><center>表 4-1  数组与链表的效率对比</center><table><thead><tr><th align="center"></th><th align="center">数组</th><th align="center">链表</th></tr></thead><tbody><tr><td align="center">存储方式</td><td align="center">连续内存空间</td><td align="center">分散内存空间</td></tr><tr><td align="center">容量扩展</td><td align="center">长度不可变</td><td align="center">可灵活扩展</td></tr><tr><td align="center">内存效率</td><td align="center">元素占用内存少</td><td align="center">元素占用内存多</td></tr><tr><td align="center">访问元素</td><td align="center">O(1)</td><td align="center">O(n)</td></tr><tr><td align="center">添加元素</td><td align="center">O(n)</td><td align="center">O(1)</td></tr><tr><td align="center">删除元素</td><td align="center">O(n)</td><td align="center">O(1)</td></tr></tbody></table><p>选自 <a href="https://www.hello-algo.com/chapter_array_and_linkedlist/linked_list/#422-vs">Hello算法：数组和链表的比较</a></p><p>接下来，我们一步一步实现自己的链表。</p><p>首先定义<strong>节点</strong>，这是每个链表的基本单元，包括<code>val</code>（储存当前节点的值）和<code>next</code>指向下一个节点地址的指针，在后文笔者习惯把它称为这个节点的<strong>引用</strong>。</p><p>注意到在结构体中增加了一行隐式构造函数，可以在新创建一个节点时设置默认参数（避免指针产生许多奇奇怪怪的问题）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ListNode</span> &#123;<br>    <span class="hljs-type">int</span> val;<br>    ListNode *next;<br>    <span class="hljs-built_in">ListNode</span>(<span class="hljs-type">int</span> value = <span class="hljs-number">0</span>, ListNode *next = <span class="hljs-literal">nullptr</span>) : <span class="hljs-built_in">val</span>(value), <span class="hljs-built_in">next</span>(next) &#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="单链表的创建"><a href="#单链表的创建" class="headerlink" title="单链表的创建"></a>单链表的创建</h4><p>如何初始化一个单链表？难道就是<strong>空空如也？</strong>显然不是，在之后的许多操作时，为了避免指针产生越界的情况，我们经常需要对链表进行<strong>置空检查</strong>（判断链表是否为空）。因此，我们需要再初始化一个新链表时，创建一个<strong>头结点</strong>，并对头节点的指向下一节点的指针初始化为<strong>空指针</strong>。</p><blockquote><p>以下对链表的若干操作都写成函数的形式，方便向OOP的过渡。</p><p>我既然都写析构函数和构造函数了，为什么不直接创建一个类呢（乐）</p></blockquote><p><strong>头结点非常的重要</strong>！！！它代表着链表这一条长蛇的开端，很多操作都是从头结点开始的。</p><p>在之后的操作中，<code>head-&gt;next==nullptr</code>就是对链表的置空检查（可以写成函数封装的形式），如果返回值为<code>true</code>，则代表链表为空，需要对头结点直接操作。</p><p><strong>头结点是链表中额外加入的一个特殊结点，它不存放数据，只是作为链表的开始标记，位于链表的最前面，它的指针部分指向表中的第一个元素，这样就保证了链表中每个结点前面都有一个结点 。</strong></p><blockquote><p>其实头结点也可以指向第一个实际数据，但是这样会导致在后续的链表操作中如果涉及对头结点（也就是首元素）的修改，会变得非常复杂，在这里笔者给出头结点不储存数据的链表实现。</p></blockquote><p>我们定义的第一个函数就是结构体的<strong>默认构造函数</strong>，只有在创建一个新链表的时候才会使用到，其功能是将头结点的引用设置为空指针。同样的，我们也可以设置<strong>析构函数</strong>，在链表结束其生命周期的时候自动调用，通过while循环自动<code>delete</code>所有节点（包括头结点）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">LinkedList</span> &#123;<br>    <span class="hljs-comment">// By default, construct a sentinel node that does not store any value, and its reference points to the first element of the list</span><br>    <span class="hljs-comment">// Initially, it points to nullptr</span><br>    ListNode* sentinel;<br>    <span class="hljs-type">int</span> size = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//size represents the number of nodes in the Linkedlist</span><br><br>    <span class="hljs-comment">// Constructor: Initialize the sentinel node, allocate memory on the heap for it</span><br>    <span class="hljs-built_in">LinkedList</span>(): <span class="hljs-built_in">sentinel</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>()), <span class="hljs-built_in">size</span>(<span class="hljs-number">0</span>) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Created successfully&quot;</span> &lt;&lt; endl;<br>    &#125;;<br><br>    <span class="hljs-comment">// Destructor: Iteratively delete all nodes (including the memory pointed to by the sentinel node initially)</span><br>    <span class="hljs-comment">// Once the sentinel points to a null pointer, the destruction process is complete</span><br>    ~<span class="hljs-built_in">LinkedList</span>() &#123;<br>        <span class="hljs-keyword">while</span> (sentinel != <span class="hljs-literal">nullptr</span>) &#123;<br>            ListNode* temp = sentinel;<br>            sentinel = sentinel-&gt;next;<br>            <span class="hljs-keyword">delete</span> temp;<br>        &#125;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Destroyed successfully&quot;</span> &lt;&lt; endl;<br>    &#125;<br></code></pre></td></tr></table></figure><h4 id="单链表的插入"><a href="#单链表的插入" class="headerlink" title="单链表的插入"></a>单链表的插入</h4><p>我们先来看一种比较原始的插入方式：</p><p><img src="/posts/Above-All/t-Implementation-Based-on-Structs/Insert.png" alt="Insert"></p><p>由上图可知，如果要再节点p的后面插入一个新的节点temp，需要完成以下几件事：</p><ul><li>修改节点p中指向下一个节点的指针，使其指向新节点temp的地址</li><li>修改节点temp中指向下一个节点的指针，使其指向原来在p后面的节点的地址</li></ul><blockquote><p>看到了吗？链表的操作本质上就是对指针的操作！</p></blockquote><p>因此，我们可以给出插入新节点的第一个函数 <code>insertAfter</code>，实现在当前节点current后面插入新的节点，节点值是value。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insertAfter</span><span class="hljs-params">(ListNode* current, <span class="hljs-type">int</span> value)</span> </span>&#123;<br>        <span class="hljs-comment">// If the current node is null, return or throw an exception</span><br>        <span class="hljs-keyword">if</span> (current == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">invalid_argument</span>(<span class="hljs-string">&quot;Current node is null&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// Create a new node</span><br>        ListNode* newNode = <span class="hljs-keyword">new</span> ListNode&#123;value, current-&gt;next&#125;;<br>        <span class="hljs-comment">// Insert the new node after the current node</span><br>        current-&gt;next = newNode;<br>        size++;<br>    &#125;<br></code></pre></td></tr></table></figure><h5 id="Modify①插入到第一个节点"><a href="#Modify①插入到第一个节点" class="headerlink" title="Modify①插入到第一个节点"></a>Modify①插入到第一个节点</h5><p>这个问题非常好解决，相当于更换了链表的头结点，只需要更改插入节点的引用即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insertAtHead</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> </span>&#123;<br>        <span class="hljs-comment">// Set the reference of the new node to the reference of the sentinel node</span><br>        ListNode* newNode = <span class="hljs-keyword">new</span> ListNode&#123;value, sentinel-&gt;next&#125;;<br>        <span class="hljs-comment">// Change the reference of the sentinel node because the first element of the list has changed</span><br>        sentinel-&gt;next = newNode;<br>        size++;<br>    &#125;<br></code></pre></td></tr></table></figure><h5 id="Modify②如何更加的高效？（配合查找）"><a href="#Modify②如何更加的高效？（配合查找）" class="headerlink" title="Modify②如何更加的高效？（配合查找）"></a>Modify②如何更加的高效？（配合查找）</h5><p>如果我们现在需要插入一个新节点使新节点的索引为3，应该怎么办？那我们需要先遍历节点直到达到目标节点，然后再调用<code>insertAfter</code>函数进行目标的插入，当然，如果索引为0，直接<code>insertAtHead</code>即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insertAtPosition</span><span class="hljs-params">(<span class="hljs-type">int</span> value, <span class="hljs-type">int</span> position)</span> </span>&#123;<br>        <span class="hljs-comment">// If the position is 0 or the list is empty, insert at the head</span><br>        <span class="hljs-keyword">if</span> (position == <span class="hljs-number">0</span> || sentinel-&gt;next == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-built_in">insertAtHead</span>(value);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        ListNode* current = sentinel-&gt;next;<br>        <span class="hljs-type">int</span> currentPosition = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// Set a pointer to start the traversal</span><br><br>        <span class="hljs-comment">// Find the node before the insertion position</span><br>        <span class="hljs-keyword">while</span> (current-&gt;next != <span class="hljs-literal">nullptr</span> &amp;&amp; currentPosition &lt; position - <span class="hljs-number">1</span>) &#123;<br>            current = current-&gt;next;<br>            currentPosition++;<br>        &#125;<br><br>        <span class="hljs-comment">// If the position exceeds the end of the list, insert at the end</span><br>        <span class="hljs-keyword">if</span> (currentPosition &lt; position - <span class="hljs-number">1</span>) &#123;<br>            ListNode* newNode = <span class="hljs-keyword">new</span> ListNode&#123;value, <span class="hljs-literal">nullptr</span>&#125;;<br>            current-&gt;next = newNode;<br>            size++;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// Insert the new node</span><br>            <span class="hljs-comment">// current represents the node at index n-1, inserting after it achieves the desired index</span><br>            <span class="hljs-built_in">insertAfter</span>(current, value);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h5 id="Modify③直接在尾部插入"><a href="#Modify③直接在尾部插入" class="headerlink" title="Modify③直接在尾部插入"></a>Modify③直接在尾部插入</h5><p>这里提供了一种比较方便的插入函数，当然我们在定义结构体时也定义了size来维护结构体中的节点个数，因此也可以通过<code>insertAtPosition</code>来实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// Insert directly at the end</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insertAtEnd</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (sentinel-&gt;next == <span class="hljs-literal">nullptr</span>) &#123;<br>            ListNode* newNode = <span class="hljs-keyword">new</span> ListNode&#123;value, <span class="hljs-literal">nullptr</span>&#125;;<br>            sentinel-&gt;next = newNode;<br>            size++;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        ListNode* current = sentinel-&gt;next;<br>        <span class="hljs-keyword">while</span> (current-&gt;next != <span class="hljs-literal">nullptr</span>) &#123;<br>            current = current-&gt;next;<br>        &#125;<br>        <span class="hljs-comment">// Traverse to the last node</span><br>        <span class="hljs-comment">// Create a new node</span><br>        ListNode* newNode = <span class="hljs-keyword">new</span> ListNode&#123;value, <span class="hljs-literal">nullptr</span>&#125;;<br>        current-&gt;next = newNode;<br>        size++;<br>    &#125;<br></code></pre></td></tr></table></figure><p>因此，我们实现了链表的插入操作的函数，用于不同的功能：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//插入函数</span><br>    <span class="hljs-comment">// 在链表头部插入节点</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insertAtHead</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> </span>&#123;<br>        Node* newNode = <span class="hljs-keyword">new</span> Node&#123;value, head&#125;; <span class="hljs-comment">// 使用初始化列表来初始化新节点</span><br>        head = newNode;<br>    &#125;<br><br>    <span class="hljs-comment">// 在指定节点之后插入新节点</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insertAfter</span><span class="hljs-params">(Node* current, <span class="hljs-type">int</span> value)</span> </span>&#123;<br>        <span class="hljs-comment">// 如果当前节点为空，直接返回或抛出异常</span><br>        <span class="hljs-keyword">if</span> (current == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">invalid_argument</span>(<span class="hljs-string">&quot;Current node is null&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 创建新节点</span><br>        Node* newNode = <span class="hljs-keyword">new</span> Node&#123;value, current-&gt;next&#125;;<br>        <span class="hljs-comment">// 将新节点插入到当前节点之后</span><br>        current-&gt;next = newNode;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insertAtPosition</span><span class="hljs-params">(<span class="hljs-type">int</span> value, <span class="hljs-type">int</span> position)</span> </span>&#123;<br>        <span class="hljs-comment">// 如果位置是0或链表为空，则在头部插入</span><br>        <span class="hljs-keyword">if</span> (position == <span class="hljs-number">0</span> || head == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-built_in">insertAtHead</span>(value);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        Node* current = head;<br>        <span class="hljs-type">int</span> currentPosition = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//设置一个指针，开始执行遍历</span><br>    <br>    <br>        <span class="hljs-comment">// 找到插入位置的前一个节点</span><br>        <span class="hljs-keyword">while</span> (current-&gt;next != <span class="hljs-literal">nullptr</span> &amp;&amp; currentPosition &lt; position - <span class="hljs-number">1</span>) &#123;<br>            current = current-&gt;next;<br>            currentPosition++;<br>        &#125;<br><br>        <span class="hljs-comment">// 如果位置超出了链表的末尾，则在末尾插入</span><br>        <span class="hljs-keyword">if</span> (currentPosition &lt; position - <span class="hljs-number">1</span>) &#123;<br>            Node* newNode = <span class="hljs-keyword">new</span> Node&#123;value, <span class="hljs-literal">nullptr</span>&#125;;<br>            current-&gt;next = newNode;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 插入新节点</span><br>            <span class="hljs-comment">//current代表的是n-1索引上的节点，插入到他的后面就是需要达到的目标索引</span><br>            <span class="hljs-built_in">insertAfter</span>(current, value);<br>        &#125;<br>    &#125;<br>    <br></code></pre></td></tr></table></figure><h4 id="单链表的删除"><a href="#单链表的删除" class="headerlink" title="单链表的删除"></a>单链表的删除</h4><p><img src="/posts/Above-All/t-Implementation-Based-on-Structs/erase.png" alt="erase"></p><p>原理和单链表的插入大同小异：</p><ul><li>将<code>delPtr</code>前面的一个节点p的引用更改，使其直接指向后面的一个节点即可</li><li>但是在删除时，要额外关注头和尾的特殊情况<ul><li>如果是第一个元素，则需要更改头结点的对应的值</li><li>如果是尾部元素，直接将上一个元素的应用设置为空指针即可</li></ul></li><li><strong>一定要注意delete！！！</strong></li></ul><p>我们先来看一下比较基础的功能实现：删除末尾的元素，思路如下：</p><ul><li>首先遍历数组走到最后一个元素<ul><li>由于链表非连续的物理结构的特点，其遍历的过程的复杂度会高于数组，达到了O（n）的时间复杂度。</li></ul></li><li>修改倒数第二个元素的引用为空指针</li><li><code>delete</code>掉最后一个元素的内存</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// Delete the last element of the list</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deletetheend</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (sentinel-&gt;next == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// Empty list</span><br><br>        ListNode* current = sentinel-&gt;next;<br>        ListNode* prev = sentinel;<br><br>        <span class="hljs-keyword">while</span> (current-&gt;next != <span class="hljs-literal">nullptr</span>) &#123;<br>            prev = current;<br>            current = current-&gt;next;<br>        &#125;<br>        <span class="hljs-comment">// At this point, current is the last element of the list</span><br>        prev-&gt;next = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">delete</span> current;<br>        size--;<br>    &#125;<br></code></pre></td></tr></table></figure><p>上面的代码已经实现了链表的遍历功能，因此稍微更改一下，便可以实现更多的删除功能。</p><blockquote><p>万变不离其宗，修改前一个的引用，删除后一个。要做的只有这两件事！</p></blockquote><h5 id="Modify①-根据值删除"><a href="#Modify①-根据值删除" class="headerlink" title="Modify① 根据值删除"></a>Modify① 根据值删除</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deleteNode</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (sentinel-&gt;next == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// Empty list</span><br><br>        ListNode* current = sentinel-&gt;next;<br>        ListNode* prev = sentinel;<br><br>        <span class="hljs-keyword">while</span> (current != <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">if</span> (current-&gt;val == key) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            prev = current;<br>            current = current-&gt;next;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (current == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// Node does not exist</span><br><br>        prev-&gt;next = current-&gt;next;<br>        <span class="hljs-keyword">delete</span> current;<br>        size--;<br>    &#125;<br></code></pre></td></tr></table></figure><h5 id="Modify②-根据索引删除"><a href="#Modify②-根据索引删除" class="headerlink" title="Modify② 根据索引删除"></a>Modify② 根据索引删除</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deletetheplace</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (sentinel-&gt;next == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// Empty list</span><br><br>        ListNode* current = sentinel-&gt;next;<br>        ListNode* prev = sentinel;<br>        <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span> (current != <span class="hljs-literal">nullptr</span> &amp;&amp; count &lt; index) &#123;<br>            prev = current;<br>            current = current-&gt;next;<br>            count++;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (count &lt; index) &#123;<br>            <span class="hljs-comment">// Index is too large, no corresponding index</span><br>            <span class="hljs-keyword">return</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// Then current is the node at the target index</span><br>            prev-&gt;next = current-&gt;next;<br>            <span class="hljs-keyword">delete</span> current;<br>            size--;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h4 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h4><p><strong>遍历，插入和删除是链表基本操作中最基本的三个操作，现在我们可以轻而易举地实现其他对链表的操作了。</strong></p><h5 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h5><p>返回特定索引值的val值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">at</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> </span>&#123;<br>        ListNode* current = sentinel-&gt;next;<br>        <span class="hljs-comment">// At this point, current points to the address of the first element of the list</span><br>        <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (count &gt;= size) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">out_of_range</span>(<span class="hljs-string">&quot;Out of range&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">while</span> (count &lt; index) &#123;<br>                current = current-&gt;next;<br>                count++;<br>            &#125;<br>            <span class="hljs-comment">// At this point, current points to the element at the target index</span><br>            <span class="hljs-keyword">return</span> current-&gt;val;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h5 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h5><p>修改特定索引值的val值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> index,<span class="hljs-type">int</span> replacement)</span></span>&#123;<br>        ListNode* current = sentinel-&gt;next;<br>        <span class="hljs-comment">// At this point, current points to the address of the first element of the list</span><br>        <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (count &gt;= size) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">out_of_range</span>(<span class="hljs-string">&quot;Out of range&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">while</span> (count &lt; index) &#123;<br>                current = current-&gt;next;<br>                count++;<br>            &#125;<br>            <span class="hljs-comment">// At this point, current points to the element at the target index</span><br>            current-&gt;val=replacement;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><blockquote><p>以上两个功能的实现本质上都是先通过链表的遍历找到目标索引所对应的内存（current），然后再在已经找到的内存块上做操作。</p></blockquote><h5 id="按值查找"><a href="#按值查找" class="headerlink" title="按值查找"></a>按值查找</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>        ListNode* current = sentinel-&gt;next;<br>        <span class="hljs-comment">// At this point, current points to the address of the first element of the list</span><br>        <span class="hljs-keyword">while</span> (current != <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">if</span> (current-&gt;val == target) &#123;<br>                <span class="hljs-keyword">return</span> count;<br>            &#125;<br>            count++;<br>            current = current-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><h5 id="打印列表（可视化）"><a href="#打印列表（可视化）" class="headerlink" title="打印列表（可视化）"></a>打印列表（可视化）</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printList</span><span class="hljs-params">()</span> </span>&#123;<br>        ListNode* current = sentinel-&gt;next;<br>        <span class="hljs-keyword">while</span> (current != <span class="hljs-literal">nullptr</span>) &#123;<br>            std::cout &lt;&lt; current-&gt;val &lt;&lt; <span class="hljs-string">&quot; -&gt; &quot;</span>;<br>            current = current-&gt;next;<br>        &#125;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;NULL&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br></code></pre></td></tr></table></figure><h5 id="置空检查"><a href="#置空检查" class="headerlink" title="置空检查"></a>置空检查</h5><p>判断链表是否有元素</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// Check if the list is empty</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isempty</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (sentinel-&gt;next == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="Outlook"><a href="#Outlook" class="headerlink" title="Outlook"></a>Outlook</h3><p>Congratulations！现在你已经实现了链表所有的基本操作，包括<strong>初始化，遍历，插入，删除，索引，修改，按值查找，打印等等</strong>。你可以使用自己写的链表去完成一些更加强大的功能！下面是一些展望和未来可以继续改进的方向：</p><ul><li>优化压缩代码，精简复杂度</li><li>将代码改写成OOP的形势，写成头文件</li><li>实现一些更加高级的功能<ul><li>链表的合并</li><li>链表的翻转</li><li>链表的计数</li><li>It’s up to you!</li></ul></li></ul><h2 id="All-codes"><a href="#All-codes" class="headerlink" title="All codes"></a>All codes</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @Author: Xiyuan Yang   xiyuan_yang@outlook.com</span><br><span class="hljs-comment"> * @Date: 2024-12-08 10:28:07</span><br><span class="hljs-comment"> * @LastEditors: Xiyuan Yang   xiyuan_yang@outlook.com</span><br><span class="hljs-comment"> * @LastEditTime: 2024-12-08 13:48:56</span><br><span class="hljs-comment"> * @FilePath: \CODE_for_Vscode\C++_project\Linked_list_copy.cpp</span><br><span class="hljs-comment"> * @Description: </span><br><span class="hljs-comment"> * Do you code and make progress today?</span><br><span class="hljs-comment"> * Copyright (c) 2024 by Xiyuan Yang, All Rights Reserved. </span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ListNode</span> &#123;<br>    <span class="hljs-type">int</span> val;<br>    ListNode *next;<br>    <span class="hljs-built_in">ListNode</span>(<span class="hljs-type">int</span> value = <span class="hljs-number">0</span>, ListNode *next = <span class="hljs-literal">nullptr</span>) : <span class="hljs-built_in">val</span>(value), <span class="hljs-built_in">next</span>(next) &#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">LinkedList</span> &#123;<br>    <span class="hljs-comment">// By default, construct a sentinel node that does not store any value, and its reference points to the first element of the list</span><br>    <span class="hljs-comment">// Initially, it points to nullptr</span><br>    ListNode* sentinel;<br>    <span class="hljs-type">int</span> size = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// Constructor: Initialize the sentinel node, allocate memory on the heap for it</span><br>    <span class="hljs-built_in">LinkedList</span>(): <span class="hljs-built_in">sentinel</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>()), <span class="hljs-built_in">size</span>(<span class="hljs-number">0</span>) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Created successfully&quot;</span> &lt;&lt; endl;<br>    &#125;;<br><br>    <span class="hljs-comment">// Destructor: Iteratively delete all nodes (including the memory pointed to by the sentinel node initially)</span><br>    <span class="hljs-comment">// Once the sentinel points to a null pointer, the destruction process is complete</span><br>    ~<span class="hljs-built_in">LinkedList</span>() &#123;<br>        <span class="hljs-keyword">while</span> (sentinel != <span class="hljs-literal">nullptr</span>) &#123;<br>            ListNode* temp = sentinel;<br>            sentinel = sentinel-&gt;next;<br>            <span class="hljs-keyword">delete</span> temp;<br>        &#125;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Destroyed successfully&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-comment">// Four insertion functions</span><br>    <span class="hljs-comment">// Insert a node at the head of the list</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insertAtHead</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> </span>&#123;<br>        <span class="hljs-comment">// Set the reference of the new node to the reference of the sentinel node</span><br>        ListNode* newNode = <span class="hljs-keyword">new</span> ListNode&#123;value, sentinel-&gt;next&#125;;<br>        <span class="hljs-comment">// Change the reference of the sentinel node because the first element of the list has changed</span><br>        sentinel-&gt;next = newNode;<br>        size++;<br>    &#125;<br><br>    <span class="hljs-comment">// Insert a new node after the specified node</span><br>    <span class="hljs-comment">// current represents the node after which you want to insert</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insertAfter</span><span class="hljs-params">(ListNode* current, <span class="hljs-type">int</span> value)</span> </span>&#123;<br>        <span class="hljs-comment">// If the current node is null, return or throw an exception</span><br>        <span class="hljs-keyword">if</span> (current == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">invalid_argument</span>(<span class="hljs-string">&quot;Current node is null&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// Create a new node</span><br>        ListNode* newNode = <span class="hljs-keyword">new</span> ListNode&#123;value, current-&gt;next&#125;;<br>        <span class="hljs-comment">// Insert the new node after the current node</span><br>        current-&gt;next = newNode;<br>        size++;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insertAtPosition</span><span class="hljs-params">(<span class="hljs-type">int</span> value, <span class="hljs-type">int</span> position)</span> </span>&#123;<br>        <span class="hljs-comment">// If the position is 0 or the list is empty, insert at the head</span><br>        <span class="hljs-keyword">if</span> (position == <span class="hljs-number">0</span> || sentinel-&gt;next == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-built_in">insertAtHead</span>(value);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        ListNode* current = sentinel-&gt;next;<br>        <span class="hljs-type">int</span> currentPosition = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// Set a pointer to start the traversal</span><br><br>        <span class="hljs-comment">// Find the node before the insertion position</span><br>        <span class="hljs-keyword">while</span> (current-&gt;next != <span class="hljs-literal">nullptr</span> &amp;&amp; currentPosition &lt; position - <span class="hljs-number">1</span>) &#123;<br>            current = current-&gt;next;<br>            currentPosition++;<br>        &#125;<br><br>        <span class="hljs-comment">// If the position exceeds the end of the list, insert at the end</span><br>        <span class="hljs-keyword">if</span> (currentPosition &lt; position - <span class="hljs-number">1</span>) &#123;<br>            ListNode* newNode = <span class="hljs-keyword">new</span> ListNode&#123;value, <span class="hljs-literal">nullptr</span>&#125;;<br>            current-&gt;next = newNode;<br>            size++;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// Insert the new node</span><br>            <span class="hljs-comment">// current represents the node at index n-1, inserting after it achieves the desired index</span><br>            <span class="hljs-built_in">insertAfter</span>(current, value);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// Insert directly at the end</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insertAtEnd</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (sentinel-&gt;next == <span class="hljs-literal">nullptr</span>) &#123;<br>            ListNode* newNode = <span class="hljs-keyword">new</span> ListNode&#123;value, <span class="hljs-literal">nullptr</span>&#125;;<br>            sentinel-&gt;next = newNode;<br>            size++;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        ListNode* current = sentinel-&gt;next;<br>        <span class="hljs-keyword">while</span> (current-&gt;next != <span class="hljs-literal">nullptr</span>) &#123;<br>            current = current-&gt;next;<br>        &#125;<br>        <span class="hljs-comment">// Traverse to the last node</span><br>        <span class="hljs-comment">// Create a new node</span><br>        ListNode* newNode = <span class="hljs-keyword">new</span> ListNode&#123;value, <span class="hljs-literal">nullptr</span>&#125;;<br>        current-&gt;next = newNode;<br>        size++;<br>    &#125;<br><br>    <span class="hljs-comment">// Delete operation</span><br>    <span class="hljs-comment">// Delete the node with the specified value</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deleteNode</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (sentinel-&gt;next == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// Empty list</span><br><br>        ListNode* current = sentinel-&gt;next;<br>        ListNode* prev = sentinel;<br><br>        <span class="hljs-keyword">while</span> (current != <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">if</span> (current-&gt;val == key) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            prev = current;<br>            current = current-&gt;next;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (current == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// Node does not exist</span><br><br>        prev-&gt;next = current-&gt;next;<br>        <span class="hljs-keyword">delete</span> current;<br>        size--;<br>    &#125;<br><br>    <span class="hljs-comment">// Delete the last element of the list</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deletetheend</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (sentinel-&gt;next == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// Empty list</span><br><br>        ListNode* current = sentinel-&gt;next;<br>        ListNode* prev = sentinel;<br><br>        <span class="hljs-keyword">while</span> (current-&gt;next != <span class="hljs-literal">nullptr</span>) &#123;<br>            prev = current;<br>            current = current-&gt;next;<br>        &#125;<br>        <span class="hljs-comment">// At this point, current is the last element of the list</span><br>        prev-&gt;next = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">delete</span> current;<br>        size--;<br>    &#125;<br><br>    <span class="hljs-comment">// Delete the element at a specific index in the list</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deletetheplace</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (sentinel-&gt;next == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// Empty list</span><br><br>        ListNode* current = sentinel-&gt;next;<br>        ListNode* prev = sentinel;<br>        <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span> (current != <span class="hljs-literal">nullptr</span> &amp;&amp; count &lt; index) &#123;<br>            prev = current;<br>            current = current-&gt;next;<br>            count++;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (count &lt; index) &#123;<br>            <span class="hljs-comment">// Index is too large, no corresponding index</span><br>            <span class="hljs-keyword">return</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// Then current is the node at the target index</span><br>            prev-&gt;next = current-&gt;next;<br>            <span class="hljs-keyword">delete</span> current;<br>            size--;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> index,<span class="hljs-type">int</span> replacement)</span></span>&#123;<br>        ListNode* current = sentinel-&gt;next;<br>        <span class="hljs-comment">// At this point, current points to the address of the first element of the list</span><br>        <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (count &gt;= size) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">out_of_range</span>(<span class="hljs-string">&quot;Out of range&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">while</span> (count &lt; index) &#123;<br>                current = current-&gt;next;<br>                count++;<br>            &#125;<br>            <span class="hljs-comment">// At this point, current points to the element at the target index</span><br>            current-&gt;val=replacement;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// List search</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">at</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> </span>&#123;<br>        ListNode* current = sentinel-&gt;next;<br>        <span class="hljs-comment">// At this point, current points to the address of the first element of the list</span><br>        <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (count &gt;= size) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">out_of_range</span>(<span class="hljs-string">&quot;Out of range&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">while</span> (count &lt; index) &#123;<br>                current = current-&gt;next;<br>                count++;<br>            &#125;<br>            <span class="hljs-comment">// At this point, current points to the element at the target index</span><br>            <span class="hljs-keyword">return</span> current-&gt;val;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>        ListNode* current = sentinel-&gt;next;<br>        <span class="hljs-comment">// At this point, current points to the address of the first element of the list</span><br>        <span class="hljs-keyword">while</span> (current != <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">if</span> (current-&gt;val == target) &#123;<br>                <span class="hljs-keyword">return</span> count;<br>            &#125;<br>            count++;<br>            current = current-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// Print list content</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printList</span><span class="hljs-params">()</span> </span>&#123;<br>        ListNode* current = sentinel-&gt;next;<br>        <span class="hljs-keyword">while</span> (current != <span class="hljs-literal">nullptr</span>) &#123;<br>            std::cout &lt;&lt; current-&gt;val &lt;&lt; <span class="hljs-string">&quot; -&gt; &quot;</span>;<br>            current = current-&gt;next;<br>        &#125;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;NULL&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-comment">// Check if the list is empty</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isempty</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (sentinel-&gt;next == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    LinkedList thelklist;<br>    cout &lt;&lt; thelklist.<span class="hljs-built_in">isempty</span>() &lt;&lt; endl;<br>    thelklist.<span class="hljs-built_in">insertAtEnd</span>(<span class="hljs-number">6</span>);<br>    thelklist.<span class="hljs-built_in">insertAtEnd</span>(<span class="hljs-number">5</span>);<br>    thelklist.<span class="hljs-built_in">insertAtEnd</span>(<span class="hljs-number">3</span>);<br>    thelklist.<span class="hljs-built_in">insertAfter</span>(thelklist.sentinel, <span class="hljs-number">2</span>);<br>    thelklist.<span class="hljs-built_in">insertAtHead</span>(<span class="hljs-number">11</span>);<br>    thelklist.<span class="hljs-built_in">insertAtPosition</span>(<span class="hljs-number">7</span>, <span class="hljs-number">4</span>);<br>    thelklist.<span class="hljs-built_in">deleteNode</span>(<span class="hljs-number">2</span>);<br>    thelklist.<span class="hljs-built_in">deletetheend</span>();<br>    thelklist.<span class="hljs-built_in">deletetheplace</span>(<span class="hljs-number">3</span>);<br>    cout &lt;&lt; thelklist.<span class="hljs-built_in">isempty</span>() &lt;&lt; endl;<br>    cout &lt;&lt; thelklist.<span class="hljs-built_in">search</span>(<span class="hljs-number">6</span>) &lt;&lt; endl;<br>    cout &lt;&lt; thelklist.<span class="hljs-built_in">search</span>(<span class="hljs-number">2</span>) &lt;&lt; endl;<br>    thelklist.<span class="hljs-built_in">printList</span>();<br>    cout &lt;&lt; thelklist.size &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><p>改良后的代码将会放在我的github仓库，敬请期待~</p></blockquote><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p>《C++程序设计——思想与方法》</p><p><a href="https://www.hello-algo.com/">Hello 算法</a></p><blockquote><p>THE END</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tutorial</tag>
      
      <tag>C/C++</tag>
      
      <tag>OOP</tag>
      
      <tag>Finished</tag>
      
      <tag>Linked list</tag>
      
      <tag>Structs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C-plus-plus-Primer-Plus-tutorial</title>
    <link href="/posts/C-plus-plus-Primer-Plus-tutorial/"/>
    <url>/posts/C-plus-plus-Primer-Plus-tutorial/</url>
    
    <content type="html"><![CDATA[<h1 id="C-Primer-Plus-tutorial"><a href="#C-Primer-Plus-tutorial" class="headerlink" title="C++ Primer Plus tutorial"></a>C++ Primer Plus tutorial</h1><h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>笔者又来开新坑啦！</p><p>之前看到一个很讽刺的笑话：<strong>大多数国内高校学生学到的C++只是C语言+cin&#x2F;cout</strong>。这当然只是一句玩笑话，但很深刻地反映出对于C++精髓<strong>面向对象编程</strong>的忽视。</p><p>这是有理可依的：<strong>编程语言的学习本身就和传统的课堂授课模式存在较大的出入</strong>，编程重视实践，枯燥的语法讲解如同天书一般晦涩难懂，更不用提OOP所涉及的都是比较大规模的项目工程，如果只是在课堂上乏味地讲解“什么是析构函数，什么是继承，什么是多态···”，很容易将C++学成死记硬背的无聊学科。</p><p>因此，笔者在课堂学习之余，<strong>同步学习了世界经典C++教材——《C++ Primer Plus》的相关内容</strong>。经典不愧为经典！</p><p>但是，针对我个人而言，我认为C++ Primer Plus有以下问题：（其实也不算是问题啦，就是和普通在校大学生存在一些“冲突”）</p><ul><li>一共678页，并且全是密密麻麻的字，阅读周期长，读完需要很大的意志力（对于自学者）。</li><li>由于翻译等种种的原因，在很多地方的解释并不清晰（作为一本C++的入门书籍体量有些大了，而且涉及到很多专业的名词，看得让人头大）</li></ul><p>因此，笔者希望通过博客的方式，记录自己的C++ Primer Plus学习笔记，并上传到网络上供一同学习的小伙伴参考。</p><p>博客立志于：</p><ul><li>记录自己的C++学习过程</li><li>对本人认为的C++学习中的一些重难点做一些额外的解释</li><li>尝试用简单清晰的语言梳理逻辑脉络</li></ul><h2 id="目录："><a href="#目录：" class="headerlink" title="目录："></a>目录：</h2><ul><li><strong>Chapter10 对象和类</strong></li><li><strong>Chapter11 使用类</strong></li><li><strong>Chapter12 类和动态内存分配</strong></li><li><strong>Chapter13 类继承</strong></li><li><strong>Chapter14 代码重用</strong></li><li><strong>Chapter15 友元，异常和其他</strong></li><li><strong>Chapter16 string类的标准模板库</strong></li></ul><p>（目前更新计划主要分布在OOP的章节，之后的其他章节看情况更新~）</p><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>本博客系列使用的大部分代码都摘自《C++ Primer Plus》，并非原创。相当于为《C++ Primer Plus》添加一下自己的注解和所思所想。</p>]]></content>
    
    
    <categories>
      
      <category>Code</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Announcement</tag>
      
      <tag>C/C++</tag>
      
      <tag>C++ Primer Plus</tag>
      
      <tag>Finished</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Dynamic-Memory-and-Classes</title>
    <link href="/posts/Dynamic-Memory-and-Classes/"/>
    <url>/posts/Dynamic-Memory-and-Classes/</url>
    
    <content type="html"><![CDATA[<h1 id="C-Primer-Plus-Tutorial-12"><a href="#C-Primer-Plus-Tutorial-12" class="headerlink" title="C++ Primer Plus Tutorial-12"></a>C++ Primer Plus Tutorial-12</h1><center><p style="color: red;"><b><font size=6.5>Chapter 12 Dynamic-Memory-and-Classes</font></b></p></center><center><p style="color: red;"><b><font size=6.5>动态内存和类</font></b></p></center><p>【写在前面的话】</p><p><a href="https://xiyuanyang-code.github.io/posts/C-Primer-Plus-tutorial/">C++ Primer Plus Tutorial</a></p><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>本章将重点放在如何对<strong>自定义类和对象</strong>谨慎地使用<strong>动态内存分配</strong>，以及内存管理的相关知识。首先从一个代码示例StringBad讲起，分析因为C++自带的隐式复制构造函数导致<strong>按值传递</strong>和<strong>按址传递</strong>发生冲突而导致程序无法正确输出，并以此为教材介绍了如何<strong>显式</strong>地定义<strong>复制构造函数和赋值运算符</strong>，并给出了修改后的String类的类定义和使用示范。接着，文章聚焦于在类中使用动态内存的易错点，包括new和delete的一一对应问题。最后，文章分析了使用动态内存分配在设计类和对象过程中的应用：<strong>设置合理的返回对象</strong>和<strong>使用指向对象的指针</strong>，同时介绍了动态内存管理的一些高级操作，包括<strong>正确地使用析构函数</strong>和<strong>使用定位new运算符</strong>。</p><blockquote><p>This chapter focuses on how to <strong>cautiously use dynamic memory allocation with</strong> <strong>custom classes and objects</strong>, along with related knowledge on memory management. It begins with a code example, StringBad, to analyze how the implicit copy constructor provided by C++ leads to conflicts between <strong>pass-by-value</strong> and <strong>pass-by-reference</strong>, resulting in incorrect program output. Using this example as a teaching tool, the chapter introduces how to <strong>explicitly</strong> define <strong>copy constructors and assignment operators</strong>, and provides an updated class definition and usage demonstration for the String class. Next, the article focuses on common pitfalls when using dynamic memory in classes, including the one-to-one correspondence issue between new and delete. Finally, the chapter discusses the application of dynamic memory allocation in the design of classes and objects: <strong>setting appropriate return objects</strong> and <strong>using pointers to objects</strong>, while also introducing some advanced operations in dynamic memory management, such as <strong>correctly using destructors</strong> and <strong>using placement new operator</strong>.</p><p><strong>Key words: OOP, Dynamic Memory, C++, Classes</strong></p></blockquote><h2 id="Introduction：C-中的特殊成员函数"><a href="#Introduction：C-中的特殊成员函数" class="headerlink" title="Introduction：C++中的特殊成员函数"></a>Introduction：C++中的特殊成员函数</h2><h3 id="示例代码（stringbad类的实现）"><a href="#示例代码（stringbad类的实现）" class="headerlink" title="示例代码（stringbad类的实现）"></a>示例代码（stringbad类的实现）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// strngbad.h -- flawed string class definition</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> STRNGBAD_H_</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> STRNGBAD_H_</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">StringBad</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">char</span> * str;                <span class="hljs-comment">// pointer to string</span><br>    <span class="hljs-type">int</span> len;                   <span class="hljs-comment">// length of string</span><br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> num_strings;    <span class="hljs-comment">// number of objects</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">StringBad</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> * s); <span class="hljs-comment">// constructor</span><br>    <span class="hljs-built_in">StringBad</span>();               <span class="hljs-comment">// default constructor</span><br>    ~<span class="hljs-built_in">StringBad</span>();              <span class="hljs-comment">// destructor</span><br><span class="hljs-comment">// friend function</span><br>    <span class="hljs-keyword">friend</span> std::ostream &amp; <span class="hljs-keyword">operator</span>&lt;&lt;(std::ostream &amp; os, <span class="hljs-type">const</span> StringBad &amp; st);<br>&#125;;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// strngbad.cpp -- StringBad class methods</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span>                    <span class="hljs-comment">// string.h for some</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;strngbad.h&quot;</span></span><br><span class="hljs-keyword">using</span> std::cout;<br><br><span class="hljs-comment">// initializing static class member</span><br><span class="hljs-type">int</span> StringBad::num_strings = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// class methods</span><br><br><span class="hljs-comment">// construct StringBad from C string</span><br>StringBad::<span class="hljs-built_in">StringBad</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> * s)<br>&#123;<br>    len = std::<span class="hljs-built_in">strlen</span>(s);             <span class="hljs-comment">// set size</span><br>    str = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[len + <span class="hljs-number">1</span>];          <span class="hljs-comment">// allot storage</span><br>    std::<span class="hljs-built_in">strcpy</span>(str, s);              <span class="hljs-comment">// initialize pointer</span><br>    num_strings++;                    <span class="hljs-comment">// set object count</span><br>    cout &lt;&lt; num_strings &lt;&lt; <span class="hljs-string">&quot;: \&quot;&quot;</span> &lt;&lt; str<br>         &lt;&lt; <span class="hljs-string">&quot;\&quot; object created\n&quot;</span>;    <span class="hljs-comment">// For Your Information</span><br>&#125;<br><br>StringBad::<span class="hljs-built_in">StringBad</span>()                <span class="hljs-comment">// default constructor</span><br>&#123;<br>    len = <span class="hljs-number">4</span>;<br>    str = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-number">4</span>];<br>    std::<span class="hljs-built_in">strcpy</span>(str, <span class="hljs-string">&quot;C++&quot;</span>);          <span class="hljs-comment">// default string</span><br>    num_strings++;<br>    cout &lt;&lt; num_strings &lt;&lt; <span class="hljs-string">&quot;: \&quot;&quot;</span> &lt;&lt; str<br>         &lt;&lt; <span class="hljs-string">&quot;\&quot; default object created\n&quot;</span>;  <span class="hljs-comment">// FYI</span><br>&#125;<br><br>StringBad::~<span class="hljs-built_in">StringBad</span>()               <span class="hljs-comment">// necessary destructor</span><br>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;\&quot;&quot;</span> &lt;&lt; str &lt;&lt; <span class="hljs-string">&quot;\&quot; object deleted, &quot;</span>;    <span class="hljs-comment">// FYI</span><br>    --num_strings;                    <span class="hljs-comment">// required</span><br>    cout &lt;&lt; num_strings &lt;&lt; <span class="hljs-string">&quot; left\n&quot;</span>; <span class="hljs-comment">// FYI</span><br>    <span class="hljs-keyword">delete</span> [] str;                    <span class="hljs-comment">// required</span><br>&#125;<br><br>std::ostream &amp; <span class="hljs-keyword">operator</span>&lt;&lt;(std::ostream &amp; os, <span class="hljs-type">const</span> StringBad &amp; st)<br>&#123;<br>    os &lt;&lt; st.str;<br>    <span class="hljs-keyword">return</span> os; <br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// vegnews.cpp -- using new and delete with classes</span><br><span class="hljs-comment">// compile with strngbad.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> std::cout;<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;strngbad.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">callme1</span><span class="hljs-params">(StringBad &amp;)</span></span>;  <span class="hljs-comment">// pass by reference</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">callme2</span><span class="hljs-params">(StringBad)</span></span>;    <span class="hljs-comment">// pass by value</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">using</span> std::endl;<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Starting an inner block.\n&quot;</span>;<br>        <span class="hljs-function">StringBad <span class="hljs-title">headline1</span><span class="hljs-params">(<span class="hljs-string">&quot;Celery Stalks at Midnight&quot;</span>)</span></span>;<br>        <span class="hljs-function">StringBad <span class="hljs-title">headline2</span><span class="hljs-params">(<span class="hljs-string">&quot;Lettuce Prey&quot;</span>)</span></span>;<br>        <span class="hljs-function">StringBad <span class="hljs-title">sports</span><span class="hljs-params">(<span class="hljs-string">&quot;Spinach Leaves Bowl for Dollars&quot;</span>)</span></span>;<br>        cout &lt;&lt; <span class="hljs-string">&quot;headline1: &quot;</span> &lt;&lt; headline1 &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">&quot;headline2: &quot;</span> &lt;&lt; headline2 &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">&quot;sports: &quot;</span> &lt;&lt; sports &lt;&lt; endl;<br>        <span class="hljs-built_in">callme1</span>(headline1);<br>        cout &lt;&lt; <span class="hljs-string">&quot;headline1: &quot;</span> &lt;&lt; headline1 &lt;&lt; endl;<br>        <span class="hljs-built_in">callme2</span>(headline2);<br>        cout &lt;&lt; <span class="hljs-string">&quot;headline2: &quot;</span> &lt;&lt; headline2 &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Initialize one object to another:\n&quot;</span>;<br>        StringBad sailor = sports;<br>        cout &lt;&lt; <span class="hljs-string">&quot;sailor: &quot;</span> &lt;&lt; sailor &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Assign one object to another:\n&quot;</span>;<br>        StringBad knot;<br>        knot = headline1;<br>        cout &lt;&lt; <span class="hljs-string">&quot;knot: &quot;</span> &lt;&lt; knot &lt;&lt; endl; <br>        cout &lt;&lt; <span class="hljs-string">&quot;Exiting the block.\n&quot;</span>;<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-string">&quot;End of main()\n&quot;</span>;<br>    <span class="hljs-comment">// std::cin.get();</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">callme1</span><span class="hljs-params">(StringBad &amp; rsb)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;String passed by reference:\n&quot;</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;    \&quot;&quot;</span> &lt;&lt; rsb &lt;&lt; <span class="hljs-string">&quot;\&quot;\n&quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">callme2</span><span class="hljs-params">(StringBad sb)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;String passed by value:\n&quot;</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;    \&quot;&quot;</span> &lt;&lt; sb &lt;&lt; <span class="hljs-string">&quot;\&quot;\n&quot;</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>以上代码实现了一个对字符串类<code>StringBad</code>类的声明与定义，代码示例参见注释，不做解释。</p><p>以下是原书给出的输出示例：</p><p><img src="/posts/Above-All/mory-and-Classes/input1.png"></p><p><img src="/posts/Above-All/mory-and-Classes/input2.png" alt="Output"></p><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p>通过输出可以大致判断<code>stringbad</code>类出现奇怪问题的原因可能如下：</p><ul><li>静态变量<code>num_strings</code>出现了负值，说明在程序中<strong>使用析构函数的次数</strong>多于<strong>使用构造函数的次数</strong></li><li>出现了<strong>非标准字符</strong>，说明字符串在传递过程中的值出现了问题。</li></ul><h3 id="问题分析1"><a href="#问题分析1" class="headerlink" title="问题分析1"></a>问题分析1</h3><p>在上述代码中，存在<strong>两个构造函数</strong>，分别对应有参数和无参数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++">StringBad::<span class="hljs-built_in">StringBad</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> * s)<br>&#123;<br>    len = std::<span class="hljs-built_in">strlen</span>(s);             <span class="hljs-comment">// set size</span><br>    str = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[len + <span class="hljs-number">1</span>];          <span class="hljs-comment">// allot storage</span><br>    std::<span class="hljs-built_in">strcpy</span>(str, s);              <span class="hljs-comment">// initialize pointer</span><br>    num_strings++;                    <span class="hljs-comment">// set object count</span><br>    cout &lt;&lt; num_strings &lt;&lt; <span class="hljs-string">&quot;: \&quot;&quot;</span> &lt;&lt; str<br>         &lt;&lt; <span class="hljs-string">&quot;\&quot; object created\n&quot;</span>;    <span class="hljs-comment">// For Your Information</span><br>&#125;<br><br>StringBad::<span class="hljs-built_in">StringBad</span>()                <span class="hljs-comment">// default constructor</span><br>&#123;<br>    len = <span class="hljs-number">4</span>;<br>    str = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-number">4</span>];<br>    std::<span class="hljs-built_in">strcpy</span>(str, <span class="hljs-string">&quot;C++&quot;</span>);          <span class="hljs-comment">// default string</span><br>    num_strings++;<br>    cout &lt;&lt; num_strings &lt;&lt; <span class="hljs-string">&quot;: \&quot;&quot;</span> &lt;&lt; str<br>         &lt;&lt; <span class="hljs-string">&quot;\&quot; default object created\n&quot;</span>;  <span class="hljs-comment">// FYI</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这是析构函数的定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++">StringBad::~<span class="hljs-built_in">StringBad</span>()               <span class="hljs-comment">// necessary destructor</span><br>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;\&quot;&quot;</span> &lt;&lt; str &lt;&lt; <span class="hljs-string">&quot;\&quot; object deleted, &quot;</span>;    <span class="hljs-comment">// FYI</span><br>    --num_strings;                    <span class="hljs-comment">// required</span><br>    cout &lt;&lt; num_strings &lt;&lt; <span class="hljs-string">&quot; left\n&quot;</span>; <span class="hljs-comment">// FYI</span><br>    <span class="hljs-keyword">delete</span> [] str;                    <span class="hljs-comment">// required</span><br>&#125;<br></code></pre></td></tr></table></figure><p>以上三个函数定义是都没有忘记对静态成员变量<code>num_strings</code>的操作（++&#x2F;–）。因此，原因①可以被更加规范地表述为：<strong>在程序运行中使用显式定义的构造函数的次数少于使用析构函数的次数</strong>，换句话说，程序使用了<strong>第三种构造函数</strong>，这个“第三种构造函数”为程序自动生成，因此没有对<code>num_strings</code>的++操作，导致负值的出现。（毕竟在作用域中每个对象只能构造一次，析构一次，两者的数量应该是相等的。）</p><p>程序中一共涉及到5个对象，这是他们的构造方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">StringBad <span class="hljs-title">headline1</span><span class="hljs-params">(<span class="hljs-string">&quot;Celery Stalks at Midnight&quot;</span>)</span></span>;<br><span class="hljs-function">StringBad <span class="hljs-title">headline2</span><span class="hljs-params">(<span class="hljs-string">&quot;Lettuce Prey&quot;</span>)</span></span>;<br><span class="hljs-function">StringBad <span class="hljs-title">sports</span><span class="hljs-params">(<span class="hljs-string">&quot;Spinach Leaves Bowl for Dollars&quot;</span>)</span></span>;<br><br>StringBad sailor = sports;<br><br>StringBad knot;<br>knot = headline1;<br></code></pre></td></tr></table></figure><p>前三个对象，<code>headline1</code>，<code>headline2</code>，<code>sports</code>都是有函数定义中<code>StringBad::StringBad(const char * s)</code>的构造函数进行构造；最后一个<code>knot</code>使用默认构造函数<code>StringBad::StringBad()</code>进行构造，因此，问题出现在<code>StringBad sailor = sports</code>上。</p><blockquote><p>sailor和knot的初始化很像，但程序处理的方式完全不同。knot在使用<strong>默认构造函数</strong>构造后用headline1进行赋值；而sailor对象使用了一种名叫<strong>复制构造函数</strong>的构造方式！</p></blockquote><h4 id="复制构造函数：隐藏的“第三者”"><a href="#复制构造函数：隐藏的“第三者”" class="headerlink" title="复制构造函数：隐藏的“第三者”"></a>复制构造函数：隐藏的“第三者”</h4><h5 id="复制构造函数的声明"><a href="#复制构造函数的声明" class="headerlink" title="复制构造函数的声明"></a>复制构造函数的声明</h5><p>sailor的构造函数原型等价于如下语句：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">StringBad sailor = <span class="hljs-built_in">StringBad</span> (sports);<br><span class="hljs-comment">//相当于把sailor的副本拷贝给sailor</span><br></code></pre></td></tr></table></figure><p>这里的<code>StringBad()</code>就是C++自动提供的<strong>复制构造函数</strong>，用于<strong>将一个对象复制到一个新创建的对象的初始化中</strong>，注意，是<strong>初始化不是赋值！！！</strong>knot对象的赋值操作和复制构造函数无关（后文会讲到，使用的是<code>赋值运算符</code>），因为对knot的初始化操作已经在上一行代码使用默认构造函数完成了。</p><p>下面是复制构造函数的原型，它<strong>接受一个指向类对象的常量引用作为参数</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">Class_name</span>(<span class="hljs-type">const</span> Class_name &amp;);<br><br><span class="hljs-built_in">StringBad</span>(<span class="hljs-type">const</span> StringBad &amp;);<br></code></pre></td></tr></table></figure><h5 id="复制构造函数的使用场景"><a href="#复制构造函数的使用场景" class="headerlink" title="复制构造函数的使用场景"></a>复制构造函数的使用场景</h5><p>复制构造函数的使用非常常见，尤其在<strong>将新对象与现有对象之间建立联系的时候</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">StringBad <span class="hljs-title">sailor</span><span class="hljs-params">(sports)</span></span>;<br>StringBad sailor=sports;<br>StringBad sailor = <span class="hljs-built_in">StringBad</span> (sports);<br>StringBad *sailor = <span class="hljs-keyword">new</span> <span class="hljs-built_in">StringBad</span>(sports); <br><span class="hljs-comment">//以上四种初始化方式等价，都会使用复制构造函数</span><br></code></pre></td></tr></table></figure><p>更深入地讲，当函数<strong>按值传递对象或返回对象时</strong>，会使用复制构造函数创建原始对象的一个副本作为临时对象，然后将<strong>临时对象的内容赋给要被初始化的对象</strong>（第四种初始化方式所赋值的是所创建的匿名对象的指针）。</p><p>例如程序中的 <code>callme2()</code>函数使用按值传递，会创建一个副本（<strong>这里和函数的形参实参传递本质是相同的</strong>），因此会使用复制构造函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">callme2</span><span class="hljs-params">(StringBad sb)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;String passed by value:\n&quot;</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;    \&quot;&quot;</span> &lt;&lt; sb &lt;&lt; <span class="hljs-string">&quot;\&quot;\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="复制构造函数的功能"><a href="#复制构造函数的功能" class="headerlink" title="复制构造函数的功能"></a>复制构造函数的功能</h5><p>默认的复制构造函数<strong>逐个复制非静态成员（成员复制也称为浅复制）</strong>，复制的是成员的值。  </p><ul><li><p>补充：显式使用复制构造函数提供了对对象复制行为的精细控制，因此也被称作<strong>深拷贝</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span>* data;<br>    <span class="hljs-built_in">MyClass</span>() &#123; data = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">0</span>); &#125;<br>    ~<span class="hljs-built_in">MyClass</span>() &#123; <span class="hljs-keyword">delete</span> data; &#125;<br>    <br>    <span class="hljs-comment">// 显式的复制构造函数</span><br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">const</span> MyClass&amp; other) &#123;<br>        <span class="hljs-comment">// 深拷贝</span><br>        data = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(*other.data);<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    MyClass a;<br>    *a.data = <span class="hljs-number">10</span>;<br>    MyClass b = a; <span class="hljs-comment">// 调用复制构造函数</span><br>    <span class="hljs-comment">// 现在b.data指向一个新的int，其值为10</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>显式声明</strong>：如果你不希望编译器生成默认的复制构造函数，可以通过在类中声明一个私有的复制构造函数并将其标记为<code>delete</code>来阻止默认复制构造函数的生成。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 其他成员函数和变量...</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">const</span> MyClass&amp;) = <span class="hljs-keyword">delete</span>; <span class="hljs-comment">// 阻止默认复制构造函数的生成</span><br>&#125;;<br></code></pre></td></tr></table></figure></li></ul><h4 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h4><p>在了解的复制构造函数后，就不难理解为何静态变量<code>num_strings</code>出现了负值了。在主程序 <code>vegnews.cpp</code> 中，有一下代码用到了隐式的复制构造函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">callme2</span>(headline2);<br>StringBad sailor = sports;<br><span class="hljs-comment">//使用隐式复制构造函数两次，因此计数器会出现-2，problems solved!</span><br></code></pre></td></tr></table></figure><blockquote><p>问题的解决方式已经在上文给出，构建显式构造函数。</p></blockquote><h3 id="问题分析2"><a href="#问题分析2" class="headerlink" title="问题分析2"></a>问题分析2</h3><p>接下来我们将重点放在 <code>字符串乱码</code>的问题上。</p><h4 id="还是复制构造函数的锅！"><a href="#还是复制构造函数的锅！" class="headerlink" title="还是复制构造函数的锅！"></a>还是复制构造函数的锅！</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">StringBad sailor = sports;<br></code></pre></td></tr></table></figure><p>上文提到，隐式复制构造函数奉行<strong>按值传递</strong>的基本思想，而这对于字符串成员而言是非常危险。因为C风格字符串的本质就是<code>char</code>数组，或者说指向<code>char</code>类型的特殊指针。</p><p>因此，在使用隐式复制构造函数时，<code>sports.str</code>将自己的<strong>值</strong>复制给了<code>sailor.str</code>。<strong>此时这两个字符串（指向char类型的指针）指向了同一块内存！</strong>，因此，当释放其中一个对象时，被调用的析构函数会执行下面的操作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">delete</span> [] str;<br></code></pre></td></tr></table></figure><p>在这个程序中，<code>sailor</code>先于 <code>sports</code>被析构函数调用，因此，<code>sailor.str</code>会先被<code>delete</code>掉，这样，**<code>sports.str</code>就变成了“无家可归”的悬挂指针**，后续生成乱码也就很好理解了。</p><p>更严重地，在后续<code>delete``sports.str</code>的时候，相当于程序对同一块内存连续delete两次，这会导致程序的异常终止。</p><h4 id="solution-1"><a href="#solution-1" class="headerlink" title="solution"></a>solution</h4><p>按值传递更加直观，易于理解，但是，一旦程序涉及于指针和内存管理相关的操作时，<strong>按值传递和按址传递（指针）会产生冲突</strong>。因此，手动构建一个显式的复制构造函数迫在眉睫。</p><p>这是原书给出的显示复制构造函数（深拷贝），手动使用 <code>strcpy</code>函数实现字符串的拷贝（按址拷贝）。</p><p><img src="/posts/Above-All/mory-and-Classes/3.png" alt="Explicit Copy Constructor"></p><h3 id="问题还未被解决…"><a href="#问题还未被解决…" class="headerlink" title="问题还未被解决…"></a>问题还未被解决…</h3><p>我们已经解决了因为<strong>隐式复制构造函数</strong>带来的一些问题，其中，问题②主要是因为浅拷贝的<strong>赋值操作</strong>导致的<strong>按值传递与按址传递的冲突</strong>。请看下面的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++">StringBad sailor = sports;<br><br>StringBad knot;<br>knot = headline1;<br></code></pre></td></tr></table></figure><p><code>sailor</code>使用复制构造函数，将<code>sports</code>对象的临时拷贝<strong>赋值</strong>给<code>sailor</code>完成初始化。<code>knot</code>在初始化时使用了默认构造函数，但是也免不了<code>knot = headline1</code>中对其的<strong>赋值操作</strong>，<strong>按值传递与按址传递的冲突</strong>仍然存在！</p><p><img src="/posts/Above-All/mory-and-Classes/input2.png" alt="Output"></p><p>输出示例验证了我们的猜想，在析构时，<code>knot</code>先被<code>delete</code>，因此在最后<code>delete</code> <code>headline1</code>时，字符串呈现乱码。也就是说，<strong>C++默认的对对象的赋值运算符依旧使用按值传递</strong>，即<strong>类重载赋值运算符</strong>。下面是这种运算符的函数原型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">Class_name &amp; Class_name::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Class_name &amp;)<br></code></pre></td></tr></table></figure><p>因此，解决问题的方式也显而易见了：手动定义赋值运算符的重载，和复制构造函数的定义基本相同。书中实现了运算符重载的代码示例：</p><p><img src="/posts/Above-All/mory-and-Classes/4.png" alt="Explicit Overloading of Assignment Operator"></p><h3 id="特殊成员函数"><a href="#特殊成员函数" class="headerlink" title="特殊成员函数"></a>特殊成员函数</h3><p>StringBad 类的问题是由特殊成员函数引起的。这些成员函数是自动定义的，就 StringBad 而言，这些函数的行为与类设计不符。具体地说， C++自动提供了下面这些成员函数：</p><ul><li><strong>默认构造函数，如果没有定义构造函数；</strong></li><li><strong>默认析构函数，如果没有定义；</strong></li><li><strong>复制构造函数，如果没有定义；</strong></li><li><strong>赋值运算符，如果没有定义；</strong></li><li><strong>地址运算符，如果没有定义。</strong>（读者可以自行查阅，就是取址运算符）</li></ul><p>更准确地说，编译器将生成上述最后三个函数的定义——如果程序使用对象的方式要求这样做。例如，如果您将一个对象赋给另一个对象，编译器将提供赋值运算符的定义。</p><h3 id="From-StringBad-to-String"><a href="#From-StringBad-to-String" class="headerlink" title="From StringBad to String"></a>From StringBad to String</h3><p>这就是C++风格的string类的实现！请阅读教材的12.2节，其简单介绍了string类的相关成员函数的定义，受篇幅限制，本博客不再讨论本节内容。对于使用者而言，只需要了解string类的接口足矣，但对于一位优秀的OOP学习者而言，但阅读书中代码，甚至尝试自己实现是锻炼自己OOP能力的一大有力武器。</p><p>此处只给出书中的源代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// string1.h -- fixed and augmented string class definition</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> STRING1_H_</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> STRING1_H_</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> std::ostream;<br><span class="hljs-keyword">using</span> std::istream;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">char</span> * str;             <span class="hljs-comment">// pointer to string</span><br>    <span class="hljs-type">int</span> len;                <span class="hljs-comment">// length of string</span><br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> num_strings; <span class="hljs-comment">// number of objects</span><br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> CINLIM = <span class="hljs-number">80</span>;  <span class="hljs-comment">// cin input limit</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// constructors and other methods</span><br>    <span class="hljs-built_in">String</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> * s); <span class="hljs-comment">// constructor</span><br>    <span class="hljs-built_in">String</span>();               <span class="hljs-comment">// default constructor</span><br>    <span class="hljs-built_in">String</span>(<span class="hljs-type">const</span> String &amp;); <span class="hljs-comment">// copy constructor</span><br>    ~<span class="hljs-built_in">String</span>();              <span class="hljs-comment">// destructor</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">length</span> <span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> len; &#125;<br><span class="hljs-comment">// overloaded operator methods    </span><br>    String &amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> String &amp;);<br>    String &amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *);<br>    <span class="hljs-type">char</span> &amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> i);<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> &amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> i) <span class="hljs-type">const</span>;<br><span class="hljs-comment">// overloaded operator friends</span><br>    <span class="hljs-keyword">friend</span> <span class="hljs-type">bool</span> <span class="hljs-built_in">operator</span>&lt;(<span class="hljs-type">const</span> String &amp;st, <span class="hljs-type">const</span> String &amp;st2);<br>    <span class="hljs-keyword">friend</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&gt;(<span class="hljs-type">const</span> String &amp;st1, <span class="hljs-type">const</span> String &amp;st2);<br>    <span class="hljs-keyword">friend</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> String &amp;st, <span class="hljs-type">const</span> String &amp;st2);<br>    <span class="hljs-keyword">friend</span> ostream &amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp; os, <span class="hljs-type">const</span> String &amp; st);<br>    <span class="hljs-keyword">friend</span> istream &amp; <span class="hljs-keyword">operator</span>&gt;&gt;(istream &amp; is, String &amp; st);<br><span class="hljs-comment">// static function</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">HowMany</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// string1.cpp -- String class methods</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span>                 <span class="hljs-comment">// string.h for some</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;string1.h&quot;</span>               <span class="hljs-comment">// includes &lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> std::cin;<br><span class="hljs-keyword">using</span> std::cout;<br><br><span class="hljs-comment">// initializing static class member</span><br><br><span class="hljs-type">int</span> String::num_strings = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// static method</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">String::HowMany</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> num_strings;<br>&#125;<br><br><span class="hljs-comment">// class methods</span><br>String::<span class="hljs-built_in">String</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> * s)     <span class="hljs-comment">// construct String from C string</span><br>&#123;<br>    len = std::<span class="hljs-built_in">strlen</span>(s);          <span class="hljs-comment">// set size</span><br>    str = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[len + <span class="hljs-number">1</span>];       <span class="hljs-comment">// allot storage</span><br>    std::<span class="hljs-built_in">strcpy</span>(str, s);           <span class="hljs-comment">// initialize pointer</span><br>    num_strings++;                 <span class="hljs-comment">// set object count</span><br>&#125;<br><br>String::<span class="hljs-built_in">String</span>()                   <span class="hljs-comment">// default constructor</span><br>&#123;<br>    len = <span class="hljs-number">4</span>;<br>    str = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-number">1</span>];<br>    str[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;\0&#x27;</span>;                 <span class="hljs-comment">// default string</span><br>    num_strings++;<br>&#125;<br><br>String::<span class="hljs-built_in">String</span>(<span class="hljs-type">const</span> String &amp; st)<br>&#123;<br>    num_strings++;             <span class="hljs-comment">// handle static member update</span><br>    len = st.len;              <span class="hljs-comment">// same length</span><br>    str = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span> [len + <span class="hljs-number">1</span>];  <span class="hljs-comment">// allot space</span><br>    std::<span class="hljs-built_in">strcpy</span>(str, st.str);  <span class="hljs-comment">// copy string to new location</span><br>&#125;<br><br>String::~<span class="hljs-built_in">String</span>()                     <span class="hljs-comment">// necessary destructor</span><br>&#123;<br>    --num_strings;                    <span class="hljs-comment">// required</span><br>    <span class="hljs-keyword">delete</span> [] str;                    <span class="hljs-comment">// required</span><br>&#125;<br><br><span class="hljs-comment">// overloaded operator methods    </span><br><br>    <span class="hljs-comment">// assign a String to a String</span><br>String &amp; String::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> String &amp; st)<br>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;st)<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    <span class="hljs-keyword">delete</span> [] str;<br>    len = st.len;<br>    str = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[len + <span class="hljs-number">1</span>];<br>    std::<span class="hljs-built_in">strcpy</span>(str, st.str);<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><br>    <span class="hljs-comment">// assign a C string to a String</span><br>String &amp; String::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> <span class="hljs-type">char</span> * s)<br>&#123;<br>    <span class="hljs-keyword">delete</span> [] str;<br>    len = std::<span class="hljs-built_in">strlen</span>(s);<br>    str = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[len + <span class="hljs-number">1</span>];<br>    std::<span class="hljs-built_in">strcpy</span>(str, s);<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><br>    <span class="hljs-comment">// read-write char access for non-const String</span><br><span class="hljs-type">char</span> &amp; String::<span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> i)<br>&#123;<br>    <span class="hljs-keyword">return</span> str[i];<br>&#125;<br><br>    <span class="hljs-comment">// read-only char access for const String</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> &amp; String::<span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> i) <span class="hljs-type">const</span><br>&#123;<br>    <span class="hljs-keyword">return</span> str[i];<br>&#125;<br><br><span class="hljs-comment">// overloaded operator friends</span><br><br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> String &amp;st1, <span class="hljs-type">const</span> String &amp;st2)<br>&#123;<br>    <span class="hljs-keyword">return</span> (std::<span class="hljs-built_in">strcmp</span>(st<span class="hljs-number">1.</span>str, st<span class="hljs-number">2.</span>str) &lt; <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&gt;(<span class="hljs-type">const</span> String &amp;st1, <span class="hljs-type">const</span> String &amp;st2)<br>&#123;<br>    <span class="hljs-keyword">return</span> st2 &lt; st1;<br>&#125;<br><br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> String &amp;st1, <span class="hljs-type">const</span> String &amp;st2)<br>&#123;<br>    <span class="hljs-built_in">return</span> (std::<span class="hljs-built_in">strcmp</span>(st<span class="hljs-number">1.</span>str, st<span class="hljs-number">2.</span>str) == <span class="hljs-number">0</span>);<br>&#125;<br><br>    <span class="hljs-comment">// simple String output</span><br>ostream &amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp; os, <span class="hljs-type">const</span> String &amp; st)<br>&#123;<br>    os &lt;&lt; st.str;<br>    <span class="hljs-keyword">return</span> os; <br>&#125;<br><br>    <span class="hljs-comment">// quick and dirty String input</span><br>istream &amp; <span class="hljs-keyword">operator</span>&gt;&gt;(istream &amp; is, String &amp; st)<br>&#123;<br>    <span class="hljs-type">char</span> temp[String::CINLIM];<br>    is.<span class="hljs-built_in">get</span>(temp, String::CINLIM);<br>    <span class="hljs-keyword">if</span> (is)<br>        st = temp;<br>    <span class="hljs-keyword">while</span> (is &amp;&amp; is.<span class="hljs-built_in">get</span>() != <span class="hljs-string">&#x27;\n&#x27;</span>)<br>        <span class="hljs-keyword">continue</span>;<br>    <span class="hljs-keyword">return</span> is; <br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// sayings1.cpp -- using expanded String class</span><br><span class="hljs-comment">// compile with string1.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;string1.h&quot;</span> </span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> ArSize = <span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MaxLen =<span class="hljs-number">81</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">using</span> std::cout;<br>    <span class="hljs-keyword">using</span> std::cin;<br>    <span class="hljs-keyword">using</span> std::endl;<br>    String name;<br>    cout &lt;&lt;<span class="hljs-string">&quot;Hi, what&#x27;s your name?\n&gt;&gt; &quot;</span>;<br>    cin &gt;&gt; name;<br><br>    cout &lt;&lt; name &lt;&lt; <span class="hljs-string">&quot;, please enter up to &quot;</span> &lt;&lt; ArSize<br>        &lt;&lt; <span class="hljs-string">&quot; short sayings &lt;empty line to quit&gt;:\n&quot;</span>;<br>    String sayings[ArSize];     <span class="hljs-comment">// array of objects</span><br>    <span class="hljs-type">char</span> temp[MaxLen];          <span class="hljs-comment">// temporary string storage</span><br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; ArSize; i++)<br>    &#123;<br>        cout &lt;&lt; i<span class="hljs-number">+1</span> &lt;&lt; <span class="hljs-string">&quot;: &quot;</span>;<br>        cin.<span class="hljs-built_in">get</span>(temp, MaxLen);<br>        <span class="hljs-keyword">while</span> (cin &amp;&amp; cin.<span class="hljs-built_in">get</span>() != <span class="hljs-string">&#x27;\n&#x27;</span>)<br>            <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span> (!cin || temp[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;\0&#x27;</span>)    <span class="hljs-comment">// empty line?</span><br>            <span class="hljs-keyword">break</span>;              <span class="hljs-comment">// i not incremented</span><br>        <span class="hljs-keyword">else</span><br>            sayings[i] = temp;  <span class="hljs-comment">// overloaded assignment</span><br>    &#125;<br>    <span class="hljs-type">int</span> total = i;              <span class="hljs-comment">// total # of lines read</span><br><br>    <span class="hljs-keyword">if</span> ( total &gt; <span class="hljs-number">0</span>)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Here are your sayings:\n&quot;</span>;<br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; total; i++)<br>            cout &lt;&lt; sayings[i][<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-string">&quot;: &quot;</span> &lt;&lt; sayings[i] &lt;&lt; endl;<br><br>        <span class="hljs-type">int</span> shortest = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> first = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; total; i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (sayings[i].<span class="hljs-built_in">length</span>() &lt; sayings[shortest].<span class="hljs-built_in">length</span>())<br>                shortest = i;<br>            <span class="hljs-keyword">if</span> (sayings[i] &lt; sayings[first])<br>                first = i;<br>        &#125;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Shortest saying:\n&quot;</span> &lt;&lt; sayings[shortest] &lt;&lt; endl;;<br>        cout &lt;&lt; <span class="hljs-string">&quot;First alphabetically:\n&quot;</span> &lt;&lt; sayings[first] &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">&quot;This program used &quot;</span>&lt;&lt; String::<span class="hljs-built_in">HowMany</span>() <br>             &lt;&lt; <span class="hljs-string">&quot; String objects. Bye.\n&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;No input! Bye.\n&quot;</span>;<br><span class="hljs-comment">// keep window open </span><br><span class="hljs-comment">/*    if (!cin)</span><br><span class="hljs-comment">        cin.clear();</span><br><span class="hljs-comment">    while (cin.get() != &#x27;\n&#x27;)</span><br><span class="hljs-comment">        continue; */</span> <br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="类中动态内存的使用"><a href="#类中动态内存的使用" class="headerlink" title="类中动态内存的使用"></a>类中动态内存的使用</h2><p>通过string类的实现，我们不难发现<strong>动态内存</strong>在类中的使用既便捷，又危险。下文总结了在类与对象定义过程中应当注意的易错点：</p><ul><li><p>使用<code>new</code>创建指针成员，应该在析构函数中使用<code>delete</code></p><ul><li><p><strong>注意点：尽量不要定义类中的静态指针成员，若需要请额外关注其生命周期！</strong></p></li><li><p>在C++中，如果你在类中定义了一个静态指针成员变量，你需要特别注意其生命周期的管理，因为静态成员变量在程序的整个生命周期内只存在一个实例。这意味着：</p><ol><li><strong>初始化</strong>：静态成员变量需要在类外进行初始化。</li><li><strong>内存管理</strong>：如果你使用了动态分配内存（例如，使用<code>new</code>关键字），你需要确保在程序结束之前手动释放这块内存。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span>* staticPointer;<br>&#125;;<br><br><span class="hljs-comment">// 类外初始化</span><br><span class="hljs-type">int</span>* MyClass::staticPointer = <span class="hljs-literal">nullptr</span>;<br></code></pre></td></tr></table></figure><ul><li><p><strong>程序结束之前</strong>：静态成员变量的生命周期与程序相同，因此在程序结束之前，你应该确保所有动态分配的内存被正确释放。这通常意味着在<code>main</code>函数结束之前或在某个全局清理函数中进行<code>delete</code>操作。</p></li><li><p><strong>自定义的清理函数</strong>：如果你希望在程序结束之前明确地控制删除静态成员变量的时间，你可以创建一个函数来执行清理操作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">cleanup</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">delete</span> MyClass::staticPointer;<br>    MyClass::staticPointer = <span class="hljs-literal">nullptr</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 程序运行...</span><br>    <span class="hljs-built_in">cleanup</span>(); <span class="hljs-comment">// 在程序结束前调用</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>使用智能指针</strong>：为了避免手动管理内存，可以考虑使用智能指针（例如<code>std::unique_ptr</code>或<code>std::shared_ptr</code>）来管理静态成员变量的生命周期。这样，内存管理将由智能指针自动处理：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">static</span> std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; staticPointer;<br>&#125;;<br><br><span class="hljs-comment">// 初始化</span><br>std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; MyClass::staticPointer = std::<span class="hljs-built_in">make_unique</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure><p>在这种情况下，你不需要手动<code>delete</code>，因为<code>unique_ptr</code>会在超出作用域时自动释放内存。</p></li><li><p><strong>避免重复删除</strong>：确保你不会多次<code>delete</code>同一个指针，因为这会导致未定义行为。</p></li><li><p>**检查指针是否为<code>nullptr</code>**：在删除静态指针前，检查它是否已经指向了有效的内存地址，防止对<code>nullptr</code>进行<code>delete</code>操作。</p></li></ul></li><li><p>推荐使用C++中的新的关键字<code>nullptr</code>（来替代C风格的<code>NULL</code>）</p></li></ul></li><li><p>注意C++中自动提供的若干<strong>特殊成员函数</strong></p><ul><li>默认构造函数</li><li>默认析构函数</li><li>（隐式）的复制构造函数</li><li>赋值运算符</li><li>地址运算符</li><li><strong>注意：如果你设计的类成员中存在指针等，请务必手动构建显式的成员函数！！！否则会因为按值传递和按址传递的冲突导致很多奇奇怪怪的问题（尤其在赋值和动态内存的手动管理上）</strong></li></ul></li><li><p><code>new</code>和<code>delete</code>很危险，但请踏出使用他们的第一步！</p></li></ul><p>例如，原书给出了三个定义构造函数的实例：</p><p><img src="/posts/Above-All/mory-and-Classes/example1.png"></p><p><img src="/posts/Above-All/mory-and-Classes/example2.png" alt="Standard Practices for Using Dynamic Memory"></p><h2 id="返回对象"><a href="#返回对象" class="headerlink" title="返回对象"></a>返回对象</h2><h3 id="返回类的引用"><a href="#返回类的引用" class="headerlink" title="返回类的引用"></a>返回类的引用</h3><p>在C++中，引用同样也是奉行“按址传递”思想的一大有力武器。在类中，返回引用不用拷贝一个类（这会消耗额外的内存），自然也不会调用复制构造函数。下文将介绍在类中返回引用的一些基础知识：</p><ul><li><p>使用<code>const</code>引用，效率更高，但同时需要注意匹配问题：</p><ul><li>如果形式参数是<code>const</code>对象的话，返回值也应该是<code>const</code>对象！</li></ul></li><li><p>返回指向非const对象的引用</p><ul><li>重载赋值运算符</li></ul><p>例如，我想实现一个连续赋值的操作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++">string s1=<span class="hljs-string">&quot;Hello world&quot;</span>;<br>string s2,s3;<br>s3=s2=s1;<br><span class="hljs-comment">//第三行代码等价于</span><br>s3=(s2=s1);<br></code></pre></td></tr></table></figure><p>首先执行赋值语句 <code>s2=s1</code>，问题来了，表达式的返回值是什么？对于基本数据类型而言，赋值表达式的返回类型是左操作数（即被赋值变量）的引用类型。例如，如果<code>a</code>是一个<code>int</code>变量，那么<code>a = b</code>的返回类型就是<code>int&amp;</code>。如果是自定义类，就需要我们 <strong>关注赋值运算符重载的返回类型、即返回一个自定义类的非const引用</strong>，示例代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 其他成员变量和成员函数...</span><br><br>    <span class="hljs-comment">// 赋值运算符重载</span><br>    MyClass&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> MyClass&amp; other) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;other) &#123; <span class="hljs-comment">// 自赋值检查，防止自我复制</span><br>            <span class="hljs-comment">// 执行实际的赋值操作</span><br>            <span class="hljs-comment">// 例如：</span><br>            <span class="hljs-comment">// this-&gt;data = other.data;</span><br>            <span class="hljs-comment">// ...</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>; <span class="hljs-comment">// 返回当前对象的引用</span><br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 私有成员变量</span><br>    <span class="hljs-type">int</span> data;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    MyClass a, b, c;<br>    <span class="hljs-comment">// 链式赋值</span><br>    a = b = c; <span class="hljs-comment">// 这将按预期工作</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><p>为什么是自身类型的非const引用？一方面，为了连续链式赋值的合法性，我们必须保证首先执行的赋值语句的返回值能够作为参数传入下一个赋值语句，例如在上面的代码中，首先执行的<code>s2=s1</code>，返回值是对s2的引用，而这正好能作为参数传入到下一个赋值语句（将<code>s2</code>的值传递给<code>s3</code>，在这里是s2的引用）。另一方面，由于赋值会改变对象的值，因此不可以使用const引用，故返回一个<strong>自身类型的非const引用</strong>。</p></blockquote><ul><li><code>&lt;&lt;</code>运算符</li></ul><p>这其实和赋值运算符的本质差不多，运算符的本质还是一个<strong>函数</strong>，所以运算（表达式）一定会有返回值（<strong>这个观点非常重要，对我们后续学习运算符重载有很大的帮助</strong>）。我们知道，<strong>流输出运算符的返回值是对流对象的引用</strong>，例如<code>cout&lt;&lt;&quot;Hello&quot;&lt;&lt;&quot;World&quot;;</code>返回的对象是<code>std::ostream&amp;</code>。</p><blockquote><p>还记得第一堂C++课的时候笔者接触到cin和cout，感叹其功能强大之处。但在之后的coding过程中，各种花里胡哨的输入输出类型让笔者恼羞成怒，甚至在一段时间内换回了C风格的<code>printf()</code>和<code>scanf()</code>。但是随着学习的深入，当我们对<strong>流</strong>和引用，类，对象等C++的新概念有了更深刻的理解之后，我们便能体会到cin和cout的强大究竟是如何实现的！</p></blockquote></li></ul><h3 id="返回局部变量：返回对象"><a href="#返回局部变量：返回对象" class="headerlink" title="返回局部变量：返回对象"></a>返回局部变量：返回对象</h3><p>考虑到局部变量的作用域，我们不应该在函数中返回一个局部变量的引用（否则会产生悬挂指针等非常严重的问题）。因此，我们需要<strong>返回一个对象</strong>。看下面的代码示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++">Vector Vector::operater+(<span class="hljs-type">const</span> Vector &amp; b) <span class="hljs-type">const</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">Vector</span>(x+b.x,y+b.y);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Vector</code>（向量）相信大家不陌生，在这里重载了算数运算符<code>+</code>，将两个矢量的和储存在一个新的临时对象中，作为函数的返回值之后再进行相关的赋值操作，最后被丢弃。<strong>在这里会不可避免的使用到复制构造函数，所以务必小心。</strong></p><p>为了保证安全性，可以返回一个<strong>const 对象</strong>，这样可以保证生成的临时对象的值不会被赋值运算符修改。</p><h2 id="使用指向对象的指针"><a href="#使用指向对象的指针" class="headerlink" title="使用指向对象的指针"></a>使用指向对象的指针</h2><h3 id="基本用法回顾"><a href="#基本用法回顾" class="headerlink" title="基本用法回顾"></a>基本用法回顾</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++">  <span class="hljs-comment">// use pointers to keep track of shortest, first strings</span><br>      String * shortest = &amp;sayings[<span class="hljs-number">0</span>]; <span class="hljs-comment">// initialize to first object</span><br>      String * first = &amp;sayings[<span class="hljs-number">0</span>];<br>      <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; total; i++)<br>      &#123;<br>          <span class="hljs-keyword">if</span> (sayings[i].<span class="hljs-built_in">length</span>() &lt; shortest-&gt;<span class="hljs-built_in">length</span>())<br>              shortest = &amp;sayings[i];<br>          <span class="hljs-keyword">if</span> (sayings[i] &lt; *first)     <span class="hljs-comment">// compare values</span><br>              first = &amp;sayings[i];     <span class="hljs-comment">// assign address</span><br>      &#125;<br>      cout &lt;&lt; <span class="hljs-string">&quot;Shortest saying:\n&quot;</span> &lt;&lt; * shortest &lt;&lt; endl;<br>      cout &lt;&lt; <span class="hljs-string">&quot;First alphabetically:\n&quot;</span> &lt;&lt; * first &lt;&lt; endl;<br><br>      <span class="hljs-built_in">srand</span>(<span class="hljs-built_in">time</span>(<span class="hljs-number">0</span>));<br>      <span class="hljs-type">int</span> choice = <span class="hljs-built_in">rand</span>() % total; <span class="hljs-comment">// pick index at random</span><br><br><br><br>  <span class="hljs-comment">// use new to create, initialize new String object</span><br>      String * favorite = <span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(sayings[choice]);<br><span class="hljs-comment">//这里会调用相应的构造函数</span><br>      cout &lt;&lt; <span class="hljs-string">&quot;My favorite saying:\n&quot;</span> &lt;&lt; *favorite &lt;&lt; endl;<br>      <span class="hljs-keyword">delete</span> favorite;<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>      cout &lt;&lt; <span class="hljs-string">&quot;Not much to say, eh?\n&quot;</span>;<br>  cout &lt;&lt; <span class="hljs-string">&quot;Bye.\n&quot;</span>;<br></code></pre></td></tr></table></figure><p>代码的第一部分是指向对象指针的常见用法，包括<code>-&gt;</code>运算符，常见的取址和解引用运算。代码的第二部分涉及到<code>new</code>和<code>delete</code>操作。</p><h3 id="一些高级用法"><a href="#一些高级用法" class="headerlink" title="一些高级用法"></a>一些高级用法</h3><h4 id="何时使用析构函数？"><a href="#何时使用析构函数？" class="headerlink" title="何时使用析构函数？"></a>何时使用析构函数？</h4><p><img src="/posts/Above-All/mory-and-Classes/%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0.png" alt="析构函数"></p><p>在下述情况下析构函数将被调用（参见图 12.4）。</p><ul><li>如果对象是动态变量，则当<strong>执行完定义该对象的程序块</strong>时，将调用该对象的析构函数。</li><li>如果对象是<strong>静态变量（外部、静态、静态外部或来自名称空间）</strong>，则在程序结束时将调用对象的析构函数。</li><li>如果对象是用 new 创建的，则仅当您<strong>显式使用 delete 删除对象</strong>时，其析构函数才会被调用。</li></ul><p>例如在上面的例子中，一共定义了三个基于<code>Act</code>类的对象：<code>nice</code>（全局变量，与程序共存亡）、<code>pt</code>（使用new定义的一个指向Act类的指针）、<code>up</code>（在一个代码块中定义的自动局部变量）</p><p><strong>注意！</strong></p><ul><li><p>如果析构函数通过对指针类成员使用 delete 来释放内存，则每个构造函数都应当使用 new 来初始化指针，或将它设置为空指针。</p><blockquote><p>如果类的析构函数使用<code>delete</code>来释放指针成员，那么意味着这个指针成员在对象的生命周期内被认为是指向动态分配的内存的。为了确保在对象被销毁时不会尝试删除一个未初始化的指针，每个构造函数都应该使用<code>new</code>来为指针成员分配内存，或者将指针成员初始化为<code>nullptr</code>（在C++11及以后的版本中使用<code>nullptr</code>，之前的版本使用<code>NULL</code>或<code>0</code>）</p></blockquote></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyClass</span>() : <span class="hljs-built_in">data</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">42</span>)) &#123;&#125; <span class="hljs-comment">// 初始化指针成员</span><br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">int</span> val) : <span class="hljs-built_in">data</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(val)) &#123;&#125; <span class="hljs-comment">// 另一种初始化方式</span><br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">MyClass</span><span class="hljs-params">(<span class="hljs-type">bool</span> flag)</span> : data(nullptr) &#123;</span>&#125; <span class="hljs-comment">// 将指针设置为空指针</span><br>    ~<span class="hljs-built_in">MyClass</span>() &#123;<br>        <span class="hljs-keyword">delete</span> data;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span>* data;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h4 id="定位new运算符"><a href="#定位new运算符" class="headerlink" title="定位new运算符"></a>定位new运算符</h4><h5 id="什么是定位new运算符？"><a href="#什么是定位new运算符？" class="headerlink" title="什么是定位new运算符？"></a>什么是定位new运算符？</h5><p><strong>定位new运算符</strong>（Placement New Operator）是C++中一种特殊的<code>new</code>运算符，它允许你将对象构造在预先分配好的内存位置上，而不像常规的<code>new</code>那样动态分配内存。这在某些情况下特别有用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">void</span>* memory = ...; <span class="hljs-comment">// 预先分配好的内存</span><br>SomeType* obj = <span class="hljs-built_in">new</span> (memory) <span class="hljs-built_in">SomeType</span>(arguments); <span class="hljs-comment">// 构造对象在预先分配的内存上</span><br></code></pre></td></tr></table></figure><p>这里的<code>memory</code>是一个指向已经分配好的内存的指针，<code>SomeType</code>是你的类或类型，<code>arguments</code>是传递给构造函数的参数。</p><ol><li><p><strong>不分配内存</strong>：定位new不会分配新的内存，它只是在<strong>给定的内存位置上调用构造函数来初始化对象</strong>。</p></li><li><p><strong>手动内存管理</strong>：使用定位new意味着你必须手动管理内存的生命周期，包括确保内存是在定位new之前分配的，并且在对象不再需要时正确地调用析构函数。</p></li><li><p><strong>异常安全性</strong>：如果构造函数抛出异常，定位new不会自动释放内存，因为它没有分配新的内存。你需要手动处理异常情况。</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">int</span> val) : <span class="hljs-built_in">value</span>(val) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Constructing MyClass with value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;<br>    &#125;<br>    ~<span class="hljs-built_in">MyClass</span>() &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Destructing MyClass with value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-type">int</span> value;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 预先分配一块内存</span><br>    <span class="hljs-type">char</span>* buffer = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-built_in">sizeof</span>(MyClass)];<br>    <br>    <span class="hljs-comment">// 使用定位new在预先分配的内存上构造对象</span><br>    MyClass* obj = <span class="hljs-built_in">new</span> (buffer) <span class="hljs-built_in">MyClass</span>(<span class="hljs-number">42</span>);<br>    <br>    <span class="hljs-comment">// 使用对象</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Object value: &quot;</span> &lt;&lt; obj-&gt;value &lt;&lt; std::endl;<br>    <br>    <span class="hljs-comment">// 手动调用析构函数</span><br>    obj-&gt;~<span class="hljs-built_in">MyClass</span>();<br>    <br>    <span class="hljs-comment">// 释放预先分配的内存</span><br>    <span class="hljs-keyword">delete</span>[] buffer;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="定位new运算符的使用注意事项"><a href="#定位new运算符的使用注意事项" class="headerlink" title="定位new运算符的使用注意事项"></a>定位new运算符的使用注意事项</h5><p>下面的程序对普通的<code>new</code>使用和<code>定位new运算符</code>的使用进行了比较，并归纳出使用<code>定位new运算符</code>的常见易错点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// placenew1.cpp  -- new, placement new, no delete</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;new&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> BUF = <span class="hljs-number">512</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">JustTesting</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>    string words;<br>    <span class="hljs-type">int</span> number;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">JustTesting</span>(<span class="hljs-type">const</span> string &amp; s = <span class="hljs-string">&quot;Just Testing&quot;</span>, <span class="hljs-type">int</span> n = <span class="hljs-number">0</span>) <br>    &#123;words = s; number = n; cout &lt;&lt; words &lt;&lt; <span class="hljs-string">&quot; constructed\n&quot;</span>; &#125;<br>    <span class="hljs-comment">//默认构造函数</span><br>    ~<span class="hljs-built_in">JustTesting</span>() &#123; cout &lt;&lt; words &lt;&lt; <span class="hljs-string">&quot; destroyed\n&quot;</span>;&#125;<br>    <span class="hljs-comment">//析构函数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Show</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; cout &lt;&lt; words &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; number &lt;&lt; endl;&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">char</span> * buffer = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[BUF];       <span class="hljs-comment">// get a block of memory</span><br><br>    JustTesting *pc1, *pc2;<br><br>    pc1 = <span class="hljs-built_in">new</span> (buffer) JustTesting;      <span class="hljs-comment">// place object in buffer</span><br>    pc2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">JustTesting</span>(<span class="hljs-string">&quot;Heap1&quot;</span>, <span class="hljs-number">20</span>);  <span class="hljs-comment">// place object on heap（直接在堆上分配内存）</span><br>    <br>    cout &lt;&lt; <span class="hljs-string">&quot;Memory block addresses:\n&quot;</span> &lt;&lt; <span class="hljs-string">&quot;buffer: &quot;</span>&lt;&lt; (<span class="hljs-type">void</span> *) buffer &lt;&lt; <span class="hljs-string">&quot;    heap: &quot;</span> &lt;&lt; pc2 &lt;&lt;endl;<br>    <span class="hljs-comment">//void*使buffer被强制转换成通用指针使其打印地址而不是字符串的值</span><br>    <br>    cout &lt;&lt; <span class="hljs-string">&quot;Memory contents:\n&quot;</span>;<br>    cout &lt;&lt; pc1 &lt;&lt; <span class="hljs-string">&quot;: &quot;</span>;<br>    pc1-&gt;<span class="hljs-built_in">Show</span>();<br>    cout &lt;&lt; pc2 &lt;&lt; <span class="hljs-string">&quot;: &quot;</span>;<br>    pc2-&gt;<span class="hljs-built_in">Show</span>();<br><br>    JustTesting *pc3, *pc4;<br>    pc3 = <span class="hljs-built_in">new</span> (buffer) <span class="hljs-built_in">JustTesting</span>(<span class="hljs-string">&quot;Bad Idea&quot;</span>, <span class="hljs-number">6</span>);<br>    pc4 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">JustTesting</span>(<span class="hljs-string">&quot;Heap2&quot;</span>, <span class="hljs-number">10</span>);<br>    cout &lt;&lt; <span class="hljs-string">&quot;Memory contents:\n&quot;</span>;<br>    cout &lt;&lt; pc3 &lt;&lt; <span class="hljs-string">&quot;: &quot;</span>;<br>    pc3-&gt;<span class="hljs-built_in">Show</span>();<br>    cout &lt;&lt; pc4 &lt;&lt; <span class="hljs-string">&quot;: &quot;</span>;<br>    pc4-&gt;<span class="hljs-built_in">Show</span>();<br>    <br>    <span class="hljs-keyword">delete</span> pc2;                          <span class="hljs-comment">// free Heap1         </span><br>    <span class="hljs-keyword">delete</span> pc4;                          <span class="hljs-comment">// free Heap2</span><br>    <span class="hljs-keyword">delete</span> [] buffer;                    <span class="hljs-comment">// free buffer</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;Done\n&quot;</span>;<br>    <span class="hljs-comment">// std::cin.get();</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>输出示例：</strong></p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">Just Testing constructed</span><br><span class="hljs-attribute">Heap1 constructed</span><br><span class="hljs-attribute">Memory block addresses</span><span class="hljs-punctuation">:</span><br><span class="hljs-attribute">buffer</span><span class="hljs-punctuation">:</span> <span class="hljs-string">0xf61e80    heap: 0xf62090</span><br><span class="hljs-attribute">Memory contents</span><span class="hljs-punctuation">:</span><br><span class="hljs-attribute">0xf61e80</span><span class="hljs-punctuation">:</span> <span class="hljs-string">Just Testing, 0</span><br><span class="hljs-attribute">0xf62090</span><span class="hljs-punctuation">:</span> <span class="hljs-string">Heap1, 20</span><br><span class="hljs-attribute">Bad Idea constructed</span><br><span class="hljs-attribute">Heap2 constructed</span><br><span class="hljs-attribute">Memory contents</span><span class="hljs-punctuation">:</span><br><span class="hljs-attribute">0xf61e80</span><span class="hljs-punctuation">:</span> <span class="hljs-string">Bad Idea, 6</span><br><span class="hljs-attribute">0xf620c0</span><span class="hljs-punctuation">:</span> <span class="hljs-string">Heap2, 10</span><br>Heap1 destroyed<br>Heap2 destroyed<br>Done<br></code></pre></td></tr></table></figure><p><strong>①覆盖问题</strong></p><p>尝试读懂代码的执行逻辑并观察输出示例，我们不难发现 <code>Just Testing</code>（pc1，调用了默认构造函数）和 <code>Bad Idea</code>（pc3，调用了显式构造函数和复制构造函数）两块存储的内存是相同的，都是 <code>buffer: 0xf61e80</code>的内存。</p><p>这会带来一个比较严重的问题，我们的初衷是在分配好的内存块上同时储存pc1和pc3两个指针指向的对象的内存，但是新对象（pc3指向的对象）<strong>在程序中覆盖掉了原来pc1所指向的对象，导致值的丢失</strong>。例如，如果我在代码的44行后加上<code>pc1-&gt;Show();</code>输出的结果会是<code>Bad Idea, 6</code>，原来pc1指向的对象的值已经被覆盖。</p><p>因此，程序员必须手动管理定位new运算符，使不同的指针指向不同区域的内存，互不冲突。修改方式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">pc1=<span class="hljs-built_in">new</span>(buffer) JustTesting;<br>pc3=<span class="hljs-built_in">new</span>(buffer+<span class="hljs-built_in">sizeof</span>(JustTesting)) <span class="hljs-built_in">JustTesting</span>(<span class="hljs-string">&quot;Better idea&quot;</span>,<span class="hljs-number">6</span>);<br></code></pre></td></tr></table></figure><p>在定义pc3的时候，加上了<code>sizeof(JustTesting)</code>，保证了两块被分配的内存不会产生重叠。</p><p><strong>②何时delete？</strong></p><p><strong>使用定位new运算符分配的内存在delete时要格外的小心！</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">delete</span> pc2;                          <span class="hljs-comment">// free Heap1         </span><br><span class="hljs-keyword">delete</span> pc4;                          <span class="hljs-comment">// free Heap2</span><br><span class="hljs-keyword">delete</span> [] buffer;                    <span class="hljs-comment">// free buffer</span><br>cout &lt;&lt; <span class="hljs-string">&quot;Done\n&quot;</span>;<br></code></pre></td></tr></table></figure><p>源代码中<code>delete</code>掉了所有动态分配的内存，包括p2，p4。p1，p3由于使用了定位new运算符，因此在delete掉buffer的内存指定区域后，p1，p3自然也就被delete掉了。这并不难理解，但是请注意以下操作是非法的！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">delete</span> pc2;                          <span class="hljs-comment">// free Heap1         </span><br><span class="hljs-keyword">delete</span> pc4;                          <span class="hljs-comment">// free Heap2</span><br><span class="hljs-keyword">delete</span> pc1;<span class="hljs-comment">//INVALID!</span><br><span class="hljs-keyword">delete</span> pc3;<span class="hljs-comment">//INVALID!</span><br></code></pre></td></tr></table></figure><p>原书中这一段讲的非常清楚并且直白，直接贴上来：</p><p>原因在于 delete 可与常规 new 运算符配合使用，但<strong>不能与定位 new 运算符配合使用</strong>。例如，指针 pc3 没有收到 new 运算符返回的地址，因此 <strong>delete pc3 将导致运行阶段错误</strong>。在另一方面，指针pc1 指向的地址与 buffer 相同， 但 buffer 是使用 new []初始化的，因此必须使用 delete [ ]而不是 delete来释放。即使 buffer 是使用 new 而不是 new []初始化的， delete pc1 也将释放 buffer，而不是 pc1。这是因为 new&#x2F;delete 系统知道已分配的 512 字节块 buffer，但对定位 new 运算符对该内存块做了何种处理一无所知。  </p><blockquote><p>总之一句话：<strong>不能混着用</strong>！</p></blockquote><p>那么，如何只delete我们定义的pc1和pc3而不delete掉整块buffer内存呢？我们可以<strong>显示地为定位new运算符创建的对象调用析构函数，销毁指定的对象。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++">pc3 = <span class="hljs-built_in">new</span> (buffer + <span class="hljs-built_in">sizeof</span> (JustTesting))<br>            <span class="hljs-built_in">JustTesting</span>(<span class="hljs-string">&quot;Better Idea&quot;</span>, <span class="hljs-number">6</span>);<br>pc4 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">JustTesting</span>(<span class="hljs-string">&quot;Heap2&quot;</span>, <span class="hljs-number">10</span>);<br><br>cout &lt;&lt; <span class="hljs-string">&quot;Memory contents:\n&quot;</span>;<br>cout &lt;&lt; pc3 &lt;&lt; <span class="hljs-string">&quot;: &quot;</span>;<br>pc3-&gt;<span class="hljs-built_in">Show</span>();<br>cout &lt;&lt; pc4 &lt;&lt; <span class="hljs-string">&quot;: &quot;</span>;<br>pc4-&gt;<span class="hljs-built_in">Show</span>();<br><br><span class="hljs-keyword">delete</span> pc2;           <span class="hljs-comment">// free Heap1         </span><br><span class="hljs-keyword">delete</span> pc4;           <span class="hljs-comment">// free Heap2</span><br><span class="hljs-comment">// explicitly destroy placement new objects</span><br>pc3-&gt;~<span class="hljs-built_in">JustTesting</span>();  <span class="hljs-comment">// destroy object pointed to by pc3</span><br>pc1-&gt;~<span class="hljs-built_in">JustTesting</span>();  <span class="hljs-comment">// destroy object pointed to by pc1</span><br><span class="hljs-comment">//这样的操作保证了我可以只delete两个指针指向的动态内存，但不delete掉buffer内存</span><br><span class="hljs-keyword">delete</span> [] buffer;     <span class="hljs-comment">// free buffer</span><br></code></pre></td></tr></table></figure><h2 id="ADT-for-queue"><a href="#ADT-for-queue" class="headerlink" title="ADT for queue"></a>ADT for queue</h2><p>因为篇幅限制，本博客不再转载这部分内容，而将其移动到<code>数据结构和算法部分</code>更新~</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li>《C++ Primer Plus》</li></ul><blockquote><p>THE END 2024&#x2F;12&#x2F;7</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Code</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tutorial</tag>
      
      <tag>C/C++</tag>
      
      <tag>OOP</tag>
      
      <tag>C++ Primer Plus</tag>
      
      <tag>Dynamic Memory</tag>
      
      <tag>Finished</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AI-indepth-reading-AlexNet</title>
    <link href="/posts/AI-indepth-reading-AlexNet/"/>
    <url>/posts/AI-indepth-reading-AlexNet/</url>
    
    <content type="html"><![CDATA[<h1 id="ImageNet-Classification-with-Deep-Convolutional-Neural-Networks"><a href="#ImageNet-Classification-with-Deep-Convolutional-Neural-Networks" class="headerlink" title="ImageNet Classification with Deep Convolutional Neural Networks"></a>ImageNet Classification with Deep Convolutional Neural Networks</h1><p>【写在前面的话】</p><p>本文是AI论文精读计划的第一篇！在本频道中我将采用<strong>双语</strong>模式力求用准确且逻辑清晰的语言复述表达论文作者的核心观点和细节实现，同时配上一些配图。希望大家喜欢</p><p>今天分享的文章是 <a href="https://dl.acm.org/doi/10.1145/3065386">ImageNet Classification with Deep Convolutional Neural Networks</a>，作者是 <a href="https://dl.acm.org/doi/10.1145/3065386#">Alex Krizhevsky</a> ， <a href="https://dl.acm.org/doi/10.1145/3065386#">Ilya Sutskever</a> 和 <a href="https://dl.acm.org/doi/10.1145/3065386#">Geoffrey E. Hinton</a> （今年诺奖得主）。<strong>这篇文章创新性地将卷积神经网络高效地应用到图像识别领域，在当年的ILSVRC比赛中以极大的优势斩获头名，同时也掀起了神经网络复兴和深度学习的浪潮。</strong></p><blockquote><p>This is the first article in our <strong>In-Depth Reading of AI Papers</strong> series! In this channel, I will use a <strong>bilingual</strong> approach to restate and explain the core ideas and implementation details of the paper’s authors with accuracy and clear logic, accompanied by some illustrations. I hope you enjoy it.</p><p>Today’s paper is “<a href="https://dl.acm.org/doi/10.1145/3065386">ImageNet Classification with Deep Convolutional Neural Networks</a>“, authored by <a href="https://dl.acm.org/doi/10.1145/3065386#">Alex Krizhevsky</a>, <a href="https://dl.acm.org/doi/10.1145/3065386#">Ilya Sutskever</a>, and <a href="https://dl.acm.org/doi/10.1145/3065386#">Geoffrey E. Hinton</a> (this year’s Nobel Prize winner). <strong>This article innovatively and efficiently applied convolutional neural networks to the field of image recognition, winning first place in the ILSVRC competition that year by a significant margin, and sparked the resurgence of neural networks and the wave of deep learning.</strong></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Frontier and Classic Papers in AI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Convolutional Neural Networks</tag>
      
      <tag>Artificial Intelligence</tag>
      
      <tag>AlexNet</tag>
      
      <tag>Image Clssification</tag>
      
      <tag>Deep Learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Above-All</title>
    <link href="/posts/Above-All/"/>
    <url>/posts/Above-All/</url>
    
    <content type="html"><![CDATA[<h1 id="Welcome-To-My-Blog"><a href="#Welcome-To-My-Blog" class="headerlink" title="Welcome To My Blog !"></a>Welcome To My Blog !</h1><h2 id="写在前面的话"><a href="#写在前面的话" class="headerlink" title="写在前面的话"></a>写在前面的话</h2><p>这部分的内容和 <a href="https://xiyuanyang-code.github.io/above/">Intro</a> 的部分相同，主要是对本人博客的更新动机，更新目标和更新内容做一个总体性的概览~可自行跳转观看。</p><h2 id="Before-The-Blog"><a href="#Before-The-Blog" class="headerlink" title="Before The Blog"></a>Before The Blog</h2><p>三个月前，我通过偶然的机会了解到前 OpenAI 研究副总裁，主管GPT模型安全的杰出华人女性，<strong>翁荔(Lilian Weng)<strong>。她提出了著名的</strong>Agent 配方：Agent&#x3D;LLM+Memory+planning skills+tool use</strong>。在当今的GPT时代，她可谓是功不可没。</p><p>在OpenAI对她的独家专访<a href="https://openai.com/index/the-power-of-continuous-learning/">The power of continuous learning</a>中，她提到：</p><blockquote><p>I believe in the power of learning and it is never too late to learn. Maintaining my personal blog is a good way to keep this curiosity going and learn about new progress in the deep learning community regularly. I also encourage my team to keep on learning, whether related or unrelated to their current projects. Ideas in different topics or fields can often inspire new ideas and broaden the potential solution space.</p><p>I’m also a strong believer in teamwork. If everyone shines in their best strength, we will get 1+1 &gt; 2. Meanwhile, we might often run into “dirty” work and personally I’m very willing to take on those tasks, because as long as that’s the biggest blocker or that task can add the biggest value into the project, nothing should be considered “dirty” or “trivial.” I encourage people around me to do the same, being a team player and working together to expedite the team productivity.</p><p>我相信学习的力量，学习永远不会太迟。维护个人博客是一个保持好奇心，定期了解深度学习社区新进展的好方法。我也鼓励我的团队不断学习，无论是否与他们当前的项目相关。不同主题或领域的想法常常能激发新的灵感，并拓宽潜在的解决方案空间。</p><p>我也是团队合作的坚定信徒。如果每个人都能在自己最擅长的领域发光，我们就能实现1+1大于2。同时，我们可能会碰到一些“脏活”，而我个人非常愿意承担这些任务，因为只要那是最大的障碍，或者那项任务能为项目带来最大的价值，就没有什么是“脏活”或“琐事”。我鼓励周围的人也这样做，成为团队的一员，共同努力提高团队的生产力。</p></blockquote><p><img src="https://images.ctfassets.net/kftzwdyauwt9/e3357d5a-b177-4b3a-1edf79a7f2dc/ca1f3418cd72b4eb84c9d1a09dfffc7f/stangel-2022-0421.jpg?w=3840&q=90&fm=webp" alt="Lilian Weng&#39;s interview"></p><p>图源：<a href="https://openai.com/index/the-power-of-continuous-learning/">The power of continuous learning | OpenAI</a>   Photo: Jake Stangel</p><blockquote><p>PS：这个姐姐好漂亮~</p></blockquote><p>这与<strong>费曼学习法（Feynman Technique）</strong>可谓是不谋而合：</p><blockquote><p>1.Identify the subject. Write down everything you know about the topic.</p><p>2.Teach it to a child. If you can teach a concept to a child, you’re way ahead of the game.</p><p>3.Identify your knowledge gaps. This is the point where the real learning happens.</p><p>4.Organize + simplify + Tell a story. Start to tell your story.</p></blockquote><p>此时，刚刚步入大学校园3个月的笔者，由于深受高中优绩主义和应试思想的遗风荼毒，对大学生活和计算机学科的学习颇具不适应的疲态。学习的知识如此海量，却无法依靠应试和做题进行巩固，该如何是好？</p><p>或许<strong>上文已经给出了答案。</strong></p><center><p><font size=6><b><p style="color:red;">我要创建自己的博客!</p></b></font></p></center><p>无论是传统的做题刷卷，还是博客，亦或是“费曼学习法”，本质上都是<strong>强化训练人脑在吸收新知识后的有效输出过程</strong>：当你能很流畅地给出一道数学题的若干种证明方法时，能逻辑清晰地将所学的知识穿成逻辑链条或思维导图，呈现在博客中为他人所吸收时，你便通过<strong>有效的对外做功输出</strong>很好地巩固了所学的知识。同时，知识的不断沉淀也带来了莫大的成就感。</p><p>但是，写一篇博客，可不仅仅是打打字那么简单。</p><p>不知各位在高中写议论文的时候有没有一种“咬牙切齿”的感觉，就是<strong>我想到的≠我实际构思好的≠我输出的≠我希望所表达的</strong>，甚至于，很多时候我们心中所谓的灵感只是<strong>乍现的只言片语的碎片</strong>，距离成为一篇逻辑清晰，内容详实且有创新性的博客文章还有很长的路要走。这便是博客写作的难点，也是<strong>我希望通过个人博客来训练的最重要的内容：将心里的灵感进行有效的输出，力求逻辑性和学术的专业性。</strong></p><h2 id="About-the-Blog"><a href="#About-the-Blog" class="headerlink" title="About the Blog"></a>About the Blog</h2><p><strong>Xiyuan Yang’s Blog</strong>，创建于<strong>2024年11月19日</strong>。</p><p>以下是自我简介（摘自<a href="https://xiyuanyang-code.github.io/about/">About - Xiyuan Yang’s Blog</a>）：</p><blockquote><p>Greetings! I am <strong>Xiyuan Yang (杨希渊)</strong>, currently pursuing an undergraduate degree in Artificial Intelligence at Shanghai Jiao Tong University. With a longstanding aspiration to become a programmer, I am passionate about leveraging technology to make a meaningful impact on the world. Through my personal website, I aim to share a collection of my blogs and learning notes with you. Some of these entries will be presented as a series, updated at irregular intervals. Additionally, I will offer insights into my personal observations and reflections on life. I hope your visit here is both enjoyable and enriching!</p></blockquote><blockquote><p><strong>My email:</strong></p><ul><li><p><a href="mailto:xiyuan__yang@outlook.com">xiyuan__yang@outlook.com</a></p></li><li><p><a href="mailto:yangxiyuan@sjtu.edu.cn">yangxiyuan@sjtu.edu.cn</a></p><p>Feel free to contact me!</p></li></ul></blockquote><blockquote><p>VENI VIDI VICI</p></blockquote><p>这个博客的更新内容将随着笔者后续的专业课程的学习同步进行，<strong>旨在分享笔者在学习过程中学到的有意思的专业知识，力求在博客输出的过程中培养自己的逻辑思维和表达能力</strong>，不过更新时间，更新内容，更新篇幅<strong>将会完全随机</strong>。</p><p>本博客部署在github的静态网站上，轮子使用<code>Hexo</code>的<code>Fluid</code>的模版，配置环境还是比较简单的，下面贴出一些相关的网址，有相同爱好的童鞋可以参考借鉴一下：</p><ul><li><a href="https://github.com/xiyuanyang-code">xiyuanyang-code (Xiyuan Yang)我的Github主页</a></li><li><a href="https://github.com/xiyuanyang-code/xiyuanyang-code.github.io">xiyuanyang-code&#x2F;xiyuanyang-code.github.io我的博客Github仓库</a></li><li><a href="https://github.com/fluid-dev/hexo-theme-fluid">fluid-dev&#x2F;hexo-theme-fluid-Design theme for Hexo Fluid的Github官方仓库</a></li><li><a href="https://fluid-dev.github.io/hexo-fluid-docs/guide/">配置指南 | Hexo Fluid 用户手册</a></li><li><a href="https://fluid-dev.github.io/hexo-fluid-docs/start/">开始使用 | Hexo Fluid 用户手册</a></li></ul><p>有关博客的具体更新内容，请详见<code>Goals and Plans of Updates</code>部分~</p><h2 id="Goals-and-Plans-of-Updates"><a href="#Goals-and-Plans-of-Updates" class="headerlink" title="Goals and Plans of Updates"></a>Goals and Plans of Updates</h2><h3 id="更新的主要内容"><a href="#更新的主要内容" class="headerlink" title="更新的主要内容"></a>更新的主要内容</h3><p>笔者更新的主要内容包括：（<strong>草拟</strong>）</p><ul><li>编程语言的语法学习<ul><li>C&#x2F;C++</li><li>Python<ul><li>语法</li><li>Anaconda</li><li>一些常见的库</li></ul></li><li>HTML&#x2F;Javascript</li><li>Bash&#x2F;Shell</li></ul></li><li>一些常用的工具教程<ul><li>LaTeX</li><li>命令行</li><li>Git</li><li>Vim编辑器</li><li>Linux和服务器（主要和深度学习相关）<ul><li>Linux常见命令</li><li>Tmux</li><li>SSH远程连接</li></ul></li></ul></li><li>[CS]算法<ul><li>数据结构</li><li>算法</li><li>计算机四大件</li></ul></li><li>AI专业课<ul><li>机器学习</li><li>强化学习</li><li>深度学习<ul><li>Pytorch</li></ul></li></ul></li><li>AI前沿&amp;经典论文精读</li><li><del>一些晦涩难懂的</del>数学课</li><li>发发牢骚</li></ul><h3 id="具体的分类（实时更新）"><a href="#具体的分类（实时更新）" class="headerlink" title="具体的分类（实时更新）"></a>具体的分类（实时更新）</h3><ul><li><strong>Code</strong></li><li><strong>Math</strong></li><li><strong>Efficient Tools</strong></li><li><strong>Algorithm</strong></li><li><strong>Frontier and Classic Papers in AI</strong></li><li><strong>AI Core Courses</strong></li></ul><h3 id="具体的标签（实时更新）"><a href="#具体的标签（实时更新）" class="headerlink" title="具体的标签（实时更新）"></a>具体的标签（实时更新）</h3><p>见 <a href="https://xiyuanyang-code.github.io/tags/">Tags</a> 页。</p><h2 id="Several-Pages"><a href="#Several-Pages" class="headerlink" title="Several Pages"></a>Several Pages</h2><p>以下是对本博客若干基本页面的介绍：</p><ul><li><h4 id="Home"><a href="#Home" class="headerlink" title="Home"></a>Home</h4></li><li><h4 id="Intro（你现在在的地方）"><a href="#Intro（你现在在的地方）" class="headerlink" title="Intro（你现在在的地方）"></a><strong>Intro</strong>（你现在在的地方）</h4></li><li><h4 id="Archives（文章）"><a href="#Archives（文章）" class="headerlink" title="Archives（文章）"></a>Archives（文章）</h4></li><li><h4 id="Categories（分类页）"><a href="#Categories（分类页）" class="headerlink" title="Categories（分类页）"></a>Categories（分类页）</h4></li><li><h4 id="Tags（标签页）"><a href="#Tags（标签页）" class="headerlink" title="Tags（标签页）"></a>Tags（标签页）</h4></li><li><h4 id="About（关于作者）"><a href="#About（关于作者）" class="headerlink" title="About（关于作者）"></a>About（关于作者）</h4></li><li><h4 id="FAQ（一些常见的问题）"><a href="#FAQ（一些常见的问题）" class="headerlink" title="FAQ（一些常见的问题）"></a>FAQ（一些常见的问题）</h4></li><li><h4 id="Resume（Academic-CV-of-the-Author）"><a href="#Resume（Academic-CV-of-the-Author）" class="headerlink" title="Resume（Academic CV of the Author）"></a>Resume（<strong>Academic CV of the Author</strong>）</h4></li></ul><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p><a href="https://github.com/lilianweng">lilianweng (Lilian)的github主页</a></p><p> <a href="https://lilianweng.github.io/">Lil’Log（翁荔的博客）</a></p><p><a href="https://openai.com/index/the-power-of-continuous-learning/">The power of continuous learning | OpenAI</a></p><p><a href="https://github.com/xiyuanyang-code">https://github.com/xiyuanyang-code</a></p><p><a href="https://github.com/xiyuanyang-code/xiyuanyang-code.github.io">https://github.com/xiyuanyang-code/xiyuanyang-code.github.io</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Announcement</tag>
      
      <tag>Updating</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Algorithm_tutorial_section1</title>
    <link href="/posts/Algorithm-tutorial-section1/"/>
    <url>/posts/Algorithm-tutorial-section1/</url>
    
    <content type="html"><![CDATA[<h1 id="Algorithm-tutorial-section1"><a href="#Algorithm-tutorial-section1" class="headerlink" title="Algorithm_tutorial_section1"></a>Algorithm_tutorial_section1</h1><p>【写在前面的话】</p><p>​本文是笔者自己算法课程的学习笔记，目前的学习内容主要是算法和数据结构基础（提前自学，笔者会在大一下学期系统学习），学习途径和资源主要是 <a href="https://www.hello-algo.com/">Hello 算法</a>（一本非常易入门的算法书！非常推荐！）。因此，<strong>此文章是Algorithm_tutorial的第一篇博客~，且大部分内容来自Hello算法原书，原创部分属于少数，笔者在此处只是按照自己的知识体系进行归纳总结并且尝试记录下来。</strong>希望大家都能愉快地开启自己的算法学习之旅~</p><h1 id="Algorithm-Section1-Introduction"><a href="#Algorithm-Section1-Introduction" class="headerlink" title="Algorithm.Section1 Introduction"></a>Algorithm.Section1 Introduction</h1><p>Introduction：</p><ul><li>迭代与递归</li><li>时间复杂度</li><li>空间复杂度</li><li>数据结构的物理结构</li></ul><h2 id="一、算法-复杂度分析"><a href="#一、算法-复杂度分析" class="headerlink" title="一、算法 复杂度分析"></a>一、算法 复杂度分析</h2><p>​由于实际测试具有较大的局限性，因此我们可以考虑仅通过一些计算来评估算法的效率。这种估算方法被称为渐近复杂度分析（asymptotic complexity analysis），简称复杂度分析。</p><p>​复杂度分析能够体现算法运行所需的时间和空间资源与输入数据大小之间的关系。<strong>它描述了随着输入数据大小的增加，算法执行所需时间和空间的增长趋势</strong>。这个定义有些拗口，我们可以将其分为三个重点来理解。</p><ul><li>“<strong>时间和空间资源</strong>”分别对应时间复杂度（time complexity）和空间复杂度（space complexity）。</li><li>“随着输入数据大小的增加”意味着复杂度反映了算法运行效率与输入数据体量之间的关系。</li><li>“<strong>时间和空间的增长趋势</strong>”表示复杂度分析关注的不是运行时间或占用空间的具体值，而是时间或空间增长的“快慢”。（<strong>一种趋势！</strong>）</li></ul><h3 id="迭代与递归"><a href="#迭代与递归" class="headerlink" title="@迭代与递归"></a>@迭代与递归</h3><p><strong>迭代：自下而上，小问题积累成大问题</strong></p><p><strong>递归：自上而下，大问题拆解成小问题</strong></p><p>程序实现重复代码块执行的两种方式：</p><ul><li><p>迭代（for循环，while循环）</p></li><li><p>递归</p></li></ul><p>​递归（recursion）是一种算法策略，通过函数调用自身来解决问题。它主要包含两个阶段。</p><ol><li><strong>递</strong>：程序不断深入地调用自身，通常传入更小或更简化的参数，直到达到“终止条件”。</li><li><strong>归</strong>：触发“终止条件”后，程序从最深层的递归函数开始逐层返回，汇聚每一层的结果。</li></ol><p>​而从实现的角度看，递归代码主要包含三个要素。</p><ol><li><strong>终止条件</strong>：用于决定什么时候由“递”转“归”。</li><li><strong>递归调用</strong>：对应“递”，函数调用自身，通常输入更小或更简化的参数。</li><li><strong>返回结果</strong>：对应“归”，将当前递归层级的结果返回至上一层。</li></ol><p><strong>有关递归的时间问题和空间问题</strong></p><p>​递归函数每次调用自身时，系统都会为新开启的函数分配内存，以存储局部变量、调用地址和其他信息等。这将导致两方面的结果。</p><ul><li><p>函数的上下文数据都存储在称为“<strong>栈帧空间</strong>”的内存区域中，直至函数返回后才会被释放。因此，<strong>递归通常比迭代更加耗费内存空间</strong>。（需要控制递归深度，否则过深的递归会导致栈的溢出错误）</p></li><li><p><strong>有关栈帧空间</strong>：</p></li><li><p>栈帧空间是指在程序执行过程中，为每个函数调用分配的一块内存区域，用于存储该函数的局部变量、参数、返回地址以及其他控制信息。每次函数被调用时，都会在调用栈上创建一个新的栈帧，这个栈帧的生命周期与函数的执行周期相同。</p><ol><li><strong>返回地址</strong>：当函数调用完成后，程序需要知道从哪里继续执行，因此返回地址会被压入栈帧中。</li><li><strong>参数</strong>：函数调用时传递给被调用函数的参数也会存储在栈帧中。</li><li><strong>局部变量</strong>：函数内部定义的局部变量会占用栈帧空间。</li><li><strong>控制信息</strong>：包括指向上一个栈帧的指针（帧指针），用于维护调用链。</li></ol><p><strong>栈帧的工作机制</strong></p><ul><li><strong>入栈</strong>：当一个函数被调用时，首先将参数和返回地址压入栈中，然后分配空间给局部变量，形成新的栈帧。</li><li><strong>出栈</strong>：当函数执行完毕时，局部变量和参数的空间被释放，返回地址被弹出，程序控制流转回调用该函数的位置。</li></ul><p><strong>栈帧的优点</strong></p><ul><li><strong>自动管理</strong>：栈帧由系统自动管理，无需手动分配和释放内存。</li><li><strong>高效性</strong>：由于栈的后进先出特性，内存分配和释放速度非常快。</li></ul></li><li><p>递归调用函数会产生额外的开销。<strong>因此递归通常比循环的时间效率更低</strong>。</p></li><li><p><strong>使用尾递归</strong>可以优化递归的效率（系统无需保存函数上一级的上下文）</p></li></ul><p><strong>有关递归树</strong></p><p>我们在函数内递归调用了两个函数，<strong>这意味着从一个调用产生了两个调用分支</strong>。如图 2-6 所示，这样不断递归调用下去，最终将产生一棵层数为 n 的递归树（recursion tree）。</p><p><img src="https://www.hello-algo.com/chapter_computational_complexity/iteration_and_recursion.assets/recursion_tree.png" alt="斐波那契数列的递归树"></p><blockquote><p>这种递归树可以达到指数阶的时间复杂度。</p></blockquote><p><strong>一定要理解递归的核心思想：分治！</strong></p><p>从本质上看，递归体现了“将问题分解为更小子问题”的思维范式，这种分治策略至关重要。</p><ul><li>从算法角度看，<strong>搜索、排序、回溯、分治、动态规划</strong>等许多重要算法策略直接或间接地应用了这种思维方式。</li><li>从数据结构角度看，<strong>递归天然适合处理链表、树和图的相关问题</strong>，因为它们非常适合用分治思想进行分析。</li></ul><p><strong>迭代和递归的本质与内在联系</strong></p><p>以上述递归函数为例，求和操作在递归的“归”阶段进行。这意味着<strong>最初被调用的函数实际上是最后完成其求和操作</strong>的，<strong>这种工作机制与栈的“先入后出”原则异曲同工</strong>。</p><p>事实上，“<strong>调用栈</strong>”和“<strong>栈帧空间</strong>”这类递归术语已经暗示了递归与栈之间的密切关系。</p><ol><li><strong>递</strong>：当函数被调用时，系统会在“调用栈”上为该函数分配新的栈帧，用于<strong>存储函数的局部变量、参数、返回地址</strong>等数据。</li><li><strong>归</strong>：当函数完成执行并返回时，对应的栈帧会被从“调用栈”上移除，恢复之前函数的执行环境。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">for_loop_recur</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;使用迭代模拟递归&quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 使用一个显式的栈来模拟系统调用栈</span><br>    stack = []<br>    res = <span class="hljs-number">0</span><br>    <span class="hljs-comment"># 递：递归调用</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>):<br>        <span class="hljs-comment"># 通过“入栈操作”模拟“递”</span><br>        stack.append(i)<br>    <span class="hljs-comment"># 归：返回结果</span><br>    <span class="hljs-keyword">while</span> stack:<br>        <span class="hljs-comment"># 通过“出栈操作”模拟“归”</span><br>        res += stack.pop()<br>    <span class="hljs-comment"># res = 1+2+3+...+n</span><br>    <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="@时间复杂度"></a>@时间复杂度</h3><ul><li><strong>常数</strong>时间复杂度</li><li><strong>线性</strong>时间复杂度</li><li><strong>平方</strong>时间复杂度</li><li><strong>指数阶</strong>时间复杂度<ul><li>递归树的一分为二</li></ul></li><li><strong>对数阶</strong>时间复杂度<ul><li>每轮缩减到一半</li><li>也会出现在递归树中（经典例题：快速幂计算）</li></ul></li><li><strong>线性对数阶</strong>时间复杂度（<code>O(nlogn)</code>）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">linear_log_recur</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;线性对数阶&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">if</span> n &lt;= <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    <span class="hljs-comment"># 一分为二，子问题的规模减小一半</span><br>    count = linear_log_recur(n // <span class="hljs-number">2</span>) + linear_log_recur(n // <span class="hljs-number">2</span>)<br>    <span class="hljs-comment"># 与C++不同，//表示地板出发（整数截断）</span><br>    <span class="hljs-comment"># 当前子问题包含 n 个操作</span><br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>        count += <span class="hljs-number">1</span><br>    <span class="hljs-comment"># 代表当前需要执行的n次操作</span><br>    <span class="hljs-keyword">return</span> count<br></code></pre></td></tr></table></figure><p><img src="https://www.hello-algo.com/chapter_computational_complexity/time_complexity.assets/time_complexity_logarithmic_linear.png" alt="线性对数阶的时间复杂度"></p><ul><li><strong>阶乘阶</strong>时间复杂度</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">factorial_recur</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;阶乘阶（递归实现）&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    count = <span class="hljs-number">0</span><br>    <span class="hljs-comment"># 从 1 个分裂出 n 个</span><br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>        count += factorial_recur(n - <span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> count<br></code></pre></td></tr></table></figure><p><img src="https://www.hello-algo.com/chapter_computational_complexity/time_complexity.assets/time_complexity_factorial.png" alt="阶乘阶的时间复杂度"></p><p>时间复杂度的分类：</p><ul><li>最差时间复杂度</li><li>最佳时间复杂度</li></ul><blockquote><p>以上两个时间复杂度均与数据的分布存在联系，具有偶然性</p></blockquote><ul><li>平均时间复杂度</li></ul><p>符号表示：</p><p>时间复杂度的符号表示法主要有三种：<code>O</code>、<code>Ω</code> 和 <code>Θ</code>，它们分别表示算法在不同情况下的性能表现。</p><ol><li><p><strong>大 O 表示法 (O(f(n)))</strong>：</p><ul><li>描述：表示算法在<strong>最坏情况下的时间复杂度</strong>。</li><li>用途：用于描述算法的上界，即算法的执行时间不会超过某个函数的增长速度。</li><li>示例：如果一个算法的时间复杂度是 (O(n^2))，意味着在最坏情况下，算法的执行时间最多是输入规模的平方。</li></ul></li><li><p><strong>大 Ω 表示法 (Ω(f(n)))</strong>：</p><ul><li>描述：表示算法在<strong>最好情况下的时间复杂度</strong>。</li><li>用途：用于描述算法的下界，即算法的执行时间至少是某个函数的增长速度。</li><li>示例：如果一个算法的时间复杂度是 (Ω(n))，意味着在最好情况下，算法的执行时间至少是输入规模的线性增长。</li></ul></li><li><p><strong>大 Θ 表示法 (Θ(f(n)))</strong>：</p><ul><li>描述：表示算法在<strong>平均情况下的时间复杂度</strong>。</li><li>用途：用于描述算法的确界，即算法的执行时间既不会超过某个函数的上界，也不会低于某个函数的下界。</li><li>示例：如果一个算法的时间复杂度是 (Θ(n \log n))，意味着在所有情况下，算法的执行时间大致是输入规模的 (n \log n) 级别。</li></ul></li></ol><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="@空间复杂度"></a>@空间复杂度</h3><p>算法在运行过程中使用的内存空间主要包括以下几种。</p><ul><li><strong>输入空间</strong>：用于存储算法的输入数据。</li><li><strong>暂存空间</strong>：用于存储算法在运行过程中的变量、对象、函数上下文等数据。</li><li><strong>输出空间</strong>：用于存储算法的输出数据。</li></ul><p>一般情况下，空间复杂度的统计范围是“<strong>暂存空间”加上“输出空间”</strong>。</p><p>暂存空间可以进一步划分为三个部分。</p><ul><li><strong>暂存数据</strong>：用于保存算法运行过程中的各种常量、变量、对象等。</li><li><strong>栈帧空间</strong>：用于保存调用函数的上下文数据。系统在每次调用函数时都会在栈顶部创建一个栈帧，函数返回后，栈帧空间会被释放。</li><li><strong>指令空间</strong>：用于保存编译后的程序指令，在实际统计中通常忽略不计。</li></ul><p>在分析一段程序的空间复杂度时，<strong>我们通常统计暂存数据、栈帧空间和输出数据三部分</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;类&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, x: <span class="hljs-built_in">int</span></span>):<br>        <span class="hljs-variable language_">self</span>.val: <span class="hljs-built_in">int</span> = x              <span class="hljs-comment"># 节点值</span><br>        <span class="hljs-variable language_">self</span>.<span class="hljs-built_in">next</span>: Node | <span class="hljs-literal">None</span> = <span class="hljs-literal">None</span>  <span class="hljs-comment"># 指向下一节点的引用</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">function</span>() -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;函数&quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 执行某些操作...</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">algorithm</span>(<span class="hljs-params">n</span>) -&gt; <span class="hljs-built_in">int</span>:  <span class="hljs-comment"># 输入数据</span><br>    A = <span class="hljs-number">0</span>                 <span class="hljs-comment"># 暂存数据（常量，一般用大写字母表示）</span><br>    b = <span class="hljs-number">0</span>                 <span class="hljs-comment"># 暂存数据（变量）</span><br>    node = Node(<span class="hljs-number">0</span>)        <span class="hljs-comment"># 暂存数据（对象）</span><br>    c = function()        <span class="hljs-comment"># 栈帧空间（调用函数）</span><br>    <span class="hljs-keyword">return</span> A + b + c      <span class="hljs-comment"># 输出数据</span><br></code></pre></td></tr></table></figure><p>​而与时间复杂度不同的是，<strong>我们通常只关注最差空间复杂度</strong>。这是因为内存空间是一项硬性要求，我们必须确保在所有输入数据下都有足够的内存空间预留。</p><ul><li>以最差输入数据为准</li><li>以算法运行的<strong>峰值内存</strong>（注意不是累积量）为准</li></ul><p>一些常见的空间复杂度：</p><ul><li><p>常数阶空间复杂度</p><ul><li>在循环中初始化变量或调用函数而占用的内存，在进入下一循环后就会被释放，因此不会累积占用空间，空间复杂度还是<code>O(1)</code>。</li></ul></li><li><p>线性阶空间复杂度</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">linear</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span></span>):<br>    <span class="hljs-string">&quot;&quot;&quot;线性阶&quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 长度为 n 的列表占用 O(n) 空间</span><br>    nums = [<span class="hljs-number">0</span>] * n<br>    <span class="hljs-comment"># 长度为 n 的哈希表占用 O(n) 空间</span><br>    hmap = <span class="hljs-built_in">dict</span>[<span class="hljs-built_in">int</span>, <span class="hljs-built_in">str</span>]()<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>        hmap[i] = <span class="hljs-built_in">str</span>(i)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">linear_recur</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span></span>):<br>    <span class="hljs-string">&quot;&quot;&quot;线性阶（递归实现）&quot;&quot;&quot;</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;递归 n =&quot;</span>, n)<br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span><br>    linear_recur(n - <span class="hljs-number">1</span>)<br>    <span class="hljs-comment"># 在达到最深的递归深度的时候，会有n个变量n（涉及到局部变量）</span><br></code></pre></td></tr></table></figure></li><li><p>平方阶空间复杂度</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">quadratic</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span></span>):<br>    <span class="hljs-string">&quot;&quot;&quot;平方阶&quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 二维列表占用 O(n^2) 空间</span><br>    num_matrix = [[<span class="hljs-number">0</span>] * n <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br></code></pre></td></tr></table></figure><ul><li><p><code>num_matrix</code>：这是一个变量名，用于存储生成的二维矩阵。</p><p><code>[[0] * n for _ in range(n)]</code>：这是一个列表生成式，用于创建一个包含 <code>n</code> 个子列表的列表，每个子列表包含 <code>n</code> 个元素。</p><ul><li><code>[0] * n</code>：这一部分创建一个包含 <code>n</code> 个 <code>0</code> 的列表。例如，如果 <code>n</code> 是 <code>3</code>，则生成 <code>[0, 0, 0]</code>。</li><li><code>for _ in range(n)</code>：这一部分用于重复创建上述的子列表 <code>n</code> 次。<code>_</code> 是一个惯用的变量名，表示循环变量在循环体内未被使用。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">quadratic_recur</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;平方阶（递归实现）&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">if</span> n &lt;= <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    <span class="hljs-comment"># 数组 nums 长度为 n, n-1, ..., 2, 1</span><br>    nums = [<span class="hljs-number">0</span>] * n<br>    <span class="hljs-keyword">return</span> quadratic_recur(n - <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure></li></ul></li><li><p>指数阶空间复杂度（二叉树）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">build_tree</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span></span>) -&gt; TreeNode | <span class="hljs-literal">None</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;指数阶（建立满二叉树）&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>    root = TreeNode(<span class="hljs-number">0</span>)<br>    root.left = build_tree(n - <span class="hljs-number">1</span>)<br>    root.right = build_tree(n - <span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> root<br></code></pre></td></tr></table></figure><p><img src="https://www.hello-algo.com/chapter_computational_complexity/space_complexity.assets/space_complexity_exponential.png" alt="满二叉树产生的指数阶空间复杂度"></p></li><li><p>对数阶空间复杂度</p></li></ul><p>对数阶空间复杂度（(O(\log n))）在算法中并不如其他复杂度（如常数、线性、平方等）常见，因为对数阶通常与递归深度相关联。以下是一些可能具有对数阶空间复杂度的常见算法和场景：</p><ol><li><p><strong>递归算法</strong>：</p><ul><li><strong>二分查找</strong>：在递归实现中，二分查找的空间复杂度是 (O(\log n))，因为递归调用栈的深度是对数级别的。</li><li><strong>快速排序</strong>：在最优情况下（即每次分区都能将数组均匀分割），快速排序的递归深度是 (O(\log n))，因此空间复杂度也是 (O(\log n))。</li><li><strong>归并排序</strong>：尽管归并排序的时间复杂度是 (O(n \log n))，其递归实现的空间复杂度可以是 (O(\log n))（不包括用于存储结果的额外数组）。</li></ul><h3 id="快速排序（Quick-Sort）"><a href="#快速排序（Quick-Sort）" class="headerlink" title="快速排序（Quick Sort）"></a>快速排序（Quick Sort）</h3><p>快速排序是一种分而治之的排序算法。它的基本思想是选择一个基准元素（pivot），然后将数组分成两个子数组，一个包含所有小于基准元素的元素，另一个包含所有大于基准元素的元素，然后递归地对这两个子数组进行排序。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">quick_sort</span>(<span class="hljs-params">arr</span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(arr) &lt;= <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span> arr<br>    <span class="hljs-keyword">else</span>:<br>        pivot = arr[<span class="hljs-built_in">len</span>(arr) // <span class="hljs-number">2</span>]<br>        left = [x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> arr <span class="hljs-keyword">if</span> x &lt; pivot]<br>        middle = [x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> arr <span class="hljs-keyword">if</span> x == pivot]<br>        right = [x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> arr <span class="hljs-keyword">if</span> x &gt; pivot]<br>        <span class="hljs-keyword">return</span> quick_sort(left) + middle + quick_sort(right)<br><br><span class="hljs-comment"># 示例使用</span><br>arr = [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">10</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Original array:&quot;</span>, arr)<br>sorted_arr = quick_sort(arr)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Sorted array:&quot;</span>, sorted_arr)<br></code></pre></td></tr></table></figure><h3 id="归并排序（Merge-Sort）"><a href="#归并排序（Merge-Sort）" class="headerlink" title="归并排序（Merge Sort）"></a>归并排序（Merge Sort）</h3><p>归并排序也是一种分而治之的排序算法。它的基本思想是将数组分成两个子数组，对这两个子数组分别进行排序，然后将排序后的子数组合并成一个有序的数组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">merge_sort</span>(<span class="hljs-params">arr</span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(arr) &lt;= <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span> arr<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">merge</span>(<span class="hljs-params">left, right</span>):<br>        result = []<br>        i = j = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> i &lt; <span class="hljs-built_in">len</span>(left) <span class="hljs-keyword">and</span> j &lt; <span class="hljs-built_in">len</span>(right):<br>            <span class="hljs-keyword">if</span> left[i] &lt; right[j]:<br>                result.append(left[i])<br>                i += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                result.append(right[j])<br>                j += <span class="hljs-number">1</span><br>        result.extend(left[i:])<br>        result.extend(right[j:])<br>        <span class="hljs-keyword">return</span> result<br><br>    mid = <span class="hljs-built_in">len</span>(arr) // <span class="hljs-number">2</span><br>    left = merge_sort(arr[:mid])<br>    right = merge_sort(arr[mid:])<br>    <span class="hljs-keyword">return</span> merge(left, right)<br><br><span class="hljs-comment"># 示例使用</span><br>arr = [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">10</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Original array:&quot;</span>, arr)<br>sorted_arr = merge_sort(arr)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Sorted array:&quot;</span>, sorted_arr)<br></code></pre></td></tr></table></figure><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><ul><li><p><strong>快速排序</strong>：</p><ul><li>选择一个基准元素（pivot）。</li><li>将数组分成三个部分：小于基准的部分、等于基准的部分和大于基准的部分。</li><li>递归地对小于基准和大于基准的部分进行排序。</li><li>合并结果。</li></ul></li><li><p><strong>归并排序</strong>：</p><ul><li>将数组分成两半。</li><li>递归地对每一半进行排序。</li><li>合并两个排序后的子数组。</li></ul></li></ul><p>这两种排序算法都是经典的分而治之算法，具有较好的性能和广泛的应用。</p></li><li><p><strong>平衡树的数据结构</strong>：</p><ul><li><strong>平衡二叉搜索树（如 AVL 树、红黑树）</strong>：这些数据结构在执行插入、删除和查找操作时的递归深度通常是 (O(\log n))，因此在某些实现中，可能会有 (O(\log n)) 的空间复杂度，主要用于递归调用栈。</li></ul></li><li><p><strong>迭代算法</strong>：</p><ul><li>某些迭代算法在实现中可能会使用一个栈来模拟递归，从而使得其空间复杂度为 (O(\log n))。例如，某些树遍历算法在深度优先搜索时可能使用栈来存储路径信息。</li></ul></li></ol><p>需要注意的是，空间复杂度为 (O(\log n)) 的算法通常涉及递归调用或需要存储某些对数数量的信息。这种复杂度通常与算法的递归深度或树结构的高度相关。</p><p><strong>循环与递归在空间复杂度上的差异</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">function</span>() -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-comment"># 执行某些操作</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">loop</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span></span>):<br>    <span class="hljs-string">&quot;&quot;&quot;循环的空间复杂度为 O(1)&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>        function()<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">recur</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span></span>):<br>    <span class="hljs-string">&quot;&quot;&quot;递归的空间复杂度为 O(n)&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span><br>    <span class="hljs-keyword">return</span> recur(n - <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>函数 <code>loop()</code> 和 <code>recur()</code> 的时间复杂度都为 O(n) ，但空间复杂度不同。</p><ul><li>函数 <code>loop()</code> 在循环中调用了 n 次 <code>function()</code> ，每轮中的 <code>function()</code> 都返回并释放了栈帧空间，因此空间复杂度仍为 O(1) 。</li><li>递归函数 <code>recur()</code> 在运行过程中会同时存在 n 个未返回的 <code>recur()</code> ，从而占用 O(n) 的栈帧空间。</li></ul><h2 id="二、数据结构"><a href="#二、数据结构" class="headerlink" title="二、数据结构"></a>二、数据结构</h2><p>数组，链表，栈，队列，哈希表，树，堆，图</p><h3 id="数据结构的物理结构"><a href="#数据结构的物理结构" class="headerlink" title="@数据结构的物理结构"></a>@数据结构的物理结构</h3><p>如图 3-3 所示，<strong>物理结构反映了数据在计算机内存中的存储方式</strong>，可分为连续空间存储（数组）和分散空间存储（链表）。物理结构从底层决定了数据的访问、更新、增删等操作方法，两种物理结构在时间效率和空间效率方面呈现出互补的特点。</p><p><img src="https://www.hello-algo.com/chapter_data_structure/classification_of_data_structure.assets/classification_phisical_structure.png" alt="连续空间存储与分散空间存储"></p><p>连续空间存储（数组）</p><ul><li><strong>定义</strong>：连续空间存储是指数据元素在内存中连续排列，数组是这种存储方式的典型代表。</li><li><strong>优点</strong>：<ul><li><strong>快速访问</strong>：由于数组元素是连续存储的，可以通过索引直接访问任意元素，时间复杂度为 O(1)。</li><li><strong>空间局部性</strong>：连续存储有助于缓存命中率，因为访问一个元素后，后续访问相邻元素时，可能已经在缓存中。</li></ul></li><li><strong>缺点</strong>：<ul><li><strong>插入和删除操作效率低</strong>：在数组中插入或删除元素通常需要移动其他元素以保持数据的连续性，时间复杂度为 <em>O</em>(<em>n</em>)。</li><li><strong>固定大小</strong>：数组的大小在创建时确定，扩展数组的大小需要重新分配内存并复制数据。</li></ul></li></ul><p>分散空间存储（链表）</p><ul><li><strong>定义</strong>：分散空间存储是指数据元素在内存中不必连续排列，链表是这种存储方式的典型代表。</li><li><strong>优点</strong>：<ul><li><strong>动态大小</strong>：链表可以方便地进行动态内存分配，允许在运行时灵活地增加或减少元素。</li><li><strong>高效插入和删除</strong>：在链表中，插入和删除元素只需调整指针，而不需要移动其他元素，时间复杂度为 <em>O</em>(1)（在已知位置的情况下）。</li></ul></li><li><strong>缺点</strong>：<ul><li><strong>访问速度慢</strong>：由于链表元素存储在非连续的内存位置，访问某个特定元素需要从头遍历链表，时间复杂度为 <em>O</em>(<em>n</em>)。</li><li><strong>额外空间开销</strong>：链表需要额外的存储空间来存储指针（如前驱和后继指针），这增加了内存使用量。</li></ul></li></ul><p>互补特点</p><ul><li><strong>数组</strong>适合需要频繁随机访问的场景，如需要快速读取大量数据但不经常修改数据的情况。</li><li><strong>链表</strong>适合需要频繁插入和删除操作的场景，如实现动态数据结构（例如队列、栈）时。</li></ul><p>值得说明的是，<strong>所有数据结构都是基于数组、链表或二者的组合实现的</strong>。例如，栈和队列既可以使用数组实现，也可以使用链表实现；而哈希表的实现可能同时包含数组和链表。</p><ul><li><strong>基于数组可实现</strong>：栈、队列、哈希表、树、堆、图、矩阵、张量（维度 ≥3 的数组）等。</li><li><strong>基于链表可实现</strong>：栈、队列、哈希表、树、堆、图等。</li></ul><p>​哈希表底层是数组，而为了解决哈希冲突，我们可能会使用“链式地址”（后续“哈希冲突”章节会讲）：数组中每个桶指向一个链表，当链表长度超过一定阈值时，又可能被转化为树（通常为红黑树）。</p><p>​从存储的角度来看，哈希表的底层是数组，其中每一个桶槽位可能包含一个值，也可能包含一个链表或一棵树。因此，哈希表可能同时包含线性数据结构（数组、链表）和非线性数据结构（树）。</p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tutorial</tag>
      
      <tag>C/C++</tag>
      
      <tag>Time and Space Complexity</tag>
      
      <tag>Recursion</tag>
      
      <tag>Hello-algorithm-tutorial</tag>
      
      <tag>Finished</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LaTeX-tutorial</title>
    <link href="/posts/LaTeX-tutorial/"/>
    <url>/posts/LaTeX-tutorial/</url>
    
    <content type="html"><![CDATA[<h1 id="About-LaTeX"><a href="#About-LaTeX" class="headerlink" title="About LaTeX"></a>About LaTeX</h1><p>​听说过LaTeX吗？亦或是老师突然要求你们使用LaTeX进行写论文，自己面对奇奇怪怪的复杂代码毫无头绪，下不去手？</p><p><strong>需要提前准备的内容</strong>：</p><ul><li>无</li></ul><p><strong>如果你是</strong>：</p><ul><li>纯LaTeX新手，从零开始接触LaTeX；</li><li>纯路人，想学习LaTeX技巧；</li><li>想要支持作者的帅哥美女❥(^_-)；</li></ul><p>那恭喜你来对地方了！在这篇文章中，<strong>你将学习到以下内容</strong>：</p><ul><li>一段LaTeX的历史和一位伟人；</li><li>掌握LaTeX的最基本原理；</li><li>如何从零开始构建第一篇LaTeX文档，并按需进行个性化的修改；</li><li>尝试接触一些LaTeX的高级功能（Optional）；</li><li>获得一些精进LaTeX技能包的方法和途径；</li></ul><p><strong>准备好了吗？</strong> 在接下来的时光里，就让我们一起走进LaTeX的世界。</p><p><img src="/posts/LaTeX-tutorial/LaTeX.png" alt="LaTeX"></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://en.wikipedia.org/wiki/TeX">TeX - Wikipedia</a></p><p><a href="https://en.wikipedia.org/wiki/LaTeX">LaTeX - Wikipedia</a></p><p><a href="https://www.overleaf.com/">Overleaf, Online LaTeX Editor</a></p><p><a href="https://www.latex-project.org/">LaTeX - A document preparation system</a></p><h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1 Introduction"></a>1 Introduction</h2><p><strong>又来到了讲故事环节，可跳过</strong></p><p>​在开始我们今天的话题之前，我想先向各位介绍一位老先生，<a href="https://en.wikipedia.org/wiki/Donald_Knuth">Donald Knuth</a>。</p><p><img src="/posts/LaTeX-tutorial/Knuth.jpg" alt="Donald Knuth"></p><p>​先来看看他到底有多牛逼，这是维基百科对这位老爷爷（还没有去世哦）的评价：He is the 1974 recipient of <strong>the <a href="https://en.wikipedia.org/wiki/Acm_Turing_award">ACM Turing Award</a></strong>, informally considered the <a href="https://en.wikipedia.org/wiki/Nobel_Prize">Nobel Prize</a> of computer science. Knuth has been called the “<strong>father of the <a href="https://en.wikipedia.org/wiki/Analysis_of_algorithms">analysis of algorithms</a></strong>“。 <a href="https://en.wikipedia.org/wiki/Donald_Knuth">原文</a></p><p>​ACM图灵奖不必多说，能拿奖的都是计算机科学领域大牛中的大牛，他甚至还有第二个称号，<strong>the father of the analysis of algorithms</strong>, 算法分析之父！更不可思议的是，他的主要贡献竟然是一系列至今尚未完篇的鸿篇巨著：*<a href="https://en.wikipedia.org/wiki/The_Art_of_Computer_Programming">The Art of Computer Programming</a>*。<strong>计算机程序设计艺术</strong>，简称TAOCP，是关于计算机程序设计之七卷本著作。作者并因此获得美国计算机协会1974年<a href="https://zh.wikipedia.org/wiki/%E5%9B%BE%E7%81%B5%E5%A5%96">图灵奖</a>。</p><blockquote><p>对我来说，读完这本书不仅花了好几个月，而且还要求我有极高的自律性。如果你能读完这本书，不妨给我发个简历。——Bill Gates</p></blockquote><p>​这一套书涵盖了计算机领域几乎所有的底层知识，目录如下：</p><p><img src="/posts/LaTeX-tutorial/theartofprogramming.png" alt="TAOCP"></p><p><a href="https://zh.wikipedia.org/zh-cn/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%89%BA%E6%9C%AF">链接指路：计算机程序设计艺术</a></p><p>​这本书的具体内容我们不做过多的介绍，那这位老者和LaTeX有什么关系呢？<strong>他是LaTeX的前身——TeX的发明者！</strong></p><p>​维基百科在这一块写的比较含蓄哈哈哈：</p><blockquote><p>In 1977, he decided to spend some time <strong>creating something more suitable</strong>. Eight years later, he returned with <a href="https://en.wikipedia.org/wiki/TeX">TEX</a>, which is currently used for all volumes.</p></blockquote><p>什么是<strong>something more suitable</strong>？Maybe the LaTeX！</p><h2 id="2-LaTeX"><a href="#2-LaTeX" class="headerlink" title="2 LaTeX"></a>2 LaTeX</h2><p>​举一个非常简单的例子，你想在word文档中输入这样一个公式：</p><p><img src="/posts/LaTeX-tutorial/QianJianTec1732279187844.png" alt="Gradient Descent"></p><blockquote><p>这是机器学习中梯度下降的基本数学原理。</p></blockquote><p>​我们来看看word是怎么编辑公式的：</p><p><img src="/posts/LaTeX-tutorial/word.png" alt="How does Microsoft Word handle it?"></p><p>​Word等文字编辑器始终秉持着一种<strong>所见即所得</strong>的思想，我打出一个字符，这个字符就实时的反映在我的文本文档中，至于图片缩放，表格插入，文字大小，排版，以及以上所涉及的数学符号等等，在word中虽然能实现，但是调试的时间成本非常高，难度非常大，而且十分的低效！笔者在高中时期曾经有过写数学小论文卡在编辑公式和统一插入图片的格式等细枝末节的小事上的惨痛的回忆。(不过好像现在word也支持LaTeX了)</p><p>​但是在LaTeX中，我们可以利用下面的代码生成：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\begin</span>&#123;aligned&#125;<br><span class="hljs-keyword">\theta</span><span class="hljs-built_in">_</span>&#123;j&#125;:=<span class="hljs-keyword">\theta</span><span class="hljs-built_in">_</span>&#123;j&#125;- <span class="hljs-built_in">&amp;</span> <span class="hljs-keyword">\alpha</span> <span class="hljs-keyword">\frac</span>&#123;<span class="hljs-keyword">\partial</span>&#125;&#123;<span class="hljs-keyword">\partial</span> <span class="hljs-keyword">\theta</span><span class="hljs-built_in">_</span>&#123;j&#125;&#125; J(<span class="hljs-keyword">\theta</span>) <span class="hljs-keyword">\\</span><br><span class="hljs-keyword">\frac</span>&#123;<span class="hljs-keyword">\partial</span>&#125;&#123;<span class="hljs-keyword">\partial</span> <span class="hljs-keyword">\theta</span><span class="hljs-built_in">_</span>&#123;j&#125;&#125; J(<span class="hljs-keyword">\theta</span>) <span class="hljs-built_in">&amp;</span> =<span class="hljs-keyword">\frac</span>&#123;<span class="hljs-keyword">\partial</span>&#125;&#123;<span class="hljs-keyword">\partial</span> <span class="hljs-keyword">\theta</span><span class="hljs-built_in">_</span>&#123;j&#125;&#125; <span class="hljs-keyword">\frac</span>&#123;1&#125;&#123;2&#125;<span class="hljs-keyword">\left</span>(h<span class="hljs-built_in">_</span>&#123;<span class="hljs-keyword">\theta</span>&#125;(x)-y<span class="hljs-keyword">\right</span>)<span class="hljs-built_in">^</span>&#123;2&#125; <span class="hljs-keyword">\\</span><br><span class="hljs-built_in">&amp;</span> =2 <span class="hljs-keyword">\cdot</span> <span class="hljs-keyword">\frac</span>&#123;1&#125;&#123;2&#125;<span class="hljs-keyword">\left</span>(h<span class="hljs-built_in">_</span>&#123;<span class="hljs-keyword">\theta</span>&#125;(x)-y<span class="hljs-keyword">\right</span>) <span class="hljs-keyword">\cdot</span> <span class="hljs-keyword">\frac</span>&#123;<span class="hljs-keyword">\partial</span>&#125;&#123;<span class="hljs-keyword">\partial</span> <span class="hljs-keyword">\theta</span><span class="hljs-built_in">_</span>&#123;j&#125;&#125;<span class="hljs-keyword">\left</span>(h<span class="hljs-built_in">_</span>&#123;<span class="hljs-keyword">\theta</span>&#125;(x)-y<span class="hljs-keyword">\right</span>) <span class="hljs-keyword">\\</span><br><span class="hljs-built_in">&amp;</span> =<span class="hljs-keyword">\left</span>(h<span class="hljs-built_in">_</span>&#123;<span class="hljs-keyword">\theta</span>&#125;(x)-y<span class="hljs-keyword">\right</span>) <span class="hljs-keyword">\cdot</span> <span class="hljs-keyword">\frac</span>&#123;<span class="hljs-keyword">\partial</span>&#125;&#123;<span class="hljs-keyword">\partial</span> <span class="hljs-keyword">\theta</span><span class="hljs-built_in">_</span>&#123;j&#125;&#125;<span class="hljs-keyword">\left</span>(<span class="hljs-keyword">\sum</span><span class="hljs-built_in">_</span>&#123;i=0&#125;<span class="hljs-built_in">^</span>&#123;n&#125; <span class="hljs-keyword">\theta</span><span class="hljs-built_in">_</span>&#123;i&#125; x<span class="hljs-built_in">_</span>&#123;i&#125;-y<span class="hljs-keyword">\right</span>) <span class="hljs-keyword">\\</span><br><span class="hljs-built_in">&amp;</span> =<span class="hljs-keyword">\left</span>(h<span class="hljs-built_in">_</span>&#123;<span class="hljs-keyword">\theta</span>&#125;(x)-y<span class="hljs-keyword">\right</span>) x<span class="hljs-built_in">_</span>&#123;j&#125;<br><span class="hljs-keyword">\end</span>&#123;aligned&#125;<br></code></pre></td></tr></table></figure><p>​完全看不懂是不是？没关系，这就是<strong>LaTeX的精髓</strong>：<strong>将可视化的文本编辑转化成一种严谨的代码语言</strong>，当你学会并且快速上手之后，你便会越来越体会到LaTeX在学术写作上的强大之处。</p><h2 id="3-LaTeX-入门"><a href="#3-LaTeX-入门" class="headerlink" title="3 LaTeX 入门"></a>3 LaTeX 入门</h2><p>​由上面的示例我们可以看出，<strong>LaTeX可以生成极为精美的文档，涵盖公式，表格，图片等等各种形式（你甚至可以用来做PPT！后面会讲到）</strong>，但代价就是<strong>LaTeX牺牲了市面上主流文本编辑器的”所见即所得”的思想</strong>，将所有文字和图片的生成都转化为了一种规则和<strong>编程语言</strong>，初学者入门可能会很吃力，但相信我，熟练后你会爱上他的！</p><h3 id="3-1-开始你的第一篇LaTeX文档！"><a href="#3-1-开始你的第一篇LaTeX文档！" class="headerlink" title="3.1 开始你的第一篇LaTeX文档！"></a>3.1 开始你的第一篇LaTeX文档！</h3><p>​万事万物第一步：配环境！一般来说有两种方式：</p><ul><li>本地环境配置：<a href="https://www.tug.org/texlive/">TeX Live - TeX Users Group</a>。需要安装textlive，后续可以集成在vscode中使用，具体的操作方法比较繁琐，读者可以自行搜索，网上有很多保姆级的环境搭建教程。（<strong>不推荐，个人建议是等上手熟悉了之后再考虑是否安装，配环境报错真的能把人给烦死</strong>）</li><li><strong>推荐在线LaTeX网站：</strong>使用LaTeX在线网站，例如<a href="https://www.overleaf.com/">Overleaf</a>，国内有些高校也会开通自己的LaTeX平台。在线网站更加轻量化，隐藏了配置环境的细节，注册一个账号就可以使用，<strong>非常推荐新手小白使用！</strong></li><li>在接下来的新手教程中，我们将全程在<a href="https://www.overleaf.com/">Overleaf</a>上进行演示，请登录网站并注册好你的账号。（使用免费版即可）</li></ul><h3 id="3-2-建立一个模版LaTeX"><a href="#3-2-建立一个模版LaTeX" class="headerlink" title="3.2 建立一个模版LaTeX"></a>3.2 建立一个模版LaTeX</h3><p>​对新手而言，<strong>快速上手熟悉LaTeX比了解LaTeX背后的原理重要的多</strong>。因此，我们将会从一个模版LaTeX出发，从实操慢慢过渡到原理的讲解。</p><p><img src="/posts/LaTeX-tutorial/s1.png" alt="Choose a template"></p><p>​点击左上角的new project——然后有四个选项：</p><ul><li><p>Blank project（完全的空文本）</p></li><li><p>Example Project（模版）</p></li><li><p>Upload Project（上传本地项目，通常是压缩包形式）</p></li><li><p>Import Project（从Github引入）</p><p>在这里我们选择Example Project。输入自己的Project Name(建议英文)。我在这里输入的是Hello world。</p></li></ul><h3 id="3-3-探索LaTeX模版！"><a href="#3-3-探索LaTeX模版！" class="headerlink" title="3.3 探索LaTeX模版！"></a>3.3 探索LaTeX模版！</h3><p><img src="/posts/LaTeX-tutorial/image_9.png" alt="Hello world!"></p><p>​当你看到一只经典的绿色小青蛙时，恭喜你，你已经成功创建了第一个LaTeX文档！</p><blockquote><p>没有看到？试试点一下右上侧绿色的<strong>Recompile</strong>按钮试试看，可能要等一会。</p></blockquote><p>​简单介绍一下各模块都是干啥用的：</p><ul><li>最左边：文件栏和<strong>File Outline</strong><ul><li>文件栏可以理解为<strong>一个存放这个LaTeX文档所有资源的文件夹</strong>。我们现在中间所打开的就是文件夹中的<strong>main.tex</strong>文件，这也是LaTeX文档的核心部分。还有一些附属的资源也会存放在文件栏中，包括插入的图片，还有参考文献(.bib)。目前大家知道这些就足够了。</li><li>File Outline 不必多说，展示文章大纲的地方。</li></ul></li><li>正中间：文本编辑区，也就是敲代码的地方。</li><li>最右边：视图区：当你点击<strong>Recompile</strong>的按钮之后，<strong>编译器</strong>（点击左上方的menu可以查看，<strong>新手不要随便改变这一项！</strong>）会根据main.tex的代码以及一些附属文件（例如frog.jpg）生成最终的LaTeX文档（PDF），在右侧可以预览，也可以导出保存。</li></ul><p><img src="/posts/LaTeX-tutorial/image_11.png" alt="The Compiler"></p><ul><li>上方一栏的一些工具看名字应该就知道是干什么的了，和普通的文本编辑器差不太多，都是一些附加功能，读者可以自己来探索。</li></ul><h3 id="3-4-进入main-tex"><a href="#3-4-进入main-tex" class="headerlink" title="3.4 进入main.tex"></a>3.4 进入main.tex</h3><p>​接下来，让我们把重点放在main.tex的代码上。</p><h4 id="3-4-1-整体架构"><a href="#3-4-1-整体架构" class="headerlink" title="3.4.1 整体架构"></a>3.4.1 整体架构</h4><p>​一篇标准的LaTeX代码架构如下：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-comment">% 这是一行注释，不会对代码产生任何影响</span><br><span class="hljs-keyword">\documentclass</span>&#123;article&#125;<br><span class="hljs-comment">%导言区（相当于前期的准备工作）</span><br><span class="hljs-keyword">\begin</span>&#123;document&#125;<br><span class="hljs-comment">%正文（文章内容）</span><br><span class="hljs-keyword">\end</span>&#123;document&#125;<br><span class="hljs-comment">% \end&#123;document&#125;代表着main.tex的结尾，相当于C++的return 0;这个语句后面不要加上任何的东西！（因为加了也没有任何意义）</span><br></code></pre></td></tr></table></figure><p>​<code>\</code>在LaTeX中是非常重要的一个字符，类似于C&#x2F;C++中的转义字符，在后面跟着的都是<strong>LaTeX的关键词和命令</strong>（会有代码高亮），我们<strong>重点学习的内容</strong>就是<strong>这些命令代表什么意思，以及如何使用这些命令</strong>。</p><p>​首先，我们来介绍LaTeX中的<strong>导言区</strong>，即<code>\begin&#123;document&#125;</code>之前的部分。</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\documentclass</span>&#123;article&#125;<br><span class="hljs-comment">%这行代码指定了文档的类型为 article，即文章类型。LaTeX 中有几种文档类型（如 report、book 等），article 是最常用的一种，适用于论文、报告、演讲稿等。</span><br></code></pre></td></tr></table></figure><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs LaTeX"><span class="hljs-comment">% Language setting</span><br><span class="hljs-comment">% Replace `english&#x27; with e.g. `spanish&#x27; to change the document language</span><br><span class="hljs-keyword">\usepackage</span>[english]&#123;babel&#125;<br><span class="hljs-comment">% Useful packages</span><br><span class="hljs-keyword">\usepackage</span>&#123;amsmath&#125;<br><span class="hljs-keyword">\usepackage</span>&#123;graphicx&#125;<br><span class="hljs-keyword">\usepackage</span>[colorlinks=true, allcolors=blue]&#123;hyperref&#125;<br></code></pre></td></tr></table></figure><p>​在LaTeX，几乎所有的高级操作都是建立在<strong>导入宏包</strong>的基础之上的，类似于C++中的#include和Python中的import，导入宏包可以让你的LaTeX代码变的更加强大。在此处导入的三个常用宏包分别用于数学公式(amsmath)，图形处理(graphix)和引用(hyperref)。<br>​在之后的学习过程中，你可以根据需求自己导入特定的宏包，不过别担心，后面会具体教你怎么做的。</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\title</span>&#123;Your Paper&#125;<br><span class="hljs-keyword">\author</span>&#123;You&#125;<br><span class="hljs-comment">% 作者的信息和文章标题，这一块也可以自己魔改（属于高级功能）</span><br></code></pre></td></tr></table></figure><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\begin</span>&#123;document&#125;<br><span class="hljs-comment">%正文</span><br><span class="hljs-keyword">\end</span>&#123;document&#125;<br></code></pre></td></tr></table></figure><p>​夹在<code>\begin&#123;document&#125;</code>和<code>\end&#123;document&#125;</code>之间的是文章的正文部分，<strong>任何你想在最后PDF出现的内容，无论是图片，文字，都需要在<code>\begin&#123;document&#125;</code>和<code>\end&#123;document&#125;</code>之间通过命令表达出来！</strong>接下来我们来重点介绍正文部分。</p><h4 id="3-4-2-正文部分①——文字"><a href="#3-4-2-正文部分①——文字" class="headerlink" title="3.4.2 正文部分①——文字"></a>3.4.2 正文部分①——文字</h4><blockquote><p>在这里为了方便演示，我创建了一个新的空白文档，所以和LaTeX模版之间存在差异。读者可以先尝试理解这些指令都代表着什么功能，然后回到自己的template中尝试“读懂”他！也可以自己尝试修改一些内容看看最后生成的文档有什么不同~</p></blockquote><p>正文的代码开始看不懂了？别着急，先来看看我写的简化版的</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\begin</span>&#123;document&#125;<br><span class="hljs-keyword">\maketitle</span><br><br><span class="hljs-keyword">\begin</span>&#123;abstract&#125;<br>Your abstract.<br><span class="hljs-keyword">\end</span>&#123;abstract&#125;<br><span class="hljs-keyword">\section</span>&#123;introducccction&#125;<br><span class="hljs-keyword">\section</span>&#123;Part1&#125;<br><span class="hljs-keyword">\subsection</span>&#123;hello&#125;<br>Hello, this is a test file.<br>is this a new paragraph?<br><br>is this a new paragraph?<br><span class="hljs-keyword">\subsection</span>&#123;world!&#125;<br><span class="hljs-keyword">\subsubsection</span>&#123;hahah&#125;<br><span class="hljs-keyword">\subsubsection</span>&#123;hahahahahah&#125;<br>i know you are very smart!<br><span class="hljs-keyword">\section</span>&#123;Part22&#125;<br><span class="hljs-keyword">\begin</span>&#123;enumerate&#125;<br>    <span class="hljs-keyword">\item</span> this is the firrst point<br>    <span class="hljs-keyword">\item</span> this is the 2nd points<br><span class="hljs-keyword">\end</span>&#123;enumerate&#125;<br><span class="hljs-keyword">\section</span>&#123;p3&#125;<br><span class="hljs-keyword">\section</span>&#123;Conclusion&#125;<br><br><span class="hljs-keyword">\end</span>&#123;document&#125;<br></code></pre></td></tr></table></figure><p>包含一些必要的文件准备工作，这份PDF输出如下：</p><p><img src="/posts/LaTeX-tutorial/image_12.png" alt="The Output"></p><blockquote><p>为了让展示变得更加清晰，我故意拼错了许多单词，请勿模仿！</p></blockquote><ul><li><p><code>\maketitle</code>命令首先输出文章的标题（包括作者信息和时间），不要删除。</p></li><li><p>摘要（abstract）</p><ul><li>论文的一个组成部分，由<code>\begin&#123;abstract&#125;</code>和<code>\end&#123;abstract&#125;</code>包裹。</li></ul></li><li><p><code>\section</code>,<code>\subsection</code>,<code>\subsubsection</code></p><ul><li>类似于论文中1,2,3级小标题的概念，读者可以将代码中的文字和最终输出在PDF中的位置对应起来，应该很快就能够理解。</li><li>这就是LaTeX的强大之处，可能用起来没有word可视化，但是他省去了很多文字排版以及大小调整优化的工作，实际上大大地提高了工作效率。</li></ul></li><li><p>正文</p><ul><li><p>文章中<em>i know you are very smart!</em> 和<em>Hello, this is a test file. is this a new paragraph?</em> 都是正文语句。</p></li><li><p><strong>缩进</strong>：LaTeX默认模版中首段不缩进，第二段才缩进，如果想更改这个设置，可以在导言区加入命令：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\usepackage</span>&#123;indentfirst&#125;<br><span class="hljs-comment">% 这是你加入的第一个宏包！快来compile一下看看有什么变化吧！</span><br></code></pre></td></tr></table></figure><p><img src="/posts/LaTeX-tutorial/image_13.png" alt="Indient"></p><p>你会发现，第一段也缩进啦！</p></li><li><p><strong>换行</strong>：</p><ul><li><p>第一个雷点：<strong>在源代码中换行并不代表真的换行了！</strong>比如第一个is this a new paragraph和Hello, this is a test file.分属两行，但他们实际输出上只在一行上面。</p></li><li><p>最简单的换行方法：<strong>直接在段落中添加一个空行，即按下两个回车键</strong>，这样就能成功实现换行。</p><p><strong>以下内容新手自动跳过！</strong></p></li><li><p>使用<code>\\</code>换行，一种更紧凑的写法（但有风险）</p></li></ul><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs LaTeX">This is the first line.<span class="hljs-keyword">\\</span><br>This is the second line.<br></code></pre></td></tr></table></figure><ul><li>其他换行方法：都是通过一些命令实现，可以作补充了解</li></ul><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs latex">This is the first line.<br><span class="hljs-keyword">\newline</span><br>This is the second line.<br><span class="hljs-comment">% 类比的，你应该就知道命令</span><br><span class="hljs-keyword">\newpage</span><br><span class="hljs-comment">% 是什么意思了吧！</span><br></code></pre></td></tr></table></figure><p>注意，使用<code>\\</code>和<code>\newline</code>进行强制换行时，两行之间没有额外的垂直间距！格式会有差异，<strong>建议非必要不要使用强制换行符</strong>。</p><p><img src="/posts/LaTeX-tutorial/image_14.png" alt="Using Newline Carefully"></p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-comment">% 一些补充命令：</span><br><br><span class="hljs-comment">%有垂直间距的换行</span><br>This is the first line.<br><span class="hljs-keyword">\vspace</span>&#123;1cm&#125;<br><br>This is the second line.<br><br><span class="hljs-comment">%无垂直间距的换行</span><br>This is the first line.<br><span class="hljs-keyword">\noindent</span><br><br>This is the second line without extra space.<br><br></code></pre></td></tr></table></figure><p><img src="/posts/LaTeX-tutorial/image_15.png" alt="Some advanced techniques"></p></li></ul></li><li><p><code>enumerate</code></p><ul><li>中文翻译“枚举”，用于文章中生成小标号，不作为小标题出现</li></ul><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\section</span>&#123;Part22&#125;<br><span class="hljs-keyword">\begin</span>&#123;enumerate&#125;<br>    <span class="hljs-keyword">\item</span> this is the firrst point<br>    <span class="hljs-keyword">\item</span> this is the 2nd points<br><span class="hljs-keyword">\end</span>&#123;enumerate&#125;<br><span class="hljs-comment">% 注意一个begin对应一个end，不然会报错！</span><br></code></pre></td></tr></table></figure><p><img src="/posts/LaTeX-tutorial/image_16.png" alt="Enumerate"></p><ul><li>可以和一些指令搭配使用，例如加粗<code>\textbf&#123;&#125;</code>等等。</li></ul></li><li><p>文本美化：</p><blockquote><p>这里的命令都是比较简单的，大家可以自行尝试~</p></blockquote><ul><li>加粗命令</li></ul><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\textbf</span>&#123;This text is bold.&#125;<br></code></pre></td></tr></table></figure><ul><li>斜线命令</li></ul><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\textit</span>&#123;This text is italic.&#125;<br></code></pre></td></tr></table></figure><ul><li>下划线命令</li></ul><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\underline</span>&#123;This text is underlined.&#125;<br></code></pre></td></tr></table></figure><ul><li>等宽字体</li></ul><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\texttt</span>&#123;This text is in typewriter font.&#125;<br></code></pre></td></tr></table></figure></li></ul><p>​<strong>Congratulations！到现在为止，你已经能够处理一篇最基本的latex的90%的内容了！你学习了如何编辑正文中的文字部分（这常常占了文章的大头，不是吗？）</strong></p><p>​接下来的旅程会变的更复杂，也更有趣，我们将继续向我们的latex中添加更多有趣的东西！</p><h4 id="3-4-3-正文部分②——图片和图表"><a href="#3-4-3-正文部分②——图片和图表" class="headerlink" title="3.4.3 正文部分②——图片和图表"></a>3.4.3 正文部分②——图片和图表</h4><p>​数据可视化在一篇论文中是非常重要的。因此，你需要再适当的位置添加你的图表！</p><ul><li>插入图片</li><li>插入统计图</li><li>插入统计表</li></ul><h4 id="3-4-4-正文部分③——数学公式"><a href="#3-4-4-正文部分③——数学公式" class="headerlink" title="3.4.4 正文部分③——数学公式"></a>3.4.4 正文部分③——数学公式</h4><h2 id="4-LaTeX精进"><a href="#4-LaTeX精进" class="headerlink" title="4 LaTeX精进"></a>4 LaTeX精进</h2><h3 id="4-1-坏了，报错了！"><a href="#4-1-坏了，报错了！" class="headerlink" title="4.1 坏了，报错了！"></a>4.1 坏了，报错了！</h3><h3 id="4-2-导入特定的宏包"><a href="#4-2-导入特定的宏包" class="headerlink" title="4.2 导入特定的宏包"></a>4.2 导入特定的宏包</h3><h3 id="4-3-Advanced-Methods"><a href="#4-3-Advanced-Methods" class="headerlink" title="4.3 Advanced Methods"></a>4.3 Advanced Methods</h3><h3 id="4-4-自定义？"><a href="#4-4-自定义？" class="headerlink" title="4.4 自定义？"></a>4.4 自定义？</h3><h3 id="4-5-网站指南"><a href="#4-5-网站指南" class="headerlink" title="4.5 网站指南"></a>4.5 网站指南</h3><h2 id="5-Conclusion-and-Outlook"><a href="#5-Conclusion-and-Outlook" class="headerlink" title="5 Conclusion and Outlook"></a>5 Conclusion and Outlook</h2><p>（2024.11.22）笔者累啦，之后会更新的！</p>]]></content>
    
    
    <categories>
      
      <category>Efficient Tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tutorial</tag>
      
      <tag>LaTeX</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Introduction_to_C</title>
    <link href="/posts/Introduction-to-C/"/>
    <url>/posts/Introduction-to-C/</url>
    
    <content type="html"><![CDATA[<h1 id="C语言-入门中的入门"><a href="#C语言-入门中的入门" class="headerlink" title="C语言 入门中的入门"></a>C语言 入门中的入门</h1><p>笔者的第一门博客，就献给C语言叭~</p><h2 id="1-目标群体"><a href="#1-目标群体" class="headerlink" title="-1 目标群体"></a>-1 目标群体</h2><ul><li><strong>对编程和计算机语言完全没有基础的萌新小白</strong>。</li><li>闲的蛋疼的帅哥美女们。</li></ul><p><strong>注意：</strong>这篇文章只适合作为入门导论使用，目的在于让完全萌新的小白们在短时间内获得对C语言的宏观初步了解，<strong>不涉及任何具体代码层面的细节知识</strong>。如果读者已经对C的语法基本掌握，想要跟上一层楼的话，请另寻他路~（或者点个关注等我更新（bushi））</p><p>​</p><h2 id="begin-document"><a href="#begin-document" class="headerlink" title="\begin{document}"></a>\begin{document}</h2><h2 id="0-为什么我们要选择C语言"><a href="#0-为什么我们要选择C语言" class="headerlink" title="0 为什么我们要选择C语言"></a>0 为什么我们要选择C语言</h2><p>​如果你不幸选到了<del>天坑专业</del>——<code>计算机科学与技术</code>，一般来说，学校都会把C语言作为同学们需要学习的<strong>第一门现代编程语言</strong>。</p><h3 id="Question1-什么叫语言？"><a href="#Question1-什么叫语言？" class="headerlink" title="Question1 什么叫语言？"></a>Question1 什么叫<strong>语言</strong>？</h3><p>​区别与我们日常说话的<strong>自然语言</strong>，<strong>编程语言</strong>是一种用于描述计算机程序的形式语言。它提供了一组符号和规则，用于描述程序的结构、功能和行为。程序员可以使用编程语言来编写计算机程序，这些程序可以在计算机上执行，从而实现特定的任务或实现特定的功能。</p><p>​通俗来说，你可以把程序想象成一个“机器人”，他完全按照工程师输入给他的指令进行工作。那对于开发机器人的工程师而言，他与机器人对话的语言（即编程语言）必须具备<strong>严谨，高效，无二义性</strong>的特征：即每一条语句都可以发挥作用；每一条语句只能表达一种指令（不然机器人就要犯迷糊了）；每一条语句在逻辑上必须完全严谨。</p><p>​再引入第二个概念，<strong>高级编程语言</strong>和<strong>低级编程语言</strong>，在以前，机器人所交流的语言（例如机器语言和汇编语言，这两种语言被称为低级编程语言）在提升严谨性的基础之上牺牲了<strong>可读性</strong>，而高级编程语言通过编译器、解释器等种种方式，将程序中”机器人看的懂，人看不懂“的部分（低级编程语言）隐藏起来，使代码更容易理解。而我们的C语言，<strong>就是一种经典的高级编程语言</strong>。</p><p><img src="/posts/Introduction-to-C/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80.png" alt="高级编程语言"></p><p>[图片来源](<a href="https://blog.csdn.net/weixin_42727710/article/details/121900806">编译型语言（Compile）和解释型语言（Interpreter）的区别_compilation interpretation-CSDN博客</a>)</p><blockquote><p>对这一块感兴趣的读者可以自行查阅有关机器语言，汇编语言，编译器，解释器等相关资料。深入了解这块内容需要涉及到二进制的基础知识和一些艰深复杂的语法规则，此处不再涉及。</p></blockquote><blockquote><p>在人工智能的时代，The best programming language is English！</p></blockquote><h3 id="Question2-为什么是C语言？"><a href="#Question2-为什么是C语言？" class="headerlink" title="Question2 为什么是C语言？"></a>Question2 为什么是<strong>C语言</strong>？</h3><p>​<strong>对于这个结论，我们不妨先摆事实，再探求原理。</strong></p><p>​下图是<a href="https://www.tiobe.com/tiobe-index/">TIOBE</a>对市场上主流的编程语言所占市场份额的统计（数据截至2024年10月），我们亲爱的C语言排在了第四位，占比8.38%。</p><p><img src="/posts/Introduction-to-C/TIOBE.jpg" alt="TIOBE"></p><p>​或许到这里你可能会问，占比甚至不到二成，<strong>看着也不是很流行啊！</strong>不过，请看接下来的两组数据：</p><ul><li>市面上流行的C-like语言（即与C语言具有相似的底层架构和语法规则）包括：C++、C#、Objective-C、Go、Java、JavaScript和Swift等等等等，这样一来，<strong>C-like 语言的市场份额达到了40%以上</strong>。</li><li>Python作为一种<a href="https://baike.baidu.com/item/%E8%A7%A3%E9%87%8A%E5%9E%8B%E8%AF%AD%E8%A8%80/8888952">解释型语言</a>，底层原理和C（C是一种编译型语言，后面会讲）存在差异，但Python中的许多语法规则都继承自C语言，同时，Python中各种库的底层都是用C&#x2F;C++编写的！</li></ul><blockquote><p>The Zen of Python, by Tim Peters</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs applescript">Beautiful <span class="hljs-keyword">is</span> better than ugly.<br>Explicit <span class="hljs-keyword">is</span> better than implicit.<br>Simple <span class="hljs-keyword">is</span> better than complex.<br>Complex <span class="hljs-keyword">is</span> better than complicated.<br>Flat <span class="hljs-keyword">is</span> better than nested.<br>Sparse <span class="hljs-keyword">is</span> better than dense.<br>Readability counts.<br>Special cases aren&#x27;t special enough <span class="hljs-keyword">to</span> break <span class="hljs-keyword">the</span> rules.<br>Although practicality beats purity.<br>Errors should never pass silently.<br>Unless explicitly silenced.<br>In <span class="hljs-keyword">the</span> face <span class="hljs-keyword">of</span> ambiguity, refuse <span class="hljs-keyword">the</span> temptation <span class="hljs-keyword">to</span> guess.<br>There should be one<span class="hljs-comment">-- and preferably only one --obvious way to do it.</span><br>Although <span class="hljs-keyword">that</span> way may <span class="hljs-keyword">not</span> be obvious <span class="hljs-keyword">at</span> <span class="hljs-keyword">first</span> unless you&#x27;re Dutch.<br>Now <span class="hljs-keyword">is</span> better than never.<br>Although never <span class="hljs-keyword">is</span> often better than *right* now.<br>If <span class="hljs-keyword">the</span> implementation <span class="hljs-keyword">is</span> hard <span class="hljs-keyword">to</span> explain, <span class="hljs-keyword">it</span>&#x27;s a bad idea.<br>If <span class="hljs-keyword">the</span> implementation <span class="hljs-keyword">is</span> easy <span class="hljs-keyword">to</span> explain, <span class="hljs-keyword">it</span> may be a good idea.<br>Namespaces are one honking great idea <span class="hljs-comment">-- let&#x27;s do more of those!</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> this<br><span class="hljs-comment">#在Python中写入这行代码，运行就会输出上述结果(The Zen of Python)，这些思想很大程度上都继承自C的简洁性和高效性！</span><br></code></pre></td></tr></table></figure></blockquote><p>​对此，我们惊讶的发现，<strong>C语言无处不在！</strong></p><p>​接下来，让我们进入C语言的世界叭！</p><blockquote><p><a href="https://zhuanlan.zhihu.com/p/145852301">C语言的历史，补充阅读</a></p></blockquote><h2 id="1-再谈C语言的工作原理——编译型语言"><a href="#1-再谈C语言的工作原理——编译型语言" class="headerlink" title="1 再谈C语言的工作原理——编译型语言"></a>1 再谈C语言的工作原理——编译型语言</h2><p>​在这个部分，我们将要重点讨论：一个C语言文件是怎么来的？</p><p>​让我们再回到这张图片：</p><p><img src="/posts/Introduction-to-C/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80.png" alt="高级编程语言"></p><p>​很明显，左边的高级语言（C）（或者叫做<strong>源代码</strong>）更加具备可读性，但你的电脑只能识别并运行右边的Low level language，也就是完全由二进制编码的文件，<strong>叫做可执行文件</strong>。在Windows系统下，<code>.exe</code>文件就是一种可执行文件。</p><p>​中间的转换被隐藏了，这便是<strong>编译器</strong>的作用，C<strong>通过编译器将源代码转化成机器语言</strong>，这就是一种<strong>编译型语言</strong>。那编译器具体是怎么实现的呢？具体而言涉及到两个过程：<strong>编译和链接</strong>，笔者可以大概扫一眼留个印象，相信我，你会回来的。</p><p><img src="/posts/Introduction-to-C/OIP-C.jpg" alt="OIP-C"></p><blockquote><p>concrete.c是<strong>源代码文件</strong>，就是我们所谓“敲代码”敲出来的东西，经过编译器，.c的源文件被转化成那个.o的目标代码，到这里就已经变成了机器语言了，但是此时这个程序“缺了一些东西”，<strong>即库代码和启动代码</strong>，这个时候链接器把这三个部分（库代码，启动代码，目标代码）组装起来，形成了最终可运行的.exe文件。</p></blockquote><p>图片摘自C语言经典著作：《C Primer Plus》</p><h2 id="2-入门C语言"><a href="#2-入门C语言" class="headerlink" title="2 入门C语言"></a>2 入门C语言</h2><h3 id="2-1-第一个C语言程序"><a href="#2-1-第一个C语言程序" class="headerlink" title="2.1 第一个C语言程序"></a>2.1 第一个C语言程序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-type">int</span> n=<span class="hljs-number">5</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello,world!\n&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,n);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><span class="hljs-built_in">Hello,</span>world!<br><span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>​这就是你看到的第一个C语言程序（.c的源文件）！他实现了很简单的功能，打印一些“东西”，包括一些字符和数字。接下来，让我们逐行解释输出内容是怎么来的（这部分内容需要结合上一章节C语言工作原理食用）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br></code></pre></td></tr></table></figure><p>​<strong>这个语句叫做预处理器指令</strong>，我们知道，程序可以实现各种各样的功能，但是总有一些底层原理是所有程序共有的（就像社会上每个人都不一样，但每个人都有吃喝拉撒等最基本的生理活动）。于是，C语言将一些常见的功能打包封装起来，通过<strong>导入库文件的方式</strong>，把轮子造好，让程序员可以开箱即用！在这里，include命令就告诉了程序我需要导入C自带库文件<code>stdio.h</code>的相关内容。</p><blockquote><p>这个工作由谁实现呢？<strong>是链接器</strong>，将库代码和目标结合。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br></code></pre></td></tr></table></figure><h3 id="2-2-基本数据类型"><a href="#2-2-基本数据类型" class="headerlink" title="2.2 基本数据类型"></a>2.2 基本数据类型</h3><h3 id="2-3-数组"><a href="#2-3-数组" class="headerlink" title="2.3 数组"></a>2.3 数组</h3><h2 id="3-初见C语言的基本语法规则"><a href="#3-初见C语言的基本语法规则" class="headerlink" title="3 初见C语言的基本语法规则"></a>3 初见C语言的基本语法规则</h2><h3 id="3-1-控制结构——分支"><a href="#3-1-控制结构——分支" class="headerlink" title="3.1 控制结构——分支"></a>3.1 控制结构——分支</h3><h3 id="3-2-控制结构——循环"><a href="#3-2-控制结构——循环" class="headerlink" title="3.2 控制结构——循环"></a>3.2 控制结构——循环</h3><h3 id="3-3-表达式和语句"><a href="#3-3-表达式和语句" class="headerlink" title="3.3 表达式和语句"></a>3.3 表达式和语句</h3><h2 id="4-函数！"><a href="#4-函数！" class="headerlink" title="4 函数！"></a>4 函数！</h2><h2 id="5-指针！"><a href="#5-指针！" class="headerlink" title="5 指针！"></a>5 指针！</h2><h2 id="6-一些更加高级的操作"><a href="#6-一些更加高级的操作" class="headerlink" title="6 一些更加高级的操作"></a>6 一些更加高级的操作</h2><h3 id="6-1-内存管理"><a href="#6-1-内存管理" class="headerlink" title="6.1 内存管理"></a>6.1 内存管理</h3><h3 id="6-2-文件I-O"><a href="#6-2-文件I-O" class="headerlink" title="6.2 文件I&#x2F;O"></a>6.2 文件I&#x2F;O</h3><h3 id="6-3-结构体"><a href="#6-3-结构体" class="headerlink" title="6.3 结构体"></a>6.3 结构体</h3><h3 id="6-4-高级数据表示和ADT"><a href="#6-4-高级数据表示和ADT" class="headerlink" title="6.4 高级数据表示和ADT"></a>6.4 高级数据表示和ADT</h3><h2 id="7-谈谈C"><a href="#7-谈谈C" class="headerlink" title="7 谈谈C++"></a>7 谈谈C++</h2><h3 id="7-1-什么是-？"><a href="#7-1-什么是-？" class="headerlink" title="7.1 什么是++？"></a>7.1 什么是++？</h3><h3 id="7-2-OOP初探"><a href="#7-2-OOP初探" class="headerlink" title="7.2 OOP初探"></a>7.2 OOP初探</h3><h2 id="8-写在最后的话"><a href="#8-写在最后的话" class="headerlink" title="8 写在最后的话"></a>8 写在最后的话</h2><h2 id="end-document"><a href="#end-document" class="headerlink" title="\end{document}"></a>\end{document}</h2>]]></content>
    
    
    <categories>
      
      <category>Code</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tutorial</tag>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Programming of Leetcode 1-5</title>
    <link href="/posts/Programming-of-Leetcode-1-5/"/>
    <url>/posts/Programming-of-Leetcode-1-5/</url>
    
    <content type="html"><![CDATA[<h1 id="程设错题总结-1-5"><a href="#程设错题总结-1-5" class="headerlink" title="程设错题总结 1~5"></a>程设错题总结 1~5</h1><h3 id="1-Leetcode202-Happynumber"><a href="#1-Leetcode202-Happynumber" class="headerlink" title="1.Leetcode202 Happynumber"></a>1.Leetcode202 Happynumber</h3><p><img src="C:\Users\29349\AppData\Roaming\Typora\typora-user-images\image-20241015001727914.png" alt="image-20241015001727914"></p><p>1.使用快慢指针解决循环问题</p><p>当快指针追上慢指针时，代表完成了一次循环。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">happynumber</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123;<br>        <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(n!=<span class="hljs-number">0</span>)&#123;<br>            sum+=(n%<span class="hljs-number">10</span>)*(n%<span class="hljs-number">10</span>);<br>            n/=<span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isHappy</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-type">int</span> i=n,j=n;<br>        <span class="hljs-keyword">do</span>&#123;<br>            i=<span class="hljs-built_in">happynumber</span>(i);<br>            j=<span class="hljs-built_in">happynumber</span>(j);<br>            j=<span class="hljs-built_in">happynumber</span>(j);<br>            <span class="hljs-keyword">if</span>(i==<span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(i!=j);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>2.使用哈希表存储</p><p>此处使用容器：unordered_set</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">happynumber</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123;<br>        <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(n!=<span class="hljs-number">0</span>)&#123;<br>            sum+=(n%<span class="hljs-number">10</span>)*(n%<span class="hljs-number">10</span>);<br>            n/=<span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isHappy</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        unordered_set &lt;<span class="hljs-type">int</span>&gt; list;<br>        <span class="hljs-keyword">while</span>(n!=<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">if</span>(list.<span class="hljs-built_in">find</span>(n)!=list.<span class="hljs-built_in">end</span>())&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                list.<span class="hljs-built_in">insert</span>(n);<br>            &#125;<br>            n=<span class="hljs-built_in">happynumber</span>(n);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="2-Acwing-817-数组去重"><a href="#2-Acwing-817-数组去重" class="headerlink" title="2.Acwing 817 数组去重"></a>2.Acwing 817 数组去重</h3><p><img src="C:\Users\29349\AppData\Roaming\Typora\typora-user-images\image-20241013114226617.png" alt="image-20241013114226617"></p><p>method1：使用STL</p><p><strong>unique函数</strong>：</p><p>unique是C++语言中的STL函数，包含于<algorithm>头文件中。 <strong>功能是将数组中相邻的重复元素去除</strong>。 然而其本质是将重复的元素移动到数组的末尾，最后再将迭代器指向第一个重复元素的下标。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n, s[<span class="hljs-number">1010</span>];<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) cin &gt;&gt; s[i];<br>    <span class="hljs-built_in">sort</span>(s, s + n);<br>    cout &lt;&lt; <span class="hljs-built_in">unique</span>(s, s + n) - s;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>method2：基本方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> b[<span class="hljs-number">1001</span>];<br><span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br><span class="hljs-comment">/*两个数组的区别：</span><br><span class="hljs-comment">a[]代表输入的数组（待去重的数组）</span><br><span class="hljs-comment">b[]数组是一个状态数组，其下标对应的值和a[]对应，初始值均为0，一旦出现a[i],即代表下标为a[i]的b[]被访问过，状态值变为1。（且只有初次访问是生效的）</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_unique_count</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(b[a[i]]==<span class="hljs-number">0</span>)<br>        b[a[i]]=<span class="hljs-number">1</span>;<br>        sum++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br><span class="hljs-comment">//函数作用：统计数组中一共出现了多少不相同的数。</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">int</span> n;<br>  cin&gt;&gt;n;<br>  <span class="hljs-type">int</span> a[n<span class="hljs-number">+1</span>];<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>  &#123;<br>      cin&gt;&gt;a[i];<br>  &#125;<br>  cout&lt;&lt;<span class="hljs-built_in">get_unique_count</span>(a,n);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="3-ACwing-15-二维数组的查找"><a href="#3-ACwing-15-二维数组的查找" class="headerlink" title="3.ACwing 15 二维数组的查找"></a>3.ACwing 15 二维数组的查找</h3><p><img src="C:\Users\29349\AppData\Roaming\Typora\typora-user-images\image-20241014094230026.png" alt="image-20241014094230026"></p><p>思路：</p><p>​1.暴力循环（两个for循环嵌套）</p><p>​2.通过数组大小关系的规律实现<strong>逐步逼近</strong>的策略</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Find</span><span class="hljs-params">(<span class="hljs-type">int</span> target, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; array)</span> </span>&#123;<br>        <span class="hljs-type">int</span> row=array.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> col=array[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> i=row<span class="hljs-number">-1</span>;<br>        <span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//定义扫描的初始位置，(row-1,0),即数组棋盘的左下角</span><br>        <span class="hljs-keyword">while</span>(i&gt;=<span class="hljs-number">0</span>&amp;&amp;j&lt;col)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(target==array[i][j])<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-comment">//得到return后即可跳出循环，代表查找成功</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(target&lt;array[i][j])<br>                i--;<br>            <span class="hljs-comment">//删去最下面一行(判断大小关系)</span><br>            <span class="hljs-keyword">else</span><br>                j++;<br>            <span class="hljs-comment">//删去第一列，移动到第二列(判断大小关系)</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br></code></pre></td></tr></table></figure><h3 id="4-Acwing3801-最佳连续子数组"><a href="#4-Acwing3801-最佳连续子数组" class="headerlink" title="4.Acwing3801 最佳连续子数组"></a>4.Acwing3801 最佳连续子数组</h3><p><img src="C:\Users\29349\AppData\Roaming\Typora\typora-user-images\image-20241014133831155.png" alt="image-20241014133831155"></p><p>最暴力解法：分别枚举首项和尾项 O(n^2)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">testbestarray</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n; cin&gt;&gt;n;<br>    <span class="hljs-type">int</span> numarray[n];<br>    <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>,targetnumber=<span class="hljs-number">0</span>;<br>    <span class="hljs-type">double</span> maxave=<span class="hljs-number">0</span>,ave;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        cin&gt;&gt;numarray[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i;j&lt;n;j++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=i;k&lt;=j;k++)&#123;<br>                sum+=numarray[k];<br>            &#125;<br>            <span class="hljs-comment">//在已知i，j的情况下，遍历对子数组求和</span><br>            ave=<span class="hljs-built_in">double</span>(sum)/(j-i<span class="hljs-number">+1</span>);<br>            <span class="hljs-keyword">if</span>(ave&gt;maxave)&#123;<br>                maxave=ave;<br>                targetnumber=(j-i<span class="hljs-number">+1</span>);<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ave==maxave)&#123;<br>                <span class="hljs-keyword">if</span>((j-i<span class="hljs-number">+1</span>)&gt;targetnumber)&#123;<br>                    targetnumber=(j-i<span class="hljs-number">+1</span>);<br>                &#125;<br>            &#125;<br>            sum=<span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> targetnumber;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> T; cin&gt;&gt;T;<br>    <span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (count&lt;T)&#123;<br>        cout&lt;&lt;<span class="hljs-built_in">testbestarray</span>()&lt;&lt;endl;<br>        count++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>解法优化：</p><p><strong>分治的思想</strong>：将一个大问题拆分成若干个小问题再分别解决。</p><p>子问题1：最大子数列的值</p><p>​<em><strong>最大子数列的值一定等于数列中最大项的值</strong></em></p><p>子问题2：在子数列平均值最大的情况下，找到最长长度：</p><p>​<em><strong>找到数列中是否有若干项连续，且值均为最大值。</strong></em></p><p>优化代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">testbestarray</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n; cin&gt;&gt;n;<br>    <span class="hljs-type">int</span> numarray[n];<br>    <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>,max=<span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;<span class="hljs-type">int</span> countmax=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        cin&gt;&gt;numarray[i];<br>        max=(numarray[i]&gt;max?numarray[i]:max);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;)&#123;<br>        <span class="hljs-keyword">if</span>(i&lt;n&amp;&amp;numarray[i]==max)&#123;<br>            <span class="hljs-keyword">while</span>(i&lt;n&amp;&amp;numarray[i]==max)&#123;<br>            count++;<br>            i++;<br>            &#125;<br>            i++;<br>            countmax=(countmax&lt;count?count:countmax);<br>            count=<span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i&lt;n)&#123;<br>            i++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//这一段for循环是筛查的核心，如果某元素是列表中最大值，则进入while循环直到第一个非最大值元素的出现终止while循环，同时结束count++，并最大化countmax。在遍历完一整个数组后，即可得到最大子区间的长度。</span><br>    <span class="hljs-keyword">return</span> countmax;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> T; cin&gt;&gt;T;<br>    <span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (count&lt;T)&#123;<br>        cout&lt;&lt;<span class="hljs-built_in">testbestarray</span>()&lt;&lt;endl;<br>        count++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>进一步简化：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">10e5</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> a[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> T;<br>    cin &gt;&gt; T;<br>    <span class="hljs-keyword">while</span>(T--)<br>    &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br><br>        <span class="hljs-type">int</span> m = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        &#123;<br>            cin &gt;&gt; a[i];<br>            m = <span class="hljs-built_in">max</span>(m, a[i]);<span class="hljs-comment">//m保存最大值</span><br>        &#125;<br><br>        <span class="hljs-type">int</span> res = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n;i++)<span class="hljs-comment">//求长度</span><br>        &#123;<br>            <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span>(i &lt; n &amp;&amp; a[i] == m)<br>            &#123;<br>                t++;<br>                i++;<br>            &#125;<br>            res = <span class="hljs-built_in">max</span>(res, t);<br>        &#125;<br>        <span class="hljs-comment">/*核心while循环：</span><br><span class="hljs-comment">        此处不用再添加if语句，直接使用外部的for循环即可。</span><br><span class="hljs-comment">        */</span><br>        cout &lt;&lt; res &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="5-ACwing-862-三元组排序"><a href="#5-ACwing-862-三元组排序" class="headerlink" title="5.ACwing 862 三元组排序"></a>5.ACwing 862 三元组排序</h3><p><img src="C:\Users\29349\AppData\Roaming\Typora\typora-user-images\image-20241014191357986.png" alt="image-20241014191357986"></p><p>思路：</p><ul><li>最基本的排序使用排序算法（此处用algorithm库中的sort（）函数）</li><li>如何构建一一对应的关系？<ul><li>map容器</li><li>pair：将两组数据整合成一个数据对<ul><li>（int,（double,string））</li><li>对pair类型的int数排序，一一对应的（double，string）满足映射</li></ul></li></ul></li></ul><p>代码实现：</p><p>①最基本的数组实现</p><p>排序算法（Bubblesort）+交换函数swap（）（内置在C++库中）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n; cin&gt;&gt;n;<br>    <span class="hljs-type">int</span> intlist[n];<br>    <span class="hljs-type">double</span> doublelist[n];<br>    string stringlist[n];<br>    <span class="hljs-comment">//定义三个数组，分别储存三种不同的数据结构。</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        cin&gt;&gt;intlist[i]&gt;&gt;doublelist[i]&gt;&gt;stringlist[i];<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=n;j&gt;<span class="hljs-number">1</span>;j--)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;j<span class="hljs-number">-1</span>;i++)&#123;<br>            <span class="hljs-keyword">if</span>(intlist[i]&gt;intlist[i<span class="hljs-number">+1</span>])&#123;<br>                <span class="hljs-built_in">swap</span>(intlist[i],intlist[i<span class="hljs-number">+1</span>]);<br>                <span class="hljs-built_in">swap</span>(doublelist[i],doublelist[i<span class="hljs-number">+1</span>]);<br>                <span class="hljs-built_in">swap</span>(stringlist[i],stringlist[i<span class="hljs-number">+1</span>]);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//核心算法：冒泡排序</span><br>    <span class="hljs-comment">//从第一位开始逐项与后一位冒泡比较确定是否交换，第一轮下来就确定末尾项为最大值。</span><br>    <span class="hljs-comment">//之后通过外层的for循环逐步确定直至首项</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %.2lf&quot;</span>,intlist[i],doublelist[i]);<br>        cout&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;stringlist[i]&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>②map映射</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;map&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> x first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> y second</span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">10010</span>;<br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">double</span>, string&gt; PII;<br>map&lt;<span class="hljs-type">int</span>, PII&gt; ans;<br><span class="hljs-comment">//定义了一个从int向PII的映射，就不用使用两次pair了</span><br><span class="hljs-type">int</span> n;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-type">double</span> b;<br>    string c;<br>    cin &gt;&gt; n;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ )<br>    &#123;<br>        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;<br>        ans.<span class="hljs-built_in">insert</span>(&#123;a, &#123;b, c&#125;&#125;);<br>    &#125;<br><br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> iter = ans.<span class="hljs-built_in">begin</span>(); iter != ans.<span class="hljs-built_in">end</span>(); iter ++ )<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %.2f %s\n&quot;</span>, iter-&gt;x, iter-&gt;y.x, iter-&gt;y.y.<span class="hljs-built_in">c_str</span>());  <br>    <span class="hljs-comment">/*这里 iter是一个迭代器</span><br><span class="hljs-comment">    iter-&gt;first代表指向map类型的first成员函数（即自变量）</span><br><span class="hljs-comment">    iter-&gt;second代表指向因变量</span><br><span class="hljs-comment">    iter-&gt;second.first代表指向因变量pair的第一个元素</span><br><span class="hljs-comment">    iter-&gt;second.second               第二个元素</span><br><span class="hljs-comment">    c_str()返回一个指向字符串的指针</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>③使用pair类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> x first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> y second</span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">10010</span>;<br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, pair&lt;<span class="hljs-type">double</span>, string &gt;&gt; PII;<br><br>vector&lt;PII&gt; ans;<br><span class="hljs-type">int</span> n, a;<br><span class="hljs-type">double</span> b;<br>string s;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ )<br>    &#123;<br>        cin &gt;&gt; a &gt;&gt; b &gt;&gt; s;<br>        ans.<span class="hljs-built_in">push_back</span>(&#123;a, &#123;b, s&#125;&#125;);<br>        <span class="hljs-comment">//vector类型的push_back函数，&#123;a,&#123;b,s&#125;&#125;是一个PII类型的数据</span><br>    &#125;<br>    <span class="hljs-built_in">sort</span>(ans.<span class="hljs-built_in">begin</span>(), ans.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-comment">//使用sort()函数实现ans这个vector的自动排序(默认升序)</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i: ans)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %.2lf %s\n&quot;</span>,i.x, i.y.x, i.y.y.<span class="hljs-built_in">c_str</span>());   <br>    <span class="hljs-comment">//若i是一个pair类型，则i.first代表pair的第一个元素，而i.second代表pair的第二个元素。</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C/C++</tag>
      
      <tag>Leetcode notes</tag>
      
      <tag>algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Life-musings</title>
    <link href="/posts/Life-musings/"/>
    <url>/posts/Life-musings/</url>
    
    <content type="html"><![CDATA[<h1 id="Life-Musings"><a href="#Life-Musings" class="headerlink" title="Life-Musings"></a>Life-Musings</h1><p><strong>生活随想录</strong></p><h2 id="2024-11-19"><a href="#2024-11-19" class="headerlink" title="2024.11.19"></a>2024.11.19</h2><p>第一篇文章！</p><h2 id="2024-12-4"><a href="#2024-12-4" class="headerlink" title="2024.12.4"></a>2024.12.4</h2><p>数分期中考试</p><p>好难好难呜呜呜</p>]]></content>
    
    
    
    <tags>
      
      <tag>life</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/posts/hello-world/"/>
    <url>/posts/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
  
  
  <entry>
    <title>resume</title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[<div class="markdown-body">    Hello, I'm Xiyuan Yang!    </div>]]></content>
    
  </entry>
  
  
  
  <entry>
    <title>above</title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[<div class="markdown-body"><h1 id="Welcome-To-My-Blog"><a href="#Welcome-To-My-Blog" class="headerlink" title="Welcome To My Blog !"></a>Welcome To My Blog !</h1><h2 id="Before-The-Blog"><a href="#Before-The-Blog" class="headerlink" title="Before The Blog"></a>Before The Blog</h2><p>三个月前，我通过偶然的机会了解到前 OpenAI 研究副总裁，主管GPT模型安全的杰出华人女性，<strong>翁荔(Lilian Weng)<strong>。她提出了著名的</strong>Agent 配方：Agent&#x3D;LLM+Memory+planning skills+tool use</strong>。在当今的GPT时代，她可谓是功不可没。</p><p>在OpenAI对她的独家专访<a href="https://openai.com/index/the-power-of-continuous-learning/">The power of continuous learning</a>中，她提到：</p><blockquote><p>I believe in the power of learning and it is never too late to learn. Maintaining my personal blog is a good way to keep this curiosity going and learn about new progress in the deep learning community regularly. I also encourage my team to keep on learning, whether related or unrelated to their current projects. Ideas in different topics or fields can often inspire new ideas and broaden the potential solution space.</p><p>I’m also a strong believer in teamwork. If everyone shines in their best strength, we will get 1+1 &gt; 2. Meanwhile, we might often run into “dirty” work and personally I’m very willing to take on those tasks, because as long as that’s the biggest blocker or that task can add the biggest value into the project, nothing should be considered “dirty” or “trivial.” I encourage people around me to do the same, being a team player and working together to expedite the team productivity.</p><p>我相信学习的力量，学习永远不会太迟。维护个人博客是一个保持好奇心，定期了解深度学习社区新进展的好方法。我也鼓励我的团队不断学习，无论是否与他们当前的项目相关。不同主题或领域的想法常常能激发新的灵感，并拓宽潜在的解决方案空间。</p><p>我也是团队合作的坚定信徒。如果每个人都能在自己最擅长的领域发光，我们就能实现1+1大于2。同时，我们可能会碰到一些“脏活”，而我个人非常愿意承担这些任务，因为只要那是最大的障碍，或者那项任务能为项目带来最大的价值，就没有什么是“脏活”或“琐事”。我鼓励周围的人也这样做，成为团队的一员，共同努力提高团队的生产力。</p></blockquote><p><img src="https://images.ctfassets.net/kftzwdyauwt9/e3357d5a-b177-4b3a-1edf79a7f2dc/ca1f3418cd72b4eb84c9d1a09dfffc7f/stangel-2022-0421.jpg?w=3840&q=90&fm=webp" alt="Lilian Weng&#39;s interview"></p><p>图源：<a href="https://openai.com/index/the-power-of-continuous-learning/">The power of continuous learning | OpenAI</a>   Photo: Jake Stangel</p><blockquote><p>PS：这个姐姐好漂亮~</p></blockquote><p>这与<strong>费曼学习法（Feynman Technique）</strong>可谓是不谋而合：</p><blockquote><p>1.Identify the subject. Write down everything you know about the topic.</p><p>2.Teach it to a child. If you can teach a concept to a child, you’re way ahead of the game.</p><p>3.Identify your knowledge gaps. This is the point where the real learning happens.</p><p>4.Organize + simplify + Tell a story. Start to tell your story.</p></blockquote><p>此时，刚刚步入大学校园3个月的笔者，由于深受高中优绩主义和应试思想的遗风荼毒，对大学生活和计算机学科的学习颇具不适应的疲态。学习的知识如此海量，却无法依靠应试和做题进行巩固，该如何是好？</p><p>或许<strong>上文已经给出了答案。</strong></p><center><p><font size=6><b><p style="color:red;">我要创建自己的博客!</p></b></font></p></center><p>无论是传统的做题刷卷，还是博客，亦或是“费曼学习法”，本质上都是<strong>强化训练人脑在吸收新知识后的有效输出过程</strong>：当你能很流畅地给出一道数学题的若干种证明方法时，能逻辑清晰地将所学的知识穿成逻辑链条或思维导图，呈现在博客中为他人所吸收时，你便通过<strong>有效的对外做功输出</strong>很好地巩固了所学的知识。同时，知识的不断沉淀也带来了莫大的成就感。</p><p>但是，写一篇博客，可不仅仅是打打字那么简单。</p><p>不知各位在高中写议论文的时候有没有一种“咬牙切齿”的感觉，就是<strong>我想到的≠我实际构思好的≠我输出的≠我希望所表达的</strong>，甚至于，很多时候我们心中所谓的灵感只是<strong>乍现的只言片语的碎片</strong>，距离成为一篇逻辑清晰，内容详实且有创新性的博客文章还有很长的路要走。这便是博客写作的难点，也是<strong>我希望通过个人博客来训练的最重要的内容：将心里的灵感进行有效的输出，力求逻辑性和学术的专业性。</strong></p><h2 id="About-the-Blog"><a href="#About-the-Blog" class="headerlink" title="About the Blog"></a>About the Blog</h2><p><strong>Xiyuan Yang’s Blog</strong>，创建于<strong>2024年11月19日</strong>。</p><p>以下是自我简介（摘自<a href="https://xiyuanyang-code.github.io/about/">About - Xiyuan Yang’s Blog</a>）：</p><blockquote><p>Greetings! I am <strong>Xiyuan Yang (杨希渊)</strong>, currently pursuing an undergraduate degree in Artificial Intelligence at Shanghai Jiao Tong University. With a longstanding aspiration to become a programmer, I am passionate about leveraging technology to make a meaningful impact on the world. Through my personal website, I aim to share a collection of my blogs and learning notes with you. Some of these entries will be presented as a series, updated at irregular intervals. Additionally, I will offer insights into my personal observations and reflections on life. I hope your visit here is both enjoyable and enriching!</p></blockquote><blockquote><p><strong>My email:</strong></p><ul><li><p><a href="mailto:xiyuan__yang@outlook.com">xiyuan__yang@outlook.com</a></p></li><li><p><a href="mailto:yangxiyuan@sjtu.edu.cn">yangxiyuan@sjtu.edu.cn</a></p><p>Feel free to contact me!</p></li></ul></blockquote><blockquote><p>VENI VIDI VICI</p></blockquote><p>这个博客的更新内容将随着笔者后续的专业课程的学习同步进行，<strong>旨在分享笔者在学习过程中学到的有意思的专业知识，力求在博客输出的过程中培养自己的逻辑思维和表达能力</strong>，不过更新时间，更新内容，更新篇幅<strong>将会完全随机</strong>。</p><p>本博客部署在github的静态网站上，轮子使用<code>Hexo</code>的<code>Fluid</code>的模版，配置环境还是比较简单的，下面贴出一些相关的网址，有相同爱好的童鞋可以参考借鉴一下：</p><ul><li><a href="https://github.com/xiyuanyang-code">xiyuanyang-code (Xiyuan Yang)我的Github主页</a></li><li><a href="https://github.com/xiyuanyang-code/xiyuanyang-code.github.io">xiyuanyang-code&#x2F;xiyuanyang-code.github.io我的博客Github仓库</a></li><li><a href="https://github.com/fluid-dev/hexo-theme-fluid">fluid-dev&#x2F;hexo-theme-fluid-Design theme for Hexo Fluid的Github官方仓库</a></li><li><a href="https://fluid-dev.github.io/hexo-fluid-docs/guide/">配置指南 | Hexo Fluid 用户手册</a></li><li><a href="https://fluid-dev.github.io/hexo-fluid-docs/start/">开始使用 | Hexo Fluid 用户手册</a></li></ul><p>有关博客的具体更新内容，请详见<code>Goals and Plans of Updates</code>部分~</p><h2 id="Goals-and-Plans-of-Updates"><a href="#Goals-and-Plans-of-Updates" class="headerlink" title="Goals and Plans of Updates"></a>Goals and Plans of Updates</h2><h3 id="更新的主要内容"><a href="#更新的主要内容" class="headerlink" title="更新的主要内容"></a>更新的主要内容</h3><p>笔者更新的主要内容包括：（<strong>草拟</strong>）</p><ul><li>编程语言的语法学习<ul><li>C&#x2F;C++</li><li>Python<ul><li>语法</li><li>Anaconda</li><li>一些常见的库</li></ul></li><li>HTML&#x2F;Javascript</li><li>Bash&#x2F;Shell</li></ul></li><li>一些常用的工具教程<ul><li>LaTeX</li><li>命令行</li><li>Git</li><li>Vim编辑器</li><li>Linux和服务器（主要和深度学习相关）<ul><li>Linux常见命令</li><li>Tmux</li><li>SSH远程连接</li></ul></li></ul></li><li>[CS]算法<ul><li>数据结构</li><li>算法</li><li>计算机四大件</li></ul></li><li>AI专业课<ul><li>机器学习</li><li>强化学习</li><li>深度学习<ul><li>Pytorch</li></ul></li></ul></li><li>AI前沿&amp;经典论文精读</li><li><del>一些晦涩难懂的</del>数学课</li><li>发发牢骚</li></ul><h3 id="具体的分类（实时更新）"><a href="#具体的分类（实时更新）" class="headerlink" title="具体的分类（实时更新）"></a>具体的分类（实时更新）</h3><ul><li><strong>Code</strong></li><li><strong>Math</strong></li><li><strong>Efficient Tools</strong></li><li><strong>Algorithm</strong></li><li><strong>Frontier and Classic Papers in AI</strong></li><li><strong>AI Core Courses</strong></li></ul><h3 id="具体的标签（实时更新）"><a href="#具体的标签（实时更新）" class="headerlink" title="具体的标签（实时更新）"></a>具体的标签（实时更新）</h3><p>见 <a href="https://xiyuanyang-code.github.io/tags/">Tags</a> 页。</p><h2 id="Several-Pages"><a href="#Several-Pages" class="headerlink" title="Several Pages"></a>Several Pages</h2><p>以下是对本博客若干基本页面的介绍：</p><ul><li><h4 id="Home"><a href="#Home" class="headerlink" title="Home"></a>Home</h4></li><li><h4 id="Intro（你现在在的地方）"><a href="#Intro（你现在在的地方）" class="headerlink" title="Intro（你现在在的地方）"></a><strong>Intro</strong>（你现在在的地方）</h4></li><li><h4 id="Archives（文章）"><a href="#Archives（文章）" class="headerlink" title="Archives（文章）"></a>Archives（文章）</h4></li><li><h4 id="Categories（分类页）"><a href="#Categories（分类页）" class="headerlink" title="Categories（分类页）"></a>Categories（分类页）</h4></li><li><h4 id="Tags（标签页）"><a href="#Tags（标签页）" class="headerlink" title="Tags（标签页）"></a>Tags（标签页）</h4></li><li><h4 id="About（关于作者）"><a href="#About（关于作者）" class="headerlink" title="About（关于作者）"></a>About（关于作者）</h4></li><li><h4 id="FAQ（一些常见的问题）"><a href="#FAQ（一些常见的问题）" class="headerlink" title="FAQ（一些常见的问题）"></a>FAQ（一些常见的问题）</h4></li><li><h4 id="Resume（Academic-CV-of-the-Author）"><a href="#Resume（Academic-CV-of-the-Author）" class="headerlink" title="Resume（Academic CV of the Author）"></a>Resume（<strong>Academic CV of the Author</strong>）</h4></li></ul><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p><a href="https://github.com/lilianweng">lilianweng (Lilian)的github主页</a></p><p> <a href="https://lilianweng.github.io/">Lil’Log（翁荔的博客）</a></p><p><a href="https://openai.com/index/the-power-of-continuous-learning/">The power of continuous learning | OpenAI</a></p><p><a href="https://github.com/xiyuanyang-code">https://github.com/xiyuanyang-code</a></p><p><a href="https://github.com/xiyuanyang-code/xiyuanyang-code.github.io">https://github.com/xiyuanyang-code/xiyuanyang-code.github.io</a></p><center><p><font size=6><b>欢迎大家常常来玩~&#128512&#128516&#128513</p></font></p></center><div/>]]></content>
    
  </entry>
  
  
  
  <entry>
    <title>about</title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[<p>Greetings! I am <strong>Xiyuan Yang (杨希渊)</strong>, currently pursuing an undergraduate degree in Artificial Intelligence at Shanghai Jiao Tong University. With a longstanding aspiration to become a programmer, I am passionate about leveraging technology to make a meaningful impact on the world. Through my personal website, I aim to share a collection of my blogs and learning notes with you. Some of these entries will be presented as a series, updated at irregular intervals. Additionally, I will offer insights into my personal observations and reflections on life. I hope your visit here is both enjoyable and enriching!</p><p><strong>My email:</strong></p><ul><li><p><a href="mailto:&#x78;&#x69;&#121;&#117;&#97;&#110;&#95;&#95;&#x79;&#97;&#x6e;&#x67;&#64;&#111;&#117;&#116;&#108;&#x6f;&#111;&#x6b;&#46;&#x63;&#111;&#x6d;">&#x78;&#x69;&#121;&#117;&#97;&#110;&#95;&#95;&#x79;&#97;&#x6e;&#x67;&#64;&#111;&#117;&#116;&#108;&#x6f;&#111;&#x6b;&#46;&#x63;&#111;&#x6d;</a></p></li><li><p><a href="mailto:&#121;&#x61;&#110;&#x67;&#x78;&#x69;&#x79;&#x75;&#97;&#110;&#x40;&#115;&#x6a;&#116;&#117;&#46;&#101;&#x64;&#x75;&#46;&#99;&#110;">&#121;&#x61;&#110;&#x67;&#x78;&#x69;&#x79;&#x75;&#97;&#110;&#x40;&#115;&#x6a;&#116;&#117;&#46;&#101;&#x64;&#x75;&#46;&#99;&#110;</a></p><p>Feel free to contact me!</p></li></ul><blockquote><p>VENI VIDI VICI</p></blockquote>]]></content>
    
  </entry>
  
  
  
  <entry>
    <title>FAQ</title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[<div class="markdown-body"><center><p><font size=6><b>FAQ~&#128512&#128516&#128513</b></p></font></p></center><p><strong>Found some issues or bugs in the blog? Feel free to contact the author.</strong></p><p><strong>My email:</strong></p><ul><li><p><a href="mailto:xiyuan__yang@outlook.com">xiyuan__yang@outlook.com</a></p></li><li><p><a href="mailto:yangxiyuan@sjtu.edu.cn">yangxiyuan@sjtu.edu.cn</a></p></li></ul><h1 id="FAQs"><a href="#FAQs" class="headerlink" title="FAQs"></a>FAQs</h1><h2 id="全是烂尾文章？"><a href="#全是烂尾文章？" class="headerlink" title="全是烂尾文章？"></a>全是烂尾文章？</h2><p>呜呜呜别骂了。。。博客的更新真的好花时间。。。一般来说，笔者会努力把前面的就坑全部填上再开新坑哒。</p><ul><li>一般在<code>Home</code>页写好摘要，设置好封面，Tags中标上<code>Finished</code>的文章就是已经完成不会大改的文章，可放心食用~</li><li>如果Tags标注是<code>Updating</code>，一般是一些声明性的文章，表示内容会时不时地更新。</li><li>如果是光秃秃的一片，说明亟需完工。🤡🤡🤡</li></ul><h2 id="关于评论系统"><a href="#关于评论系统" class="headerlink" title="关于评论系统"></a>关于评论系统</h2><p>评论系统算是笔者踩过的大坑之一，前后换了四五个评论系统，最后选择了强大的<code>giscus</code>提供支持。</p><p>相关网站：<a href="https://giscus.app/zh-CN">Giscus</a></p><p><strong>有关评论系统的使用：</strong></p><ul><li>需要自己的github账号（github在国内有时慢的离谱，请自备加速器或<del>自行解决</del>）</li><li>之后使用就和正常的评论区没什么区别了，轻点喷~</li><li>相关的评论内容可以在我博客仓库的 <a href="https://github.com/xiyuanyang-code/xiyuanyang-code.github.io/discussions">Discussion</a> 页面找到。</li><li>目前只有文章页可以发表评论哦，有什么奇奇怪怪的问题可以给我发 <a href="https://github.com/xiyuanyang-code/xiyuanyang-code.github.io/issues">issue</a> 或者email 我。</li><li><strong>好像手机端没办法发表评论（我也不知道为什么）。</strong></li></ul><h2 id="更新频率？更新内容？"><a href="#更新频率？更新内容？" class="headerlink" title="更新频率？更新内容？"></a>更新频率？更新内容？</h2><p><a href="https://xiyuanyang-code.github.io/above/">参见这里</a></p><blockquote><p>最后引用一下我的偶像的博客的FAQ的最后一个问题：</p><p>相关网址：<a href="https://lilianweng.github.io/faq/">lilianweng</a></p><p><strong>Q: How can you keep up blogging?</strong></p><p><strong>A:</strong> “Pain is inevitable but suffering is optional” — this is the first sentence of Haruki Murakami’s book <a href="https://www.goodreads.com/book/show/2195464.What_I_Talk_About_When_I_Talk_About_Running">“What I Talk About When I Talk About Running”</a>. I love that book. His altitude towards running is pretty much aligned with how I feel about maintaining this blog.</p></blockquote><div/><hr><h1 id="English-Version-FAQs"><a href="#English-Version-FAQs" class="headerlink" title="English Version FAQs"></a>English Version FAQs</h1><h2 id="Are-all-your-posts-incomplete"><a href="#Are-all-your-posts-incomplete" class="headerlink" title="Are all your posts incomplete?"></a>Are all your posts incomplete?</h2><p>Please don’t scold me… 😭 Maintaining and updating a blog takes a lot of time. Generally, I strive to finish old posts before starting new ones.</p><ul><li>Posts marked with <code>Finished</code> in the <em>Tags</em> section on the <code>Home</code> page, along with summaries and cover images, are complete and won’t undergo major changes. Feel free to enjoy them with peace of mind!</li><li>Posts marked with <code>Updating</code> in <em>Tags</em> are generally declarative in nature and are updated from time to time.</li><li>If a post has no tags at all, it’s a work in urgent need of completion. 🤡🤡🤡</li></ul><h2 id="About-the-Comment-System"><a href="#About-the-Comment-System" class="headerlink" title="About the Comment System"></a>About the Comment System</h2><p>The comment system has been one of the biggest challenges I’ve faced. After trying four or five systems, I finally settled on the robust support provided by <code>giscus</code>.</p><p>Relevant website: <a href="https://giscus.app/zh-CN">Giscus</a></p><p><strong>How to use the comment system:</strong></p><ul><li>You need your own GitHub account (GitHub can be painfully slow in some regions of China, so prepare a VPN or find your own solution).</li><li>Once logged in, using the comment section is no different from a regular comments platform—please be gentle with your critiques. 😉</li><li>Comments are linked to the <a href="https://github.com/xiyuanyang-code/xiyuanyang-code.github.io/discussions">Discussions</a> page in my blog’s GitHub repository.</li><li>Currently, only article pages allow comments. For unusual issues, you can send me an <a href="https://github.com/xiyuanyang-code/xiyuanyang-code.github.io/issues">issue</a> or email me.</li><li><strong>It seems that comments don’t work on mobile devices (I have no idea why).</strong></li></ul><h2 id="How-often-do-you-update-What-do-you-post"><a href="#How-often-do-you-update-What-do-you-post" class="headerlink" title="How often do you update? What do you post?"></a>How often do you update? What do you post?</h2><p><a href="https://xiyuanyang-code.github.io/above/">See this page</a> for more details.</p><blockquote><p>Finally, here’s a quote from my idol’s FAQ page:</p><p>Relevant website: <a href="https://lilianweng.github.io/faq/">lilianweng</a></p><p><strong>Q: How can you keep up blogging?</strong></p><p><strong>A:</strong> “Pain is inevitable but suffering is optional” — This is the first sentence of Haruki Murakami’s book <a href="https://www.goodreads.com/book/show/2195464.What_I_Talk_About_When_I_Talk_About_Running">“What I Talk About When I Talk About Running”</a>. I love that book. His attitude toward running aligns closely with how I feel about maintaining this blog.</p></blockquote>]]></content>
    
  </entry>
  
  
  
</search>
