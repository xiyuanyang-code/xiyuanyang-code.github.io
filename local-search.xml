<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>C++-Primer-Plus-tutorial</title>
    <link href="/posts/C-Primer-Plus-tutorial/"/>
    <url>/posts/C-Primer-Plus-tutorial/</url>
    
    <content type="html"><![CDATA[<h1 id="C-Primer-Plus-tutorial"><a href="#C-Primer-Plus-tutorial" class="headerlink" title="C++ Primer Plus tutorial"></a>C++ Primer Plus tutorial</h1><h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>笔者又来开新坑啦！</p><p>之前看到一个很讽刺的笑话：<strong>大多数国内高校学生学到的C++只是C语言+cin&#x2F;cout</strong>。这当然只是一句玩笑话，但很深刻地反映出对于C++精髓<strong>面向对象编程</strong>的忽视。</p><p>这是有理可依的：<strong>编程语言的学习本身就和传统的课堂授课模式存在较大的出入</strong>，编程重视实践，枯燥的语法讲解如同天书一般晦涩难懂，更不用提OOP所涉及的都是比较大规模的项目工程，如果只是在课堂上乏味地讲解“什么是析构函数，什么是继承，什么是多态···”，很容易将C++学成死记硬背的无聊学科。</p><p>因此，笔者在课堂学习之余，<strong>同步学习了世界经典C++教材——《C++ Primer Plus》的相关内容</strong>。经典不愧为经典！</p><p>但是，针对我个人而言，我认为C++ Primer Plus有以下问题：（其实也不算是问题啦，就是和普通在校大学生存在一些“冲突”）</p><ul><li>一共678页，并且全是密密麻麻的字，阅读周期长，读完需要很大的意志力（对于自学者）。</li><li>由于翻译等种种的原因，在很多地方的解释并不清晰（作为一本C++的入门书籍体量有些大了，而且涉及到很多专业的名词，看得让人头大）</li></ul><p>因此，笔者希望通过博客的方式，记录自己的C++ Primer Plus学习笔记，并上传到网络上供一同学习的小伙伴参考。</p><p>博客立志于：</p><ul><li>记录自己的C++学习过程</li><li>对本人认为的C++学习中的一些重难点做一些额外的解释</li><li>尝试用简单清晰的语言梳理逻辑脉络</li></ul><h2 id="目录："><a href="#目录：" class="headerlink" title="目录："></a>目录：</h2><ul><li><strong>Chapter10 对象和类</strong></li><li><strong>Chapter11 使用类</strong></li><li><strong>Chapter12 类和动态内存分配</strong></li><li><strong>Chapter13 类继承</strong></li><li><strong>Chapter14 代码重用</strong></li><li><strong>Chapter15 友元，异常和其他</strong></li><li><strong>Chapter16 string类的标准模板库</strong></li></ul><p>（目前更新计划主要分布在OOP的章节，之后的其他章节看情况更新~）</p><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>本博客系列使用的大部分代码都摘自《C++ Primer Plus》，并非原创。相当于为《C++ Primer Plus》添加一下自己的注解和所思所想。</p>]]></content>
    
    
    <categories>
      
      <category>Code</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Announcement</tag>
      
      <tag>C/C++</tag>
      
      <tag>C++ Primer Plus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Dynamic-Memory-and-Classes</title>
    <link href="/posts/Dynamic-Memory-and-Classes/"/>
    <url>/posts/Dynamic-Memory-and-Classes/</url>
    
    <content type="html"><![CDATA[<h1 id="C-Primer-Plus-Tutorial-12"><a href="#C-Primer-Plus-Tutorial-12" class="headerlink" title="C++ Primer Plus Tutorial-12"></a>C++ Primer Plus Tutorial-12</h1><center><p style="color: red;"><b><font size=6.5>Chapter 12 Dynamic-Memory-and-Classes</font></b></p></center><center><p style="color: red;"><b><font size=6.5>动态内存和类</font></b></p></center><p>【写在前面的话】</p><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><h2 id="Introduction：C-中的特殊成员函数"><a href="#Introduction：C-中的特殊成员函数" class="headerlink" title="Introduction：C++中的特殊成员函数"></a>Introduction：C++中的特殊成员函数</h2><h3 id="示例代码（stringbad类的实现）"><a href="#示例代码（stringbad类的实现）" class="headerlink" title="示例代码（stringbad类的实现）"></a>示例代码（stringbad类的实现）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// strngbad.h -- flawed string class definition</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> STRNGBAD_H_</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> STRNGBAD_H_</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">StringBad</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">char</span> * str;                <span class="hljs-comment">// pointer to string</span><br>    <span class="hljs-type">int</span> len;                   <span class="hljs-comment">// length of string</span><br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> num_strings;    <span class="hljs-comment">// number of objects</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">StringBad</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> * s); <span class="hljs-comment">// constructor</span><br>    <span class="hljs-built_in">StringBad</span>();               <span class="hljs-comment">// default constructor</span><br>    ~<span class="hljs-built_in">StringBad</span>();              <span class="hljs-comment">// destructor</span><br><span class="hljs-comment">// friend function</span><br>    <span class="hljs-keyword">friend</span> std::ostream &amp; <span class="hljs-keyword">operator</span>&lt;&lt;(std::ostream &amp; os, <span class="hljs-type">const</span> StringBad &amp; st);<br>&#125;;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// strngbad.cpp -- StringBad class methods</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span>                    <span class="hljs-comment">// string.h for some</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;strngbad.h&quot;</span></span><br><span class="hljs-keyword">using</span> std::cout;<br><br><span class="hljs-comment">// initializing static class member</span><br><span class="hljs-type">int</span> StringBad::num_strings = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// class methods</span><br><br><span class="hljs-comment">// construct StringBad from C string</span><br>StringBad::<span class="hljs-built_in">StringBad</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> * s)<br>&#123;<br>    len = std::<span class="hljs-built_in">strlen</span>(s);             <span class="hljs-comment">// set size</span><br>    str = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[len + <span class="hljs-number">1</span>];          <span class="hljs-comment">// allot storage</span><br>    std::<span class="hljs-built_in">strcpy</span>(str, s);              <span class="hljs-comment">// initialize pointer</span><br>    num_strings++;                    <span class="hljs-comment">// set object count</span><br>    cout &lt;&lt; num_strings &lt;&lt; <span class="hljs-string">&quot;: \&quot;&quot;</span> &lt;&lt; str<br>         &lt;&lt; <span class="hljs-string">&quot;\&quot; object created\n&quot;</span>;    <span class="hljs-comment">// For Your Information</span><br>&#125;<br><br>StringBad::<span class="hljs-built_in">StringBad</span>()                <span class="hljs-comment">// default constructor</span><br>&#123;<br>    len = <span class="hljs-number">4</span>;<br>    str = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-number">4</span>];<br>    std::<span class="hljs-built_in">strcpy</span>(str, <span class="hljs-string">&quot;C++&quot;</span>);          <span class="hljs-comment">// default string</span><br>    num_strings++;<br>    cout &lt;&lt; num_strings &lt;&lt; <span class="hljs-string">&quot;: \&quot;&quot;</span> &lt;&lt; str<br>         &lt;&lt; <span class="hljs-string">&quot;\&quot; default object created\n&quot;</span>;  <span class="hljs-comment">// FYI</span><br>&#125;<br><br>StringBad::~<span class="hljs-built_in">StringBad</span>()               <span class="hljs-comment">// necessary destructor</span><br>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;\&quot;&quot;</span> &lt;&lt; str &lt;&lt; <span class="hljs-string">&quot;\&quot; object deleted, &quot;</span>;    <span class="hljs-comment">// FYI</span><br>    --num_strings;                    <span class="hljs-comment">// required</span><br>    cout &lt;&lt; num_strings &lt;&lt; <span class="hljs-string">&quot; left\n&quot;</span>; <span class="hljs-comment">// FYI</span><br>    <span class="hljs-keyword">delete</span> [] str;                    <span class="hljs-comment">// required</span><br>&#125;<br><br>std::ostream &amp; <span class="hljs-keyword">operator</span>&lt;&lt;(std::ostream &amp; os, <span class="hljs-type">const</span> StringBad &amp; st)<br>&#123;<br>    os &lt;&lt; st.str;<br>    <span class="hljs-keyword">return</span> os; <br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// vegnews.cpp -- using new and delete with classes</span><br><span class="hljs-comment">// compile with strngbad.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> std::cout;<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;strngbad.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">callme1</span><span class="hljs-params">(StringBad &amp;)</span></span>;  <span class="hljs-comment">// pass by reference</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">callme2</span><span class="hljs-params">(StringBad)</span></span>;    <span class="hljs-comment">// pass by value</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">using</span> std::endl;<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Starting an inner block.\n&quot;</span>;<br>        <span class="hljs-function">StringBad <span class="hljs-title">headline1</span><span class="hljs-params">(<span class="hljs-string">&quot;Celery Stalks at Midnight&quot;</span>)</span></span>;<br>        <span class="hljs-function">StringBad <span class="hljs-title">headline2</span><span class="hljs-params">(<span class="hljs-string">&quot;Lettuce Prey&quot;</span>)</span></span>;<br>        <span class="hljs-function">StringBad <span class="hljs-title">sports</span><span class="hljs-params">(<span class="hljs-string">&quot;Spinach Leaves Bowl for Dollars&quot;</span>)</span></span>;<br>        cout &lt;&lt; <span class="hljs-string">&quot;headline1: &quot;</span> &lt;&lt; headline1 &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">&quot;headline2: &quot;</span> &lt;&lt; headline2 &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">&quot;sports: &quot;</span> &lt;&lt; sports &lt;&lt; endl;<br>        <span class="hljs-built_in">callme1</span>(headline1);<br>        cout &lt;&lt; <span class="hljs-string">&quot;headline1: &quot;</span> &lt;&lt; headline1 &lt;&lt; endl;<br>        <span class="hljs-built_in">callme2</span>(headline2);<br>        cout &lt;&lt; <span class="hljs-string">&quot;headline2: &quot;</span> &lt;&lt; headline2 &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Initialize one object to another:\n&quot;</span>;<br>        StringBad sailor = sports;<br>        cout &lt;&lt; <span class="hljs-string">&quot;sailor: &quot;</span> &lt;&lt; sailor &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Assign one object to another:\n&quot;</span>;<br>        StringBad knot;<br>        knot = headline1;<br>        cout &lt;&lt; <span class="hljs-string">&quot;knot: &quot;</span> &lt;&lt; knot &lt;&lt; endl; <br>        cout &lt;&lt; <span class="hljs-string">&quot;Exiting the block.\n&quot;</span>;<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-string">&quot;End of main()\n&quot;</span>;<br>    <span class="hljs-comment">// std::cin.get();</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">callme1</span><span class="hljs-params">(StringBad &amp; rsb)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;String passed by reference:\n&quot;</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;    \&quot;&quot;</span> &lt;&lt; rsb &lt;&lt; <span class="hljs-string">&quot;\&quot;\n&quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">callme2</span><span class="hljs-params">(StringBad sb)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;String passed by value:\n&quot;</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;    \&quot;&quot;</span> &lt;&lt; sb &lt;&lt; <span class="hljs-string">&quot;\&quot;\n&quot;</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>以上代码实现了一个对字符串类<code>StringBad</code>类的声明与定义，代码示例参见注释，不做解释。</p><p>以下是原书给出的输出示例：</p><p><img src="/posts/Above-All/mory-and-Classes/input1.png"></p><p><img src="/posts/Above-All/mory-and-Classes/input2.png" alt="Output"></p><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p>通过输出可以大致判断<code>stringbad</code>类出现奇怪问题的原因可能如下：</p><ul><li>静态变量<code>num_strings</code>出现了负值，说明在程序中<strong>使用析构函数的次数</strong>多于<strong>使用构造函数的次数</strong></li><li>出现了<strong>非标准字符</strong>，说明字符串在传递过程中的值出现了问题。</li></ul><h3 id="问题分析1"><a href="#问题分析1" class="headerlink" title="问题分析1"></a>问题分析1</h3><p>在上述代码中，存在<strong>两个构造函数</strong>，分别对应有参数和无参数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++">StringBad::<span class="hljs-built_in">StringBad</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> * s)<br>&#123;<br>    len = std::<span class="hljs-built_in">strlen</span>(s);             <span class="hljs-comment">// set size</span><br>    str = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[len + <span class="hljs-number">1</span>];          <span class="hljs-comment">// allot storage</span><br>    std::<span class="hljs-built_in">strcpy</span>(str, s);              <span class="hljs-comment">// initialize pointer</span><br>    num_strings++;                    <span class="hljs-comment">// set object count</span><br>    cout &lt;&lt; num_strings &lt;&lt; <span class="hljs-string">&quot;: \&quot;&quot;</span> &lt;&lt; str<br>         &lt;&lt; <span class="hljs-string">&quot;\&quot; object created\n&quot;</span>;    <span class="hljs-comment">// For Your Information</span><br>&#125;<br><br>StringBad::<span class="hljs-built_in">StringBad</span>()                <span class="hljs-comment">// default constructor</span><br>&#123;<br>    len = <span class="hljs-number">4</span>;<br>    str = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-number">4</span>];<br>    std::<span class="hljs-built_in">strcpy</span>(str, <span class="hljs-string">&quot;C++&quot;</span>);          <span class="hljs-comment">// default string</span><br>    num_strings++;<br>    cout &lt;&lt; num_strings &lt;&lt; <span class="hljs-string">&quot;: \&quot;&quot;</span> &lt;&lt; str<br>         &lt;&lt; <span class="hljs-string">&quot;\&quot; default object created\n&quot;</span>;  <span class="hljs-comment">// FYI</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这是析构函数的定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++">StringBad::~<span class="hljs-built_in">StringBad</span>()               <span class="hljs-comment">// necessary destructor</span><br>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;\&quot;&quot;</span> &lt;&lt; str &lt;&lt; <span class="hljs-string">&quot;\&quot; object deleted, &quot;</span>;    <span class="hljs-comment">// FYI</span><br>    --num_strings;                    <span class="hljs-comment">// required</span><br>    cout &lt;&lt; num_strings &lt;&lt; <span class="hljs-string">&quot; left\n&quot;</span>; <span class="hljs-comment">// FYI</span><br>    <span class="hljs-keyword">delete</span> [] str;                    <span class="hljs-comment">// required</span><br>&#125;<br></code></pre></td></tr></table></figure><p>以上三个函数定义是都没有忘记对静态成员变量<code>num_strings</code>的操作（++&#x2F;–）。因此，原因①可以被更加规范地表述为：<strong>在程序运行中使用显式定义的构造函数的次数少于使用析构函数的次数</strong>，换句话说，程序使用了<strong>第三种构造函数</strong>，这个“第三种构造函数”为程序自动生成，因此没有对<code>num_strings</code>的++操作，导致负值的出现。（毕竟在作用域中每个对象只能构造一次，析构一次，两者的数量应该是相等的。）</p><p>程序中一共涉及到5个对象，这是他们的构造方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">StringBad <span class="hljs-title">headline1</span><span class="hljs-params">(<span class="hljs-string">&quot;Celery Stalks at Midnight&quot;</span>)</span></span>;<br><span class="hljs-function">StringBad <span class="hljs-title">headline2</span><span class="hljs-params">(<span class="hljs-string">&quot;Lettuce Prey&quot;</span>)</span></span>;<br><span class="hljs-function">StringBad <span class="hljs-title">sports</span><span class="hljs-params">(<span class="hljs-string">&quot;Spinach Leaves Bowl for Dollars&quot;</span>)</span></span>;<br><br>StringBad sailor = sports;<br><br>StringBad knot;<br>knot = headline1;<br></code></pre></td></tr></table></figure><p>前三个对象，<code>headline1</code>，<code>headline2</code>，<code>sports</code>都是有函数定义中<code>StringBad::StringBad(const char * s)</code>的构造函数进行构造；最后一个<code>knot</code>使用默认构造函数<code>StringBad::StringBad()</code>进行构造，因此，问题出现在<code>StringBad sailor = sports</code>上。</p><blockquote><p>sailor和knot的初始化很像，但程序处理的方式完全不同。knot在使用<strong>默认构造函数</strong>构造后用headline1进行赋值；而sailor对象使用了一种名叫<strong>复制构造函数</strong>的构造方式！</p></blockquote><h4 id="复制构造函数：隐藏的“第三者”"><a href="#复制构造函数：隐藏的“第三者”" class="headerlink" title="复制构造函数：隐藏的“第三者”"></a>复制构造函数：隐藏的“第三者”</h4><h5 id="复制构造函数的声明"><a href="#复制构造函数的声明" class="headerlink" title="复制构造函数的声明"></a>复制构造函数的声明</h5><p>sailor的构造函数原型等价于如下语句：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">StringBad sailor = <span class="hljs-built_in">StringBad</span> (sports);<br><span class="hljs-comment">//相当于把sailor的副本拷贝给sailor</span><br></code></pre></td></tr></table></figure><p>这里的<code>StringBad()</code>就是C++自动提供的<strong>复制构造函数</strong>，用于<strong>将一个对象复制到一个新创建的对象的初始化中</strong>，注意，是<strong>初始化不是赋值！！！</strong>knot对象的赋值操作和复制构造函数无关（后文会讲到，使用的是<code>赋值运算符</code>），因为对knot的初始化操作已经在上一行代码使用默认构造函数完成了。</p><p>下面是复制构造函数的原型，它<strong>接受一个指向类对象的常量引用作为参数</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">Class_name</span>(<span class="hljs-type">const</span> Class_name &amp;);<br><br><span class="hljs-built_in">StringBad</span>(<span class="hljs-type">const</span> StringBad &amp;);<br></code></pre></td></tr></table></figure><h5 id="复制构造函数的使用场景"><a href="#复制构造函数的使用场景" class="headerlink" title="复制构造函数的使用场景"></a>复制构造函数的使用场景</h5><p>复制构造函数的使用非常常见，尤其在<strong>将新对象与现有对象之间建立联系的时候</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">StringBad <span class="hljs-title">sailor</span><span class="hljs-params">(sports)</span></span>;<br>StringBad sailor=sports;<br>StringBad sailor = <span class="hljs-built_in">StringBad</span> (sports);<br>StringBad *sailor = <span class="hljs-keyword">new</span> <span class="hljs-built_in">StringBad</span>(sports); <br><span class="hljs-comment">//以上四种初始化方式等价，都会使用复制构造函数</span><br></code></pre></td></tr></table></figure><p>更深入地讲，当函数<strong>按值传递对象或返回对象时</strong>，会使用复制构造函数创建原始对象的一个副本作为临时对象，然后将<strong>临时对象的内容赋给要被初始化的对象</strong>（第四种初始化方式所赋值的是所创建的匿名对象的指针）。</p><p>例如程序中的 <code>callme2()</code>函数使用按值传递，会创建一个副本（<strong>这里和函数的形参实参传递本质是相同的</strong>），因此会使用复制构造函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">callme2</span><span class="hljs-params">(StringBad sb)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;String passed by value:\n&quot;</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;    \&quot;&quot;</span> &lt;&lt; sb &lt;&lt; <span class="hljs-string">&quot;\&quot;\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="复制构造函数的功能"><a href="#复制构造函数的功能" class="headerlink" title="复制构造函数的功能"></a>复制构造函数的功能</h5><p>默认的复制构造函数<strong>逐个复制非静态成员（成员复制也称为浅复制）</strong>，复制的是成员的值。  </p><ul><li><p>补充：显式使用复制构造函数提供了对对象复制行为的精细控制，因此也被称作<strong>深拷贝</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span>* data;<br>    <span class="hljs-built_in">MyClass</span>() &#123; data = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">0</span>); &#125;<br>    ~<span class="hljs-built_in">MyClass</span>() &#123; <span class="hljs-keyword">delete</span> data; &#125;<br>    <br>    <span class="hljs-comment">// 显式的复制构造函数</span><br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">const</span> MyClass&amp; other) &#123;<br>        <span class="hljs-comment">// 深拷贝</span><br>        data = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(*other.data);<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    MyClass a;<br>    *a.data = <span class="hljs-number">10</span>;<br>    MyClass b = a; <span class="hljs-comment">// 调用复制构造函数</span><br>    <span class="hljs-comment">// 现在b.data指向一个新的int，其值为10</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>显式声明</strong>：如果你不希望编译器生成默认的复制构造函数，可以通过在类中声明一个私有的复制构造函数并将其标记为<code>delete</code>来阻止默认复制构造函数的生成。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 其他成员函数和变量...</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">const</span> MyClass&amp;) = <span class="hljs-keyword">delete</span>; <span class="hljs-comment">// 阻止默认复制构造函数的生成</span><br>&#125;;<br></code></pre></td></tr></table></figure></li></ul><h4 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h4><p>在了解的复制构造函数后，就不难理解为何静态变量<code>num_strings</code>出现了负值了。在主程序 <code>vegnews.cpp</code> 中，有一下代码用到了隐式的复制构造函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">callme2</span>(headline2);<br>StringBad sailor = sports;<br><span class="hljs-comment">//使用隐式复制构造函数两次，因此计数器会出现-2，problems solved!</span><br></code></pre></td></tr></table></figure><blockquote><p>问题的解决方式已经在上文给出，构建显式构造函数。</p></blockquote><h3 id="问题分析2"><a href="#问题分析2" class="headerlink" title="问题分析2"></a>问题分析2</h3><p>接下来我们将重点放在 <code>字符串乱码</code>的问题上。</p><h4 id="还是复制函数的锅！"><a href="#还是复制函数的锅！" class="headerlink" title="还是复制函数的锅！"></a>还是复制函数的锅！</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">StringBad sailor = sports;<br></code></pre></td></tr></table></figure><p>上文提到，隐式复制构造函数奉行<strong>按值传递</strong>的基本思想，而这对于字符串成员而言是非常危险。因为C风格字符串的本质就是<code>char</code>数组，或者说指向<code>char</code>类型的特殊指针。</p><p>因此，在使用隐式复制构造函数时，<code>sports.str</code>将自己的<strong>值</strong>复制给了<code>sailor.str</code>。<strong>此时这两个字符串（指向char类型的指针）指向了同一块内存！</strong>，因此，当释放其中一个对象时，被调用的析构函数会执行下面的操作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">delete</span> [] str;<br></code></pre></td></tr></table></figure><p>在这个程序中，<code>sailor</code>先于 <code>sports</code>被析构函数调用，因此，<code>sailor.str</code>会先被<code>delete</code>掉，这样，**<code>sports.str</code>就变成了“无家可归”的悬挂指针**，后续生成乱码也就很好理解了。</p><p>更严重地，在后续<code>delete``sports.str</code>的时候，相当于程序对同一块内存连续delete两次，这会导致程序的异常终止。</p><h4 id="solution-1"><a href="#solution-1" class="headerlink" title="solution"></a>solution</h4><p>按值传递更加直观，易于理解，但是，一旦程序涉及于指针和内存管理相关的操作时，<strong>按值传递和按址传递（指针）会产生冲突</strong>。因此，手动构建一个显式的复制构造函数迫在眉睫。</p><p>这是原书给出的显示复制构造函数（深拷贝），手动使用 <code>strcpy</code>函数实现字符串的拷贝（按址拷贝）。</p><p><img src="/posts/Above-All/mory-and-Classes/3.png" alt="Explicit Copy Constructor"></p><h3 id="问题还未被解决…"><a href="#问题还未被解决…" class="headerlink" title="问题还未被解决…"></a>问题还未被解决…</h3><p>我们已经解决了因为<strong>隐式复制构造函数</strong>带来的一些问题，其中，问题②主要是因为浅拷贝的<strong>赋值操作</strong>导致的<strong>按值传递与按址传递的冲突</strong>。请看下面的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++">StringBad sailor = sports;<br><br>StringBad knot;<br>knot = headline1;<br></code></pre></td></tr></table></figure><p><code>sailor</code>使用复制构造函数，将<code>sports</code>对象的临时拷贝<strong>赋值</strong>给<code>sailor</code>完成初始化。<code>knot</code>在初始化时使用了默认构造函数，但是也免不了<code>knot = headline1</code>中对其的<strong>赋值操作</strong>，<strong>按值传递与按址传递的冲突</strong>仍然存在！</p><p><img src="/posts/Above-All/mory-and-Classes/input2.png" alt="Output"></p><p>输出示例验证了我们的猜想，在析构时，<code>knot</code>先被<code>delete</code>，因此在最后<code>delete</code> <code>headline1</code>时，字符串呈现乱码。也就是说，<strong>C++默认的对对象的赋值运算符依旧使用按值传递</strong>，即<strong>类重载赋值运算符</strong>。下面是这种运算符的函数原型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">Class_name &amp; Class_name::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Class_name &amp;)<br></code></pre></td></tr></table></figure><p>因此，解决问题的方式也显而易见了：手动定义赋值运算符的重载，和复制构造函数的定义基本相同。书中实现了运算符重载的代码示例：</p><p><img src="/posts/Above-All/mory-and-Classes/4.png" alt="Explicit Overloading of Assignment Operator"></p><h3 id="特殊成员函数"><a href="#特殊成员函数" class="headerlink" title="特殊成员函数"></a>特殊成员函数</h3><p>StringBad 类的问题是由特殊成员函数引起的。这些成员函数是自动定义的，就 StringBad 而言，这些函数的行为与类设计不符。具体地说， C++自动提供了下面这些成员函数：</p><ul><li><strong>默认构造函数，如果没有定义构造函数；</strong></li><li><strong>默认析构函数，如果没有定义；</strong></li><li><strong>复制构造函数，如果没有定义；</strong></li><li><strong>赋值运算符，如果没有定义；</strong></li><li><strong>地址运算符，如果没有定义。</strong>（读者可以自行查阅，就是取址运算符）</li></ul><p>更准确地说，编译器将生成上述最后三个函数的定义——如果程序使用对象的方式要求这样做。例如，如果您将一个对象赋给另一个对象，编译器将提供赋值运算符的定义。</p><h3 id="From-StringBad-to-String"><a href="#From-StringBad-to-String" class="headerlink" title="From StringBad to String"></a>From StringBad to String</h3><p>这就是C++风格的string类的实现！请阅读教材的12.2节，其简单介绍了string类的相关成员函数的定义，受篇幅限制，本博客不再讨论本节内容。对于使用者而言，只需要了解string类的接口足矣，但对于一位优秀的OOP学习者而言，但阅读书中代码，甚至尝试自己实现是锻炼自己OOP能力的一大有力武器。</p><p>此处只给出书中的源代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// string1.h -- fixed and augmented string class definition</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> STRING1_H_</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> STRING1_H_</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> std::ostream;<br><span class="hljs-keyword">using</span> std::istream;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">char</span> * str;             <span class="hljs-comment">// pointer to string</span><br>    <span class="hljs-type">int</span> len;                <span class="hljs-comment">// length of string</span><br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> num_strings; <span class="hljs-comment">// number of objects</span><br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> CINLIM = <span class="hljs-number">80</span>;  <span class="hljs-comment">// cin input limit</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// constructors and other methods</span><br>    <span class="hljs-built_in">String</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> * s); <span class="hljs-comment">// constructor</span><br>    <span class="hljs-built_in">String</span>();               <span class="hljs-comment">// default constructor</span><br>    <span class="hljs-built_in">String</span>(<span class="hljs-type">const</span> String &amp;); <span class="hljs-comment">// copy constructor</span><br>    ~<span class="hljs-built_in">String</span>();              <span class="hljs-comment">// destructor</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">length</span> <span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> len; &#125;<br><span class="hljs-comment">// overloaded operator methods    </span><br>    String &amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> String &amp;);<br>    String &amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *);<br>    <span class="hljs-type">char</span> &amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> i);<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> &amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> i) <span class="hljs-type">const</span>;<br><span class="hljs-comment">// overloaded operator friends</span><br>    <span class="hljs-keyword">friend</span> <span class="hljs-type">bool</span> <span class="hljs-built_in">operator</span>&lt;(<span class="hljs-type">const</span> String &amp;st, <span class="hljs-type">const</span> String &amp;st2);<br>    <span class="hljs-keyword">friend</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&gt;(<span class="hljs-type">const</span> String &amp;st1, <span class="hljs-type">const</span> String &amp;st2);<br>    <span class="hljs-keyword">friend</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> String &amp;st, <span class="hljs-type">const</span> String &amp;st2);<br>    <span class="hljs-keyword">friend</span> ostream &amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp; os, <span class="hljs-type">const</span> String &amp; st);<br>    <span class="hljs-keyword">friend</span> istream &amp; <span class="hljs-keyword">operator</span>&gt;&gt;(istream &amp; is, String &amp; st);<br><span class="hljs-comment">// static function</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">HowMany</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// string1.cpp -- String class methods</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span>                 <span class="hljs-comment">// string.h for some</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;string1.h&quot;</span>               <span class="hljs-comment">// includes &lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> std::cin;<br><span class="hljs-keyword">using</span> std::cout;<br><br><span class="hljs-comment">// initializing static class member</span><br><br><span class="hljs-type">int</span> String::num_strings = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// static method</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">String::HowMany</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> num_strings;<br>&#125;<br><br><span class="hljs-comment">// class methods</span><br>String::<span class="hljs-built_in">String</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> * s)     <span class="hljs-comment">// construct String from C string</span><br>&#123;<br>    len = std::<span class="hljs-built_in">strlen</span>(s);          <span class="hljs-comment">// set size</span><br>    str = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[len + <span class="hljs-number">1</span>];       <span class="hljs-comment">// allot storage</span><br>    std::<span class="hljs-built_in">strcpy</span>(str, s);           <span class="hljs-comment">// initialize pointer</span><br>    num_strings++;                 <span class="hljs-comment">// set object count</span><br>&#125;<br><br>String::<span class="hljs-built_in">String</span>()                   <span class="hljs-comment">// default constructor</span><br>&#123;<br>    len = <span class="hljs-number">4</span>;<br>    str = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-number">1</span>];<br>    str[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;\0&#x27;</span>;                 <span class="hljs-comment">// default string</span><br>    num_strings++;<br>&#125;<br><br>String::<span class="hljs-built_in">String</span>(<span class="hljs-type">const</span> String &amp; st)<br>&#123;<br>    num_strings++;             <span class="hljs-comment">// handle static member update</span><br>    len = st.len;              <span class="hljs-comment">// same length</span><br>    str = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span> [len + <span class="hljs-number">1</span>];  <span class="hljs-comment">// allot space</span><br>    std::<span class="hljs-built_in">strcpy</span>(str, st.str);  <span class="hljs-comment">// copy string to new location</span><br>&#125;<br><br>String::~<span class="hljs-built_in">String</span>()                     <span class="hljs-comment">// necessary destructor</span><br>&#123;<br>    --num_strings;                    <span class="hljs-comment">// required</span><br>    <span class="hljs-keyword">delete</span> [] str;                    <span class="hljs-comment">// required</span><br>&#125;<br><br><span class="hljs-comment">// overloaded operator methods    </span><br><br>    <span class="hljs-comment">// assign a String to a String</span><br>String &amp; String::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> String &amp; st)<br>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;st)<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    <span class="hljs-keyword">delete</span> [] str;<br>    len = st.len;<br>    str = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[len + <span class="hljs-number">1</span>];<br>    std::<span class="hljs-built_in">strcpy</span>(str, st.str);<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><br>    <span class="hljs-comment">// assign a C string to a String</span><br>String &amp; String::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> <span class="hljs-type">char</span> * s)<br>&#123;<br>    <span class="hljs-keyword">delete</span> [] str;<br>    len = std::<span class="hljs-built_in">strlen</span>(s);<br>    str = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[len + <span class="hljs-number">1</span>];<br>    std::<span class="hljs-built_in">strcpy</span>(str, s);<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><br>    <span class="hljs-comment">// read-write char access for non-const String</span><br><span class="hljs-type">char</span> &amp; String::<span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> i)<br>&#123;<br>    <span class="hljs-keyword">return</span> str[i];<br>&#125;<br><br>    <span class="hljs-comment">// read-only char access for const String</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> &amp; String::<span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> i) <span class="hljs-type">const</span><br>&#123;<br>    <span class="hljs-keyword">return</span> str[i];<br>&#125;<br><br><span class="hljs-comment">// overloaded operator friends</span><br><br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> String &amp;st1, <span class="hljs-type">const</span> String &amp;st2)<br>&#123;<br>    <span class="hljs-keyword">return</span> (std::<span class="hljs-built_in">strcmp</span>(st<span class="hljs-number">1.</span>str, st<span class="hljs-number">2.</span>str) &lt; <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&gt;(<span class="hljs-type">const</span> String &amp;st1, <span class="hljs-type">const</span> String &amp;st2)<br>&#123;<br>    <span class="hljs-keyword">return</span> st2 &lt; st1;<br>&#125;<br><br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> String &amp;st1, <span class="hljs-type">const</span> String &amp;st2)<br>&#123;<br>    <span class="hljs-built_in">return</span> (std::<span class="hljs-built_in">strcmp</span>(st<span class="hljs-number">1.</span>str, st<span class="hljs-number">2.</span>str) == <span class="hljs-number">0</span>);<br>&#125;<br><br>    <span class="hljs-comment">// simple String output</span><br>ostream &amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp; os, <span class="hljs-type">const</span> String &amp; st)<br>&#123;<br>    os &lt;&lt; st.str;<br>    <span class="hljs-keyword">return</span> os; <br>&#125;<br><br>    <span class="hljs-comment">// quick and dirty String input</span><br>istream &amp; <span class="hljs-keyword">operator</span>&gt;&gt;(istream &amp; is, String &amp; st)<br>&#123;<br>    <span class="hljs-type">char</span> temp[String::CINLIM];<br>    is.<span class="hljs-built_in">get</span>(temp, String::CINLIM);<br>    <span class="hljs-keyword">if</span> (is)<br>        st = temp;<br>    <span class="hljs-keyword">while</span> (is &amp;&amp; is.<span class="hljs-built_in">get</span>() != <span class="hljs-string">&#x27;\n&#x27;</span>)<br>        <span class="hljs-keyword">continue</span>;<br>    <span class="hljs-keyword">return</span> is; <br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// sayings1.cpp -- using expanded String class</span><br><span class="hljs-comment">// compile with string1.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;string1.h&quot;</span> </span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> ArSize = <span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MaxLen =<span class="hljs-number">81</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">using</span> std::cout;<br>    <span class="hljs-keyword">using</span> std::cin;<br>    <span class="hljs-keyword">using</span> std::endl;<br>    String name;<br>    cout &lt;&lt;<span class="hljs-string">&quot;Hi, what&#x27;s your name?\n&gt;&gt; &quot;</span>;<br>    cin &gt;&gt; name;<br><br>    cout &lt;&lt; name &lt;&lt; <span class="hljs-string">&quot;, please enter up to &quot;</span> &lt;&lt; ArSize<br>        &lt;&lt; <span class="hljs-string">&quot; short sayings &lt;empty line to quit&gt;:\n&quot;</span>;<br>    String sayings[ArSize];     <span class="hljs-comment">// array of objects</span><br>    <span class="hljs-type">char</span> temp[MaxLen];          <span class="hljs-comment">// temporary string storage</span><br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; ArSize; i++)<br>    &#123;<br>        cout &lt;&lt; i<span class="hljs-number">+1</span> &lt;&lt; <span class="hljs-string">&quot;: &quot;</span>;<br>        cin.<span class="hljs-built_in">get</span>(temp, MaxLen);<br>        <span class="hljs-keyword">while</span> (cin &amp;&amp; cin.<span class="hljs-built_in">get</span>() != <span class="hljs-string">&#x27;\n&#x27;</span>)<br>            <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span> (!cin || temp[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;\0&#x27;</span>)    <span class="hljs-comment">// empty line?</span><br>            <span class="hljs-keyword">break</span>;              <span class="hljs-comment">// i not incremented</span><br>        <span class="hljs-keyword">else</span><br>            sayings[i] = temp;  <span class="hljs-comment">// overloaded assignment</span><br>    &#125;<br>    <span class="hljs-type">int</span> total = i;              <span class="hljs-comment">// total # of lines read</span><br><br>    <span class="hljs-keyword">if</span> ( total &gt; <span class="hljs-number">0</span>)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Here are your sayings:\n&quot;</span>;<br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; total; i++)<br>            cout &lt;&lt; sayings[i][<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-string">&quot;: &quot;</span> &lt;&lt; sayings[i] &lt;&lt; endl;<br><br>        <span class="hljs-type">int</span> shortest = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> first = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; total; i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (sayings[i].<span class="hljs-built_in">length</span>() &lt; sayings[shortest].<span class="hljs-built_in">length</span>())<br>                shortest = i;<br>            <span class="hljs-keyword">if</span> (sayings[i] &lt; sayings[first])<br>                first = i;<br>        &#125;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Shortest saying:\n&quot;</span> &lt;&lt; sayings[shortest] &lt;&lt; endl;;<br>        cout &lt;&lt; <span class="hljs-string">&quot;First alphabetically:\n&quot;</span> &lt;&lt; sayings[first] &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">&quot;This program used &quot;</span>&lt;&lt; String::<span class="hljs-built_in">HowMany</span>() <br>             &lt;&lt; <span class="hljs-string">&quot; String objects. Bye.\n&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;No input! Bye.\n&quot;</span>;<br><span class="hljs-comment">// keep window open </span><br><span class="hljs-comment">/*    if (!cin)</span><br><span class="hljs-comment">        cin.clear();</span><br><span class="hljs-comment">    while (cin.get() != &#x27;\n&#x27;)</span><br><span class="hljs-comment">        continue; */</span> <br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="类中动态内存的使用"><a href="#类中动态内存的使用" class="headerlink" title="类中动态内存的使用"></a>类中动态内存的使用</h2><p>通过string类的实现，我们不难发现<strong>动态内存</strong>在类中的使用既便捷，又危险。</p><blockquote><p>更新日期 2024&#x2F;12&#x2F;5</p><p>希望不要烂尾。。。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Code</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tutorial</tag>
      
      <tag>C/C++</tag>
      
      <tag>OOP</tag>
      
      <tag>C++ Primer Plus</tag>
      
      <tag>Dynamic Memory</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AI-indepth-reading-AlexNet</title>
    <link href="/posts/AI-indepth-reading-AlexNet/"/>
    <url>/posts/AI-indepth-reading-AlexNet/</url>
    
    <content type="html"><![CDATA[<h1 id="ImageNet-Classification-with-Deep-Convolutional-Neural-Networks"><a href="#ImageNet-Classification-with-Deep-Convolutional-Neural-Networks" class="headerlink" title="ImageNet Classification with Deep Convolutional Neural Networks"></a>ImageNet Classification with Deep Convolutional Neural Networks</h1><p>【写在前面的话】</p><p>本文是AI论文精读计划的第一篇！在本频道中我将采用<strong>双语</strong>模式力求用准确且逻辑清晰的语言复述表达论文作者的核心观点和细节实现，同时配上一些配图。希望大家喜欢</p><p>今天分享的文章是 <a href="https://dl.acm.org/doi/10.1145/3065386">ImageNet Classification with Deep Convolutional Neural Networks</a>，作者是 <a href="https://dl.acm.org/doi/10.1145/3065386#">Alex Krizhevsky</a> ， <a href="https://dl.acm.org/doi/10.1145/3065386#">Ilya Sutskever</a> 和 <a href="https://dl.acm.org/doi/10.1145/3065386#">Geoffrey E. Hinton</a> （今年诺奖得主）。<strong>这篇文章创新性地将卷积神经网络高效地应用到图像识别领域，在当年的ILSVRC比赛中以极大的优势斩获头名，同时也掀起了神经网络复兴和深度学习的浪潮。</strong></p><blockquote><p>This is the first article in our <strong>In-Depth Reading of AI Papers</strong> series! In this channel, I will use a <strong>bilingual</strong> approach to restate and explain the core ideas and implementation details of the paper’s authors with accuracy and clear logic, accompanied by some illustrations. I hope you enjoy it.</p><p>Today’s paper is “<a href="https://dl.acm.org/doi/10.1145/3065386">ImageNet Classification with Deep Convolutional Neural Networks</a>“, authored by <a href="https://dl.acm.org/doi/10.1145/3065386#">Alex Krizhevsky</a>, <a href="https://dl.acm.org/doi/10.1145/3065386#">Ilya Sutskever</a>, and <a href="https://dl.acm.org/doi/10.1145/3065386#">Geoffrey E. Hinton</a> (this year’s Nobel Prize winner). <strong>This article innovatively and efficiently applied convolutional neural networks to the field of image recognition, winning first place in the ILSVRC competition that year by a significant margin, and sparked the resurgence of neural networks and the wave of deep learning.</strong></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Frontier and Classic Papers in AI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Convolutional Neural Networks</tag>
      
      <tag>Artificial Intelligence</tag>
      
      <tag>AlexNet</tag>
      
      <tag>Image Clssification</tag>
      
      <tag>Deep Learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Above-All</title>
    <link href="/posts/Above-All/"/>
    <url>/posts/Above-All/</url>
    
    <content type="html"><![CDATA[<h1 id="Welcome-To-My-Blog"><a href="#Welcome-To-My-Blog" class="headerlink" title="Welcome To My Blog !"></a>Welcome To My Blog !</h1><h2 id="写在前面的话"><a href="#写在前面的话" class="headerlink" title="写在前面的话"></a>写在前面的话</h2><p>这部分的内容和 <a href="https://xiyuanyang-code.github.io/above/">Intro</a> 的部分相同，主要是对本人博客的更新动机，更新目标和更新内容做一个总体性的概览~可自行跳转观看。</p><h2 id="Before-The-Blog"><a href="#Before-The-Blog" class="headerlink" title="Before The Blog"></a>Before The Blog</h2><p>三个月前，我通过偶然的机会了解到前 OpenAI 研究副总裁，主管GPT模型安全的杰出华人女性，<strong>翁荔(Lilian Weng)<strong>。她提出了著名的</strong>Agent 配方：Agent&#x3D;LLM+Memory+planning skills+tool use</strong>。在当今的GPT时代，她可谓是功不可没。</p><p>在OpenAI对她的独家专访<a href="https://openai.com/index/the-power-of-continuous-learning/">The power of continuous learning</a>中，她提到：</p><blockquote><p>I believe in the power of learning and it is never too late to learn. Maintaining my personal blog is a good way to keep this curiosity going and learn about new progress in the deep learning community regularly. I also encourage my team to keep on learning, whether related or unrelated to their current projects. Ideas in different topics or fields can often inspire new ideas and broaden the potential solution space.</p><p>I’m also a strong believer in teamwork. If everyone shines in their best strength, we will get 1+1 &gt; 2. Meanwhile, we might often run into “dirty” work and personally I’m very willing to take on those tasks, because as long as that’s the biggest blocker or that task can add the biggest value into the project, nothing should be considered “dirty” or “trivial.” I encourage people around me to do the same, being a team player and working together to expedite the team productivity.</p><p>我相信学习的力量，学习永远不会太迟。维护个人博客是一个保持好奇心，定期了解深度学习社区新进展的好方法。我也鼓励我的团队不断学习，无论是否与他们当前的项目相关。不同主题或领域的想法常常能激发新的灵感，并拓宽潜在的解决方案空间。</p><p>我也是团队合作的坚定信徒。如果每个人都能在自己最擅长的领域发光，我们就能实现1+1大于2。同时，我们可能会碰到一些“脏活”，而我个人非常愿意承担这些任务，因为只要那是最大的障碍，或者那项任务能为项目带来最大的价值，就没有什么是“脏活”或“琐事”。我鼓励周围的人也这样做，成为团队的一员，共同努力提高团队的生产力。</p></blockquote><p><img src="https://images.ctfassets.net/kftzwdyauwt9/e3357d5a-b177-4b3a-1edf79a7f2dc/ca1f3418cd72b4eb84c9d1a09dfffc7f/stangel-2022-0421.jpg?w=3840&q=90&fm=webp" alt="Lilian Weng&#39;s interview"></p><p>图源：<a href="https://openai.com/index/the-power-of-continuous-learning/">The power of continuous learning | OpenAI</a>   Photo: Jake Stangel</p><blockquote><p>PS：这个姐姐好漂亮~</p></blockquote><p>这与<strong>费曼学习法（Feynman Technique）</strong>可谓是不谋而合：</p><blockquote><p>1.Identify the subject. Write down everything you know about the topic.</p><p>2.Teach it to a child. If you can teach a concept to a child, you’re way ahead of the game.</p><p>3.Identify your knowledge gaps. This is the point where the real learning happens.</p><p>4.Organize + simplify + Tell a story. Start to tell your story.</p></blockquote><p>此时，刚刚步入大学校园3个月的笔者，由于深受高中优绩主义和应试思想的遗风荼毒，对大学生活和计算机学科的学习颇具不适应的疲态。学习的知识如此海量，却无法依靠应试和做题进行巩固，该如何是好？</p><p>或许<strong>上文已经给出了答案。</strong></p><center><p><font size=6><b><p style="color:red;">我要创建自己的博客!</p></b></font></p></center><p>无论是传统的做题刷卷，还是博客，亦或是“费曼学习法”，本质上都是<strong>强化训练人脑在吸收新知识后的有效输出过程</strong>：当你能很流畅地给出一道数学题的若干种证明方法时，能逻辑清晰地将所学的知识穿成逻辑链条或思维导图，呈现在博客中为他人所吸收时，你便通过<strong>有效的对外做功输出</strong>很好地巩固了所学的知识。同时，知识的不断沉淀也带来了莫大的成就感。</p><p>但是，写一篇博客，可不仅仅是打打字那么简单。</p><p>不知各位在高中写议论文的时候有没有一种“咬牙切齿”的感觉，就是<strong>我想到的≠我实际构思好的≠我输出的≠我希望所表达的</strong>，甚至于，很多时候我们心中所谓的灵感只是<strong>乍现的只言片语的碎片</strong>，距离成为一篇逻辑清晰，内容详实且有创新性的博客文章还有很长的路要走。这便是博客写作的难点，也是<strong>我希望通过个人博客来训练的最重要的内容：将心里的灵感进行有效的输出，力求逻辑性和学术的专业性。</strong></p><h2 id="About-the-Blog"><a href="#About-the-Blog" class="headerlink" title="About the Blog"></a>About the Blog</h2><p><strong>Xiyuan Yang’s Blog</strong>，创建于<strong>2024年11月19日</strong>。</p><p>以下是自我简介（摘自<a href="https://xiyuanyang-code.github.io/about/">About - Xiyuan Yang’s Blog</a>）：</p><blockquote><p>Greetings! I am <strong>Xiyuan Yang (杨希渊)</strong>, currently pursuing an undergraduate degree in Artificial Intelligence at Shanghai Jiao Tong University. With a longstanding aspiration to become a programmer, I am passionate about leveraging technology to make a meaningful impact on the world. Through my personal website, I aim to share a collection of my blogs and learning notes with you. Some of these entries will be presented as a series, updated at irregular intervals. Additionally, I will offer insights into my personal observations and reflections on life. I hope your visit here is both enjoyable and enriching!</p></blockquote><blockquote><p><strong>My email:</strong></p><ul><li><p><a href="mailto:xiyuan__yang@outlook.com">xiyuan__yang@outlook.com</a></p></li><li><p><a href="mailto:yangxiyuan@sjtu.edu.cn">yangxiyuan@sjtu.edu.cn</a></p><p>Feel free to contact me!</p></li></ul></blockquote><blockquote><p>VENI VIDI VICI</p></blockquote><p>这个博客的更新内容将随着笔者后续的专业课程的学习同步进行，<strong>旨在分享笔者在学习过程中学到的有意思的专业知识，力求在博客输出的过程中培养自己的逻辑思维和表达能力</strong>，不过更新时间，更新内容，更新篇幅<strong>将会完全随机</strong>。</p><p>本博客部署在github的静态网站上，轮子使用<code>Hexo</code>的<code>Fluid</code>的模版，配置环境还是比较简单的，下面贴出一些相关的网址，有相同爱好的童鞋可以参考借鉴一下：</p><ul><li><a href="https://github.com/xiyuanyang-code">xiyuanyang-code (Xiyuan Yang)我的Github主页</a></li><li><a href="https://github.com/xiyuanyang-code/xiyuanyang-code.github.io">xiyuanyang-code&#x2F;xiyuanyang-code.github.io我的博客Github仓库</a></li><li><a href="https://github.com/fluid-dev/hexo-theme-fluid">fluid-dev&#x2F;hexo-theme-fluid-Design theme for Hexo Fluid的Github官方仓库</a></li><li><a href="https://fluid-dev.github.io/hexo-fluid-docs/guide/">配置指南 | Hexo Fluid 用户手册</a></li><li><a href="https://fluid-dev.github.io/hexo-fluid-docs/start/">开始使用 | Hexo Fluid 用户手册</a></li></ul><p>有关博客的具体更新内容，请详见<code>Goals and Plans of Updates</code>部分~</p><h2 id="Goals-and-Plans-of-Updates"><a href="#Goals-and-Plans-of-Updates" class="headerlink" title="Goals and Plans of Updates"></a>Goals and Plans of Updates</h2><h3 id="更新的主要内容"><a href="#更新的主要内容" class="headerlink" title="更新的主要内容"></a>更新的主要内容</h3><p>笔者更新的主要内容包括：（<strong>草拟</strong>）</p><ul><li>编程语言的语法学习<ul><li>C&#x2F;C++</li><li>Python<ul><li>语法</li><li>Anaconda</li><li>一些常见的库</li></ul></li><li>HTML&#x2F;Javascript</li><li>Bash&#x2F;Shell</li></ul></li><li>一些常用的工具教程<ul><li>LaTeX</li><li>命令行</li><li>Git</li><li>Vim编辑器</li><li>Linux和服务器（主要和深度学习相关）<ul><li>Linux常见命令</li><li>Tmux</li><li>SSH远程连接</li></ul></li></ul></li><li>[CS]算法<ul><li>数据结构</li><li>算法</li><li>计算机四大件</li></ul></li><li>AI专业课<ul><li>机器学习</li><li>强化学习</li><li>深度学习<ul><li>Pytorch</li></ul></li></ul></li><li>AI前沿&amp;经典论文精读</li><li><del>一些晦涩难懂的</del>数学课</li><li>发发牢骚</li></ul><h3 id="具体的分类（实时更新）"><a href="#具体的分类（实时更新）" class="headerlink" title="具体的分类（实时更新）"></a>具体的分类（实时更新）</h3><ul><li><strong>Code</strong></li><li><strong>Math</strong></li><li><strong>Efficient Tools</strong></li><li><strong>Algorithm</strong></li><li><strong>Frontier and Classic Papers in AI</strong></li><li><strong>AI Core Courses</strong></li></ul><h3 id="具体的标签（实时更新）"><a href="#具体的标签（实时更新）" class="headerlink" title="具体的标签（实时更新）"></a>具体的标签（实时更新）</h3><p>见 <a href="https://xiyuanyang-code.github.io/tags/">Tags</a> 页。</p><h2 id="Several-Pages"><a href="#Several-Pages" class="headerlink" title="Several Pages"></a>Several Pages</h2><p>以下是对本博客若干基本页面的介绍：</p><ul><li><h4 id="Home"><a href="#Home" class="headerlink" title="Home"></a>Home</h4></li><li><h4 id="Intro（你现在在的地方）"><a href="#Intro（你现在在的地方）" class="headerlink" title="Intro（你现在在的地方）"></a><strong>Intro</strong>（你现在在的地方）</h4></li><li><h4 id="Archives（文章）"><a href="#Archives（文章）" class="headerlink" title="Archives（文章）"></a>Archives（文章）</h4></li><li><h4 id="Categories（分类页）"><a href="#Categories（分类页）" class="headerlink" title="Categories（分类页）"></a>Categories（分类页）</h4></li><li><h4 id="Tags（标签页）"><a href="#Tags（标签页）" class="headerlink" title="Tags（标签页）"></a>Tags（标签页）</h4></li><li><h4 id="About（关于作者）"><a href="#About（关于作者）" class="headerlink" title="About（关于作者）"></a>About（关于作者）</h4></li><li><h4 id="Resume（Academic-CV-of-the-Author）"><a href="#Resume（Academic-CV-of-the-Author）" class="headerlink" title="Resume（Academic CV of the Author）"></a>Resume（<strong>Academic CV of the Author</strong>）</h4></li></ul><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p><a href="https://github.com/lilianweng">lilianweng (Lilian)的github主页</a></p><p> <a href="https://lilianweng.github.io/">Lil’Log（翁荔的博客）</a></p><p><a href="https://openai.com/index/the-power-of-continuous-learning/">The power of continuous learning | OpenAI</a></p><p><a href="https://github.com/xiyuanyang-code">https://github.com/xiyuanyang-code</a></p><p><a href="https://github.com/xiyuanyang-code/xiyuanyang-code.github.io">https://github.com/xiyuanyang-code/xiyuanyang-code.github.io</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Announcement</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Algorithm_tutorial_section1</title>
    <link href="/posts/Algorithm-tutorial-section1/"/>
    <url>/posts/Algorithm-tutorial-section1/</url>
    
    <content type="html"><![CDATA[<h1 id="Algorithm-tutorial-section1"><a href="#Algorithm-tutorial-section1" class="headerlink" title="Algorithm_tutorial_section1"></a>Algorithm_tutorial_section1</h1><p>【写在前面的话】</p><p>​本文是笔者自己算法课程的学习笔记，目前的学习内容主要是算法和数据结构基础（提前自学，笔者会在大一下学期系统学习），学习途径和资源主要是 <a href="https://www.hello-algo.com/">Hello 算法</a>（一本非常易入门的算法书！非常推荐！）。因此，<strong>此文章是Algorithm_tutorial的第一篇博客~，且大部分内容来自Hello算法原书，原创部分属于少数，笔者在此处只是按照自己的知识体系进行归纳总结并且尝试记录下来。</strong>希望大家都能愉快地开启自己的算法学习之旅~</p><h1 id="Algorithm-Section1-Introduction"><a href="#Algorithm-Section1-Introduction" class="headerlink" title="Algorithm.Section1 Introduction"></a>Algorithm.Section1 Introduction</h1><p>Introduction：</p><ul><li>迭代与递归</li><li>时间复杂度</li><li>空间复杂度</li><li>数据结构的物理结构</li></ul><h2 id="一、算法-复杂度分析"><a href="#一、算法-复杂度分析" class="headerlink" title="一、算法 复杂度分析"></a>一、算法 复杂度分析</h2><p>​由于实际测试具有较大的局限性，因此我们可以考虑仅通过一些计算来评估算法的效率。这种估算方法被称为渐近复杂度分析（asymptotic complexity analysis），简称复杂度分析。</p><p>​复杂度分析能够体现算法运行所需的时间和空间资源与输入数据大小之间的关系。<strong>它描述了随着输入数据大小的增加，算法执行所需时间和空间的增长趋势</strong>。这个定义有些拗口，我们可以将其分为三个重点来理解。</p><ul><li>“<strong>时间和空间资源</strong>”分别对应时间复杂度（time complexity）和空间复杂度（space complexity）。</li><li>“随着输入数据大小的增加”意味着复杂度反映了算法运行效率与输入数据体量之间的关系。</li><li>“<strong>时间和空间的增长趋势</strong>”表示复杂度分析关注的不是运行时间或占用空间的具体值，而是时间或空间增长的“快慢”。（<strong>一种趋势！</strong>）</li></ul><h3 id="迭代与递归"><a href="#迭代与递归" class="headerlink" title="@迭代与递归"></a>@迭代与递归</h3><p><strong>迭代：自下而上，小问题积累成大问题</strong></p><p><strong>递归：自上而下，大问题拆解成小问题</strong></p><p>程序实现重复代码块执行的两种方式：</p><ul><li><p>迭代（for循环，while循环）</p></li><li><p>递归</p></li></ul><p>​递归（recursion）是一种算法策略，通过函数调用自身来解决问题。它主要包含两个阶段。</p><ol><li><strong>递</strong>：程序不断深入地调用自身，通常传入更小或更简化的参数，直到达到“终止条件”。</li><li><strong>归</strong>：触发“终止条件”后，程序从最深层的递归函数开始逐层返回，汇聚每一层的结果。</li></ol><p>​而从实现的角度看，递归代码主要包含三个要素。</p><ol><li><strong>终止条件</strong>：用于决定什么时候由“递”转“归”。</li><li><strong>递归调用</strong>：对应“递”，函数调用自身，通常输入更小或更简化的参数。</li><li><strong>返回结果</strong>：对应“归”，将当前递归层级的结果返回至上一层。</li></ol><p><strong>有关递归的时间问题和空间问题</strong></p><p>​递归函数每次调用自身时，系统都会为新开启的函数分配内存，以存储局部变量、调用地址和其他信息等。这将导致两方面的结果。</p><ul><li><p>函数的上下文数据都存储在称为“<strong>栈帧空间</strong>”的内存区域中，直至函数返回后才会被释放。因此，<strong>递归通常比迭代更加耗费内存空间</strong>。（需要控制递归深度，否则过深的递归会导致栈的溢出错误）</p></li><li><p><strong>有关栈帧空间</strong>：</p></li><li><p>栈帧空间是指在程序执行过程中，为每个函数调用分配的一块内存区域，用于存储该函数的局部变量、参数、返回地址以及其他控制信息。每次函数被调用时，都会在调用栈上创建一个新的栈帧，这个栈帧的生命周期与函数的执行周期相同。</p><ol><li><strong>返回地址</strong>：当函数调用完成后，程序需要知道从哪里继续执行，因此返回地址会被压入栈帧中。</li><li><strong>参数</strong>：函数调用时传递给被调用函数的参数也会存储在栈帧中。</li><li><strong>局部变量</strong>：函数内部定义的局部变量会占用栈帧空间。</li><li><strong>控制信息</strong>：包括指向上一个栈帧的指针（帧指针），用于维护调用链。</li></ol><p><strong>栈帧的工作机制</strong></p><ul><li><strong>入栈</strong>：当一个函数被调用时，首先将参数和返回地址压入栈中，然后分配空间给局部变量，形成新的栈帧。</li><li><strong>出栈</strong>：当函数执行完毕时，局部变量和参数的空间被释放，返回地址被弹出，程序控制流转回调用该函数的位置。</li></ul><p><strong>栈帧的优点</strong></p><ul><li><strong>自动管理</strong>：栈帧由系统自动管理，无需手动分配和释放内存。</li><li><strong>高效性</strong>：由于栈的后进先出特性，内存分配和释放速度非常快。</li></ul></li><li><p>递归调用函数会产生额外的开销。<strong>因此递归通常比循环的时间效率更低</strong>。</p></li><li><p><strong>使用尾递归</strong>可以优化递归的效率（系统无需保存函数上一级的上下文）</p></li></ul><p><strong>有关递归树</strong></p><p>我们在函数内递归调用了两个函数，<strong>这意味着从一个调用产生了两个调用分支</strong>。如图 2-6 所示，这样不断递归调用下去，最终将产生一棵层数为 n 的递归树（recursion tree）。</p><p><img src="https://www.hello-algo.com/chapter_computational_complexity/iteration_and_recursion.assets/recursion_tree.png" alt="斐波那契数列的递归树"></p><blockquote><p>这种递归树可以达到指数阶的时间复杂度。</p></blockquote><p><strong>一定要理解递归的核心思想：分治！</strong></p><p>从本质上看，递归体现了“将问题分解为更小子问题”的思维范式，这种分治策略至关重要。</p><ul><li>从算法角度看，<strong>搜索、排序、回溯、分治、动态规划</strong>等许多重要算法策略直接或间接地应用了这种思维方式。</li><li>从数据结构角度看，<strong>递归天然适合处理链表、树和图的相关问题</strong>，因为它们非常适合用分治思想进行分析。</li></ul><p><strong>迭代和递归的本质与内在联系</strong></p><p>以上述递归函数为例，求和操作在递归的“归”阶段进行。这意味着<strong>最初被调用的函数实际上是最后完成其求和操作</strong>的，<strong>这种工作机制与栈的“先入后出”原则异曲同工</strong>。</p><p>事实上，“<strong>调用栈</strong>”和“<strong>栈帧空间</strong>”这类递归术语已经暗示了递归与栈之间的密切关系。</p><ol><li><strong>递</strong>：当函数被调用时，系统会在“调用栈”上为该函数分配新的栈帧，用于<strong>存储函数的局部变量、参数、返回地址</strong>等数据。</li><li><strong>归</strong>：当函数完成执行并返回时，对应的栈帧会被从“调用栈”上移除，恢复之前函数的执行环境。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">for_loop_recur</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;使用迭代模拟递归&quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 使用一个显式的栈来模拟系统调用栈</span><br>    stack = []<br>    res = <span class="hljs-number">0</span><br>    <span class="hljs-comment"># 递：递归调用</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>):<br>        <span class="hljs-comment"># 通过“入栈操作”模拟“递”</span><br>        stack.append(i)<br>    <span class="hljs-comment"># 归：返回结果</span><br>    <span class="hljs-keyword">while</span> stack:<br>        <span class="hljs-comment"># 通过“出栈操作”模拟“归”</span><br>        res += stack.pop()<br>    <span class="hljs-comment"># res = 1+2+3+...+n</span><br>    <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="@时间复杂度"></a>@时间复杂度</h3><ul><li><strong>常数</strong>时间复杂度</li><li><strong>线性</strong>时间复杂度</li><li><strong>平方</strong>时间复杂度</li><li><strong>指数阶</strong>时间复杂度<ul><li>递归树的一分为二</li></ul></li><li><strong>对数阶</strong>时间复杂度<ul><li>每轮缩减到一半</li><li>也会出现在递归树中（经典例题：快速幂计算）</li></ul></li><li><strong>线性对数阶</strong>时间复杂度（<code>O(nlogn)</code>）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">linear_log_recur</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;线性对数阶&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">if</span> n &lt;= <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    <span class="hljs-comment"># 一分为二，子问题的规模减小一半</span><br>    count = linear_log_recur(n // <span class="hljs-number">2</span>) + linear_log_recur(n // <span class="hljs-number">2</span>)<br>    <span class="hljs-comment"># 与C++不同，//表示地板出发（整数截断）</span><br>    <span class="hljs-comment"># 当前子问题包含 n 个操作</span><br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>        count += <span class="hljs-number">1</span><br>    <span class="hljs-comment"># 代表当前需要执行的n次操作</span><br>    <span class="hljs-keyword">return</span> count<br></code></pre></td></tr></table></figure><p><img src="https://www.hello-algo.com/chapter_computational_complexity/time_complexity.assets/time_complexity_logarithmic_linear.png" alt="线性对数阶的时间复杂度"></p><ul><li><strong>阶乘阶</strong>时间复杂度</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">factorial_recur</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;阶乘阶（递归实现）&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    count = <span class="hljs-number">0</span><br>    <span class="hljs-comment"># 从 1 个分裂出 n 个</span><br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>        count += factorial_recur(n - <span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> count<br></code></pre></td></tr></table></figure><p><img src="https://www.hello-algo.com/chapter_computational_complexity/time_complexity.assets/time_complexity_factorial.png" alt="阶乘阶的时间复杂度"></p><p>时间复杂度的分类：</p><ul><li>最差时间复杂度</li><li>最佳时间复杂度</li></ul><blockquote><p>以上两个时间复杂度均与数据的分布存在联系，具有偶然性</p></blockquote><ul><li>平均时间复杂度</li></ul><p>符号表示：</p><p>时间复杂度的符号表示法主要有三种：<code>O</code>、<code>Ω</code> 和 <code>Θ</code>，它们分别表示算法在不同情况下的性能表现。</p><ol><li><p><strong>大 O 表示法 (O(f(n)))</strong>：</p><ul><li>描述：表示算法在<strong>最坏情况下的时间复杂度</strong>。</li><li>用途：用于描述算法的上界，即算法的执行时间不会超过某个函数的增长速度。</li><li>示例：如果一个算法的时间复杂度是 (O(n^2))，意味着在最坏情况下，算法的执行时间最多是输入规模的平方。</li></ul></li><li><p><strong>大 Ω 表示法 (Ω(f(n)))</strong>：</p><ul><li>描述：表示算法在<strong>最好情况下的时间复杂度</strong>。</li><li>用途：用于描述算法的下界，即算法的执行时间至少是某个函数的增长速度。</li><li>示例：如果一个算法的时间复杂度是 (Ω(n))，意味着在最好情况下，算法的执行时间至少是输入规模的线性增长。</li></ul></li><li><p><strong>大 Θ 表示法 (Θ(f(n)))</strong>：</p><ul><li>描述：表示算法在<strong>平均情况下的时间复杂度</strong>。</li><li>用途：用于描述算法的确界，即算法的执行时间既不会超过某个函数的上界，也不会低于某个函数的下界。</li><li>示例：如果一个算法的时间复杂度是 (Θ(n \log n))，意味着在所有情况下，算法的执行时间大致是输入规模的 (n \log n) 级别。</li></ul></li></ol><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="@空间复杂度"></a>@空间复杂度</h3><p>算法在运行过程中使用的内存空间主要包括以下几种。</p><ul><li><strong>输入空间</strong>：用于存储算法的输入数据。</li><li><strong>暂存空间</strong>：用于存储算法在运行过程中的变量、对象、函数上下文等数据。</li><li><strong>输出空间</strong>：用于存储算法的输出数据。</li></ul><p>一般情况下，空间复杂度的统计范围是“<strong>暂存空间”加上“输出空间”</strong>。</p><p>暂存空间可以进一步划分为三个部分。</p><ul><li><strong>暂存数据</strong>：用于保存算法运行过程中的各种常量、变量、对象等。</li><li><strong>栈帧空间</strong>：用于保存调用函数的上下文数据。系统在每次调用函数时都会在栈顶部创建一个栈帧，函数返回后，栈帧空间会被释放。</li><li><strong>指令空间</strong>：用于保存编译后的程序指令，在实际统计中通常忽略不计。</li></ul><p>在分析一段程序的空间复杂度时，<strong>我们通常统计暂存数据、栈帧空间和输出数据三部分</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;类&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, x: <span class="hljs-built_in">int</span></span>):<br>        <span class="hljs-variable language_">self</span>.val: <span class="hljs-built_in">int</span> = x              <span class="hljs-comment"># 节点值</span><br>        <span class="hljs-variable language_">self</span>.<span class="hljs-built_in">next</span>: Node | <span class="hljs-literal">None</span> = <span class="hljs-literal">None</span>  <span class="hljs-comment"># 指向下一节点的引用</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">function</span>() -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;函数&quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 执行某些操作...</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">algorithm</span>(<span class="hljs-params">n</span>) -&gt; <span class="hljs-built_in">int</span>:  <span class="hljs-comment"># 输入数据</span><br>    A = <span class="hljs-number">0</span>                 <span class="hljs-comment"># 暂存数据（常量，一般用大写字母表示）</span><br>    b = <span class="hljs-number">0</span>                 <span class="hljs-comment"># 暂存数据（变量）</span><br>    node = Node(<span class="hljs-number">0</span>)        <span class="hljs-comment"># 暂存数据（对象）</span><br>    c = function()        <span class="hljs-comment"># 栈帧空间（调用函数）</span><br>    <span class="hljs-keyword">return</span> A + b + c      <span class="hljs-comment"># 输出数据</span><br></code></pre></td></tr></table></figure><p>​而与时间复杂度不同的是，<strong>我们通常只关注最差空间复杂度</strong>。这是因为内存空间是一项硬性要求，我们必须确保在所有输入数据下都有足够的内存空间预留。</p><ul><li>以最差输入数据为准</li><li>以算法运行的<strong>峰值内存</strong>（注意不是累积量）为准</li></ul><p>一些常见的空间复杂度：</p><ul><li><p>常数阶空间复杂度</p><ul><li>在循环中初始化变量或调用函数而占用的内存，在进入下一循环后就会被释放，因此不会累积占用空间，空间复杂度还是<code>O(1)</code>。</li></ul></li><li><p>线性阶空间复杂度</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">linear</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span></span>):<br>    <span class="hljs-string">&quot;&quot;&quot;线性阶&quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 长度为 n 的列表占用 O(n) 空间</span><br>    nums = [<span class="hljs-number">0</span>] * n<br>    <span class="hljs-comment"># 长度为 n 的哈希表占用 O(n) 空间</span><br>    hmap = <span class="hljs-built_in">dict</span>[<span class="hljs-built_in">int</span>, <span class="hljs-built_in">str</span>]()<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>        hmap[i] = <span class="hljs-built_in">str</span>(i)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">linear_recur</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span></span>):<br>    <span class="hljs-string">&quot;&quot;&quot;线性阶（递归实现）&quot;&quot;&quot;</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;递归 n =&quot;</span>, n)<br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span><br>    linear_recur(n - <span class="hljs-number">1</span>)<br>    <span class="hljs-comment"># 在达到最深的递归深度的时候，会有n个变量n（涉及到局部变量）</span><br></code></pre></td></tr></table></figure></li><li><p>平方阶空间复杂度</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">quadratic</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span></span>):<br>    <span class="hljs-string">&quot;&quot;&quot;平方阶&quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 二维列表占用 O(n^2) 空间</span><br>    num_matrix = [[<span class="hljs-number">0</span>] * n <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br></code></pre></td></tr></table></figure><ul><li><p><code>num_matrix</code>：这是一个变量名，用于存储生成的二维矩阵。</p><p><code>[[0] * n for _ in range(n)]</code>：这是一个列表生成式，用于创建一个包含 <code>n</code> 个子列表的列表，每个子列表包含 <code>n</code> 个元素。</p><ul><li><code>[0] * n</code>：这一部分创建一个包含 <code>n</code> 个 <code>0</code> 的列表。例如，如果 <code>n</code> 是 <code>3</code>，则生成 <code>[0, 0, 0]</code>。</li><li><code>for _ in range(n)</code>：这一部分用于重复创建上述的子列表 <code>n</code> 次。<code>_</code> 是一个惯用的变量名，表示循环变量在循环体内未被使用。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">quadratic_recur</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;平方阶（递归实现）&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">if</span> n &lt;= <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    <span class="hljs-comment"># 数组 nums 长度为 n, n-1, ..., 2, 1</span><br>    nums = [<span class="hljs-number">0</span>] * n<br>    <span class="hljs-keyword">return</span> quadratic_recur(n - <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure></li></ul></li><li><p>指数阶空间复杂度（二叉树）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">build_tree</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span></span>) -&gt; TreeNode | <span class="hljs-literal">None</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;指数阶（建立满二叉树）&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>    root = TreeNode(<span class="hljs-number">0</span>)<br>    root.left = build_tree(n - <span class="hljs-number">1</span>)<br>    root.right = build_tree(n - <span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> root<br></code></pre></td></tr></table></figure><p><img src="https://www.hello-algo.com/chapter_computational_complexity/space_complexity.assets/space_complexity_exponential.png" alt="满二叉树产生的指数阶空间复杂度"></p></li><li><p>对数阶空间复杂度</p></li></ul><p>对数阶空间复杂度（(O(\log n))）在算法中并不如其他复杂度（如常数、线性、平方等）常见，因为对数阶通常与递归深度相关联。以下是一些可能具有对数阶空间复杂度的常见算法和场景：</p><ol><li><p><strong>递归算法</strong>：</p><ul><li><strong>二分查找</strong>：在递归实现中，二分查找的空间复杂度是 (O(\log n))，因为递归调用栈的深度是对数级别的。</li><li><strong>快速排序</strong>：在最优情况下（即每次分区都能将数组均匀分割），快速排序的递归深度是 (O(\log n))，因此空间复杂度也是 (O(\log n))。</li><li><strong>归并排序</strong>：尽管归并排序的时间复杂度是 (O(n \log n))，其递归实现的空间复杂度可以是 (O(\log n))（不包括用于存储结果的额外数组）。</li></ul><h3 id="快速排序（Quick-Sort）"><a href="#快速排序（Quick-Sort）" class="headerlink" title="快速排序（Quick Sort）"></a>快速排序（Quick Sort）</h3><p>快速排序是一种分而治之的排序算法。它的基本思想是选择一个基准元素（pivot），然后将数组分成两个子数组，一个包含所有小于基准元素的元素，另一个包含所有大于基准元素的元素，然后递归地对这两个子数组进行排序。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">quick_sort</span>(<span class="hljs-params">arr</span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(arr) &lt;= <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span> arr<br>    <span class="hljs-keyword">else</span>:<br>        pivot = arr[<span class="hljs-built_in">len</span>(arr) // <span class="hljs-number">2</span>]<br>        left = [x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> arr <span class="hljs-keyword">if</span> x &lt; pivot]<br>        middle = [x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> arr <span class="hljs-keyword">if</span> x == pivot]<br>        right = [x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> arr <span class="hljs-keyword">if</span> x &gt; pivot]<br>        <span class="hljs-keyword">return</span> quick_sort(left) + middle + quick_sort(right)<br><br><span class="hljs-comment"># 示例使用</span><br>arr = [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">10</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Original array:&quot;</span>, arr)<br>sorted_arr = quick_sort(arr)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Sorted array:&quot;</span>, sorted_arr)<br></code></pre></td></tr></table></figure><h3 id="归并排序（Merge-Sort）"><a href="#归并排序（Merge-Sort）" class="headerlink" title="归并排序（Merge Sort）"></a>归并排序（Merge Sort）</h3><p>归并排序也是一种分而治之的排序算法。它的基本思想是将数组分成两个子数组，对这两个子数组分别进行排序，然后将排序后的子数组合并成一个有序的数组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">merge_sort</span>(<span class="hljs-params">arr</span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(arr) &lt;= <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span> arr<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">merge</span>(<span class="hljs-params">left, right</span>):<br>        result = []<br>        i = j = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> i &lt; <span class="hljs-built_in">len</span>(left) <span class="hljs-keyword">and</span> j &lt; <span class="hljs-built_in">len</span>(right):<br>            <span class="hljs-keyword">if</span> left[i] &lt; right[j]:<br>                result.append(left[i])<br>                i += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                result.append(right[j])<br>                j += <span class="hljs-number">1</span><br>        result.extend(left[i:])<br>        result.extend(right[j:])<br>        <span class="hljs-keyword">return</span> result<br><br>    mid = <span class="hljs-built_in">len</span>(arr) // <span class="hljs-number">2</span><br>    left = merge_sort(arr[:mid])<br>    right = merge_sort(arr[mid:])<br>    <span class="hljs-keyword">return</span> merge(left, right)<br><br><span class="hljs-comment"># 示例使用</span><br>arr = [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">10</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Original array:&quot;</span>, arr)<br>sorted_arr = merge_sort(arr)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Sorted array:&quot;</span>, sorted_arr)<br></code></pre></td></tr></table></figure><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><ul><li><p><strong>快速排序</strong>：</p><ul><li>选择一个基准元素（pivot）。</li><li>将数组分成三个部分：小于基准的部分、等于基准的部分和大于基准的部分。</li><li>递归地对小于基准和大于基准的部分进行排序。</li><li>合并结果。</li></ul></li><li><p><strong>归并排序</strong>：</p><ul><li>将数组分成两半。</li><li>递归地对每一半进行排序。</li><li>合并两个排序后的子数组。</li></ul></li></ul><p>这两种排序算法都是经典的分而治之算法，具有较好的性能和广泛的应用。</p></li><li><p><strong>平衡树的数据结构</strong>：</p><ul><li><strong>平衡二叉搜索树（如 AVL 树、红黑树）</strong>：这些数据结构在执行插入、删除和查找操作时的递归深度通常是 (O(\log n))，因此在某些实现中，可能会有 (O(\log n)) 的空间复杂度，主要用于递归调用栈。</li></ul></li><li><p><strong>迭代算法</strong>：</p><ul><li>某些迭代算法在实现中可能会使用一个栈来模拟递归，从而使得其空间复杂度为 (O(\log n))。例如，某些树遍历算法在深度优先搜索时可能使用栈来存储路径信息。</li></ul></li></ol><p>需要注意的是，空间复杂度为 (O(\log n)) 的算法通常涉及递归调用或需要存储某些对数数量的信息。这种复杂度通常与算法的递归深度或树结构的高度相关。</p><p><strong>循环与递归在空间复杂度上的差异</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">function</span>() -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-comment"># 执行某些操作</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">loop</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span></span>):<br>    <span class="hljs-string">&quot;&quot;&quot;循环的空间复杂度为 O(1)&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>        function()<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">recur</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span></span>):<br>    <span class="hljs-string">&quot;&quot;&quot;递归的空间复杂度为 O(n)&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span><br>    <span class="hljs-keyword">return</span> recur(n - <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>函数 <code>loop()</code> 和 <code>recur()</code> 的时间复杂度都为 O(n) ，但空间复杂度不同。</p><ul><li>函数 <code>loop()</code> 在循环中调用了 n 次 <code>function()</code> ，每轮中的 <code>function()</code> 都返回并释放了栈帧空间，因此空间复杂度仍为 O(1) 。</li><li>递归函数 <code>recur()</code> 在运行过程中会同时存在 n 个未返回的 <code>recur()</code> ，从而占用 O(n) 的栈帧空间。</li></ul><h2 id="二、数据结构"><a href="#二、数据结构" class="headerlink" title="二、数据结构"></a>二、数据结构</h2><p>数组，链表，栈，队列，哈希表，树，堆，图</p><h3 id="数据结构的物理结构"><a href="#数据结构的物理结构" class="headerlink" title="@数据结构的物理结构"></a>@数据结构的物理结构</h3><p>如图 3-3 所示，<strong>物理结构反映了数据在计算机内存中的存储方式</strong>，可分为连续空间存储（数组）和分散空间存储（链表）。物理结构从底层决定了数据的访问、更新、增删等操作方法，两种物理结构在时间效率和空间效率方面呈现出互补的特点。</p><p><img src="https://www.hello-algo.com/chapter_data_structure/classification_of_data_structure.assets/classification_phisical_structure.png" alt="连续空间存储与分散空间存储"></p><p>连续空间存储（数组）</p><ul><li><strong>定义</strong>：连续空间存储是指数据元素在内存中连续排列，数组是这种存储方式的典型代表。</li><li><strong>优点</strong>：<ul><li><strong>快速访问</strong>：由于数组元素是连续存储的，可以通过索引直接访问任意元素，时间复杂度为 O(1)。</li><li><strong>空间局部性</strong>：连续存储有助于缓存命中率，因为访问一个元素后，后续访问相邻元素时，可能已经在缓存中。</li></ul></li><li><strong>缺点</strong>：<ul><li><strong>插入和删除操作效率低</strong>：在数组中插入或删除元素通常需要移动其他元素以保持数据的连续性，时间复杂度为 <em>O</em>(<em>n</em>)。</li><li><strong>固定大小</strong>：数组的大小在创建时确定，扩展数组的大小需要重新分配内存并复制数据。</li></ul></li></ul><p>分散空间存储（链表）</p><ul><li><strong>定义</strong>：分散空间存储是指数据元素在内存中不必连续排列，链表是这种存储方式的典型代表。</li><li><strong>优点</strong>：<ul><li><strong>动态大小</strong>：链表可以方便地进行动态内存分配，允许在运行时灵活地增加或减少元素。</li><li><strong>高效插入和删除</strong>：在链表中，插入和删除元素只需调整指针，而不需要移动其他元素，时间复杂度为 <em>O</em>(1)（在已知位置的情况下）。</li></ul></li><li><strong>缺点</strong>：<ul><li><strong>访问速度慢</strong>：由于链表元素存储在非连续的内存位置，访问某个特定元素需要从头遍历链表，时间复杂度为 <em>O</em>(<em>n</em>)。</li><li><strong>额外空间开销</strong>：链表需要额外的存储空间来存储指针（如前驱和后继指针），这增加了内存使用量。</li></ul></li></ul><p>互补特点</p><ul><li><strong>数组</strong>适合需要频繁随机访问的场景，如需要快速读取大量数据但不经常修改数据的情况。</li><li><strong>链表</strong>适合需要频繁插入和删除操作的场景，如实现动态数据结构（例如队列、栈）时。</li></ul><p>值得说明的是，<strong>所有数据结构都是基于数组、链表或二者的组合实现的</strong>。例如，栈和队列既可以使用数组实现，也可以使用链表实现；而哈希表的实现可能同时包含数组和链表。</p><ul><li><strong>基于数组可实现</strong>：栈、队列、哈希表、树、堆、图、矩阵、张量（维度 ≥3 的数组）等。</li><li><strong>基于链表可实现</strong>：栈、队列、哈希表、树、堆、图等。</li></ul><p>​哈希表底层是数组，而为了解决哈希冲突，我们可能会使用“链式地址”（后续“哈希冲突”章节会讲）：数组中每个桶指向一个链表，当链表长度超过一定阈值时，又可能被转化为树（通常为红黑树）。</p><p>​从存储的角度来看，哈希表的底层是数组，其中每一个桶槽位可能包含一个值，也可能包含一个链表或一棵树。因此，哈希表可能同时包含线性数据结构（数组、链表）和非线性数据结构（树）。</p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tutorial</tag>
      
      <tag>C/C++</tag>
      
      <tag>Time and Space Complexity</tag>
      
      <tag>Recursion</tag>
      
      <tag>Hello-algorithm-tutorial</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LaTeX-tutorial</title>
    <link href="/posts/LaTeX-tutorial/"/>
    <url>/posts/LaTeX-tutorial/</url>
    
    <content type="html"><![CDATA[<h1 id="About-LaTeX"><a href="#About-LaTeX" class="headerlink" title="About LaTeX"></a>About LaTeX</h1><p>​听说过LaTeX吗？亦或是老师突然要求你们使用LaTeX进行写论文，自己面对奇奇怪怪的复杂代码毫无头绪，下不去手？</p><p><strong>需要提前准备的内容</strong>：</p><ul><li>无</li></ul><p><strong>如果你是</strong>：</p><ul><li>纯LaTeX新手，从零开始接触LaTeX；</li><li>纯路人，想学习LaTeX技巧；</li><li>想要支持作者的帅哥美女❥(^_-)；</li></ul><p>那恭喜你来对地方了！在这篇文章中，<strong>你将学习到以下内容</strong>：</p><ul><li>一段LaTeX的历史和一位伟人；</li><li>掌握LaTeX的最基本原理；</li><li>如何从零开始构建第一篇LaTeX文档，并按需进行个性化的修改；</li><li>尝试接触一些LaTeX的高级功能（Optional）；</li><li>获得一些精进LaTeX技能包的方法和途径；</li></ul><p><strong>准备好了吗？</strong> 在接下来的时光里，就让我们一起走进LaTeX的世界。</p><p><img src="/posts/LaTeX-tutorial/LaTeX.png" alt="LaTeX"></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://en.wikipedia.org/wiki/TeX">TeX - Wikipedia</a></p><p><a href="https://en.wikipedia.org/wiki/LaTeX">LaTeX - Wikipedia</a></p><p><a href="https://www.overleaf.com/">Overleaf, Online LaTeX Editor</a></p><p><a href="https://www.latex-project.org/">LaTeX - A document preparation system</a></p><h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1 Introduction"></a>1 Introduction</h2><p><strong>又来到了讲故事环节，可跳过</strong></p><p>​在开始我们今天的话题之前，我想先向各位介绍一位老先生，<a href="https://en.wikipedia.org/wiki/Donald_Knuth">Donald Knuth</a>。</p><p><img src="/posts/LaTeX-tutorial/Knuth.jpg" alt="Donald Knuth"></p><p>​先来看看他到底有多牛逼，这是维基百科对这位老爷爷（还没有去世哦）的评价：He is the 1974 recipient of <strong>the <a href="https://en.wikipedia.org/wiki/Acm_Turing_award">ACM Turing Award</a></strong>, informally considered the <a href="https://en.wikipedia.org/wiki/Nobel_Prize">Nobel Prize</a> of computer science. Knuth has been called the “<strong>father of the <a href="https://en.wikipedia.org/wiki/Analysis_of_algorithms">analysis of algorithms</a></strong>“。 <a href="https://en.wikipedia.org/wiki/Donald_Knuth">原文</a></p><p>​ACM图灵奖不必多说，能拿奖的都是计算机科学领域大牛中的大牛，他甚至还有第二个称号，<strong>the father of the analysis of algorithms</strong>, 算法分析之父！更不可思议的是，他的主要贡献竟然是一系列至今尚未完篇的鸿篇巨著：*<a href="https://en.wikipedia.org/wiki/The_Art_of_Computer_Programming">The Art of Computer Programming</a>*。<strong>计算机程序设计艺术</strong>，简称TAOCP，是关于计算机程序设计之七卷本著作。作者并因此获得美国计算机协会1974年<a href="https://zh.wikipedia.org/wiki/%E5%9B%BE%E7%81%B5%E5%A5%96">图灵奖</a>。</p><blockquote><p>对我来说，读完这本书不仅花了好几个月，而且还要求我有极高的自律性。如果你能读完这本书，不妨给我发个简历。——Bill Gates</p></blockquote><p>​这一套书涵盖了计算机领域几乎所有的底层知识，目录如下：</p><p><img src="/posts/LaTeX-tutorial/theartofprogramming.png" alt="TAOCP"></p><p><a href="https://zh.wikipedia.org/zh-cn/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%89%BA%E6%9C%AF">链接指路：计算机程序设计艺术</a></p><p>​这本书的具体内容我们不做过多的介绍，那这位老者和LaTeX有什么关系呢？<strong>他是LaTeX的前身——TeX的发明者！</strong></p><p>​维基百科在这一块写的比较含蓄哈哈哈：</p><blockquote><p>In 1977, he decided to spend some time <strong>creating something more suitable</strong>. Eight years later, he returned with <a href="https://en.wikipedia.org/wiki/TeX">TEX</a>, which is currently used for all volumes.</p></blockquote><p>什么是<strong>something more suitable</strong>？Maybe the LaTeX！</p><h2 id="2-LaTeX"><a href="#2-LaTeX" class="headerlink" title="2 LaTeX"></a>2 LaTeX</h2><p>​举一个非常简单的例子，你想在word文档中输入这样一个公式：</p><p><img src="/posts/LaTeX-tutorial/QianJianTec1732279187844.png" alt="Gradient Descent"></p><blockquote><p>这是机器学习中梯度下降的基本数学原理。</p></blockquote><p>​我们来看看word是怎么编辑公式的：</p><p><img src="/posts/LaTeX-tutorial/word.png" alt="How does Microsoft Word handle it?"></p><p>​Word等文字编辑器始终秉持着一种<strong>所见即所得</strong>的思想，我打出一个字符，这个字符就实时的反映在我的文本文档中，至于图片缩放，表格插入，文字大小，排版，以及以上所涉及的数学符号等等，在word中虽然能实现，但是调试的时间成本非常高，难度非常大，而且十分的低效！笔者在高中时期曾经有过写数学小论文卡在编辑公式和统一插入图片的格式等细枝末节的小事上的惨痛的回忆。(不过好像现在word也支持LaTeX了)</p><p>​但是在LaTeX中，我们可以利用下面的代码生成：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\begin</span>&#123;aligned&#125;<br><span class="hljs-keyword">\theta</span><span class="hljs-built_in">_</span>&#123;j&#125;:=<span class="hljs-keyword">\theta</span><span class="hljs-built_in">_</span>&#123;j&#125;- <span class="hljs-built_in">&amp;</span> <span class="hljs-keyword">\alpha</span> <span class="hljs-keyword">\frac</span>&#123;<span class="hljs-keyword">\partial</span>&#125;&#123;<span class="hljs-keyword">\partial</span> <span class="hljs-keyword">\theta</span><span class="hljs-built_in">_</span>&#123;j&#125;&#125; J(<span class="hljs-keyword">\theta</span>) <span class="hljs-keyword">\\</span><br><span class="hljs-keyword">\frac</span>&#123;<span class="hljs-keyword">\partial</span>&#125;&#123;<span class="hljs-keyword">\partial</span> <span class="hljs-keyword">\theta</span><span class="hljs-built_in">_</span>&#123;j&#125;&#125; J(<span class="hljs-keyword">\theta</span>) <span class="hljs-built_in">&amp;</span> =<span class="hljs-keyword">\frac</span>&#123;<span class="hljs-keyword">\partial</span>&#125;&#123;<span class="hljs-keyword">\partial</span> <span class="hljs-keyword">\theta</span><span class="hljs-built_in">_</span>&#123;j&#125;&#125; <span class="hljs-keyword">\frac</span>&#123;1&#125;&#123;2&#125;<span class="hljs-keyword">\left</span>(h<span class="hljs-built_in">_</span>&#123;<span class="hljs-keyword">\theta</span>&#125;(x)-y<span class="hljs-keyword">\right</span>)<span class="hljs-built_in">^</span>&#123;2&#125; <span class="hljs-keyword">\\</span><br><span class="hljs-built_in">&amp;</span> =2 <span class="hljs-keyword">\cdot</span> <span class="hljs-keyword">\frac</span>&#123;1&#125;&#123;2&#125;<span class="hljs-keyword">\left</span>(h<span class="hljs-built_in">_</span>&#123;<span class="hljs-keyword">\theta</span>&#125;(x)-y<span class="hljs-keyword">\right</span>) <span class="hljs-keyword">\cdot</span> <span class="hljs-keyword">\frac</span>&#123;<span class="hljs-keyword">\partial</span>&#125;&#123;<span class="hljs-keyword">\partial</span> <span class="hljs-keyword">\theta</span><span class="hljs-built_in">_</span>&#123;j&#125;&#125;<span class="hljs-keyword">\left</span>(h<span class="hljs-built_in">_</span>&#123;<span class="hljs-keyword">\theta</span>&#125;(x)-y<span class="hljs-keyword">\right</span>) <span class="hljs-keyword">\\</span><br><span class="hljs-built_in">&amp;</span> =<span class="hljs-keyword">\left</span>(h<span class="hljs-built_in">_</span>&#123;<span class="hljs-keyword">\theta</span>&#125;(x)-y<span class="hljs-keyword">\right</span>) <span class="hljs-keyword">\cdot</span> <span class="hljs-keyword">\frac</span>&#123;<span class="hljs-keyword">\partial</span>&#125;&#123;<span class="hljs-keyword">\partial</span> <span class="hljs-keyword">\theta</span><span class="hljs-built_in">_</span>&#123;j&#125;&#125;<span class="hljs-keyword">\left</span>(<span class="hljs-keyword">\sum</span><span class="hljs-built_in">_</span>&#123;i=0&#125;<span class="hljs-built_in">^</span>&#123;n&#125; <span class="hljs-keyword">\theta</span><span class="hljs-built_in">_</span>&#123;i&#125; x<span class="hljs-built_in">_</span>&#123;i&#125;-y<span class="hljs-keyword">\right</span>) <span class="hljs-keyword">\\</span><br><span class="hljs-built_in">&amp;</span> =<span class="hljs-keyword">\left</span>(h<span class="hljs-built_in">_</span>&#123;<span class="hljs-keyword">\theta</span>&#125;(x)-y<span class="hljs-keyword">\right</span>) x<span class="hljs-built_in">_</span>&#123;j&#125;<br><span class="hljs-keyword">\end</span>&#123;aligned&#125;<br></code></pre></td></tr></table></figure><p>​完全看不懂是不是？没关系，这就是<strong>LaTeX的精髓</strong>：<strong>将可视化的文本编辑转化成一种严谨的代码语言</strong>，当你学会并且快速上手之后，你便会越来越体会到LaTeX在学术写作上的强大之处。</p><h2 id="3-LaTeX-入门"><a href="#3-LaTeX-入门" class="headerlink" title="3 LaTeX 入门"></a>3 LaTeX 入门</h2><p>​由上面的示例我们可以看出，<strong>LaTeX可以生成极为精美的文档，涵盖公式，表格，图片等等各种形式（你甚至可以用来做PPT！后面会讲到）</strong>，但代价就是<strong>LaTeX牺牲了市面上主流文本编辑器的”所见即所得”的思想</strong>，将所有文字和图片的生成都转化为了一种规则和<strong>编程语言</strong>，初学者入门可能会很吃力，但相信我，熟练后你会爱上他的！</p><h3 id="3-1-开始你的第一篇LaTeX文档！"><a href="#3-1-开始你的第一篇LaTeX文档！" class="headerlink" title="3.1 开始你的第一篇LaTeX文档！"></a>3.1 开始你的第一篇LaTeX文档！</h3><p>​万事万物第一步：配环境！一般来说有两种方式：</p><ul><li>本地环境配置：<a href="https://www.tug.org/texlive/">TeX Live - TeX Users Group</a>。需要安装textlive，后续可以集成在vscode中使用，具体的操作方法比较繁琐，读者可以自行搜索，网上有很多保姆级的环境搭建教程。（<strong>不推荐，个人建议是等上手熟悉了之后再考虑是否安装，配环境报错真的能把人给烦死</strong>）</li><li><strong>推荐在线LaTeX网站：</strong>使用LaTeX在线网站，例如<a href="https://www.overleaf.com/">Overleaf</a>，国内有些高校也会开通自己的LaTeX平台。在线网站更加轻量化，隐藏了配置环境的细节，注册一个账号就可以使用，<strong>非常推荐新手小白使用！</strong></li><li>在接下来的新手教程中，我们将全程在<a href="https://www.overleaf.com/">Overleaf</a>上进行演示，请登录网站并注册好你的账号。（使用免费版即可）</li></ul><h3 id="3-2-建立一个模版LaTeX"><a href="#3-2-建立一个模版LaTeX" class="headerlink" title="3.2 建立一个模版LaTeX"></a>3.2 建立一个模版LaTeX</h3><p>​对新手而言，<strong>快速上手熟悉LaTeX比了解LaTeX背后的原理重要的多</strong>。因此，我们将会从一个模版LaTeX出发，从实操慢慢过渡到原理的讲解。</p><p><img src="/posts/LaTeX-tutorial/s1.png" alt="Choose a template"></p><p>​点击左上角的new project——然后有四个选项：</p><ul><li><p>Blank project（完全的空文本）</p></li><li><p>Example Project（模版）</p></li><li><p>Upload Project（上传本地项目，通常是压缩包形式）</p></li><li><p>Import Project（从Github引入）</p><p>在这里我们选择Example Project。输入自己的Project Name(建议英文)。我在这里输入的是Hello world。</p></li></ul><h3 id="3-3-探索LaTeX模版！"><a href="#3-3-探索LaTeX模版！" class="headerlink" title="3.3 探索LaTeX模版！"></a>3.3 探索LaTeX模版！</h3><p><img src="/posts/LaTeX-tutorial/image_9.png" alt="Hello world!"></p><p>​当你看到一只经典的绿色小青蛙时，恭喜你，你已经成功创建了第一个LaTeX文档！</p><blockquote><p>没有看到？试试点一下右上侧绿色的<strong>Recompile</strong>按钮试试看，可能要等一会。</p></blockquote><p>​简单介绍一下各模块都是干啥用的：</p><ul><li>最左边：文件栏和<strong>File Outline</strong><ul><li>文件栏可以理解为<strong>一个存放这个LaTeX文档所有资源的文件夹</strong>。我们现在中间所打开的就是文件夹中的<strong>main.tex</strong>文件，这也是LaTeX文档的核心部分。还有一些附属的资源也会存放在文件栏中，包括插入的图片，还有参考文献(.bib)。目前大家知道这些就足够了。</li><li>File Outline 不必多说，展示文章大纲的地方。</li></ul></li><li>正中间：文本编辑区，也就是敲代码的地方。</li><li>最右边：视图区：当你点击<strong>Recompile</strong>的按钮之后，<strong>编译器</strong>（点击左上方的menu可以查看，<strong>新手不要随便改变这一项！</strong>）会根据main.tex的代码以及一些附属文件（例如frog.jpg）生成最终的LaTeX文档（PDF），在右侧可以预览，也可以导出保存。</li></ul><p><img src="/posts/LaTeX-tutorial/image_11.png" alt="The Compiler"></p><ul><li>上方一栏的一些工具看名字应该就知道是干什么的了，和普通的文本编辑器差不太多，都是一些附加功能，读者可以自己来探索。</li></ul><h3 id="3-4-进入main-tex"><a href="#3-4-进入main-tex" class="headerlink" title="3.4 进入main.tex"></a>3.4 进入main.tex</h3><p>​接下来，让我们把重点放在main.tex的代码上。</p><h4 id="3-4-1-整体架构"><a href="#3-4-1-整体架构" class="headerlink" title="3.4.1 整体架构"></a>3.4.1 整体架构</h4><p>​一篇标准的LaTeX代码架构如下：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-comment">% 这是一行注释，不会对代码产生任何影响</span><br><span class="hljs-keyword">\documentclass</span>&#123;article&#125;<br><span class="hljs-comment">%导言区（相当于前期的准备工作）</span><br><span class="hljs-keyword">\begin</span>&#123;document&#125;<br><span class="hljs-comment">%正文（文章内容）</span><br><span class="hljs-keyword">\end</span>&#123;document&#125;<br><span class="hljs-comment">% \end&#123;document&#125;代表着main.tex的结尾，相当于C++的return 0;这个语句后面不要加上任何的东西！（因为加了也没有任何意义）</span><br></code></pre></td></tr></table></figure><p>​<code>\</code>在LaTeX中是非常重要的一个字符，类似于C&#x2F;C++中的转义字符，在后面跟着的都是<strong>LaTeX的关键词和命令</strong>（会有代码高亮），我们<strong>重点学习的内容</strong>就是<strong>这些命令代表什么意思，以及如何使用这些命令</strong>。</p><p>​首先，我们来介绍LaTeX中的<strong>导言区</strong>，即<code>\begin&#123;document&#125;</code>之前的部分。</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\documentclass</span>&#123;article&#125;<br><span class="hljs-comment">%这行代码指定了文档的类型为 article，即文章类型。LaTeX 中有几种文档类型（如 report、book 等），article 是最常用的一种，适用于论文、报告、演讲稿等。</span><br></code></pre></td></tr></table></figure><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs LaTeX"><span class="hljs-comment">% Language setting</span><br><span class="hljs-comment">% Replace `english&#x27; with e.g. `spanish&#x27; to change the document language</span><br><span class="hljs-keyword">\usepackage</span>[english]&#123;babel&#125;<br><span class="hljs-comment">% Useful packages</span><br><span class="hljs-keyword">\usepackage</span>&#123;amsmath&#125;<br><span class="hljs-keyword">\usepackage</span>&#123;graphicx&#125;<br><span class="hljs-keyword">\usepackage</span>[colorlinks=true, allcolors=blue]&#123;hyperref&#125;<br></code></pre></td></tr></table></figure><p>​在LaTeX，几乎所有的高级操作都是建立在<strong>导入宏包</strong>的基础之上的，类似于C++中的#include和Python中的import，导入宏包可以让你的LaTeX代码变的更加强大。在此处导入的三个常用宏包分别用于数学公式(amsmath)，图形处理(graphix)和引用(hyperref)。<br>​在之后的学习过程中，你可以根据需求自己导入特定的宏包，不过别担心，后面会具体教你怎么做的。</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\title</span>&#123;Your Paper&#125;<br><span class="hljs-keyword">\author</span>&#123;You&#125;<br><span class="hljs-comment">% 作者的信息和文章标题，这一块也可以自己魔改（属于高级功能）</span><br></code></pre></td></tr></table></figure><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\begin</span>&#123;document&#125;<br><span class="hljs-comment">%正文</span><br><span class="hljs-keyword">\end</span>&#123;document&#125;<br></code></pre></td></tr></table></figure><p>​夹在<code>\begin&#123;document&#125;</code>和<code>\end&#123;document&#125;</code>之间的是文章的正文部分，<strong>任何你想在最后PDF出现的内容，无论是图片，文字，都需要在<code>\begin&#123;document&#125;</code>和<code>\end&#123;document&#125;</code>之间通过命令表达出来！</strong>接下来我们来重点介绍正文部分。</p><h4 id="3-4-2-正文部分①——文字"><a href="#3-4-2-正文部分①——文字" class="headerlink" title="3.4.2 正文部分①——文字"></a>3.4.2 正文部分①——文字</h4><blockquote><p>在这里为了方便演示，我创建了一个新的空白文档，所以和LaTeX模版之间存在差异。读者可以先尝试理解这些指令都代表着什么功能，然后回到自己的template中尝试“读懂”他！也可以自己尝试修改一些内容看看最后生成的文档有什么不同~</p></blockquote><p>正文的代码开始看不懂了？别着急，先来看看我写的简化版的</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\begin</span>&#123;document&#125;<br><span class="hljs-keyword">\maketitle</span><br><br><span class="hljs-keyword">\begin</span>&#123;abstract&#125;<br>Your abstract.<br><span class="hljs-keyword">\end</span>&#123;abstract&#125;<br><span class="hljs-keyword">\section</span>&#123;introducccction&#125;<br><span class="hljs-keyword">\section</span>&#123;Part1&#125;<br><span class="hljs-keyword">\subsection</span>&#123;hello&#125;<br>Hello, this is a test file.<br>is this a new paragraph?<br><br>is this a new paragraph?<br><span class="hljs-keyword">\subsection</span>&#123;world!&#125;<br><span class="hljs-keyword">\subsubsection</span>&#123;hahah&#125;<br><span class="hljs-keyword">\subsubsection</span>&#123;hahahahahah&#125;<br>i know you are very smart!<br><span class="hljs-keyword">\section</span>&#123;Part22&#125;<br><span class="hljs-keyword">\begin</span>&#123;enumerate&#125;<br>    <span class="hljs-keyword">\item</span> this is the firrst point<br>    <span class="hljs-keyword">\item</span> this is the 2nd points<br><span class="hljs-keyword">\end</span>&#123;enumerate&#125;<br><span class="hljs-keyword">\section</span>&#123;p3&#125;<br><span class="hljs-keyword">\section</span>&#123;Conclusion&#125;<br><br><span class="hljs-keyword">\end</span>&#123;document&#125;<br></code></pre></td></tr></table></figure><p>包含一些必要的文件准备工作，这份PDF输出如下：</p><p><img src="/posts/LaTeX-tutorial/image_12.png" alt="The Output"></p><blockquote><p>为了让展示变得更加清晰，我故意拼错了许多单词，请勿模仿！</p></blockquote><ul><li><p><code>\maketitle</code>命令首先输出文章的标题（包括作者信息和时间），不要删除。</p></li><li><p>摘要（abstract）</p><ul><li>论文的一个组成部分，由<code>\begin&#123;abstract&#125;</code>和<code>\end&#123;abstract&#125;</code>包裹。</li></ul></li><li><p><code>\section</code>,<code>\subsection</code>,<code>\subsubsection</code></p><ul><li>类似于论文中1,2,3级小标题的概念，读者可以将代码中的文字和最终输出在PDF中的位置对应起来，应该很快就能够理解。</li><li>这就是LaTeX的强大之处，可能用起来没有word可视化，但是他省去了很多文字排版以及大小调整优化的工作，实际上大大地提高了工作效率。</li></ul></li><li><p>正文</p><ul><li><p>文章中<em>i know you are very smart!</em> 和<em>Hello, this is a test file. is this a new paragraph?</em> 都是正文语句。</p></li><li><p><strong>缩进</strong>：LaTeX默认模版中首段不缩进，第二段才缩进，如果想更改这个设置，可以在导言区加入命令：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\usepackage</span>&#123;indentfirst&#125;<br><span class="hljs-comment">% 这是你加入的第一个宏包！快来compile一下看看有什么变化吧！</span><br></code></pre></td></tr></table></figure><p><img src="/posts/LaTeX-tutorial/image_13.png" alt="Indient"></p><p>你会发现，第一段也缩进啦！</p></li><li><p><strong>换行</strong>：</p><ul><li><p>第一个雷点：<strong>在源代码中换行并不代表真的换行了！</strong>比如第一个is this a new paragraph和Hello, this is a test file.分属两行，但他们实际输出上只在一行上面。</p></li><li><p>最简单的换行方法：<strong>直接在段落中添加一个空行，即按下两个回车键</strong>，这样就能成功实现换行。</p><p><strong>以下内容新手自动跳过！</strong></p></li><li><p>使用<code>\\</code>换行，一种更紧凑的写法（但有风险）</p></li></ul><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs LaTeX">This is the first line.<span class="hljs-keyword">\\</span><br>This is the second line.<br></code></pre></td></tr></table></figure><ul><li>其他换行方法：都是通过一些命令实现，可以作补充了解</li></ul><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs latex">This is the first line.<br><span class="hljs-keyword">\newline</span><br>This is the second line.<br><span class="hljs-comment">% 类比的，你应该就知道命令</span><br><span class="hljs-keyword">\newpage</span><br><span class="hljs-comment">% 是什么意思了吧！</span><br></code></pre></td></tr></table></figure><p>注意，使用<code>\\</code>和<code>\newline</code>进行强制换行时，两行之间没有额外的垂直间距！格式会有差异，<strong>建议非必要不要使用强制换行符</strong>。</p><p><img src="/posts/LaTeX-tutorial/image_14.png" alt="Using Newline Carefully"></p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-comment">% 一些补充命令：</span><br><br><span class="hljs-comment">%有垂直间距的换行</span><br>This is the first line.<br><span class="hljs-keyword">\vspace</span>&#123;1cm&#125;<br><br>This is the second line.<br><br><span class="hljs-comment">%无垂直间距的换行</span><br>This is the first line.<br><span class="hljs-keyword">\noindent</span><br><br>This is the second line without extra space.<br><br></code></pre></td></tr></table></figure><p><img src="/posts/LaTeX-tutorial/image_15.png" alt="Some advanced techniques"></p></li></ul></li><li><p><code>enumerate</code></p><ul><li>中文翻译“枚举”，用于文章中生成小标号，不作为小标题出现</li></ul><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\section</span>&#123;Part22&#125;<br><span class="hljs-keyword">\begin</span>&#123;enumerate&#125;<br>    <span class="hljs-keyword">\item</span> this is the firrst point<br>    <span class="hljs-keyword">\item</span> this is the 2nd points<br><span class="hljs-keyword">\end</span>&#123;enumerate&#125;<br><span class="hljs-comment">% 注意一个begin对应一个end，不然会报错！</span><br></code></pre></td></tr></table></figure><p><img src="/posts/LaTeX-tutorial/image_16.png" alt="Enumerate"></p><ul><li>可以和一些指令搭配使用，例如加粗<code>\textbf&#123;&#125;</code>等等。</li></ul></li><li><p>文本美化：</p><blockquote><p>这里的命令都是比较简单的，大家可以自行尝试~</p></blockquote><ul><li>加粗命令</li></ul><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\textbf</span>&#123;This text is bold.&#125;<br></code></pre></td></tr></table></figure><ul><li>斜线命令</li></ul><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\textit</span>&#123;This text is italic.&#125;<br></code></pre></td></tr></table></figure><ul><li>下划线命令</li></ul><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\underline</span>&#123;This text is underlined.&#125;<br></code></pre></td></tr></table></figure><ul><li>等宽字体</li></ul><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\texttt</span>&#123;This text is in typewriter font.&#125;<br></code></pre></td></tr></table></figure></li></ul><p>​<strong>Congratulations！到现在为止，你已经能够处理一篇最基本的latex的90%的内容了！你学习了如何编辑正文中的文字部分（这常常占了文章的大头，不是吗？）</strong></p><p>​接下来的旅程会变的更复杂，也更有趣，我们将继续向我们的latex中添加更多有趣的东西！</p><h4 id="3-4-3-正文部分②——图片和图表"><a href="#3-4-3-正文部分②——图片和图表" class="headerlink" title="3.4.3 正文部分②——图片和图表"></a>3.4.3 正文部分②——图片和图表</h4><p>​数据可视化在一篇论文中是非常重要的。因此，你需要再适当的位置添加你的图表！</p><ul><li>插入图片</li><li>插入统计图</li><li>插入统计表</li></ul><h4 id="3-4-4-正文部分③——数学公式"><a href="#3-4-4-正文部分③——数学公式" class="headerlink" title="3.4.4 正文部分③——数学公式"></a>3.4.4 正文部分③——数学公式</h4><h2 id="4-LaTeX精进"><a href="#4-LaTeX精进" class="headerlink" title="4 LaTeX精进"></a>4 LaTeX精进</h2><h3 id="4-1-坏了，报错了！"><a href="#4-1-坏了，报错了！" class="headerlink" title="4.1 坏了，报错了！"></a>4.1 坏了，报错了！</h3><h3 id="4-2-导入特定的宏包"><a href="#4-2-导入特定的宏包" class="headerlink" title="4.2 导入特定的宏包"></a>4.2 导入特定的宏包</h3><h3 id="4-3-Advanced-Methods"><a href="#4-3-Advanced-Methods" class="headerlink" title="4.3 Advanced Methods"></a>4.3 Advanced Methods</h3><h3 id="4-4-自定义？"><a href="#4-4-自定义？" class="headerlink" title="4.4 自定义？"></a>4.4 自定义？</h3><h3 id="4-5-网站指南"><a href="#4-5-网站指南" class="headerlink" title="4.5 网站指南"></a>4.5 网站指南</h3><h2 id="5-Conclusion-and-Outlook"><a href="#5-Conclusion-and-Outlook" class="headerlink" title="5 Conclusion and Outlook"></a>5 Conclusion and Outlook</h2><p>（2024.11.22）笔者累啦，之后会更新的！</p>]]></content>
    
    
    <categories>
      
      <category>Efficient Tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tutorial</tag>
      
      <tag>LaTeX</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Introduction_to_C</title>
    <link href="/posts/Introduction-to-C/"/>
    <url>/posts/Introduction-to-C/</url>
    
    <content type="html"><![CDATA[<h1 id="C语言-入门中的入门"><a href="#C语言-入门中的入门" class="headerlink" title="C语言 入门中的入门"></a>C语言 入门中的入门</h1><p>笔者的第一门博客，就献给C语言叭~</p><h2 id="1-目标群体"><a href="#1-目标群体" class="headerlink" title="-1 目标群体"></a>-1 目标群体</h2><ul><li><strong>对编程和计算机语言完全没有基础的萌新小白</strong>。</li><li>闲的蛋疼的帅哥美女们。</li></ul><p><strong>注意：</strong>这篇文章只适合作为入门导论使用，目的在于让完全萌新的小白们在短时间内获得对C语言的宏观初步了解，<strong>不涉及任何具体代码层面的细节知识</strong>。如果读者已经对C的语法基本掌握，想要跟上一层楼的话，请另寻他路~（或者点个关注等我更新（bushi））</p><p>​</p><h2 id="begin-document"><a href="#begin-document" class="headerlink" title="\begin{document}"></a>\begin{document}</h2><h2 id="0-为什么我们要选择C语言"><a href="#0-为什么我们要选择C语言" class="headerlink" title="0 为什么我们要选择C语言"></a>0 为什么我们要选择C语言</h2><p>​如果你不幸选到了<del>天坑专业</del>——<code>计算机科学与技术</code>，一般来说，学校都会把C语言作为同学们需要学习的<strong>第一门现代编程语言</strong>。</p><h3 id="Question1-什么叫语言？"><a href="#Question1-什么叫语言？" class="headerlink" title="Question1 什么叫语言？"></a>Question1 什么叫<strong>语言</strong>？</h3><p>​区别与我们日常说话的<strong>自然语言</strong>，<strong>编程语言</strong>是一种用于描述计算机程序的形式语言。它提供了一组符号和规则，用于描述程序的结构、功能和行为。程序员可以使用编程语言来编写计算机程序，这些程序可以在计算机上执行，从而实现特定的任务或实现特定的功能。</p><p>​通俗来说，你可以把程序想象成一个“机器人”，他完全按照工程师输入给他的指令进行工作。那对于开发机器人的工程师而言，他与机器人对话的语言（即编程语言）必须具备<strong>严谨，高效，无二义性</strong>的特征：即每一条语句都可以发挥作用；每一条语句只能表达一种指令（不然机器人就要犯迷糊了）；每一条语句在逻辑上必须完全严谨。</p><p>​再引入第二个概念，<strong>高级编程语言</strong>和<strong>低级编程语言</strong>，在以前，机器人所交流的语言（例如机器语言和汇编语言，这两种语言被称为低级编程语言）在提升严谨性的基础之上牺牲了<strong>可读性</strong>，而高级编程语言通过编译器、解释器等种种方式，将程序中”机器人看的懂，人看不懂“的部分（低级编程语言）隐藏起来，使代码更容易理解。而我们的C语言，<strong>就是一种经典的高级编程语言</strong>。</p><p><img src="/posts/Introduction-to-C/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80.png" alt="高级编程语言"></p><p>[图片来源](<a href="https://blog.csdn.net/weixin_42727710/article/details/121900806">编译型语言（Compile）和解释型语言（Interpreter）的区别_compilation interpretation-CSDN博客</a>)</p><blockquote><p>对这一块感兴趣的读者可以自行查阅有关机器语言，汇编语言，编译器，解释器等相关资料。深入了解这块内容需要涉及到二进制的基础知识和一些艰深复杂的语法规则，此处不再涉及。</p></blockquote><blockquote><p>在人工智能的时代，The best programming language is English！</p></blockquote><h3 id="Question2-为什么是C语言？"><a href="#Question2-为什么是C语言？" class="headerlink" title="Question2 为什么是C语言？"></a>Question2 为什么是<strong>C语言</strong>？</h3><p>​<strong>对于这个结论，我们不妨先摆事实，再探求原理。</strong></p><p>​下图是<a href="https://www.tiobe.com/tiobe-index/">TIOBE</a>对市场上主流的编程语言所占市场份额的统计（数据截至2024年10月），我们亲爱的C语言排在了第四位，占比8.38%。</p><p><img src="/posts/Introduction-to-C/TIOBE.jpg" alt="TIOBE"></p><p>​或许到这里你可能会问，占比甚至不到二成，<strong>看着也不是很流行啊！</strong>不过，请看接下来的两组数据：</p><ul><li>市面上流行的C-like语言（即与C语言具有相似的底层架构和语法规则）包括：C++、C#、Objective-C、Go、Java、JavaScript和Swift等等等等，这样一来，<strong>C-like 语言的市场份额达到了40%以上</strong>。</li><li>Python作为一种<a href="https://baike.baidu.com/item/%E8%A7%A3%E9%87%8A%E5%9E%8B%E8%AF%AD%E8%A8%80/8888952">解释型语言</a>，底层原理和C（C是一种编译型语言，后面会讲）存在差异，但Python中的许多语法规则都继承自C语言，同时，Python中各种库的底层都是用C&#x2F;C++编写的！</li></ul><blockquote><p>The Zen of Python, by Tim Peters</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs applescript">Beautiful <span class="hljs-keyword">is</span> better than ugly.<br>Explicit <span class="hljs-keyword">is</span> better than implicit.<br>Simple <span class="hljs-keyword">is</span> better than complex.<br>Complex <span class="hljs-keyword">is</span> better than complicated.<br>Flat <span class="hljs-keyword">is</span> better than nested.<br>Sparse <span class="hljs-keyword">is</span> better than dense.<br>Readability counts.<br>Special cases aren&#x27;t special enough <span class="hljs-keyword">to</span> break <span class="hljs-keyword">the</span> rules.<br>Although practicality beats purity.<br>Errors should never pass silently.<br>Unless explicitly silenced.<br>In <span class="hljs-keyword">the</span> face <span class="hljs-keyword">of</span> ambiguity, refuse <span class="hljs-keyword">the</span> temptation <span class="hljs-keyword">to</span> guess.<br>There should be one<span class="hljs-comment">-- and preferably only one --obvious way to do it.</span><br>Although <span class="hljs-keyword">that</span> way may <span class="hljs-keyword">not</span> be obvious <span class="hljs-keyword">at</span> <span class="hljs-keyword">first</span> unless you&#x27;re Dutch.<br>Now <span class="hljs-keyword">is</span> better than never.<br>Although never <span class="hljs-keyword">is</span> often better than *right* now.<br>If <span class="hljs-keyword">the</span> implementation <span class="hljs-keyword">is</span> hard <span class="hljs-keyword">to</span> explain, <span class="hljs-keyword">it</span>&#x27;s a bad idea.<br>If <span class="hljs-keyword">the</span> implementation <span class="hljs-keyword">is</span> easy <span class="hljs-keyword">to</span> explain, <span class="hljs-keyword">it</span> may be a good idea.<br>Namespaces are one honking great idea <span class="hljs-comment">-- let&#x27;s do more of those!</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> this<br><span class="hljs-comment">#在Python中写入这行代码，运行就会输出上述结果(The Zen of Python)，这些思想很大程度上都继承自C的简洁性和高效性！</span><br></code></pre></td></tr></table></figure></blockquote><p>​对此，我们惊讶的发现，<strong>C语言无处不在！</strong></p><p>​接下来，让我们进入C语言的世界叭！</p><blockquote><p><a href="https://zhuanlan.zhihu.com/p/145852301">C语言的历史，补充阅读</a></p></blockquote><h2 id="1-再谈C语言的工作原理——编译型语言"><a href="#1-再谈C语言的工作原理——编译型语言" class="headerlink" title="1 再谈C语言的工作原理——编译型语言"></a>1 再谈C语言的工作原理——编译型语言</h2><p>​在这个部分，我们将要重点讨论：一个C语言文件是怎么来的？</p><p>​让我们再回到这张图片：</p><p><img src="/posts/Introduction-to-C/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80.png" alt="高级编程语言"></p><p>​很明显，左边的高级语言（C）（或者叫做<strong>源代码</strong>）更加具备可读性，但你的电脑只能识别并运行右边的Low level language，也就是完全由二进制编码的文件，<strong>叫做可执行文件</strong>。在Windows系统下，<code>.exe</code>文件就是一种可执行文件。</p><p>​中间的转换被隐藏了，这便是<strong>编译器</strong>的作用，C<strong>通过编译器将源代码转化成机器语言</strong>，这就是一种<strong>编译型语言</strong>。那编译器具体是怎么实现的呢？具体而言涉及到两个过程：<strong>编译和链接</strong>，笔者可以大概扫一眼留个印象，相信我，你会回来的。</p><p><img src="/posts/Introduction-to-C/OIP-C.jpg" alt="OIP-C"></p><blockquote><p>concrete.c是<strong>源代码文件</strong>，就是我们所谓“敲代码”敲出来的东西，经过编译器，.c的源文件被转化成那个.o的目标代码，到这里就已经变成了机器语言了，但是此时这个程序“缺了一些东西”，<strong>即库代码和启动代码</strong>，这个时候链接器把这三个部分（库代码，启动代码，目标代码）组装起来，形成了最终可运行的.exe文件。</p></blockquote><p>图片摘自C语言经典著作：《C Primer Plus》</p><h2 id="2-入门C语言"><a href="#2-入门C语言" class="headerlink" title="2 入门C语言"></a>2 入门C语言</h2><h3 id="2-1-第一个C语言程序"><a href="#2-1-第一个C语言程序" class="headerlink" title="2.1 第一个C语言程序"></a>2.1 第一个C语言程序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-type">int</span> n=<span class="hljs-number">5</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello,world!\n&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,n);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><span class="hljs-built_in">Hello,</span>world!<br><span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>​这就是你看到的第一个C语言程序（.c的源文件）！他实现了很简单的功能，打印一些“东西”，包括一些字符和数字。接下来，让我们逐行解释输出内容是怎么来的（这部分内容需要结合上一章节C语言工作原理食用）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br></code></pre></td></tr></table></figure><p>​<strong>这个语句叫做预处理器指令</strong>，我们知道，程序可以实现各种各样的功能，但是总有一些底层原理是所有程序共有的（就像社会上每个人都不一样，但每个人都有吃喝拉撒等最基本的生理活动）。于是，C语言将一些常见的功能打包封装起来，通过<strong>导入库文件的方式</strong>，把轮子造好，让程序员可以开箱即用！在这里，include命令就告诉了程序我需要导入C自带库文件<code>stdio.h</code>的相关内容。</p><blockquote><p>这个工作由谁实现呢？<strong>是链接器</strong>，将库代码和目标结合。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br></code></pre></td></tr></table></figure><h3 id="2-2-基本数据类型"><a href="#2-2-基本数据类型" class="headerlink" title="2.2 基本数据类型"></a>2.2 基本数据类型</h3><h3 id="2-3-数组"><a href="#2-3-数组" class="headerlink" title="2.3 数组"></a>2.3 数组</h3><h2 id="3-初见C语言的基本语法规则"><a href="#3-初见C语言的基本语法规则" class="headerlink" title="3 初见C语言的基本语法规则"></a>3 初见C语言的基本语法规则</h2><h3 id="3-1-控制结构——分支"><a href="#3-1-控制结构——分支" class="headerlink" title="3.1 控制结构——分支"></a>3.1 控制结构——分支</h3><h3 id="3-2-控制结构——循环"><a href="#3-2-控制结构——循环" class="headerlink" title="3.2 控制结构——循环"></a>3.2 控制结构——循环</h3><h3 id="3-3-表达式和语句"><a href="#3-3-表达式和语句" class="headerlink" title="3.3 表达式和语句"></a>3.3 表达式和语句</h3><h2 id="4-函数！"><a href="#4-函数！" class="headerlink" title="4 函数！"></a>4 函数！</h2><h2 id="5-指针！"><a href="#5-指针！" class="headerlink" title="5 指针！"></a>5 指针！</h2><h2 id="6-一些更加高级的操作"><a href="#6-一些更加高级的操作" class="headerlink" title="6 一些更加高级的操作"></a>6 一些更加高级的操作</h2><h3 id="6-1-内存管理"><a href="#6-1-内存管理" class="headerlink" title="6.1 内存管理"></a>6.1 内存管理</h3><h3 id="6-2-文件I-O"><a href="#6-2-文件I-O" class="headerlink" title="6.2 文件I&#x2F;O"></a>6.2 文件I&#x2F;O</h3><h3 id="6-3-结构体"><a href="#6-3-结构体" class="headerlink" title="6.3 结构体"></a>6.3 结构体</h3><h3 id="6-4-高级数据表示和ADT"><a href="#6-4-高级数据表示和ADT" class="headerlink" title="6.4 高级数据表示和ADT"></a>6.4 高级数据表示和ADT</h3><h2 id="7-谈谈C"><a href="#7-谈谈C" class="headerlink" title="7 谈谈C++"></a>7 谈谈C++</h2><h3 id="7-1-什么是-？"><a href="#7-1-什么是-？" class="headerlink" title="7.1 什么是++？"></a>7.1 什么是++？</h3><h3 id="7-2-OOP初探"><a href="#7-2-OOP初探" class="headerlink" title="7.2 OOP初探"></a>7.2 OOP初探</h3><h2 id="8-写在最后的话"><a href="#8-写在最后的话" class="headerlink" title="8 写在最后的话"></a>8 写在最后的话</h2><h2 id="end-document"><a href="#end-document" class="headerlink" title="\end{document}"></a>\end{document}</h2>]]></content>
    
    
    <categories>
      
      <category>Code</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tutorial</tag>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Programming of Leetcode 1-5</title>
    <link href="/posts/Programming-of-Leetcode-1-5/"/>
    <url>/posts/Programming-of-Leetcode-1-5/</url>
    
    <content type="html"><![CDATA[<h1 id="程设错题总结-1-5"><a href="#程设错题总结-1-5" class="headerlink" title="程设错题总结 1~5"></a>程设错题总结 1~5</h1><h3 id="1-Leetcode202-Happynumber"><a href="#1-Leetcode202-Happynumber" class="headerlink" title="1.Leetcode202 Happynumber"></a>1.Leetcode202 Happynumber</h3><p><img src="C:\Users\29349\AppData\Roaming\Typora\typora-user-images\image-20241015001727914.png" alt="image-20241015001727914"></p><p>1.使用快慢指针解决循环问题</p><p>当快指针追上慢指针时，代表完成了一次循环。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">happynumber</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123;<br>        <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(n!=<span class="hljs-number">0</span>)&#123;<br>            sum+=(n%<span class="hljs-number">10</span>)*(n%<span class="hljs-number">10</span>);<br>            n/=<span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isHappy</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-type">int</span> i=n,j=n;<br>        <span class="hljs-keyword">do</span>&#123;<br>            i=<span class="hljs-built_in">happynumber</span>(i);<br>            j=<span class="hljs-built_in">happynumber</span>(j);<br>            j=<span class="hljs-built_in">happynumber</span>(j);<br>            <span class="hljs-keyword">if</span>(i==<span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(i!=j);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>2.使用哈希表存储</p><p>此处使用容器：unordered_set</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">happynumber</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123;<br>        <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(n!=<span class="hljs-number">0</span>)&#123;<br>            sum+=(n%<span class="hljs-number">10</span>)*(n%<span class="hljs-number">10</span>);<br>            n/=<span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isHappy</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        unordered_set &lt;<span class="hljs-type">int</span>&gt; list;<br>        <span class="hljs-keyword">while</span>(n!=<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">if</span>(list.<span class="hljs-built_in">find</span>(n)!=list.<span class="hljs-built_in">end</span>())&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                list.<span class="hljs-built_in">insert</span>(n);<br>            &#125;<br>            n=<span class="hljs-built_in">happynumber</span>(n);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="2-Acwing-817-数组去重"><a href="#2-Acwing-817-数组去重" class="headerlink" title="2.Acwing 817 数组去重"></a>2.Acwing 817 数组去重</h3><p><img src="C:\Users\29349\AppData\Roaming\Typora\typora-user-images\image-20241013114226617.png" alt="image-20241013114226617"></p><p>method1：使用STL</p><p><strong>unique函数</strong>：</p><p>unique是C++语言中的STL函数，包含于<algorithm>头文件中。 <strong>功能是将数组中相邻的重复元素去除</strong>。 然而其本质是将重复的元素移动到数组的末尾，最后再将迭代器指向第一个重复元素的下标。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n, s[<span class="hljs-number">1010</span>];<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) cin &gt;&gt; s[i];<br>    <span class="hljs-built_in">sort</span>(s, s + n);<br>    cout &lt;&lt; <span class="hljs-built_in">unique</span>(s, s + n) - s;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>method2：基本方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> b[<span class="hljs-number">1001</span>];<br><span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br><span class="hljs-comment">/*两个数组的区别：</span><br><span class="hljs-comment">a[]代表输入的数组（待去重的数组）</span><br><span class="hljs-comment">b[]数组是一个状态数组，其下标对应的值和a[]对应，初始值均为0，一旦出现a[i],即代表下标为a[i]的b[]被访问过，状态值变为1。（且只有初次访问是生效的）</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_unique_count</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(b[a[i]]==<span class="hljs-number">0</span>)<br>        b[a[i]]=<span class="hljs-number">1</span>;<br>        sum++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br><span class="hljs-comment">//函数作用：统计数组中一共出现了多少不相同的数。</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">int</span> n;<br>  cin&gt;&gt;n;<br>  <span class="hljs-type">int</span> a[n<span class="hljs-number">+1</span>];<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>  &#123;<br>      cin&gt;&gt;a[i];<br>  &#125;<br>  cout&lt;&lt;<span class="hljs-built_in">get_unique_count</span>(a,n);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="3-ACwing-15-二维数组的查找"><a href="#3-ACwing-15-二维数组的查找" class="headerlink" title="3.ACwing 15 二维数组的查找"></a>3.ACwing 15 二维数组的查找</h3><p><img src="C:\Users\29349\AppData\Roaming\Typora\typora-user-images\image-20241014094230026.png" alt="image-20241014094230026"></p><p>思路：</p><p>​1.暴力循环（两个for循环嵌套）</p><p>​2.通过数组大小关系的规律实现<strong>逐步逼近</strong>的策略</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Find</span><span class="hljs-params">(<span class="hljs-type">int</span> target, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; array)</span> </span>&#123;<br>        <span class="hljs-type">int</span> row=array.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> col=array[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> i=row<span class="hljs-number">-1</span>;<br>        <span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//定义扫描的初始位置，(row-1,0),即数组棋盘的左下角</span><br>        <span class="hljs-keyword">while</span>(i&gt;=<span class="hljs-number">0</span>&amp;&amp;j&lt;col)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(target==array[i][j])<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-comment">//得到return后即可跳出循环，代表查找成功</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(target&lt;array[i][j])<br>                i--;<br>            <span class="hljs-comment">//删去最下面一行(判断大小关系)</span><br>            <span class="hljs-keyword">else</span><br>                j++;<br>            <span class="hljs-comment">//删去第一列，移动到第二列(判断大小关系)</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br></code></pre></td></tr></table></figure><h3 id="4-Acwing3801-最佳连续子数组"><a href="#4-Acwing3801-最佳连续子数组" class="headerlink" title="4.Acwing3801 最佳连续子数组"></a>4.Acwing3801 最佳连续子数组</h3><p><img src="C:\Users\29349\AppData\Roaming\Typora\typora-user-images\image-20241014133831155.png" alt="image-20241014133831155"></p><p>最暴力解法：分别枚举首项和尾项 O(n^2)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">testbestarray</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n; cin&gt;&gt;n;<br>    <span class="hljs-type">int</span> numarray[n];<br>    <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>,targetnumber=<span class="hljs-number">0</span>;<br>    <span class="hljs-type">double</span> maxave=<span class="hljs-number">0</span>,ave;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        cin&gt;&gt;numarray[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i;j&lt;n;j++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=i;k&lt;=j;k++)&#123;<br>                sum+=numarray[k];<br>            &#125;<br>            <span class="hljs-comment">//在已知i，j的情况下，遍历对子数组求和</span><br>            ave=<span class="hljs-built_in">double</span>(sum)/(j-i<span class="hljs-number">+1</span>);<br>            <span class="hljs-keyword">if</span>(ave&gt;maxave)&#123;<br>                maxave=ave;<br>                targetnumber=(j-i<span class="hljs-number">+1</span>);<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ave==maxave)&#123;<br>                <span class="hljs-keyword">if</span>((j-i<span class="hljs-number">+1</span>)&gt;targetnumber)&#123;<br>                    targetnumber=(j-i<span class="hljs-number">+1</span>);<br>                &#125;<br>            &#125;<br>            sum=<span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> targetnumber;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> T; cin&gt;&gt;T;<br>    <span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (count&lt;T)&#123;<br>        cout&lt;&lt;<span class="hljs-built_in">testbestarray</span>()&lt;&lt;endl;<br>        count++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>解法优化：</p><p><strong>分治的思想</strong>：将一个大问题拆分成若干个小问题再分别解决。</p><p>子问题1：最大子数列的值</p><p>​<em><strong>最大子数列的值一定等于数列中最大项的值</strong></em></p><p>子问题2：在子数列平均值最大的情况下，找到最长长度：</p><p>​<em><strong>找到数列中是否有若干项连续，且值均为最大值。</strong></em></p><p>优化代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">testbestarray</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n; cin&gt;&gt;n;<br>    <span class="hljs-type">int</span> numarray[n];<br>    <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>,max=<span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;<span class="hljs-type">int</span> countmax=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        cin&gt;&gt;numarray[i];<br>        max=(numarray[i]&gt;max?numarray[i]:max);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;)&#123;<br>        <span class="hljs-keyword">if</span>(i&lt;n&amp;&amp;numarray[i]==max)&#123;<br>            <span class="hljs-keyword">while</span>(i&lt;n&amp;&amp;numarray[i]==max)&#123;<br>            count++;<br>            i++;<br>            &#125;<br>            i++;<br>            countmax=(countmax&lt;count?count:countmax);<br>            count=<span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i&lt;n)&#123;<br>            i++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//这一段for循环是筛查的核心，如果某元素是列表中最大值，则进入while循环直到第一个非最大值元素的出现终止while循环，同时结束count++，并最大化countmax。在遍历完一整个数组后，即可得到最大子区间的长度。</span><br>    <span class="hljs-keyword">return</span> countmax;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> T; cin&gt;&gt;T;<br>    <span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (count&lt;T)&#123;<br>        cout&lt;&lt;<span class="hljs-built_in">testbestarray</span>()&lt;&lt;endl;<br>        count++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>进一步简化：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">10e5</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> a[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> T;<br>    cin &gt;&gt; T;<br>    <span class="hljs-keyword">while</span>(T--)<br>    &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br><br>        <span class="hljs-type">int</span> m = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        &#123;<br>            cin &gt;&gt; a[i];<br>            m = <span class="hljs-built_in">max</span>(m, a[i]);<span class="hljs-comment">//m保存最大值</span><br>        &#125;<br><br>        <span class="hljs-type">int</span> res = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n;i++)<span class="hljs-comment">//求长度</span><br>        &#123;<br>            <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span>(i &lt; n &amp;&amp; a[i] == m)<br>            &#123;<br>                t++;<br>                i++;<br>            &#125;<br>            res = <span class="hljs-built_in">max</span>(res, t);<br>        &#125;<br>        <span class="hljs-comment">/*核心while循环：</span><br><span class="hljs-comment">        此处不用再添加if语句，直接使用外部的for循环即可。</span><br><span class="hljs-comment">        */</span><br>        cout &lt;&lt; res &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="5-ACwing-862-三元组排序"><a href="#5-ACwing-862-三元组排序" class="headerlink" title="5.ACwing 862 三元组排序"></a>5.ACwing 862 三元组排序</h3><p><img src="C:\Users\29349\AppData\Roaming\Typora\typora-user-images\image-20241014191357986.png" alt="image-20241014191357986"></p><p>思路：</p><ul><li>最基本的排序使用排序算法（此处用algorithm库中的sort（）函数）</li><li>如何构建一一对应的关系？<ul><li>map容器</li><li>pair：将两组数据整合成一个数据对<ul><li>（int,（double,string））</li><li>对pair类型的int数排序，一一对应的（double，string）满足映射</li></ul></li></ul></li></ul><p>代码实现：</p><p>①最基本的数组实现</p><p>排序算法（Bubblesort）+交换函数swap（）（内置在C++库中）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n; cin&gt;&gt;n;<br>    <span class="hljs-type">int</span> intlist[n];<br>    <span class="hljs-type">double</span> doublelist[n];<br>    string stringlist[n];<br>    <span class="hljs-comment">//定义三个数组，分别储存三种不同的数据结构。</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        cin&gt;&gt;intlist[i]&gt;&gt;doublelist[i]&gt;&gt;stringlist[i];<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=n;j&gt;<span class="hljs-number">1</span>;j--)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;j<span class="hljs-number">-1</span>;i++)&#123;<br>            <span class="hljs-keyword">if</span>(intlist[i]&gt;intlist[i<span class="hljs-number">+1</span>])&#123;<br>                <span class="hljs-built_in">swap</span>(intlist[i],intlist[i<span class="hljs-number">+1</span>]);<br>                <span class="hljs-built_in">swap</span>(doublelist[i],doublelist[i<span class="hljs-number">+1</span>]);<br>                <span class="hljs-built_in">swap</span>(stringlist[i],stringlist[i<span class="hljs-number">+1</span>]);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//核心算法：冒泡排序</span><br>    <span class="hljs-comment">//从第一位开始逐项与后一位冒泡比较确定是否交换，第一轮下来就确定末尾项为最大值。</span><br>    <span class="hljs-comment">//之后通过外层的for循环逐步确定直至首项</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %.2lf&quot;</span>,intlist[i],doublelist[i]);<br>        cout&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;stringlist[i]&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>②map映射</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;map&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> x first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> y second</span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">10010</span>;<br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">double</span>, string&gt; PII;<br>map&lt;<span class="hljs-type">int</span>, PII&gt; ans;<br><span class="hljs-comment">//定义了一个从int向PII的映射，就不用使用两次pair了</span><br><span class="hljs-type">int</span> n;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-type">double</span> b;<br>    string c;<br>    cin &gt;&gt; n;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ )<br>    &#123;<br>        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;<br>        ans.<span class="hljs-built_in">insert</span>(&#123;a, &#123;b, c&#125;&#125;);<br>    &#125;<br><br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> iter = ans.<span class="hljs-built_in">begin</span>(); iter != ans.<span class="hljs-built_in">end</span>(); iter ++ )<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %.2f %s\n&quot;</span>, iter-&gt;x, iter-&gt;y.x, iter-&gt;y.y.<span class="hljs-built_in">c_str</span>());  <br>    <span class="hljs-comment">/*这里 iter是一个迭代器</span><br><span class="hljs-comment">    iter-&gt;first代表指向map类型的first成员函数（即自变量）</span><br><span class="hljs-comment">    iter-&gt;second代表指向因变量</span><br><span class="hljs-comment">    iter-&gt;second.first代表指向因变量pair的第一个元素</span><br><span class="hljs-comment">    iter-&gt;second.second               第二个元素</span><br><span class="hljs-comment">    c_str()返回一个指向字符串的指针</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>③使用pair类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> x first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> y second</span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">10010</span>;<br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, pair&lt;<span class="hljs-type">double</span>, string &gt;&gt; PII;<br><br>vector&lt;PII&gt; ans;<br><span class="hljs-type">int</span> n, a;<br><span class="hljs-type">double</span> b;<br>string s;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ )<br>    &#123;<br>        cin &gt;&gt; a &gt;&gt; b &gt;&gt; s;<br>        ans.<span class="hljs-built_in">push_back</span>(&#123;a, &#123;b, s&#125;&#125;);<br>        <span class="hljs-comment">//vector类型的push_back函数，&#123;a,&#123;b,s&#125;&#125;是一个PII类型的数据</span><br>    &#125;<br>    <span class="hljs-built_in">sort</span>(ans.<span class="hljs-built_in">begin</span>(), ans.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-comment">//使用sort()函数实现ans这个vector的自动排序(默认升序)</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i: ans)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %.2lf %s\n&quot;</span>,i.x, i.y.x, i.y.y.<span class="hljs-built_in">c_str</span>());   <br>    <span class="hljs-comment">//若i是一个pair类型，则i.first代表pair的第一个元素，而i.second代表pair的第二个元素。</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C/C++</tag>
      
      <tag>Leetcode notes</tag>
      
      <tag>algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Life-musings</title>
    <link href="/posts/Life-musings/"/>
    <url>/posts/Life-musings/</url>
    
    <content type="html"><![CDATA[<h1 id="Life-Musings"><a href="#Life-Musings" class="headerlink" title="Life-Musings"></a>Life-Musings</h1><p><strong>生活随想录</strong></p><h2 id="2024-11-19"><a href="#2024-11-19" class="headerlink" title="2024.11.19"></a>2024.11.19</h2><p>第一篇文章！</p><h2 id="2024-12-4"><a href="#2024-12-4" class="headerlink" title="2024.12.4"></a>2024.12.4</h2><p>数分期中考试</p><p>好难好难呜呜呜</p>]]></content>
    
    
    
    <tags>
      
      <tag>life</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/posts/hello-world/"/>
    <url>/posts/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
