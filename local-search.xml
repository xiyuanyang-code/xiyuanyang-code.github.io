<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>ImageNet and ILSVRC</title>
    <link href="/posts/Imagenet/"/>
    <url>/posts/Imagenet/</url>
    
    <content type="html"><![CDATA[<style>  html, body, .markdown-body {    font-family: Georgia, sans, serif;  }</style><h1 id="ImageNet-Classification-and-ILSVRC-Competition"><a href="#ImageNet-Classification-and-ILSVRC-Competition" class="headerlink" title="ImageNet Classification and ILSVRC Competition"></a>ImageNet Classification and ILSVRC Competition</h1><blockquote><p>My <strong>final assignment</strong> for <strong>Introduction to artificial intelligence</strong>.</p></blockquote><h1 id="Tracing-the-Evolution-of-ILSVRC-Winners-and-Their-Impact-on-Image-Classifications"><a href="#Tracing-the-Evolution-of-ILSVRC-Winners-and-Their-Impact-on-Image-Classifications" class="headerlink" title="Tracing the Evolution of ILSVRC Winners and Their Impact on Image Classifications"></a>Tracing the Evolution of ILSVRC Winners and Their Impact on Image Classifications</h1><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>The past decade witnessed the transformation from Fully Connected Neural Network(FCNN) to Convolutional Neural Network(CNN) , which significantly addressed various challenges in the field of image recognition. This review traces how deep learning had passed a decade of breakthrough, introducing the evolution of winners from the <strong>ImageNet Large Scale Visual Recognition Challenge (ILSVRC)</strong>, highlighting key advancements such as AlexNet, GoogLeNet, ResNet and ResNeXt. By analyzing the architectural innovations and methodological breakthroughs of these models such as ReLU, dropout, LRN, Inception, Residual Network and cardinality, the review then provides insights into the trends in neural network research, regarding how they implemented the optimization by adding the depth of the layers without introducing a huge amount of extra parameters and computational complexity. Finally, we discussed the outlook of Deep Neural Networks in the field of image classification, including striving for higher quality datasets, moving from object recognition to human-level understanding and finding alternative models outperforming traditional CNNs.</p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>再看卷积神经网络！在笔者大一上学期，曾经写过一篇有关<strong>ImageNet 和 ILSVRC</strong>相关的论文，当时属实是<strong>有一种掌握梯度下降就可以优化一切</strong>的傲气，如今回看这篇文章，颇觉得有许多需要改进的地方。因此，笔者决定<strong>重构</strong>这篇文章，并且从这篇文章出发，力求在数学上、工程上和思想上都对卷积神经网络有更深的理解。</p><p>回看当年<strong>炼丹</strong>的日子，或许在历史的长河中，我们总是<strong>能够找到新的灵感</strong>。</p><p>本博客的相关代码和文件将会存储在 <a href="https://github.com/xiyuanyang-code/ImageNet-and-CNN-learning-materials">这个仓库</a> 中。坚持用中文，因为希望<strong>力求获得更加深刻的理解</strong>。</p><h2 id="从“卷积”谈起…"><a href="#从“卷积”谈起…" class="headerlink" title="从“卷积”谈起…"></a>从“卷积”谈起…</h2><p>给定两个函数$f(t)$和$g(t)$：</p><p>$$(f*g)(t)&#x3D;\int_{-\infty}^{+\infty}f(τ)g(t−\tau)\mathrm{d}τ$$</p><p>这个定义非常的抽象，我们不妨举一个<strong>形象化的例子</strong>：</p><h3 id="音频处理"><a href="#音频处理" class="headerlink" title="音频处理"></a>音频处理</h3><p>给定一个波形函数$f(t)$代表一段音频，现在，我们希望对这个函数做数学运算，来<strong>模拟回声</strong>的效果。</p><blockquote><p>这里其实暗含一个<strong>线性系统</strong>（线性时不变系统<strong>LTI</strong>）的假设，具体指的是：</p><ul><li><strong>线性</strong>：系统的输入和输出可以进行线性叠加。<ul><li>在这里，很显然两个波形函数叠加就可以得到新的函数。</li></ul></li><li><strong>时不变性</strong>：系统的输入输出关系不随时间变化。换句话说，如果输入信号的时间发生平移（延迟或提前），那么输出信号也会相应地平移相同的时间量，而不会改变其形状或性质。<ul><li>$ y(t)&#x3D;T[x(t)] \text{ then, }T[x(t−t_0)]&#x3D;y(t−t_0)$. 其中$T$代表系统的变化关系，$x(t)$和$y(t)$分别代表系统的输入和输出。</li><li>在这里，我们可以通过平移等手段实现这一点。（不深究）</li></ul></li></ul></blockquote><p>从直觉上，我们知道，如果在时间$t_0$处连续函数$f(t)$的函数值为$s_0 &#x3D; f(t_0)$，那么我们希望某种施加变换得到新函数$F(t)$，满足$F(t_0 + \delta) &#x3D; f(t_0 + \delta) + \epsilon f(t_0) $.</p><blockquote><p>这个公式直观意思：$t_0 + \delta$处的声音波形函数收到回声的影响（$t &#x3D; t_0$），使其分贝数（函数值）发生了变化。</p></blockquote><p>如何定量的表示这个函数？我们可以定义<strong>核函数</strong>$g(t)$，定义如下：<br>$$<br>g(t) &#x3D;<br>\begin{cases}<br>1, &amp; t &#x3D; 0 \\<br>\epsilon, &amp; t &#x3D; \delta \\<br>0, &amp; \text{otherwise}<br>\end{cases}<br>$$<br>这样我们就可以写出新的函数$F(t) &#x3D; (f*g)(t)&#x3D;\int_{0}^{t}f(τ)g(t−\tau)\mathrm{d}τ$。</p><blockquote><p>这个函数可以解释为：加入<strong>回声</strong>考虑之后，在$t$时刻的函数值（声音的分贝）可以解释为<strong>在过去每一个时刻发出声音</strong>的回声的<strong>线性叠加</strong>。因此，在实际我们可以将$g(t)$定义为更加复杂的衰减函数。</p></blockquote><p>这就是卷积！我们可以推广至更一般的情况，<strong>它的核心思想是通过一个滑动窗口（核函数）对输入数据进行加权求和，从而生成一个新的表示。</strong>例如在之前音频处理的例子中，核函数就是$g$，滑动窗口就是$\int_{0}^{t}$，我们对原始的输入数据$f(t)$进行加权求和，最终得到新的表示。</p><h3 id="卷积的可视化"><a href="#卷积的可视化" class="headerlink" title="卷积的可视化"></a>卷积的可视化</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">Author: Xiyuan Yang   xiyuan_yang@outlook.com</span><br><span class="hljs-string">Date: 2025-04-14 19:23:55</span><br><span class="hljs-string">LastEditors: Xiyuan Yang   xiyuan_yang@outlook.com</span><br><span class="hljs-string">LastEditTime: 2025-04-14 19:24:01</span><br><span class="hljs-string">FilePath: /CNN-tutorial/src/convolution.py</span><br><span class="hljs-string">Description:</span><br><span class="hljs-string">Do you code and make progress today?</span><br><span class="hljs-string">Copyright (c) 2025 by Xiyuan Yang, All Rights Reserved.</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> matplotlib <span class="hljs-keyword">as</span> mlp<br><span class="hljs-keyword">from</span> scipy.integrate <span class="hljs-keyword">import</span> quad<br><br>mlp.use(<span class="hljs-string">&quot;Agg&quot;</span>)<br><br><br><span class="hljs-comment"># Original Function f(t)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">original_signal</span>(<span class="hljs-params">t</span>):<br>    <span class="hljs-keyword">return</span> np.sin(<span class="hljs-number">2</span> * np.pi * t)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">echo_kernel2</span>(<span class="hljs-params">t, alpha</span>):<br>    <span class="hljs-keyword">if</span> t &gt;= <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> np.exp(-alpha * t)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0.0</span><br><br><br><span class="hljs-comment"># Normalize the kernel to ensure its integral is 1</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">normalized_echo_kernel</span>(<span class="hljs-params">t, alpha</span>):<br>    <span class="hljs-comment"># Compute the normalization factor (integral of the kernel from 0 to infinity)</span><br>    normalization_factor, _ = quad(<span class="hljs-keyword">lambda</span> tau: echo_kernel2(tau, alpha), <span class="hljs-number">0</span>, np.inf)<br>    <span class="hljs-comment"># Return the normalized kernel value</span><br>    <span class="hljs-keyword">return</span> echo_kernel2(t, alpha) / normalization_factor<br><br><br><span class="hljs-comment"># Convolution with normalized kernel</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">convolution</span>(<span class="hljs-params">f, g, t_values, alpha</span>):<br>    h = []<br>    <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> t_values:<br>        integral, _ = quad(<span class="hljs-keyword">lambda</span> tau: f(tau) * g(t - tau, alpha), <span class="hljs-number">0</span>, t)<br>        h.append(integral)<br>    <span class="hljs-keyword">return</span> np.array(h)<br><br><br><span class="hljs-comment"># Plot figure for two pictures</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">plotfig</span>(<span class="hljs-params">t, f, h, alpha</span>):<br>    plt.figure(figsize=(<span class="hljs-number">10</span>, <span class="hljs-number">6</span>))<br>    <br>    <span class="hljs-comment"># Original Signal</span><br>    plt.subplot(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>    plt.plot(t, f, label=<span class="hljs-string">&quot;Original Signal&quot;</span>, color=<span class="hljs-string">&quot;blue&quot;</span>)<br>    plt.title(<span class="hljs-string">&quot;Original Signal&quot;</span>)<br>    plt.xlabel(<span class="hljs-string">&quot;Time (s)&quot;</span>)<br>    plt.ylabel(<span class="hljs-string">&quot;Amplitude&quot;</span>)<br>    plt.legend()<br>    plt.grid()<br><br>    <span class="hljs-comment"># Signal with Continuous Echo Effect</span><br>    plt.subplot(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br>    plt.plot(t, h, label=<span class="hljs-string">&quot;Signal with Continuous Echo&quot;</span>, color=<span class="hljs-string">&quot;red&quot;</span>)<br>    plt.title(<span class="hljs-string">&quot;Signal with Continuous Echo Effect&quot;</span>)<br>    plt.xlabel(<span class="hljs-string">&quot;Time (s)&quot;</span>)<br>    plt.ylabel(<span class="hljs-string">&quot;Amplitude&quot;</span>)<br>    plt.legend()<br>    plt.grid()<br>    plt.tight_layout()<br>    plt.savefig(<span class="hljs-string">f&quot;img/Signal_with_Continuous_Effect_alpha=<span class="hljs-subst">&#123;alpha:<span class="hljs-number">.2</span>f&#125;</span>.png&quot;</span>)<br>    plt.close()<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    t = np.linspace(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>, <span class="hljs-number">500</span>)  <span class="hljs-comment"># Time range from 0 to 5 seconds</span><br>    f = original_signal(t)      <span class="hljs-comment"># Original signal</span><br>    <br>    <span class="hljs-comment"># Test different values of alpha</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> [<span class="hljs-number">0.01</span>, <span class="hljs-number">0.1</span>, <span class="hljs-number">0.3</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">0.6</span>, <span class="hljs-number">0.8</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1.1</span>, <span class="hljs-number">1.4</span>, <span class="hljs-number">1.5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2.5</span>, <span class="hljs-number">5</span>]:<br>        h = convolution(original_signal, normalized_echo_kernel, t, alpha=i)<br>        plotfig(t, f, h, i)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    main()<br></code></pre></td></tr></table></figure><p>随便选择一个$alpha$值，可以看到带着回声卷积处理之后的函数：</p><p><img src="https://s1.imagehub.cc/images/2025/04/15/2c9b576d8bde3d09dbd4c4ee58040077.png" alt="卷积示例"></p><h2 id="卷积与图像"><a href="#卷积与图像" class="headerlink" title="卷积与图像"></a>卷积与图像</h2><p>我们知道，对于一张jpg图像可以把它转化为一个高维矩阵（每一个元素的值代表对应点的灰度大小）。但是对于<strong>自然世界中有意义的图像</strong>，矩阵在相邻位置的值往往具有<strong>一致性</strong>，比如色块和轮廓等。我们把这一特征抽象为<strong>图像中的关联性</strong>，相邻像素通常具有相似的灰度值或颜色（现实世界中物体表面的连续性和光照的平滑变化）。</p><p><img src="https://s1.imagehub.cc/images/2025/04/15/984fb8180a3715627a8214b8bbf62499.png" alt="随机矩阵对应的雪花图"></p><p>并且，我们很明显知道，<strong>图像像素点之间的关联性</strong>很大程度上会随着距离的增加而衰减，我们可以使用常见的衰减模型来刻画这种衰减的状态：</p><p>指数衰减：$y &#x3D; e^{-kx}$ 或者 幂函数衰减：$y &#x3D; \frac{1}{x^k}$</p><p>同时，图像还满足多种<strong>不变性</strong>：平移不变性，旋转不变性，视点不变性，大小伸缩不变性…</p><p>因此，我们可以联想到，<strong>选择合适的核函数</strong>进行卷积运算是否可以实现图像特征的提取？答案是肯定的，我们不妨来看下面的例子：<strong>边缘检测</strong>。</p><h3 id="边缘检测"><a href="#边缘检测" class="headerlink" title="边缘检测"></a>边缘检测</h3><p><img src="https://s1.imagehub.cc/images/2025/04/15/339343f50534cbc97d20c228d803e8fc.png" alt="image"></p><p>我们继续从<strong>音频识别</strong>的例子出发，卷积的本质就是<strong>加权平均</strong>，同时，图像相邻位置的像素点的值之间具有<strong>关联性</strong>，因此，我们可以使用**$3 \times 3$<strong>的卷积核，作为上文的卷积核函数。（这里是</strong>离散卷积**）</p><p>我们知道<strong>边缘</strong>区域代表着<strong>更加显著</strong>的亮度变化，因此，如果我们施加这样的卷积核：</p><p>$$\begin{bmatrix}-1 &amp; 0  &amp; 1 \\ -1 &amp; 0  &amp; 1 \\ -1 &amp; 0  &amp; 1 \end{bmatrix}$$</p><p><strong>负值区域</strong>（左侧）会对图像的亮度降低贡献较大，而<strong>正值区域</strong>（右侧）则会对亮度增加贡献较大。因此，就可以把对应的梯度特征给卷积出来，同理，我们也可以有对纵向的卷积核。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">Author: Xiyuan Yang   xiyuan_yang@outlook.com</span><br><span class="hljs-string">Date: 2025-04-15 00:28:15</span><br><span class="hljs-string">LastEditors: Xiyuan Yang   xiyuan_yang@outlook.com</span><br><span class="hljs-string">LastEditTime: 2025-04-15 00:29:55</span><br><span class="hljs-string">FilePath: /CNN-tutorial/src/convolution_demo.py</span><br><span class="hljs-string">Description:</span><br><span class="hljs-string">Do you code and make progress today?</span><br><span class="hljs-string">Copyright (c) 2025 by Xiyuan Yang, All Rights Reserved.</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torch.nn.functional <span class="hljs-keyword">as</span> F<br><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image<br><span class="hljs-keyword">import</span> torchvision.transforms <span class="hljs-keyword">as</span> transforms<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> matplotlib <span class="hljs-keyword">as</span> mlp<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br>mlp.use(<span class="hljs-string">&quot;Agg&quot;</span>)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">apply_convolution</span>(<span class="hljs-params">image_path, kernel, name</span>):<br>    <span class="hljs-comment"># 打开图片并转换为灰度图</span><br>    image = Image.<span class="hljs-built_in">open</span>(image_path).convert(<span class="hljs-string">&quot;L&quot;</span>)<br><br>    <span class="hljs-comment"># 转换为张量</span><br>    transform_to_tensor = transforms.ToTensor()<br>    image_tensor = transform_to_tensor(image).unsqueeze(<span class="hljs-number">0</span>)  <span class="hljs-comment"># 增加批次维度 (1, 1, H, W)</span><br><br>    <span class="hljs-comment"># 卷积操作</span><br>    kernel_tensor = (<br>        torch.tensor(kernel, dtype=torch.float32).unsqueeze(<span class="hljs-number">0</span>).unsqueeze(<span class="hljs-number">0</span>)<br>    )  <span class="hljs-comment"># (1, 1, 3, 3)</span><br>    convolved_image = F.conv2d(image_tensor, kernel_tensor, padding=<span class="hljs-number">1</span>)  <span class="hljs-comment"># 保持尺寸</span><br><br>    <span class="hljs-comment"># 转换回 NumPy 数组以便显示</span><br>    convolved_image_np = convolved_image.squeeze().detach().numpy()<br><br>    <span class="hljs-comment"># 显示原图和卷积后的图像</span><br>    plt.subplot(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>)<br>    plt.title(<span class="hljs-string">&quot;Original Image&quot;</span>)<br>    plt.imshow(image, cmap=<span class="hljs-string">&quot;gray&quot;</span>)<br><br>    plt.subplot(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>)<br>    plt.title(<span class="hljs-string">&quot;Convolved Image&quot;</span>)<br>    plt.imshow(convolved_image_np, cmap=<span class="hljs-string">&quot;gray&quot;</span>)<br>    plt.savefig(<span class="hljs-string">f&quot;img/Convolved_img <span class="hljs-subst">&#123;name&#125;</span>.png&quot;</span>)<br>    plt.close()<br><br><br><span class="hljs-comment"># 示例调用</span><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-comment"># 定义 3x3 卷积核（例如边缘检测）</span><br>    kernel_1 = [[-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>], [-<span class="hljs-number">1</span>, <span class="hljs-number">8</span>, -<span class="hljs-number">1</span>], [-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>]]<br>    kernel_2 = [[<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">0</span>], [-<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, -<span class="hljs-number">1</span>], [<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">0</span>]]<br>    kernel_3 = [[<span class="hljs-number">1</span> / <span class="hljs-number">9</span>, <span class="hljs-number">1</span> / <span class="hljs-number">9</span>, <span class="hljs-number">1</span> / <span class="hljs-number">9</span>], [<span class="hljs-number">1</span> / <span class="hljs-number">9</span>, <span class="hljs-number">1</span> / <span class="hljs-number">9</span>, <span class="hljs-number">1</span> / <span class="hljs-number">9</span>], [<span class="hljs-number">1</span> / <span class="hljs-number">9</span>, <span class="hljs-number">1</span> / <span class="hljs-number">9</span>, <span class="hljs-number">1</span> / <span class="hljs-number">9</span>]]<br>    kernel_4 = [[-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>], [-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>], [-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>]]<br>    kernel_5 = np.random.randn(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>)<br>    kernel_5 = kernel_5 / kernel_5.<span class="hljs-built_in">sum</span>()<br>    kernel_6 = np.identity(<span class="hljs-number">3</span>) / <span class="hljs-number">3</span><br>    kernel_7 = [[-<span class="hljs-number">2</span>, -<span class="hljs-number">3</span>, -<span class="hljs-number">2</span>], [-<span class="hljs-number">3</span>, <span class="hljs-number">21</span>, -<span class="hljs-number">3</span>], [-<span class="hljs-number">2</span>, -<span class="hljs-number">3</span>, -<span class="hljs-number">2</span>]]<br><br>    <span class="hljs-comment"># 替换为您本地的图片路径</span><br>    image_path = <span class="hljs-string">&quot;img/demo_cat.jpg&quot;</span>  <span class="hljs-comment"># 请确保路径正确</span><br>    apply_convolution(image_path, kernel_1, <span class="hljs-string">&quot;edge_detection&quot;</span>)<br>    apply_convolution(image_path, kernel_2, <span class="hljs-string">&quot;sharpen&quot;</span>)<br>    apply_convolution(image_path, kernel_3, <span class="hljs-string">&quot;normalize&quot;</span>)<br>    apply_convolution(image_path, kernel_4, <span class="hljs-string">&quot;edge_detect2&quot;</span>)<br>    apply_convolution(image_path, kernel_5, <span class="hljs-string">&quot;just for fun&quot;</span>)<br>    apply_convolution(image_path, kernel_6, <span class="hljs-string">&quot;kernel6&quot;</span>)<br>    apply_convolution(image_path, kernel_7, <span class="hljs-string">&quot;kernel_7&quot;</span>)<br><br>    <span class="hljs-comment"># the usage of surbo kernel</span><br>    kernel_surbo_1 = [[-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>], [-<span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>], [-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>]]<br>    kernel_surbo_2 = [[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>], [-<span class="hljs-number">1</span>, -<span class="hljs-number">2</span>, -<span class="hljs-number">2</span>]]<br>    apply_convolution(image_path, kernel_surbo_1, <span class="hljs-string">&quot;surbo_1&quot;</span>)<br>    apply_convolution(image_path, kernel_surbo_2, <span class="hljs-string">&quot;surbo_2&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="卷积的数学运算"><a href="#卷积的数学运算" class="headerlink" title="卷积的数学运算"></a>卷积的数学运算</h3><p>在图像卷积中，我们会使用<strong>卷积函数的二维离散形式</strong>：</p><p>$$F(x,y) &#x3D; \sum_{u,v} f(x-u,y-v)g(u,v)$$</p><p>$$F(x,y) &#x3D; \int f(x-u,y-v)g(u,v) \mathrm{d}u \mathrm{d}v$$</p><p>这里$g(u,v)$代表我们之前使用的$3 \times 3$的卷积核。</p><p><img src="https://s1.imagehub.cc/images/2025/04/15/852f706ca8313ad8d5d81a1d0ed3c2b0.png" alt="图像卷积的数学运算"></p><blockquote><p>这里就是一个非常经典的<strong>二维图像</strong>的滑动窗口！</p></blockquote><p>在卷积扫一遍之后，就会得到一张新的图像，这也就是我们上文展示的<strong>图像过卷积</strong>。</p><div class="note note-primary">            <p><strong>Zero Padding</strong>：解决图像过卷积的问题</p><p>对于<strong>边缘</strong>的像素块，为了防止其在卷积之后被剪裁，我们需要<strong>适当扩展图像的size</strong>，例如这样：</p><p><img src="https://s1.imagehub.cc/images/2025/04/15/facae81e4da98908c65b8cb1ee318691.png" alt="Zero Padding"></p>          </div><p>在定义好卷积核函数之后（一个<strong>可训练的矩阵</strong>），我们终于可以<strong>移动滑动窗口</strong>了，这一个过程叫<strong>跨步（Stride）</strong>。$stride(i,j)$表示单次操作中横向移动$i$步，纵向移动$j$步。</p><p>同时，对于彩色图像，我们需要对RGB三个通道进行<strong>多通道卷积</strong>，不过为了简单起见，我们这里只考虑黑白单通道图像。</p><h2 id="卷积神经网络"><a href="#卷积神经网络" class="headerlink" title="卷积神经网络"></a>卷积神经网络</h2><p>终于，我们迎来了今天的主角，<strong>卷积神经网络</strong>！</p><h4 id="生物学灵感"><a href="#生物学灵感" class="headerlink" title="生物学灵感"></a>生物学灵感</h4><p><strong>局部感受野</strong>：生物视觉系统中的神经元通常只对视野中的小区域敏感，这被称为局部感受野。CNN 中的卷积层通过卷积操作模拟了这一特性，允许网络在局部区域内提取特征。</p><p>因此，我们可以尝试<strong>将卷积结构带入到神经网络中</strong>，因为单纯的全连接网络在小数据量的情况下很容易过拟合，无法<strong>识别图像的真正特征</strong>。</p><h4 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h4><p>一个标准的卷积神经网络（Convolutional Neural Network, CNN）通常由以下几个模块构成：</p><ul><li>卷积层（Convolutional Layer） —— 简单细胞</li><li>池化层（Pooling Layer）</li><li>全连接层（Fully-Connected Layer）—— 复杂细胞</li><li>输出层（Output Layer）</li></ul><p>在接下来的部分，我们将具体介绍每一个网络层的应用。</p><h2 id="网络结构详解"><a href="#网络结构详解" class="headerlink" title="网络结构详解"></a>网络结构详解</h2><p>在这个部分，我们将会<strong>AlexNet</strong>为基础，介绍最基本的卷积神经网络的<strong>搭建</strong>和<strong>训练</strong>的过程。</p><p>先上代码（网络结构）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">Author: Xiyuan Yang   xiyuan_yang@outlook.com</span><br><span class="hljs-string">Date: 2025-04-15 14:40:20</span><br><span class="hljs-string">LastEditors: Xiyuan Yang   xiyuan_yang@outlook.com</span><br><span class="hljs-string">LastEditTime: 2025-04-15 14:41:31</span><br><span class="hljs-string">FilePath: /CNN-tutorial/src/AlexNet.py</span><br><span class="hljs-string">Description:</span><br><span class="hljs-string">Do you code and make progress today?</span><br><span class="hljs-string">Copyright (c) 2025 by Xiyuan Yang, All Rights Reserved.</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn<br><span class="hljs-keyword">import</span> torch.nn.functional <span class="hljs-keyword">as</span> F<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AlexNet</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, num_classes=<span class="hljs-number">1000</span></span>):<br>        <span class="hljs-built_in">super</span>(AlexNet, <span class="hljs-variable language_">self</span>).__init__()<br><br>        <span class="hljs-comment"># Define the convolutional layers</span><br>        <span class="hljs-variable language_">self</span>.features = nn.Sequential(<br>            <span class="hljs-comment"># First convolutional layer: 3 input channels, 64 output channels, kernel size 11x11, stride 4, padding 2</span><br>            nn.Conv2d(<span class="hljs-number">3</span>, <span class="hljs-number">64</span>, kernel_size=<span class="hljs-number">11</span>, stride=<span class="hljs-number">4</span>, padding=<span class="hljs-number">2</span>),<br>            nn.ReLU(inplace=<span class="hljs-literal">True</span>),<br>            nn.MaxPool2d(kernel_size=<span class="hljs-number">3</span>, stride=<span class="hljs-number">2</span>),<br>            <span class="hljs-comment"># Second convolutional layer: 64 input channels, 192 output channels, kernel size 5x5, padding 2</span><br>            nn.Conv2d(<span class="hljs-number">64</span>, <span class="hljs-number">192</span>, kernel_size=<span class="hljs-number">5</span>, padding=<span class="hljs-number">2</span>),<br>            nn.ReLU(inplace=<span class="hljs-literal">True</span>),<br>            nn.MaxPool2d(kernel_size=<span class="hljs-number">3</span>, stride=<span class="hljs-number">2</span>),<br>            <span class="hljs-comment"># Third convolutional layer: 192 input channels, 384 output channels, kernel size 3x3, padding 1</span><br>            nn.Conv2d(<span class="hljs-number">192</span>, <span class="hljs-number">384</span>, kernel_size=<span class="hljs-number">3</span>, padding=<span class="hljs-number">1</span>),<br>            nn.ReLU(inplace=<span class="hljs-literal">True</span>),<br>            <span class="hljs-comment"># Fourth convolutional layer: 384 input channels, 256 output channels, kernel size 3x3, padding 1</span><br>            nn.Conv2d(<span class="hljs-number">384</span>, <span class="hljs-number">256</span>, kernel_size=<span class="hljs-number">3</span>, padding=<span class="hljs-number">1</span>),<br>            nn.ReLU(inplace=<span class="hljs-literal">True</span>),<br>            <span class="hljs-comment"># Fifth convolutional layer: 256 input channels, 256 output channels, kernel size 3x3, padding 1</span><br>            nn.Conv2d(<span class="hljs-number">256</span>, <span class="hljs-number">256</span>, kernel_size=<span class="hljs-number">3</span>, padding=<span class="hljs-number">1</span>),<br>            nn.ReLU(inplace=<span class="hljs-literal">True</span>),<br>            nn.MaxPool2d(kernel_size=<span class="hljs-number">3</span>, stride=<span class="hljs-number">2</span>),<br>        )<br><br>        <span class="hljs-comment"># Define the fully connected layers</span><br>        <span class="hljs-variable language_">self</span>.classifier = nn.Sequential(<br>            nn.Dropout(),<br>            nn.Linear(<span class="hljs-number">256</span> * <span class="hljs-number">6</span> * <span class="hljs-number">6</span>, <span class="hljs-number">4096</span>),  <span class="hljs-comment"># Flattened feature map size is 256 * 6 * 6</span><br>            nn.ReLU(inplace=<span class="hljs-literal">True</span>),<br>            nn.Dropout(),<br>            nn.Linear(<span class="hljs-number">4096</span>, <span class="hljs-number">4096</span>),<br>            nn.ReLU(inplace=<span class="hljs-literal">True</span>),<br>            nn.Linear(<span class="hljs-number">4096</span>, num_classes),<br>        )<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x</span>):<br>        <span class="hljs-comment"># Pass input through the convolutional layers</span><br>        x = <span class="hljs-variable language_">self</span>.features(x)<br><br>        <span class="hljs-comment"># Flatten the output for the fully connected layers</span><br>        x = torch.flatten(x, <span class="hljs-number">1</span>)<br><br>        <span class="hljs-comment"># Pass through the fully connected layers</span><br>        x = <span class="hljs-variable language_">self</span>.classifier(x)<br>        <span class="hljs-keyword">return</span> x<br><br><br><span class="hljs-comment"># Example usage</span><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-comment"># Create an instance of AlexNet with 1000 output classes (default for ImageNet)</span><br>    model = AlexNet(num_classes=<span class="hljs-number">1000</span>)<br><br>    <span class="hljs-comment"># Print the model architecture</span><br>    <span class="hljs-built_in">print</span>(model)<br><br>    <span class="hljs-comment"># Test with a random input tensor (batch size 1, 3 channels, 224x224 image)</span><br>    input_tensor = torch.randn(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">224</span>, <span class="hljs-number">224</span>)<br>    output = model(input_tensor)<br>    <span class="hljs-built_in">print</span>(output.shape)  <span class="hljs-comment"># Should output torch.Size([1, 1000])</span><br><br></code></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs routeros">AlexNet(<br>  (features): Sequential(<br>    (0): Conv2d(3, 64, kernel_size=(11, 11), stride=(4, 4), padding=(2, 2))<br>    (1): ReLU(<span class="hljs-attribute">inplace</span>=<span class="hljs-literal">True</span>)<br>    (2): MaxPool2d(<span class="hljs-attribute">kernel_size</span>=3, <span class="hljs-attribute">stride</span>=2, <span class="hljs-attribute">padding</span>=0, <span class="hljs-attribute">dilation</span>=1, <span class="hljs-attribute">ceil_mode</span>=<span class="hljs-literal">False</span>)<br>    (3): Conv2d(64, 192, kernel_size=(5, 5), stride=(1, 1), padding=(2, 2))<br>    (4): ReLU(<span class="hljs-attribute">inplace</span>=<span class="hljs-literal">True</span>)<br>    (5): MaxPool2d(<span class="hljs-attribute">kernel_size</span>=3, <span class="hljs-attribute">stride</span>=2, <span class="hljs-attribute">padding</span>=0, <span class="hljs-attribute">dilation</span>=1, <span class="hljs-attribute">ceil_mode</span>=<span class="hljs-literal">False</span>)<br>    (6): Conv2d(192, 384, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))<br>    (7): ReLU(<span class="hljs-attribute">inplace</span>=<span class="hljs-literal">True</span>)<br>    (8): Conv2d(384, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))<br>    (9): ReLU(<span class="hljs-attribute">inplace</span>=<span class="hljs-literal">True</span>)<br>    (10): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))<br>    (11): ReLU(<span class="hljs-attribute">inplace</span>=<span class="hljs-literal">True</span>)<br>    (12): MaxPool2d(<span class="hljs-attribute">kernel_size</span>=3, <span class="hljs-attribute">stride</span>=2, <span class="hljs-attribute">padding</span>=0, <span class="hljs-attribute">dilation</span>=1, <span class="hljs-attribute">ceil_mode</span>=<span class="hljs-literal">False</span>)<br>  )<br>  (classifier): Sequential(<br>    (0): Dropout(<span class="hljs-attribute">p</span>=0.5, <span class="hljs-attribute">inplace</span>=<span class="hljs-literal">False</span>)<br>    (1): Linear(<span class="hljs-attribute">in_features</span>=9216, <span class="hljs-attribute">out_features</span>=4096, <span class="hljs-attribute">bias</span>=<span class="hljs-literal">True</span>)<br>    (2): ReLU(<span class="hljs-attribute">inplace</span>=<span class="hljs-literal">True</span>)<br>    (3): Dropout(<span class="hljs-attribute">p</span>=0.5, <span class="hljs-attribute">inplace</span>=<span class="hljs-literal">False</span>)<br>    (4): Linear(<span class="hljs-attribute">in_features</span>=4096, <span class="hljs-attribute">out_features</span>=4096, <span class="hljs-attribute">bias</span>=<span class="hljs-literal">True</span>)<br>    (5): ReLU(<span class="hljs-attribute">inplace</span>=<span class="hljs-literal">True</span>)<br>    (6): Linear(<span class="hljs-attribute">in_features</span>=4096, <span class="hljs-attribute">out_features</span>=1000, <span class="hljs-attribute">bias</span>=<span class="hljs-literal">True</span>)<br>  )<br>)<br>torch.Size([1, 1000])<br></code></pre></td></tr></table></figure><h3 id="Input-Layer"><a href="#Input-Layer" class="headerlink" title="Input Layer"></a>Input Layer</h3><p>首先，对于一个CNN，输入是<strong>图片</strong>，单张图片embedding为矩阵的形式就是$224 \times 224 \times 3$的张量。（<strong>张量</strong>可以理解为是一种高维形式下的矩阵）。同时，模型可以一次输入<strong>多张图片</strong>，记为$N$,批量大小（同时处理的图片数量）。</p><div class="note note-info">            <p>在深度学习中，通常用四个字母来表示<strong>多维张量的不同维度</strong>，尤其是在处理图像数据时。对于 AlexNet 输入的形状 ($N \times 224 \times 224 \times 3$)，这些字母通常代表：</p><ul><li><strong>N</strong>: Batch size（批量大小）—— 一次输入到网络中的样本数量。</li><li><strong>C</strong>: Channels（通道数）—— 通常对于 RGB 图像来说是 3（红、绿、蓝）。</li><li><strong>H</strong>: Height（高度）—— 图像的高度，这里是 224 像素。</li><li><strong>W</strong>: Width（宽度）—— 图像的宽度，这里也是 224 像素。</li></ul><p>因此，完整的表示可以是：</p><ul><li><strong>N</strong>: Batch size</li><li><strong>C</strong>: Channels</li><li><strong>H</strong>: Height</li><li><strong>W</strong>: Width</li></ul><p>在这种情况下，张量的形状可以表示为 ($N \times C \times H \times W$)，即 ($N \times 3 \times 224 \times 224$)。</p><p><strong>注意！</strong>批量指的是一次操作中输入的图片的数量，具体而言在训练细节中，指的是<strong>批量</strong>是指在一次前向传播和反向传播中处理的样本数量。比如，如果你有一个批量大小为 32 的训练集，那么在每次迭代中，模型将同时处理 32 张图像。批量反应的是<strong>GPU和模型并行处理图像的能力</strong>，但是对于网络结构而言，我们暂时不会考虑这一个参数（即每一次只研究一张图像）</p>          </div><h3 id="卷积层"><a href="#卷积层" class="headerlink" title="卷积层"></a>卷积层</h3><p>在输入层之后，就进入到了<code>Conv2d(3, 64, kernel_size=(11, 11), stride=(4, 4), padding=(2, 2))</code>的第一个卷积层。是一个$11 \times 11$的卷积核，$stride &#x3D; 4$（单次移动的步幅），同时会有一定的padding操作。</p><p>注意，这里还有一个参数<strong>64</strong>，代表着<strong>卷积核的通道数</strong>，换句话说可以理解为有多少个不同的卷积核在对这个图像做卷积。当我们说一个卷积层有 64 个输出通道时，意味着该层使用了 64 个卷积核。每个卷积核会生成一个特征图，所以最终会得到 64 个特征图。每个<strong>输出通道（特征图）</strong>捕捉输入数据的不同特征。例如，在图像处理中，一个卷积核可能专注于<strong>边缘检测</strong>，而另一个卷积核可能专注于<strong>纹理或颜色</strong>。</p><p>对于这个卷积层，其单个通道下的输出维度可以使用下面的函数进行计算：</p><p>$$Output Size&#x3D;\frac{Input Size−Kernel Size+2×Padding}{stride} + 1 &#x3D; 55$$</p><p>在这里，$Inputsize &#x3D; 224$, $KernelSize &#x3D; 11$, $Padding &#x3D; 2$, $stride &#x3D; 4$。</p><p>因此输出张量的维度 $(64,55,55)$。</p><h3 id="ReLU"><a href="#ReLU" class="headerlink" title="ReLU"></a>ReLU</h3><h3 id="池化层"><a href="#池化层" class="headerlink" title="池化层"></a>池化层</h3><h3 id="全连接层"><a href="#全连接层" class="headerlink" title="全连接层"></a>全连接层</h3><h3 id="Output-Layer"><a href="#Output-Layer" class="headerlink" title="Output Layer"></a>Output Layer</h3>]]></content>
    
    
    <categories>
      
      <category>Artificial Intelligence</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Artificial Intelligence</tag>
      
      <tag>Deep Learning</tag>
      
      <tag>Convolutional Neural Networks</tag>
      
      <tag>AlexNet</tag>
      
      <tag>Image Clssification</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Modern C++</title>
    <link href="/posts/Modern-C/"/>
    <url>/posts/Modern-C/</url>
    
    <content type="html"><![CDATA[<style>  html, body, .markdown-body {    font-family: Georgia, sans, serif;  }</style><h1 id="Modern-C"><a href="#Modern-C" class="headerlink" title="Modern C++"></a>Modern C++</h1><h2 id="What-is-Modern-Cpp"><a href="#What-is-Modern-Cpp" class="headerlink" title="What is Modern Cpp?"></a>What is Modern Cpp?</h2><p>现代C++通常指的是<strong>C++11</strong>及其后续版本（最新：C++23）。在这些C++版本中，引入了更多新的特性和改进，让C++更加的灵活并且高效。下面该文将具体介绍一些常见的并且强大的C++特性，包括：</p><ul><li>**移动语义和<code>std::move</code>**。</li><li><strong>Type inference</strong>和<strong>完美转发</strong></li><li><code>auto</code></li><li><strong>智能指针</strong>（重点）</li><li><code>std::any</code></li><li><code>std::optional</code></li><li><code>rust</code>初步介绍🤣</li></ul><h2 id="std-move-and-value-types"><a href="#std-move-and-value-types" class="headerlink" title="std::move and value types"></a><code>std::move</code> and value types</h2><ul><li>左值和右值<ul><li>对于赋值运算符的重载，只可以对左值使用。</li><li><strong>对于右值</strong>？我们希望实现移动而非拷贝，来减少不必要的拷贝。</li></ul></li></ul><p><code>std::move</code> 会让编译器相信<strong>一个左值是一个右值</strong>。（直接移动所有权而非拷贝。）</p><p><strong>注意</strong>：在使用<code>std::move</code>之后对应的变量，不可以再使用。（因为所有权已经被移动）</p><ul><li><code>const</code>变量不可以使用移动语义。</li><li>编译器有时会自动做优化。</li><li>因此，在设计自己的类的使用，需要设计对应的<strong>Copy assignment for lvalue</strong> and <strong>Move assignment for rvalue</strong>.</li></ul><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><h4 id="函数调用时避免复制"><a href="#函数调用时避免复制" class="headerlink" title="函数调用时避免复制"></a>函数调用时避免复制</h4><p>如果一个变量<strong>我们在传参进入函数之后就不再使用</strong>，可以使用<code>std::move()</code>来实现移动构造。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Fun</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt; v1, std::vector&lt;<span class="hljs-type">int</span>&gt; v2)</span> </span>&#123;<br><span class="hljs-comment">// Use vector(const vector &amp;other) as constructor</span><br><span class="hljs-built_in">Foo</span>(v1);<br><span class="hljs-comment">// v1 can still be used after this</span><br><span class="hljs-comment">// Use vector(vector &amp;&amp;other) as constructor</span><br><span class="hljs-built_in">Foo</span>(std::<span class="hljs-built_in">move</span>(v2));<br><span class="hljs-comment">// v2 cannot be used after this</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Move-assignment-for-rvalue"><a href="#Move-assignment-for-rvalue" class="headerlink" title="Move assignment for rvalue"></a>Move assignment for rvalue</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @Author: Xiyuan Yang   xiyuan_yang@outlook.com</span><br><span class="hljs-comment"> * @Date: 2025-04-13 18:54:39</span><br><span class="hljs-comment"> * @LastEditors: Xiyuan Yang   xiyuan_yang@outlook.com</span><br><span class="hljs-comment"> * @LastEditTime: 2025-04-13 23:35:26</span><br><span class="hljs-comment"> * @FilePath: /20250413_modern_cpp/move.cpp</span><br><span class="hljs-comment"> * @Description:</span><br><span class="hljs-comment"> * Do you code and make progress today?</span><br><span class="hljs-comment"> * Copyright (c) 2025 by Xiyuan Yang, All Rights Reserved.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span> <span class="hljs-comment">// for std::move</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Buffer</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Buffer</span>(<span class="hljs-type">size_t</span> size) : <span class="hljs-built_in">data</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[size]), <span class="hljs-built_in">size</span>(size) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Buffer allocated\n&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * @brief Construct a new Buffer object</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param other </span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-built_in">Buffer</span>(Buffer&amp;&amp; other) <span class="hljs-keyword">noexcept</span> : <span class="hljs-built_in">data</span>(other.data), <span class="hljs-built_in">size</span>(other.size) &#123;<br>        other.data = <span class="hljs-literal">nullptr</span>; <br>        other.size = <span class="hljs-number">0</span>;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Buffer moved\n&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * @brief Assignment for rvalue</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param other </span><br><span class="hljs-comment">     * @return Buffer&amp; </span><br><span class="hljs-comment">     */</span><br>    Buffer&amp; <span class="hljs-keyword">operator</span>=(Buffer&amp;&amp; other) <span class="hljs-keyword">noexcept</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;other) &#123;<br>            <span class="hljs-keyword">delete</span>[] data; <span class="hljs-comment">// 释放当前资源</span><br>            data = other.data; <span class="hljs-comment">// 转移所有权</span><br>            size = other.size;<br>            other.data = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// 让其他对象失去对资源的所有权</span><br>            other.size = <span class="hljs-number">0</span>;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;Buffer moved (assignment)\n&quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    ~<span class="hljs-built_in">Buffer</span>() &#123;<br>        <span class="hljs-keyword">delete</span>[] data; <span class="hljs-comment">// 释放资源</span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Buffer deallocated\n&quot;</span>;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span>* data;<br>    <span class="hljs-type">size_t</span> size;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">Buffer <span class="hljs-title">buf1</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br><br>    Buffer buf2 = std::<span class="hljs-built_in">move</span>(buf1); <br>    <br><br>    <span class="hljs-function">Buffer <span class="hljs-title">buf3</span><span class="hljs-params">(<span class="hljs-number">20</span>)</span></span>;<br>    buf3 = std::<span class="hljs-built_in">move</span>(buf2); <br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>我们没有必要<strong>对本身就是右值</strong>的数进行移动语义。</li><li>不要使用**const &amp;&amp;**。<ul><li>在 C++ 中，移动语义的核心思想是转移资源的所有权，而不是复制资源。移动操作通常涉及修改对象的内部状态（例如，转移指针、清空资源等）。因此，对于 <code>const</code> 对象，移动语义无法正常工作，因为<code>const</code> 关键字用于指示对象的值不能被修改。对 <code>const</code> 对象进行任何修改操作，包括移动操作，都是不允许的。这意味着你不能改变 <code>const</code> 对象的内部状态，比如将指针设置为 <code>nullptr</code>。</li><li>移动构造函数和移动赋值运算符通常会执行以下操作：<ul><li>将源对象的资源（如指针）转移给目标对象。</li><li>将源对象的资源状态清空（例如，将指针设置为 <code>nullptr</code>）。</li></ul></li><li>对于 <code>const</code> 对象，无法执行这些操作，因为它们的状态是不可变的。例如，尝试将一个 <code>const</code> 对象的指针设置为 <code>nullptr</code> 会导致编译错误。</li></ul></li></ul><h3 id="Applications"><a href="#Applications" class="headerlink" title="Applications"></a>Applications</h3><p>链接：<a href="https://acm.sjtu.edu.cn/OnlineJudge/problem/2641">https://acm.sjtu.edu.cn/OnlineJudge/problem/2641</a></p><div class="note note-primary">            <p>stargazer 最近正在学习 Rust 语言的所有权机制与内存安全特性。</p><p>Rust 的所有权机制要求每个值都有唯一的所有者（通常是变量），并且在同一时间内只能有一个所有者。所有权的转移可以通过赋值、函数参数传递或返回值来实现。相当于 C++ 中的移动语义（<code>std::move()</code>）。</p><p>在一个值的所有者变量的作用域之外（例如在另外一个函数中）对该值的访问必须通过借用（相当于 C++ 中指向变量的指针）来实现。Rust 中的借用分为两种：</p><ul><li>不可变借用（Immutable Borrow）：相当于 C++ 中的 <code>const T*</code>，允许读取但不允许修改</li><li>可变借用（Mutable Borrow）：相当于 C++ 中的 <code>T*</code>，允许读取和修改</li></ul><p>Rust 对变量的借用有着严格的限制：</p><ul><li>在同一时间内，只能有一个可变借用，或者多个不可变借用</li><li>不能同时存在可变借用和不可变借用</li><li>所有借用都必须在拥有变量的生命周期内有效 对以上规则的违反会导致编译错误。</li></ul><p>Rust 的借用机制对编译器优化非常有帮助。由于不可变借用不能与可变借用共存，被不可变借用指向的值只需要从堆内存中获取一次，之后可以安全地存储在寄存器或栈上缓存中。相比之下，C++ 中也进行类似的优化，但其他函数修改 <code>const*</code> 指针指向的值是未定义行为，可能导致不安全的代码。</p><p>Rust 的编译器可以在编译时就能“静态”地检查所有权和借用关系，在运行时无需额外检查。然而，对于堆上对象，在编译期检查所有权和借用关系是非常困难的。因此，Rust 提供了 <code>RefCell&lt;T&gt;</code> 类型来在运行时检查所有权和借用关系。它有如下方法：</p><ul><li><code>borrow()</code> 与 <code>try_borrow()</code>：获取一个不可变借用，返回 <code>Ref&lt;T&gt;</code> 类型。如果当前存在可变借用则失败。<code>borrow()</code> 会 panic，相当于 C++ 中的 abort，而 <code>try_borrow()</code> 返回一个 <code>Result&lt;Ref&lt;T&gt;, BorrowError&gt;</code>，相当于 C++ 中的 <code>std::optional&lt;Ref&lt;T&gt;&gt;</code>。</li><li><code>borrow_mut()</code> 与 <code>try_borrow_mut()</code>：获取一个可变借用，返回 <code>RefMut&lt;T&gt;</code> 类型。如果当前存在任何借用则会失败。</li><li>返回的 <code>Ref&lt;T&gt;</code> 和 <code>RefMut&lt;T&gt;</code> 包装器实现了解引用操作符，可以像使用普通引用一样使用</li><li>当 <code>Ref&lt;T&gt;</code> 和 <code>RefMut&lt;T&gt;</code> 的生命周期结束时，会自动减少或重置借用计数</li><li>当 <code>RefCell&lt;T&gt;</code> 的生命周期结束时，若仍有借用存在，则会 panic</li></ul><p>请借鉴 Rust 中的借用机制，在 C++ 中实现一个 <code>RefCell</code> 类。</p>          </div><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @Author: Xiyuan Yang   xiyuan_yang@outlook.com</span><br><span class="hljs-comment"> * @Date: 2025-04-06 20:47:27</span><br><span class="hljs-comment"> * @LastEditors: Xiyuan Yang   xiyuan_yang@outlook.com</span><br><span class="hljs-comment"> * @LastEditTime: 2025-04-07 09:51:11</span><br><span class="hljs-comment"> * @FilePath: /20250406_Test3/3.cpp</span><br><span class="hljs-comment"> * @Description: </span><br><span class="hljs-comment"> * Do you code and make progress today?</span><br><span class="hljs-comment"> * Copyright (c) 2025 by Xiyuan Yang, All Rights Reserved. </span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;optional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdexcept&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RefCellError</span> : <span class="hljs-keyword">public</span> std::runtime_error &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">RefCellError</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; message)</span> : std::runtime_error(message) &#123;</span>&#125;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">RefCellError</span>() = <span class="hljs-keyword">default</span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BorrowError</span> : <span class="hljs-keyword">public</span> RefCellError &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">BorrowError</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; message)</span> : RefCellError(message) &#123;</span>&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BorrowMutError</span> : <span class="hljs-keyword">public</span> RefCellError &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">BorrowMutError</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; message)</span> : RefCellError(message) &#123;</span>&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DestructionError</span> : <span class="hljs-keyword">public</span> RefCellError &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">DestructionError</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; message)</span> : RefCellError(message) &#123;</span>&#125;<br>&#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RefCell</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    T value;<br>    <span class="hljs-keyword">mutable</span> <span class="hljs-type">size_t</span> borrow_count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">mutable</span> <span class="hljs-type">size_t</span> borrow_mut_count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">mutable</span> <span class="hljs-type">bool</span> is_destroyed = <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">check_borrow</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (borrow_mut_count &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">BorrowError</span>(<span class="hljs-string">&quot;Invalid&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">check_borrow_mut</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (borrow_count &gt; <span class="hljs-number">0</span> || borrow_mut_count &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">BorrowMutError</span>(<span class="hljs-string">&quot;Invalid&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">check_destruction</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (borrow_count &gt; <span class="hljs-number">0</span> || borrow_mut_count &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">DestructionError</span>(<span class="hljs-string">&quot;Invalid&quot;</span>);<br>        &#125;<br>    &#125;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Ref</span>;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">RefMut</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">RefCell</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; initial_value)</span> : value(initial_value) &#123;</span>&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">RefCell</span><span class="hljs-params">(T&amp;&amp; initial_value)</span> : value(std::move(initial_value)) &#123;</span>&#125;<br><br>    <span class="hljs-built_in">RefCell</span>(<span class="hljs-type">const</span> RefCell&amp;) = <span class="hljs-keyword">delete</span>;<br>    RefCell&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> RefCell&amp;) = <span class="hljs-keyword">delete</span>;<br>    <span class="hljs-built_in">RefCell</span>(RefCell&amp;&amp;) = <span class="hljs-keyword">delete</span>;<br>    RefCell&amp; <span class="hljs-keyword">operator</span>=(RefCell&amp;&amp;) = <span class="hljs-keyword">delete</span>;<br><br>    <span class="hljs-function">Ref <span class="hljs-title">borrow</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-built_in">check_borrow</span>();<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Ref</span>(*<span class="hljs-keyword">this</span>);<br>    &#125;<br><br>    <span class="hljs-function">std::optional&lt;Ref&gt; <span class="hljs-title">try_borrow</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (borrow_mut_count &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> std::<span class="hljs-literal">nullopt</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Ref</span>(*<span class="hljs-keyword">this</span>);<br>    &#125;<br><br>    <span class="hljs-function">RefMut <span class="hljs-title">borrow_mut</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-built_in">check_borrow_mut</span>();<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">RefMut</span>(*<span class="hljs-keyword">this</span>);<br>    &#125;<br><br>    <span class="hljs-function">std::optional&lt;RefMut&gt; <span class="hljs-title">try_borrow_mut</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (borrow_count &gt; <span class="hljs-number">0</span> || borrow_mut_count &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> std::<span class="hljs-literal">nullopt</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">RefMut</span>(*<span class="hljs-keyword">this</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Ref</span> &#123;<br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-type">const</span> RefCell* parent;<br>        <span class="hljs-type">bool</span> valid = <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Ref</span><span class="hljs-params">(<span class="hljs-type">const</span> RefCell&amp; p)</span> : parent(&amp;p) &#123;</span><br>            parent-&gt;borrow_count++;<br>            valid = <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        ~<span class="hljs-built_in">Ref</span>() &#123;<br>            <span class="hljs-keyword">if</span> (valid) &#123;<br>                parent-&gt;borrow_count--;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-type">const</span> T&amp; <span class="hljs-keyword">operator</span>*() <span class="hljs-type">const</span> &#123;<br>            <span class="hljs-keyword">if</span> (!valid) <span class="hljs-keyword">throw</span> <span class="hljs-built_in">BorrowError</span>(<span class="hljs-string">&quot;Dangling reference&quot;</span>);<br>            <span class="hljs-keyword">return</span> parent -&gt; value;<br>        &#125;<br><br>        <span class="hljs-type">const</span> T* <span class="hljs-keyword">operator</span>-&gt;() <span class="hljs-type">const</span> &#123;<br>            <span class="hljs-keyword">if</span> (!valid) <span class="hljs-keyword">throw</span> <span class="hljs-built_in">BorrowError</span>(<span class="hljs-string">&quot;Dangling reference&quot;</span>);<br>            <span class="hljs-keyword">return</span> &amp;(parent -&gt; value);<br>        &#125;<br><br>        <span class="hljs-built_in">Ref</span>(<span class="hljs-type">const</span> Ref&amp; other) : <span class="hljs-built_in">parent</span>(other.parent), <span class="hljs-built_in">valid</span>(other.valid) &#123;<br>            <span class="hljs-keyword">if</span> (valid) &#123;<br>                parent-&gt;borrow_count++;<br>            &#125;<br>        &#125;<br><br>        Ref&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Ref&amp; other) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;other) &#123;<br>                <span class="hljs-keyword">if</span> (valid) &#123;<br>                    parent-&gt;borrow_count--;<br>                &#125;<br>                parent = other.parent;<br>                valid = other.valid;<br>                <span class="hljs-keyword">if</span> (valid) &#123;<br>                    parent-&gt;borrow_count++;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>        &#125;<br><br>        <span class="hljs-built_in">Ref</span>(Ref&amp;&amp; other) <span class="hljs-keyword">noexcept</span> : <span class="hljs-built_in">parent</span>(std::<span class="hljs-built_in">move</span>(other.parent)), <span class="hljs-built_in">valid</span>(std::<span class="hljs-built_in">move</span>(other.valid)) &#123;<br>            other.valid = <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        Ref&amp; <span class="hljs-keyword">operator</span>=(Ref&amp;&amp; other) <span class="hljs-keyword">noexcept</span> &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;other) &#123;<br>                <span class="hljs-keyword">if</span> (valid) &#123;<br>                    parent-&gt;borrow_count--;<br>                &#125;<br>                parent = std::<span class="hljs-built_in">move</span>(other.parent);<br>                valid = std::<span class="hljs-built_in">move</span>(other.valid);<br>                other.valid = <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">RefMut</span> &#123;<br>    <span class="hljs-keyword">private</span>:<br>        RefCell* parent;<br>        <span class="hljs-type">bool</span> valid = <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">RefMut</span><span class="hljs-params">(RefCell&amp; p)</span> : parent(&amp;p) &#123;</span><br>            parent-&gt;borrow_mut_count++;<br>            valid = <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        ~<span class="hljs-built_in">RefMut</span>() &#123;<br>            <span class="hljs-keyword">if</span> (valid) &#123;<br>                parent-&gt;borrow_mut_count--;<br>            &#125;<br>        &#125;<br><br>        T&amp; <span class="hljs-keyword">operator</span>*() &#123;<br>            <span class="hljs-keyword">if</span> (!valid) <span class="hljs-keyword">throw</span> <span class="hljs-built_in">BorrowMutError</span>(<span class="hljs-string">&quot;Dangling mutable reference&quot;</span>);<br>            <span class="hljs-keyword">return</span> parent-&gt;value;<br>        &#125;<br><br>        T* <span class="hljs-keyword">operator</span>-&gt;() &#123;<br>            <span class="hljs-keyword">if</span> (!valid) <span class="hljs-keyword">throw</span> <span class="hljs-built_in">BorrowMutError</span>(<span class="hljs-string">&quot;Dangling mutable reference&quot;</span>);<br>            <span class="hljs-keyword">return</span> &amp;parent-&gt;value;<br>        &#125;<br><br>        <span class="hljs-built_in">RefMut</span>(<span class="hljs-type">const</span> RefMut&amp;) = <span class="hljs-keyword">delete</span>;<br>        RefMut&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> RefMut&amp;) = <span class="hljs-keyword">delete</span>;<br><br>        <span class="hljs-built_in">RefMut</span>(RefMut&amp;&amp; other) <span class="hljs-keyword">noexcept</span> : <span class="hljs-built_in">parent</span>(other.parent), <span class="hljs-built_in">valid</span>(other.valid) &#123;<br>            other.valid = <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        RefMut&amp; <span class="hljs-keyword">operator</span>=(RefMut&amp;&amp; other) <span class="hljs-keyword">noexcept</span> &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;other) &#123;<br>                <span class="hljs-keyword">if</span> (valid) &#123;<br>                    parent-&gt;borrow_mut_count--;<br>                &#125;<br>                parent = other.parent;<br>                valid = other.valid;<br>                other.valid = <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>        &#125;<br>    &#125;;<br><br>    ~<span class="hljs-built_in">RefCell</span>() &#123;<br>        <span class="hljs-built_in">check_destruction</span>();<br>        is_destroyed = <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>例如，在这段代码中：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Ref&amp; <span class="hljs-keyword">operator</span>=(Ref&amp;&amp; other) <span class="hljs-keyword">noexcept</span> &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;other) &#123;<br>                <span class="hljs-keyword">if</span> (valid) &#123;<br>                    parent-&gt;borrow_count--;<br>                &#125;<br>                parent = std::<span class="hljs-built_in">move</span>(other.parent);<br>                valid = std::<span class="hljs-built_in">move</span>(other.valid);<br>                other.valid = <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>        &#125;<br></code></pre></td></tr></table></figure><p>对于借用，我们要严格保证<strong>所有权的独立性和严格管理</strong>，因此使用移动语义来保证所有权的移动而非复制。</p><h2 id="Type-inference-and-std-forward"><a href="#Type-inference-and-std-forward" class="headerlink" title="Type inference and std::forward"></a>Type inference and <code>std::forward</code></h2><p>对于模版函数，编译器会自动识别对应的模版参数T（但是，不可以识别右值）。</p><p>如何改进？可以使用 <code>const T&amp;</code>，并且，<strong>当一个右值被绑定到 <code>const</code> 引用时，右值的生命周期会被延长到引用的生命周期结束</strong>。这意味着在引用存在期间，右值不会被销毁。</p><blockquote><p>最简单的例子：我们写了很多遍的copy constructor.</p></blockquote><h3 id="Universal-Reference"><a href="#Universal-Reference" class="headerlink" title="Universal Reference"></a>Universal Reference</h3><p><strong>Universal References</strong>（通用引用）是 C++11 引入的一个重要概念，它允许编写可以接受左值和右值的模板参数。这个概念通常与完美转发（perfect forwarding）一起使用，使得函数模板能够有效地转发参数而不丢失其值类别（lvalue 或 rvalue）。</p><ul><li>C++的引用折叠：<code>int&amp; &amp;&amp;</code> -&gt; <code>int &amp;</code>（对于左值）</li></ul><blockquote><p>换句话说，左值还是左值，右值还是右值。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @Author: Xiyuan Yang   xiyuan_yang@outlook.com</span><br><span class="hljs-comment"> * @Date: 2025-04-14 00:03:41</span><br><span class="hljs-comment"> * @LastEditors: Xiyuan Yang   xiyuan_yang@outlook.com</span><br><span class="hljs-comment"> * @LastEditTime: 2025-04-14 00:13:32</span><br><span class="hljs-comment"> * @FilePath: /20250413_modern_cpp/universal.cpp</span><br><span class="hljs-comment"> * @Description:</span><br><span class="hljs-comment"> * Do you code and make progress today?</span><br><span class="hljs-comment"> * Copyright (c) 2025 by Xiyuan Yang, All Rights Reserved.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;type_traits&gt;</span></span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">(T &amp;&amp;param)</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(std::is_lvalue_reference&lt;T&gt;::value)</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;param is an lvalue&quot;</span> &lt;&lt; std::endl;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;param is an rvalue&quot;</span> &lt;&lt; std::endl;<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>  <span class="hljs-type">int</span> *b = &amp;a;<br>  <span class="hljs-type">const</span> <span class="hljs-type">int</span> *c = b;<br>  <span class="hljs-type">const</span> <span class="hljs-type">int</span> d = <span class="hljs-number">10</span>;<br><br>  std::cout &lt;&lt; <span class="hljs-string">&quot;Test for Universal reference&quot;</span> &lt;&lt; std::endl;<br>  <span class="hljs-built_in">test</span>(a);<br>  <span class="hljs-built_in">test</span>(a + <span class="hljs-number">1</span>);<br>  <span class="hljs-built_in">test</span>(b);<br>  <span class="hljs-built_in">test</span>(c);<br>  <span class="hljs-built_in">test</span>(d);<br>  <span class="hljs-built_in">test</span>(<span class="hljs-number">8</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>程序输出：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">Test <span class="hljs-keyword">for</span> Universal reference<br><span class="hljs-built_in">param</span> is <span class="hljs-keyword">an</span> lvalue<br><span class="hljs-built_in">param</span> is <span class="hljs-keyword">an</span> rvalue<br><span class="hljs-built_in">param</span> is <span class="hljs-keyword">an</span> lvalue<br><span class="hljs-built_in">param</span> is <span class="hljs-keyword">an</span> lvalue<br><span class="hljs-built_in">param</span> is <span class="hljs-keyword">an</span> lvalue<br><span class="hljs-built_in">param</span> is <span class="hljs-keyword">an</span> rvalue<br></code></pre></td></tr></table></figure><h3 id="std-forward"><a href="#std-forward" class="headerlink" title="std::forward"></a><code>std::forward</code></h3><p><code>std::forward</code>可以实现<strong>完美转发</strong>，即在模版参数中<strong>将参数原封不动地转发给其他函数，保持其原有的左值或者右值属性</strong>。</p><ul><li>Passes an rvalue: Ensures that an rvalue reference is passed.</li><li>Passes a const lvalue: Ensures that a const lvalue reference is passed.</li><li>Passes a non-const lvalue: Ensures that a non-const lvalue.</li></ul><p>有关<code>std::forward</code>的应用，我们在下面的例子中加以说明：</p><h4 id="为什么全是左值？"><a href="#为什么全是左值？" class="headerlink" title="为什么全是左值？"></a>为什么全是左值？</h4><p>请看下面的示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @Author: Xiyuan Yang   xiyuan_yang@outlook.com</span><br><span class="hljs-comment"> * @Date: 2025-04-13 19:07:20</span><br><span class="hljs-comment"> * @LastEditors: Xiyuan Yang   xiyuan_yang@outlook.com</span><br><span class="hljs-comment"> * @LastEditTime: 2025-04-14 00:18:51</span><br><span class="hljs-comment"> * @FilePath: /20250413_modern_cpp/forward.cpp</span><br><span class="hljs-comment"> * @Description:</span><br><span class="hljs-comment"> * Do you code and make progress today?</span><br><span class="hljs-comment"> * Copyright (c) 2025 by Xiyuan Yang, All Rights Reserved.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">A</span>(<span class="hljs-type">const</span> std::string &amp;s) : <span class="hljs-built_in">s_</span>(s) &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;const string &amp;&quot;</span> &lt;&lt; std::endl;<br>  &#125;<br>  <span class="hljs-built_in">A</span>(std::string &amp;&amp;s) : <span class="hljs-built_in">s_</span>(std::<span class="hljs-built_in">move</span>(s)) &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;string &amp;&amp;&quot;</span> &lt;&lt; std::endl;<br>  &#125;<br><br><span class="hljs-keyword">private</span>:<br>  std::string s_;<br>&#125;;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(T &amp;&amp;s)</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(std::is_lvalue_reference&lt;T&gt;::value)</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;param is an lvalue&quot;</span> &lt;&lt; std::endl;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;param is an rvalue&quot;</span> &lt;&lt; std::endl;<br>  &#125;<br>  <span class="hljs-function">A <span class="hljs-title">tmp</span><span class="hljs-params">(s)</span></span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  std::string a = <span class="hljs-string">&quot;111&quot;</span>;<br>  std::string b = <span class="hljs-string">&quot;222&quot;</span>;<br>  <span class="hljs-built_in">foo</span>(a);<br>  <span class="hljs-built_in">foo</span>(a + b);<br>  <span class="hljs-built_in">foo</span>(std::string&#123;<span class="hljs-string">&quot;111222&quot;</span>&#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>很惊讶的是，程序的输出竟然是这样：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">param <span class="hljs-keyword">is</span> an lvalue<br><span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp;<br>param <span class="hljs-keyword">is</span> an rvalue<br><span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp;<br>param <span class="hljs-keyword">is</span> an rvalue<br><span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp;<br></code></pre></td></tr></table></figure><p>为什么<strong>左值和右值都选择了使用const string&amp;<strong>？原因在于<code>const T&amp;</code>在构造函数中相比于右值构造具有更高的优先级。也就是说在const T&amp;存在的情况下，传递一个右值会将参数</strong>传递给左值const引用</strong>并且延长他的生命周期。但我们可以使用<code>std::forward</code>来强制保证 <strong>Passes an rvalue: Ensures that an rvalue reference is passed.</strong></p><p>具体而言，我们可以修改代码：<code>A tmp(std::forward&lt;T&gt;(s));</code></p><p>得到下面的输出示例：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">param <span class="hljs-keyword">is</span> an lvalue<br><span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp;<br>param <span class="hljs-keyword">is</span> an rvalue<br><span class="hljs-built_in">string</span> &amp;&amp;<br>param <span class="hljs-keyword">is</span> an rvalue<br><span class="hljs-built_in">string</span> &amp;&amp;<br></code></pre></td></tr></table></figure><h2 id="auto-reference"><a href="#auto-reference" class="headerlink" title="auto reference"></a><code>auto</code> reference</h2><p>自动类型推断：</p><ul><li><code>auto</code> 可以推出变量类型</li><li><code>auto &amp;</code> 可以推出引用类型</li><li><code>const auto &amp;</code> 可以推出常量引用</li></ul><p>同时，auto还支持对数组，元组的自动解包和打包。</p><p>同样的，我们也可以结合for循环中的代码使用auto：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::map&lt;<span class="hljs-type">int</span>, std::string&gt; <span class="hljs-title">GetMap</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">auto</span> map = <span class="hljs-built_in">GetMap</span>();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;[key, value] : map) &#123;&#125;<br><span class="hljs-comment">// Do something</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Smart-Pointer"><a href="#Smart-Pointer" class="headerlink" title="Smart Pointer"></a>Smart Pointer</h2><p>指针的使用经常伴随着<strong>内存泄漏</strong>的出现，例如如果我希望在堆内存上构造一个对象，我可以使用new来手动分配，但是<strong>我必须要在使用完成之后手动delete</strong>掉这段内存。这在代码逻辑比较复杂的时候经常会存在<strong>没有被delete的漏网之鱼</strong>出现。因此，现在C++提出了<strong>智能指针</strong>，实现了<strong>自动内存回收</strong>，保证了便捷性和安全性。</p><h3 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a><code>unique_ptr</code></h3><p>一个<strong>Move Only</strong>的智能指针，只可以拥有一个拥有者。</p><p>请看下面的代码示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @Author: Xiyuan Yang   xiyuan_yang@outlook.com</span><br><span class="hljs-comment"> * @Date: 2025-04-13 19:33:09</span><br><span class="hljs-comment"> * @LastEditors: Xiyuan Yang   xiyuan_yang@outlook.com</span><br><span class="hljs-comment"> * @LastEditTime: 2025-04-13 20:45:07</span><br><span class="hljs-comment"> * @FilePath: /20250413_modern_cpp/ptr.cpp</span><br><span class="hljs-comment"> * @Description:</span><br><span class="hljs-comment"> * Do you code and make progress today?</span><br><span class="hljs-comment"> * Copyright (c) 2025 by Xiyuan Yang, All Rights Reserved.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">test_unique</span> &#123;<br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">int</span> storage;<br>  std::string name;<br><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">test_unique</span>(<span class="hljs-type">int</span> a = <span class="hljs-number">1</span>, std::string name_ = <span class="hljs-string">&quot;Helloworld&quot;</span>)<br>      : <span class="hljs-built_in">storage</span>(a), <span class="hljs-built_in">name</span>(name_) &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Constructed&quot;</span> &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Name: &quot;</span> &lt;&lt; name &lt;&lt; std::endl;<br>  &#125;<br><br>  ~<span class="hljs-built_in">test_unique</span>() &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;This object&#x27;s name is &quot;</span> &lt;&lt; name &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Destructed&quot;</span> &lt;&lt; std::endl;<br>  &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-comment">// for unique ptr</span><br>  std::unique_ptr&lt;test_unique&gt; ptr1 =<br>      std::<span class="hljs-built_in">make_unique</span>&lt;test_unique&gt;(<span class="hljs-number">4</span>, <span class="hljs-string">&quot;Unique_ptr&quot;</span>);<br>  <span class="hljs-comment">// std::unique_ptr&lt;test_unique&gt; ptr2 = ptr1;</span><br><br>  <span class="hljs-keyword">if</span> (ptr1 == <span class="hljs-literal">nullptr</span>) &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;ptr1 is null now!&quot;</span> &lt;&lt; std::endl;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;ptr1 is not null now!&quot;</span> &lt;&lt; std::endl;<br>  &#125;<br><br>  std::unique_ptr&lt;test_unique&gt; ptr3 = std::<span class="hljs-built_in">move</span>(ptr1);<br><br>  <span class="hljs-keyword">if</span> (ptr1 == <span class="hljs-literal">nullptr</span>) &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;ptr1 is null now!&quot;</span> &lt;&lt; std::endl;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;ptr1 is not null now!&quot;</span> &lt;&lt; std::endl;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>程序的输出：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">Constructed<br><span class="hljs-type">Name</span>: Unique_ptr<br>ptr1 <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> now!<br>ptr1 <span class="hljs-keyword">is</span> <span class="hljs-keyword">null</span> now!<br>This <span class="hljs-keyword">object</span><span class="hljs-string">&#x27;s name is Unique_ptr</span><br><span class="hljs-string">Destructed</span><br></code></pre></td></tr></table></figure><p>代码的37行被注释掉了，因为如果不注释的话会在编译时报错。由上文代码可见，<strong>unique_ptr</strong>的关键在于它只有一个“主人”，因此它的所有权是独一无二的（就像rust一样）。因此，这会带来极大的安全性，并且可以实现内存的自动回收。</p><h4 id="RAII-Resource-Acquisition-is-Initialization"><a href="#RAII-Resource-Acquisition-is-Initialization" class="headerlink" title="RAII (Resource Acquisition is Initialization)"></a>RAII (Resource Acquisition is Initialization)</h4><p>RAII（Resource Acquisition Is Initialization）是一种管理资源的编程技术，广泛应用于 C++ 中。它的核心思想是将<strong>资源的生命周期与对象的生命周期</strong>绑定在一起，从而确保资源在对象创建时获取，并在对象销毁时自动释放。这种方法可以有效地避免<strong>资源泄漏和悬空指针</strong>等问题。</p><p><code>std::unique_ptr</code>就很好的满足了RAII的思想，它实现了 RAII 的原则，自动管理动态分配的内存。具体来说：</p><ol><li><strong>自动释放</strong>：当 <code>std::unique_ptr</code> 的生命周期结束时（即它被销毁），它会自动调用其管理的对象的析构函数，释放内存。</li><li><strong>独占所有权</strong>：<code>std::unique_ptr</code> 只能有一个所有者，防止多个指针同时管理同一块内存，避免了悬空指针和双重释放的问题。</li><li><strong>移动语义</strong>：<code>std::unique_ptr</code> 支持移动语义，可以通过 <code>std::move</code> 将所有权从一个指针转移到另一个指针，而不会发生复制。这符合 RAII 的设计理念。</li></ol><h3 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a><code>shared_ptr</code></h3><p><code>unique_ptr</code>非常高效地解决了安全问题（其具有极小的额外开销），但是安全性的保证势必会带来在便捷性上的约束。（<strong>这本质上就是一种权衡，不是吗（rust👀）</strong>）。而<code>shared_ptr</code><strong>允许多个指针共享同一资源</strong>，通过引用计数管理资源的生命周期。当最后一个指向资源的 <code>shared_ptr</code> 被销毁时，资源才会被释放。</p><p>我们实现相似的实例代码，看看这一次会怎么样。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @Author: Xiyuan Yang   xiyuan_yang@outlook.com</span><br><span class="hljs-comment"> * @Date: 2025-04-13 19:33:09</span><br><span class="hljs-comment"> * @LastEditors: Xiyuan Yang   xiyuan_yang@outlook.com</span><br><span class="hljs-comment"> * @LastEditTime: 2025-04-13 21:02:38</span><br><span class="hljs-comment"> * @FilePath: /20250413_modern_cpp/ptr.cpp</span><br><span class="hljs-comment"> * @Description:</span><br><span class="hljs-comment"> * Do you code and make progress today?</span><br><span class="hljs-comment"> * Copyright (c) 2025 by Xiyuan Yang, All Rights Reserved.</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">int</span> storage;<br>  std::string name;<br><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">test</span>(<span class="hljs-type">int</span> a = <span class="hljs-number">1</span>, std::string name_ = <span class="hljs-string">&quot;Helloworld&quot;</span>) : <span class="hljs-built_in">storage</span>(a), <span class="hljs-built_in">name</span>(name_) &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Constructed&quot;</span> &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Name: &quot;</span> &lt;&lt; name &lt;&lt; std::endl;<br>  &#125;<br><br>  ~<span class="hljs-built_in">test</span>() &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;This object&#x27;s name is &quot;</span> &lt;&lt; name &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Destructed&quot;</span> &lt;&lt; std::endl;<br>  &#125;<br><br>  <span class="hljs-function">std::string <span class="hljs-title">getname</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> name; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test_uniqued_ptr</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-comment">// for unique ptr</span><br>  std::unique_ptr&lt;test&gt; ptr1 = std::<span class="hljs-built_in">make_unique</span>&lt;test&gt;(<span class="hljs-number">4</span>, <span class="hljs-string">&quot;Unique_ptr&quot;</span>);<br>  <span class="hljs-comment">// std::unique_ptr&lt;test_unique&gt; ptr2 = ptr1;</span><br><br>  <span class="hljs-keyword">if</span> (ptr1 == <span class="hljs-literal">nullptr</span>) &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;ptr1 is null now!&quot;</span> &lt;&lt; std::endl;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;ptr1 is not null now!&quot;</span> &lt;&lt; std::endl;<br>  &#125;<br><br>  std::unique_ptr&lt;test&gt; ptr3 = std::<span class="hljs-built_in">move</span>(ptr1);<br><br>  <span class="hljs-keyword">if</span> (ptr1 == <span class="hljs-literal">nullptr</span>) &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;ptr1 is null now!&quot;</span> &lt;&lt; std::endl;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;ptr1 is not null now!&quot;</span> &lt;&lt; std::endl;<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test_shared_ptr</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-comment">// for shared ptr</span><br>  std::shared_ptr&lt;test&gt; ptr1 = std::<span class="hljs-built_in">make_shared</span>&lt;test&gt;(<span class="hljs-number">4</span>, <span class="hljs-string">&quot;Shared_ptr&quot;</span>);<br><br>  std::shared_ptr&lt;test&gt; ptr2 = ptr1;<br><br>  std::cout &lt;&lt; <span class="hljs-string">&quot;ptr1&#x27;s name &quot;</span> &lt;&lt; ptr1-&gt;<span class="hljs-built_in">getname</span>() &lt;&lt; std::endl;<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;ptr2&#x27;s name &quot;</span> &lt;&lt; ptr2-&gt;<span class="hljs-built_in">getname</span>() &lt;&lt; std::endl;<br><br>  <span class="hljs-keyword">if</span> (ptr1 == <span class="hljs-literal">nullptr</span>) &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;ptr1 is null now!&quot;</span> &lt;&lt; std::endl;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;ptr1 is not null now!&quot;</span> &lt;&lt; std::endl;<br>  &#125;<br><br>  std::shared_ptr&lt;test&gt; ptr3 = std::<span class="hljs-built_in">move</span>(ptr1);<br>  <br><br>  <span class="hljs-keyword">if</span> (ptr1 == <span class="hljs-literal">nullptr</span>) &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;ptr1 is null now!&quot;</span> &lt;&lt; std::endl;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;ptr1 is not null now!&quot;</span> &lt;&lt; std::endl;<br>  &#125;<br><br>  std::cout &lt;&lt; <span class="hljs-string">&quot;ptr3&#x27;s name &quot;</span> &lt;&lt; ptr3-&gt;<span class="hljs-built_in">getname</span>() &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//   test_uniqued_ptr();</span><br>  <span class="hljs-built_in">test_shared_ptr</span>();<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-number">3</span>_modern_cpp/<span class="hljs-string">&quot;ptr</span><br>Constructed<br>Name<span class="hljs-punctuation">:</span> Shared_ptr<br>ptr1&#x27;s name Shared_ptr<br>ptr2&#x27;s name Shared_ptr<br>ptr1 is not <span class="hljs-literal">null</span> now!<br>ptr1 is <span class="hljs-literal">null</span> now!<br>ptr3&#x27;s name Shared_ptr<br>This object&#x27;s name is Shared_ptr<br>Destructed<br></code></pre></td></tr></table></figure><p>我们发现在这里<code>std::shared_ptr&lt;test&gt; ptr2 = ptr1;</code>的操作是合法的。</p><h3 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a><code>weak_ptr</code></h3><p>在使用智能指针<code>shared_ptr</code>的时候，可能会存在<strong>循环引用</strong>的问题，例如智能指针a指向智能指针b，智能指针b指向智能指针a。此时两个智能指针的引用计数都不为1，此时存在内存泄露，两个指针指向的内存不会被释放。</p><p>具体而言使用代码实现就是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  std::shared_ptr&lt;Node&gt; next;<br><br>  <span class="hljs-built_in">Node</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Node created\n&quot;</span>; &#125;<br><br>  ~<span class="hljs-built_in">Node</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Node destroyed\n&quot;</span>; &#125;<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test_bug_for_shared_ptr</span><span class="hljs-params">()</span> </span>&#123;<br>  std::shared_ptr&lt;Node&gt; ptr1 = std::<span class="hljs-built_in">make_shared</span>&lt;Node&gt;();<br>  std::shared_ptr&lt;Node&gt; ptr2 = std::<span class="hljs-built_in">make_shared</span>&lt;Node&gt;();<br>  ptr1-&gt;next = ptr2;<br>  ptr2-&gt;next = ptr1;<br>&#125;<br></code></pre></td></tr></table></figure><p>程序的结果：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-keyword">Node</span> <span class="hljs-title">created</span><br><span class="hljs-keyword">Node</span> <span class="hljs-title">created</span><br></code></pre></td></tr></table></figure><p>我们可以看到<strong>在程序终止运行的时候</strong>，没有调用对应的析构函数，也就是说发生了类型泄漏。使用<code>valgrind</code>等工具进行检查可以看到更详细的日志信息：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs dns">❯ valgrind --leak-check=full ./ptr <br>==<span class="hljs-number">13994</span>== Memcheck, a memory error detector<br>==<span class="hljs-number">13994</span>== Copyright (C) <span class="hljs-number">2002-2022</span>, and GNU GPL&#x27;d, by Julian Seward et al.<br>==<span class="hljs-number">13994</span>== Using Valgrind-<span class="hljs-number">3</span>.<span class="hljs-number">22</span>.<span class="hljs-number">0</span> and LibVEX<span class="hljs-comment">; rerun with -h for copyright info</span><br>==<span class="hljs-number">13994</span>== Command: ./ptr<br>==<span class="hljs-number">13994</span>== <br>Node created<br>Node created<br>==<span class="hljs-number">13994</span>== <br>==<span class="hljs-number">13994</span>== HEAP SUMMARY:<br>==<span class="hljs-number">13994</span>==     in use at exit: <span class="hljs-number">64</span> bytes in <span class="hljs-number">2</span> blocks<br>==<span class="hljs-number">13994</span>==   total heap usage: <span class="hljs-number">4</span> allocs, <span class="hljs-number">2</span> frees, <span class="hljs-number">74</span>,<span class="hljs-number">816</span> bytes allocated<br>==<span class="hljs-number">13994</span>== <br>==<span class="hljs-number">13994</span>== <span class="hljs-number">64</span> (<span class="hljs-number">32</span> direct, <span class="hljs-number">32</span> indirect) bytes in <span class="hljs-number">1</span> blocks are definitely lost in loss record <span class="hljs-number">2</span> of <span class="hljs-number">2</span><br>==<span class="hljs-number">13994</span>==    at <span class="hljs-number">0</span>x4846FA3: operator new(unsigned long) (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)<br>==<span class="hljs-number">13994</span>==    by <span class="hljs-number">0</span>x10CAB1: st<span class="hljs-number">d::</span>__new_allocator&lt;st<span class="hljs-number">d::</span>_Sp_counted_ptr_inplace&lt;Node, st<span class="hljs-number">d::</span>allocator&lt;void&gt;, (__gnu_cxx<span class="hljs-number">::</span>_Lock_policy)<span class="hljs-number">2</span>&gt; &gt;<span class="hljs-number">::</span>allocate(unsigned long, void const*) (in /home/xiyuanyang/ACM_course_DS/<span class="hljs-number">20250413</span>_modern_cpp/ptr)<br>==<span class="hljs-number">13994</span>==    by <span class="hljs-number">0x10C4A3</span>: st<span class="hljs-number">d::</span>__allocated_ptr&lt;st<span class="hljs-number">d::</span>allocator&lt;st<span class="hljs-number">d::</span>_Sp_counted_ptr_inplace&lt;Node, st<span class="hljs-number">d::</span>allocator&lt;void&gt;, (__gnu_cxx<span class="hljs-number">::</span>_Lock_policy)<span class="hljs-number">2</span>&gt; &gt; &gt; st<span class="hljs-number">d::</span>__allocate_guarded&lt;st<span class="hljs-number">d::</span>allocator&lt;st<span class="hljs-number">d::</span>_Sp_counted_ptr_inplace&lt;Node, st<span class="hljs-number">d::</span>allocator&lt;void&gt;, (__gnu_cxx<span class="hljs-number">::</span>_Lock_policy)<span class="hljs-number">2</span>&gt; &gt; &gt;(st<span class="hljs-number">d::</span>allocator&lt;st<span class="hljs-number">d::</span>_Sp_counted_ptr_inplace&lt;Node, st<span class="hljs-number">d::</span>allocator&lt;void&gt;, (__gnu_cxx<span class="hljs-number">::</span>_Lock_policy)<span class="hljs-number">2</span>&gt; &gt;&amp;) (in /home/xiyuanyang/ACM_course_DS/<span class="hljs-number">20250413</span>_modern_cpp/ptr)<br>==<span class="hljs-number">13994</span>==    by <span class="hljs-number">0x10C0E4</span>: st<span class="hljs-number">d::</span>__shared_count&lt;(__gnu_cxx<span class="hljs-number">::</span>_Lock_policy)<span class="hljs-number">2</span>&gt;<span class="hljs-number">::</span>__shared_count&lt;Node, st<span class="hljs-number">d::</span>allocator&lt;void&gt;&gt;(Node*&amp;, st<span class="hljs-number">d::</span>_Sp_alloc_shared_tag&lt;st<span class="hljs-number">d::</span>allocator&lt;void&gt; &gt;) (in /home/xiyuanyang/ACM_course_DS/<span class="hljs-number">20250413</span>_modern_cpp/ptr)<br>==<span class="hljs-number">13994</span>==    by <span class="hljs-number">0</span>x10BE3D: st<span class="hljs-number">d::</span>__shared_ptr&lt;Node, (__gnu_cxx<span class="hljs-number">::</span>_Lock_policy)<span class="hljs-number">2</span>&gt;<span class="hljs-number">::</span>__shared_ptr&lt;st<span class="hljs-number">d::</span>allocator&lt;void&gt;&gt;(st<span class="hljs-number">d::</span>_Sp_alloc_shared_tag&lt;st<span class="hljs-number">d::</span>allocator&lt;void&gt; &gt;) (in /home/xiyuanyang/ACM_course_DS/<span class="hljs-number">20250413</span>_modern_cpp/ptr)<br>==<span class="hljs-number">13994</span>==    by <span class="hljs-number">0</span>x10BC5E: st<span class="hljs-number">d::</span>shared_ptr&lt;Node&gt;<span class="hljs-number">::</span>shared_ptr&lt;st<span class="hljs-number">d::</span>allocator&lt;void&gt;&gt;(st<span class="hljs-number">d::</span>_Sp_alloc_shared_tag&lt;st<span class="hljs-number">d::</span>allocator&lt;void&gt; &gt;) (in /home/xiyuanyang/ACM_course_DS/<span class="hljs-number">20250413</span>_modern_cpp/ptr)<br>==<span class="hljs-number">13994</span>==    by <span class="hljs-number">0x10B571</span>: st<span class="hljs-number">d::</span>shared_ptr&lt;st<span class="hljs-number">d::</span>enable_if&lt;!st<span class="hljs-number">d::</span>is_array&lt;Node&gt;<span class="hljs-number">::</span>value, Node&gt;<span class="hljs-number">::</span>type&gt; st<span class="hljs-number">d::</span>make_shared&lt;Node&gt;() (in /home/xiyuanyang/ACM_course_DS/<span class="hljs-number">20250413</span>_modern_cpp/ptr)<br>==<span class="hljs-number">13994</span>==    by <span class="hljs-number">0x10A936</span>: test_bug_for_shared_ptr() (in /home/xiyuanyang/ACM_course_DS/<span class="hljs-number">20250413</span>_modern_cpp/ptr)<br>==<span class="hljs-number">13994</span>==    by <span class="hljs-number">0x10A9F1</span>: main (in /home/xiyuanyang/ACM_course_DS/<span class="hljs-number">20250413</span>_modern_cpp/ptr)<br>==<span class="hljs-number">13994</span>== <br>==<span class="hljs-number">13994</span>== LEAK SUMMARY:<br>==<span class="hljs-number">13994</span>==    definitely lost: <span class="hljs-number">32</span> bytes in <span class="hljs-number">1</span> blocks<br>==<span class="hljs-number">13994</span>==    indirectly lost: <span class="hljs-number">32</span> bytes in <span class="hljs-number">1</span> blocks<br>==<span class="hljs-number">13994</span>==      possibly lost: <span class="hljs-number">0</span> bytes in <span class="hljs-number">0</span> blocks<br>==<span class="hljs-number">13994</span>==    still reachable: <span class="hljs-number">0</span> bytes in <span class="hljs-number">0</span> blocks<br>==<span class="hljs-number">13994</span>==         suppressed: <span class="hljs-number">0</span> bytes in <span class="hljs-number">0</span> blocks<br>==<span class="hljs-number">13994</span>== <br>==<span class="hljs-number">13994</span>== For lists of detected and suppressed errors, rerun with: -s<br>==<span class="hljs-number">13994</span>== ERROR SUMMARY: <span class="hljs-number">1</span> errors from <span class="hljs-number">1</span> contexts (suppressed: <span class="hljs-number">0</span> from <span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>因此，我们有必要实现<code>weak_ptr</code>: 即<strong>弱引用计数</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test_weak_ptr</span><span class="hljs-params">()</span> </span>&#123;<br>  std::weak_ptr&lt;test&gt; weakPtr;<br>  &#123;<br>    std::shared_ptr&lt;test&gt; ptr1 = std::<span class="hljs-built_in">make_shared</span>&lt;test&gt;(<span class="hljs-number">4</span>, <span class="hljs-string">&quot;Weak_ptr&quot;</span>);<br><br>    weakPtr = ptr1;<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Reference count: &quot;</span> &lt;&lt; ptr<span class="hljs-number">1.</span><span class="hljs-built_in">use_count</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br><br>    &#123;<br>      std::shared_ptr&lt;test&gt; ptr2 = ptr1;<br>      std::cout &lt;&lt; <span class="hljs-string">&quot;Reference count: &quot;</span> &lt;&lt; ptr<span class="hljs-number">1.</span><span class="hljs-built_in">use_count</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    &#125;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Reference count: &quot;</span> &lt;&lt; ptr<span class="hljs-number">1.</span><span class="hljs-built_in">use_count</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">auto</span> sharedPtr = weakPtr.<span class="hljs-built_in">lock</span>()) &#123;<br>      std::cout &lt;&lt; <span class="hljs-string">&quot;Weak pointer is valid\n&quot;</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      std::cout &lt;&lt; <span class="hljs-string">&quot;Weak pointer is expired\n&quot;</span>;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">auto</span> sharedPtr = weakPtr.<span class="hljs-built_in">lock</span>()) &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Weak pointer is valid\n&quot;</span>;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Weak pointer is expired\n&quot;</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们发现<code>weak_ptr</code>不会增加智能指针的引用计数，但是会随着智能指针一起被销毁。这样精巧的设计就可以保证循环引用的问题被解决，只需要让一个指针使用<code>weak_ptr</code>就可以了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NodeFix</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  std::shared_ptr&lt;NodeFix&gt; next;<br>  std::weak_ptr&lt;NodeFix&gt; prev; <br><br>  <span class="hljs-built_in">NodeFix</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;NodeFix created\n&quot;</span>; &#125;<br><br>  ~<span class="hljs-built_in">NodeFix</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;NodeFix destroyed\n&quot;</span>; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fix_problem</span><span class="hljs-params">()</span> </span>&#123;<br>  std::shared_ptr&lt;NodeFix&gt; ptr1 = std::<span class="hljs-built_in">make_shared</span>&lt;NodeFix&gt;();<br>  std::shared_ptr&lt;NodeFix&gt; ptr2 = std::<span class="hljs-built_in">make_shared</span>&lt;NodeFix&gt;();<br>  ptr1-&gt;next = ptr2;<br>  ptr2-&gt;prev = ptr1;<span class="hljs-comment">//ptr2-&gt;prev是一个weak指针，因此不会增加ptr1的引用计数</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">NodeFix created</span><br><span class="hljs-attribute">NodeFix created</span><br><span class="hljs-attribute">NodeFix destroyed</span><br><span class="hljs-attribute">NodeFix destroyed</span><br></code></pre></td></tr></table></figure><p>使用<code>Valgrind</code>也是安然无恙！😊</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-number">17644</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span> Memcheck<span class="hljs-punctuation">,</span> a memory error detector<br><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-number">17644</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span> Copyright <span class="hljs-punctuation">(</span>C<span class="hljs-punctuation">)</span> <span class="hljs-number">2002</span><span class="hljs-punctuation">-</span><span class="hljs-number">2022</span><span class="hljs-punctuation">,</span> and GNU GPL&#x27;d, by Julian Seward et al.<br>==<span class="hljs-number">1764</span>4== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info<br>==<span class="hljs-number">1764</span>4== Command: ./ptr<br>==<span class="hljs-number">1764</span>4== <br>NodeFix created<br>NodeFix created<br>NodeFix destroyed<br>NodeFix destroyed<br>==<span class="hljs-number">1764</span>4== <br>==<span class="hljs-number">1764</span>4== HEAP SUMMARY:<br>==<span class="hljs-number">1764</span>4==     in use at exit: 0 bytes in 0 blocks<br>==<span class="hljs-number">1764</span>4==   total heap usage: 4 allocs, 4 frees, 74,848 bytes allocated<br>==<span class="hljs-number">1764</span>4== <br>==<span class="hljs-number">1764</span>4== All heap blocks were freed -- no leaks are possible<br>==<span class="hljs-number">1764</span>4== <br>==<span class="hljs-number">1764</span>4== For lists of detected and suppressed errors, rerun with: -s<br>==<span class="hljs-number">1764</span>4== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)<br></code></pre></td></tr></table></figure><h3 id="Applications-1"><a href="#Applications-1" class="headerlink" title="Applications"></a>Applications</h3><p>来看下面的例题，题源：<a href="https://acm.sjtu.edu.cn/OnlineJudge/problem/2640">https://acm.sjtu.edu.cn/OnlineJudge/problem/2640</a></p><div class="note note-primary">            <p>stargazer 最近正在学习 Rust 语言的所有权机制与内存安全特性。</p><p>Rust 的所有权机制要求每个值都有唯一的所有者（通常是变量），并且在同一时间内只能有一个所有者。当变量的所有权被转移或其生命周期结束后，所有对该变量的借用（相当于 C++ 中指向变量的指针）都不能再被使用，否则会造成编译错误。Rust 的编译器可以在编译时就能“静态”地检查所有权和借用关系，从而在运行时无需额外检查的情况下保证了内存安全。</p><p>这种所有权机制虽然保证了内存安全，但是也使得一些数据结构的实现变得困难。因此，对于堆上对象的所有权，Rust 引入了类似于 C++ 中智能指针的机制，包括：</p><ul><li><code>Rc&lt;T&gt;</code>：相当于 C++ 中的 <code>std::shared_ptr</code>，允许多个所有者共享实际对象，通过引用计数管理内存</li><li><code>Weak&lt;T&gt;</code>：相当于 C++ 中的 <code>std::weak_ptr</code>，不增加强引用计数，用于解决循环引用问题</li><li><code>Weak&lt;T&gt;</code> 必须先通过 <code>upgrade()</code> 方法转换为 <code>Rc&lt;T&gt;</code> 才能访问实际对象。若实际对象已被释放，则 <code>upgrade()</code> 会返回 <code>None</code>。C++ 中的 <code>std::weak_ptr</code> 也有类似的 <code>lock()</code> 方法。</li></ul><p>在具体实现中：</p><ul><li><code>Rc&lt;T&gt;</code> 与 <code>Weak&lt;T&gt;</code> 并不直接指向对象本身，而是指向一个“引用计数块”，内含三个成员：“强引用计数”、“弱引用计数”、“指向对象的指针”</li><li>强引用计数：指向该对象的 <code>Rc&lt;T&gt;</code> 的数量</li><li>弱引用计数：指向该对象的 <code>Weak&lt;T&gt;</code> 的数量</li><li>当强引用计数为 0 时，实际对象会被释放</li><li>当弱引用计数也为 0 时，引用计数块会被释放</li></ul><p><code>Weak&lt;T&gt;</code> 避免了循环引用问题。在双链表中，每个节点需要指向前一个和后一个节点。如果所有这些指针都是强引用（如 <code>Rc&lt;T&gt;</code> 或 <code>std::shared_ptr</code>），就会形成循环引用：节点A持有指向节点B的强引用，节点B也持有指向节点A的强引用，这会导致两者的引用计数永远不会降为0，即使外部不再引用这些节点，它们也不会被释放，从而造成内存泄漏。使用 <code>Weak&lt;T&gt;</code>（或 <code>std::weak_ptr</code>）可以打破这种循环。</p><p>请借鉴 Rust 中的所有权思想，在 C++ 中实现一个无需手动管理内存的双链表。</p>          </div><p>给出我的示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;optional&gt;</span></span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DoublyLinkedList</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// Node structure definition</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;<br>        T value;<br>        std::shared_ptr&lt;Node&gt; next;<br>        std::weak_ptr&lt;Node&gt; prev;<br><br>        <span class="hljs-built_in">Node</span>(<span class="hljs-type">const</span> T&amp; val = <span class="hljs-built_in">T</span>()) : <span class="hljs-built_in">value</span>(val), <span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br>    &#125;;<br><br>    std::shared_ptr&lt;Node&gt; head;<br>    std::weak_ptr&lt;Node&gt; tail;<br>    <span class="hljs-type">size_t</span> length;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// Iterator class</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">iterator</span> &#123;<br>    <span class="hljs-keyword">private</span>:<br>        std::shared_ptr&lt;Node&gt; current;<br><br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">iterator</span>(std::shared_ptr&lt;Node&gt; node) : <span class="hljs-built_in">current</span>(node) &#123;&#125;<br><br>        <span class="hljs-comment">// Dereference operator to get value</span><br>        T&amp; <span class="hljs-keyword">operator</span>*() &#123;<br>            <span class="hljs-keyword">return</span> current-&gt;value;<br>        &#125;<br><br>        <span class="hljs-comment">// Post-increment operator</span><br>        iterator <span class="hljs-keyword">operator</span>++(<span class="hljs-type">int</span>) &#123;<br>            <span class="hljs-keyword">auto</span> tmp = *<span class="hljs-keyword">this</span>;<br>            current = current-&gt;next;<br>            <span class="hljs-keyword">return</span> tmp;<br>        &#125;<br><br>        <span class="hljs-comment">// Equality operators</span><br>        <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> iterator&amp; other) <span class="hljs-type">const</span> &#123;<br>            <span class="hljs-keyword">return</span> current == other.current;<br>        &#125;<br><br>        <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-type">const</span> iterator&amp; other) <span class="hljs-type">const</span> &#123;<br>            <span class="hljs-keyword">return</span> !(*<span class="hljs-keyword">this</span> == other);<br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-comment">// Constructor</span><br>    <span class="hljs-built_in">DoublyLinkedList</span>() : <span class="hljs-built_in">head</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">length</span>(<span class="hljs-number">0</span>) &#123;&#125;<br><br>    <span class="hljs-comment">// No destructor needed, memory managed by shared_ptr</span><br><br>    <span class="hljs-comment">// Check if list is empty</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> length == <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// Get the size of the list</span><br>    <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> length;<br>    &#125;<br><br>    <span class="hljs-comment">// Add element to the front</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_front</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; value)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> new_node = std::<span class="hljs-built_in">make_shared</span>&lt;Node&gt;(value);<br>        <span class="hljs-keyword">if</span> (head) &#123;<br>            new_node-&gt;next = head;<br>            head-&gt;prev = new_node;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            tail = new_node; <span class="hljs-comment">// If list was empty, update tail</span><br>        &#125;<br>        head = new_node;<br>        length++;<br>    &#125;<br><br>    <span class="hljs-comment">// Add element to the back</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_back</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; value)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> new_node = std::<span class="hljs-built_in">make_shared</span>&lt;Node&gt;(value);<br>        <span class="hljs-keyword">if</span> (tail.<span class="hljs-built_in">lock</span>()) &#123;<br>            <span class="hljs-keyword">auto</span> tail_node = tail.<span class="hljs-built_in">lock</span>();<br>            tail_node-&gt;next = new_node;<br>            new_node-&gt;prev = tail_node;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            head = new_node; <span class="hljs-comment">// If list was empty, update head</span><br>        &#125;<br>        tail = new_node;<br>        length++;<br>    &#125;<br><br>    <span class="hljs-comment">// Remove and return the first element</span><br>    <span class="hljs-function">std::optional&lt;T&gt; <span class="hljs-title">pop_front</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!head) &#123;<br>            <span class="hljs-keyword">return</span> std::<span class="hljs-literal">nullopt</span>;<br>        &#125;<br>        <span class="hljs-keyword">auto</span> value = head-&gt;value;<br>        head = head-&gt;next;<br>        <span class="hljs-keyword">if</span> (head) &#123;<br>            head-&gt;prev.<span class="hljs-built_in">reset</span>(); <span class="hljs-comment">// Clear the weak_ptr reference</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            tail.<span class="hljs-built_in">reset</span>(); <span class="hljs-comment">// If list becomes empty, clear tail</span><br>        &#125;<br>        length--;<br>        <span class="hljs-keyword">return</span> value;<br>    &#125;<br><br>    <span class="hljs-comment">// Remove and return the last element</span><br>    <span class="hljs-function">std::optional&lt;T&gt; <span class="hljs-title">pop_back</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-keyword">return</span> std::<span class="hljs-literal">nullopt</span>;<br>        &#125;<br>        <span class="hljs-keyword">auto</span> tail_node = tail.<span class="hljs-built_in">lock</span>();<br>        <span class="hljs-keyword">auto</span> value = tail_node-&gt;value;<br>        <span class="hljs-keyword">if</span> (tail_node-&gt;prev.<span class="hljs-built_in">lock</span>()) &#123;<br>            <span class="hljs-keyword">auto</span> prev_node = tail_node-&gt;prev.<span class="hljs-built_in">lock</span>();<br>            prev_node-&gt;next.<span class="hljs-built_in">reset</span>();<br>            tail = prev_node;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            head.<span class="hljs-built_in">reset</span>(); <span class="hljs-comment">// If list becomes empty, clear head</span><br>            tail.<span class="hljs-built_in">reset</span>();<br>        &#125;<br>        length--;<br>        <span class="hljs-keyword">return</span> value;<br>    &#125;<br><br>    <span class="hljs-comment">// Iterators</span><br>    <span class="hljs-function">iterator <span class="hljs-title">begin</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">iterator</span>(head);<br>    &#125;<br><br>    <span class="hljs-function">iterator <span class="hljs-title">end</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">iterator</span>(<span class="hljs-literal">nullptr</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>本质上就是把使用<code>weak_ptr</code>破解的过程转化为<strong>一个具体的双链表的实现</strong>。</p></blockquote><h2 id="std-any"><a href="#std-any" class="headerlink" title="std::any"></a><code>std::any</code></h2><p>C++作为一个强类型语言，对类型转换有着很高的要求，但是使用<code>std::any</code>，我们可以将C++用作弱类型语言。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>&#123;<br>    std::any x = <span class="hljs-number">114514</span>; <span class="hljs-comment">// 1</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">auto</span> ptr = std::<span class="hljs-built_in">any_cast</span>&lt;<span class="hljs-type">int</span>&gt;(&amp;x); ptr != <span class="hljs-literal">nullptr</span>) &#123; <span class="hljs-comment">// 2</span><br>        std::cout &lt;&lt; *ptr &lt;&lt; std::endl; <span class="hljs-comment">// 3</span><br>    &#125;<br>    x = <span class="hljs-string">&quot;qwerty&quot;</span>; <span class="hljs-comment">// 4</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">auto</span> ptr = std::<span class="hljs-built_in">any_cast</span>&lt;<span class="hljs-type">int</span>&gt;(&amp;x); ptr != <span class="hljs-literal">nullptr</span>) &#123; <span class="hljs-comment">// 5</span><br>        std::cout &lt;&lt; (*ptr) + <span class="hljs-number">114514</span> &lt;&lt; std::endl; <span class="hljs-comment">// 6</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li>一开始x被赋值为整数类型，此时for循环中的代码：<code>auto ptr = std::any_cast&lt;int&gt;(&amp;x)</code>会判断ptr<strong>是否可以转化为一个int*类型的指针</strong>，如果可以就做取地址，如果不可以就变成<code>nullptr</code></li></ul><h2 id="std-optional-and-std-variant"><a href="#std-optional-and-std-variant" class="headerlink" title="std::optional and std::variant"></a><code>std::optional</code> and <code>std::variant</code></h2><h3 id="std-optional"><a href="#std-optional" class="headerlink" title="std:optional"></a><code>std:optional</code></h3><p><code>std::optional</code> 是一个封装类型，用于表示一个值可能存在或不存在。它可以用来替代指针或其他机制，以更安全地处理缺失值。</p><ul><li><strong>可选值</strong>：<code>std::optional&lt;T&gt;</code> 可以存储类型 <code>T</code> 的值，或者什么都不存储（即空）。</li><li><strong>安全性</strong>：使用 <code>std::optional</code> 可以避免使用空指针，减少空指针解引用的风险。</li><li><strong>简单的接口</strong>：提供了简单的方法来检查值是否存在，并访问该值。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;optional&gt;</span></span><br><br><span class="hljs-function">std::optional&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">getValue</span><span class="hljs-params">(<span class="hljs-type">bool</span> returnValue)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (returnValue) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>; <span class="hljs-comment">// 返回一个值</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> std::<span class="hljs-literal">nullopt</span>; <span class="hljs-comment">// 返回空</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> value = <span class="hljs-built_in">getValue</span>(<span class="hljs-literal">true</span>);<br>    <span class="hljs-keyword">if</span> (value) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Value: &quot;</span> &lt;&lt; *value &lt;&lt; std::endl; <span class="hljs-comment">// 输出 42</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;No value&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="std-variant"><a href="#std-variant" class="headerlink" title="std::variant"></a><code>std::variant</code></h3><p><code>std::variant</code> 是一个类型安全的联合体，可以存储多种不同类型中的一种。它允许在运行时选择存储的类型，并提供安全的访问方式。</p><ul><li><strong>多态性</strong>：<code>std::variant&lt;T1, T2, ...&gt;</code> 可以存储 <code>T1</code>、<code>T2</code> 等类型之一。</li><li><strong>类型安全</strong>：访问存储的值时，必须确保使用正确的类型，避免类型错误。</li><li><strong>易于使用</strong>：通过 <code>std::get</code> 和 <code>std::visit</code> 等函数，可以方便地访问和处理存储的值。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;variant&gt;</span></span><br><br><span class="hljs-function">std::variant&lt;<span class="hljs-type">int</span>, std::string&gt; <span class="hljs-title">getValue</span><span class="hljs-params">(<span class="hljs-type">bool</span> returnInt)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (returnInt) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>; <span class="hljs-comment">// 返回整数</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello&quot;</span>; <span class="hljs-comment">// 返回字符串</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> value = <span class="hljs-built_in">getValue</span>(<span class="hljs-literal">false</span>);<br>    <br>    <span class="hljs-comment">// 使用 std::visit 处理不同类型</span><br>    std::<span class="hljs-built_in">visit</span>([](<span class="hljs-keyword">auto</span>&amp;&amp; arg) &#123;<br>        std::cout &lt;&lt; arg &lt;&lt; std::endl; <span class="hljs-comment">// 输出 &quot;Hello&quot;</span><br>    &#125;, value);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="Rust简介"><a href="#Rust简介" class="headerlink" title="Rust简介"></a>Rust简介</h2>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-11763cb6" role="button" aria-expanded="false" aria-controls="collapse-11763cb6">        <div class="fold-arrow">▶</div>TOBEDONE      </div>      <div class="fold-collapse collapse" id="collapse-11763cb6">        <div class="fold-content">          <p>别看了，这没写完，快去写作业叭。</p>        </div>      </div>    </div>]]></content>
    
    
    <categories>
      
      <category>Code</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tutorial</tag>
      
      <tag>Finished</tag>
      
      <tag>C/C++</tag>
      
      <tag>Modern Cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AutoGen-Automatic-Essay-Modification</title>
    <link href="/posts/AutoGen-automatic-essay-modification/"/>
    <url>/posts/AutoGen-automatic-essay-modification/</url>
    
    <content type="html"><![CDATA[<style>  html, body, .markdown-body {    font-family: Georgia, sans, serif;  }</style><h1 id="English-Essay-Revision-with-Agentic-Workflow"><a href="#English-Essay-Revision-with-Agentic-Workflow" class="headerlink" title="English Essay Revision with Agentic Workflow"></a>English Essay Revision with Agentic Workflow</h1><p><a class="btn" href="https://github.com/xiyuanyang-code/Autogen-English-Essay-Revision" title="title">Github Repo</a></p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><blockquote><p>TBD</p></blockquote><h2 id="Codes-and-demonstrations"><a href="#Codes-and-demonstrations" class="headerlink" title="Codes and demonstrations"></a>Codes and demonstrations</h2><blockquote><p>Updated: Version 2</p><p>Time: 2025&#x2F;04&#x2F;13</p></blockquote><ul><li>Autogen sucks… In multi-agent collaboration and communication, the packaging of Autogen is too rigid, making it difficult to customize a flexible framework for agent communication.</li><li>I may turn to <strong>Camel-AI</strong> instead in the future.</li><li>This <strong>logging</strong> is too simple, I will fix it later.😊😘</li></ul><h3 id="construct-py"><a href="#construct-py" class="headerlink" title="construct.py"></a><code>construct.py</code></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">Author: Xiyuan Yang   xiyuan_yang@outlook.com</span><br><span class="hljs-string">Date: 2025-04-11 14:50:06</span><br><span class="hljs-string">LastEditors: Xiyuan Yang   xiyuan_yang@outlook.com</span><br><span class="hljs-string">LastEditTime: 2025-04-13 11:20:52</span><br><span class="hljs-string">FilePath: /Autogen-English-Essay/construct.py</span><br><span class="hljs-string">Description:</span><br><span class="hljs-string">Do you code and make progress today?</span><br><span class="hljs-string">Copyright (c) 2025 by Xiyuan Yang, All Rights Reserved.</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><span class="hljs-comment"># Constructing file structures.</span><br><br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> *<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">read_file</span>(<span class="hljs-params">filename=<span class="hljs-string">&quot;Original.txt&quot;</span></span>):<br>    <span class="hljs-string">&quot;&quot;&quot;_summary_ :read file contents, especially for getting the original text</span><br><span class="hljs-string"></span><br><span class="hljs-string">    Args:</span><br><span class="hljs-string">        filename (str): file name for the original text</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(filename, <span class="hljs-string">&quot;r&quot;</span>, encoding=<span class="hljs-string">&quot;utf-8&quot;</span>) <span class="hljs-keyword">as</span> file:<br>        <span class="hljs-keyword">return</span> file.read().strip()<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">write_file</span>(<span class="hljs-params">content: <span class="hljs-built_in">str</span>, filename=<span class="hljs-string">&quot;Final.txt&quot;</span></span>):<br>    <span class="hljs-string">&quot;&quot;&quot;_summary_ :write file contents, especially for getting the original text</span><br><span class="hljs-string"></span><br><span class="hljs-string">    Args:</span><br><span class="hljs-string">        filename (str): file name for the original text</span><br><span class="hljs-string">        content (str): contents to be written into</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(filename, <span class="hljs-string">&quot;w&quot;</span>, encoding=<span class="hljs-string">&quot;utf-8&quot;</span>) <span class="hljs-keyword">as</span> file:<br>        file.write(content)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">create_dirs</span>(<span class="hljs-params">log_folder: <span class="hljs-built_in">str</span></span>):<br>    <span class="hljs-string">&quot;&quot;&quot;_summary_: create the log folder for the settings</span><br><span class="hljs-string"></span><br><span class="hljs-string">    Args:</span><br><span class="hljs-string">        log_folder (str): The name of the file folder</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment"># create the &#x27;log&#x27; file folder if it doesn&#x27;t exist</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> os.path.exists(log_folder):<br>        <span class="hljs-comment"># create new folder</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Constructing new folder...&quot;</span>)<br>        os.makedirs(log_folder)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Constructed already.&quot;</span>)<br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Finish!&quot;</span>)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_log_filename</span>(<span class="hljs-params">log_dir=<span class="hljs-string">&quot;log&quot;</span></span>) -&gt; <span class="hljs-built_in">str</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;Generate timestamp-based log filename&quot;&quot;&quot;</span><br>    timestamp = datetime.now().strftime(<span class="hljs-string">&quot;%Y%m%d_%H%M%S&quot;</span>)<br>    <span class="hljs-keyword">return</span> os.path.join(log_dir, <span class="hljs-string">f&quot;log_<span class="hljs-subst">&#123;timestamp&#125;</span>.txt&quot;</span>)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">log_conversation</span>(<span class="hljs-params">message: <span class="hljs-built_in">str</span>, log_dir=<span class="hljs-string">&quot;log&quot;</span></span>):<br>    <span class="hljs-string">&quot;&quot;&quot;Record conversation to log file&quot;&quot;&quot;</span><br>    log_file = get_log_filename(log_dir)<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(log_file, <span class="hljs-string">&quot;a&quot;</span>, encoding=<span class="hljs-string">&quot;utf-8&quot;</span>) <span class="hljs-keyword">as</span> f:<br>        f.write(message + <span class="hljs-string">&quot;\n\n&quot;</span>)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">print_progress</span>(<span class="hljs-params">message: <span class="hljs-built_in">str</span></span>):<br>    <span class="hljs-string">&quot;&quot;&quot;Print progress message and log it&quot;&quot;&quot;</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;[PROGRESS] <span class="hljs-subst">&#123;message&#125;</span>&quot;</span>)<br>    log_conversation(<span class="hljs-string">f&quot;[SYSTEM] <span class="hljs-subst">&#123;message&#125;</span>&quot;</span>)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Testing...&quot;</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Constructing all files...&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="prompts-py"><a href="#prompts-py" class="headerlink" title="prompts.py"></a><code>prompts.py</code></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">Author: Xiyuan Yang   xiyuan_yang@outlook.com</span><br><span class="hljs-string">Date: 2025-04-11 14:50:06</span><br><span class="hljs-string">LastEditors: Xiyuan Yang   xiyuan_yang@outlook.com</span><br><span class="hljs-string">LastEditTime: 2025-04-13 11:20:52</span><br><span class="hljs-string">FilePath: /Autogen-English-Essay/construct.py</span><br><span class="hljs-string">Description:</span><br><span class="hljs-string">Do you code and make progress today?</span><br><span class="hljs-string">Copyright (c) 2025 by Xiyuan Yang, All Rights Reserved.</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><span class="hljs-comment"># Constructing file structures.</span><br><br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> *<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">read_file</span>(<span class="hljs-params">filename=<span class="hljs-string">&quot;Original.txt&quot;</span></span>):<br>    <span class="hljs-string">&quot;&quot;&quot;_summary_ :read file contents, especially for getting the original text</span><br><span class="hljs-string"></span><br><span class="hljs-string">    Args:</span><br><span class="hljs-string">        filename (str): file name for the original text</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(filename, <span class="hljs-string">&quot;r&quot;</span>, encoding=<span class="hljs-string">&quot;utf-8&quot;</span>) <span class="hljs-keyword">as</span> file:<br>        <span class="hljs-keyword">return</span> file.read().strip()<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">write_file</span>(<span class="hljs-params">content: <span class="hljs-built_in">str</span>, filename=<span class="hljs-string">&quot;Final.txt&quot;</span></span>):<br>    <span class="hljs-string">&quot;&quot;&quot;_summary_ :write file contents, especially for getting the original text</span><br><span class="hljs-string"></span><br><span class="hljs-string">    Args:</span><br><span class="hljs-string">        filename (str): file name for the original text</span><br><span class="hljs-string">        content (str): contents to be written into</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(filename, <span class="hljs-string">&quot;w&quot;</span>, encoding=<span class="hljs-string">&quot;utf-8&quot;</span>) <span class="hljs-keyword">as</span> file:<br>        file.write(content)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">create_dirs</span>(<span class="hljs-params">log_folder: <span class="hljs-built_in">str</span></span>):<br>    <span class="hljs-string">&quot;&quot;&quot;_summary_: create the log folder for the settings</span><br><span class="hljs-string"></span><br><span class="hljs-string">    Args:</span><br><span class="hljs-string">        log_folder (str): The name of the file folder</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment"># create the &#x27;log&#x27; file folder if it doesn&#x27;t exist</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> os.path.exists(log_folder):<br>        <span class="hljs-comment"># create new folder</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Constructing new folder...&quot;</span>)<br>        os.makedirs(log_folder)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Constructed already.&quot;</span>)<br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Finish!&quot;</span>)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_log_filename</span>(<span class="hljs-params">log_dir=<span class="hljs-string">&quot;log&quot;</span></span>) -&gt; <span class="hljs-built_in">str</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;Generate timestamp-based log filename&quot;&quot;&quot;</span><br>    timestamp = datetime.now().strftime(<span class="hljs-string">&quot;%Y%m%d_%H%M%S&quot;</span>)<br>    <span class="hljs-keyword">return</span> os.path.join(log_dir, <span class="hljs-string">f&quot;log_<span class="hljs-subst">&#123;timestamp&#125;</span>.txt&quot;</span>)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">log_conversation</span>(<span class="hljs-params">message: <span class="hljs-built_in">str</span>, log_dir=<span class="hljs-string">&quot;log&quot;</span></span>):<br>    <span class="hljs-string">&quot;&quot;&quot;Record conversation to log file&quot;&quot;&quot;</span><br>    log_file = get_log_filename(log_dir)<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(log_file, <span class="hljs-string">&quot;a&quot;</span>, encoding=<span class="hljs-string">&quot;utf-8&quot;</span>) <span class="hljs-keyword">as</span> f:<br>        f.write(message + <span class="hljs-string">&quot;\n\n&quot;</span>)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">print_progress</span>(<span class="hljs-params">message: <span class="hljs-built_in">str</span></span>):<br>    <span class="hljs-string">&quot;&quot;&quot;Print progress message and log it&quot;&quot;&quot;</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;[PROGRESS] <span class="hljs-subst">&#123;message&#125;</span>&quot;</span>)<br>    log_conversation(<span class="hljs-string">f&quot;[SYSTEM] <span class="hljs-subst">&#123;message&#125;</span>&quot;</span>)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Testing...&quot;</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Constructing all files...&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="main-py"><a href="#main-py" class="headerlink" title="main.py"></a><code>main.py</code></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Import required modules</span><br><span class="hljs-keyword">from</span> prompts <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> construct <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> autogen <span class="hljs-keyword">import</span> (<br>    AssistantAgent,<br>    UserProxyAgent,<br>    GroupChat,<br>    GroupChatManager,<br>    config_list_from_json,<br>)<br><br><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">The intuition:</span><br><span class="hljs-string">    1.We use for agents to make the revision task:</span><br><span class="hljs-string">        1.Task decomposer:</span><br><span class="hljs-string">            Given the original text and the original prompts, and let the agent to generate the promblems and issues strictly (no actual revisions will be made during this process.)</span><br><span class="hljs-string">            The agent needs to return a simple report pointing several problems that the passage have faced.</span><br><span class="hljs-string">        2.Editor Conservative and Editor Creative</span><br><span class="hljs-string">            Where actual revisions take place. Set different temperatures for the &quot;imagination&quot;</span><br><span class="hljs-string">            !The two editor will not influence each other, works parallelly.</span><br><span class="hljs-string">        3.integrator: </span><br><span class="hljs-string">            Integrate for both two passage to make better improvements</span><br><span class="hljs-string">            To make better improvements and allow more diversity, we allow the maxlength of current passage is the 1.5*max_length</span><br><span class="hljs-string">        4.Reporter</span><br><span class="hljs-string">            Check the format and restrict words.( \le maxlength)</span><br><span class="hljs-string"></span><br><span class="hljs-string">    2.For the first version, we will just make one round conversation:</span><br><span class="hljs-string">        User -&gt; Task decomposer -&gt; Editor Conservative  -&gt; Integrator -&gt; Reporter</span><br><span class="hljs-string">                                -&gt; Editor Creative      -&gt;</span><br><span class="hljs-string">    3. To avoid information loss, we will pass total_prompt and the original text for all agents.</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><span class="hljs-comment"># Configure Pydantic model settings</span><br><span class="hljs-comment"># BaseModel.model_config = &#123;&quot;protected_namespaces&quot;: ()&#125;</span><br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AutoGenArticleEditor</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        create_dirs(<span class="hljs-string">&quot;log&quot;</span>)<br><br>        <span class="hljs-comment"># Initialize configuration</span><br>        <span class="hljs-variable language_">self</span>.config_list = config_list_from_json(env_or_file=<span class="hljs-string">&quot;OAI_CONFIG_LIST.json&quot;</span>)<br>        <span class="hljs-variable language_">self</span>.original_article = read_file()<br>        <span class="hljs-variable language_">self</span>.log_filename = get_log_filename(<span class="hljs-string">&quot;log&quot;</span>)<br>        <span class="hljs-variable language_">self</span>.max_length = <span class="hljs-number">200</span><br><br>        <span class="hljs-comment"># Initialize agents</span><br>        <span class="hljs-variable language_">self</span>.task_decomposer = <span class="hljs-literal">None</span><br>        <span class="hljs-variable language_">self</span>.editor1 = <span class="hljs-literal">None</span><br>        <span class="hljs-variable language_">self</span>.editor2 = <span class="hljs-literal">None</span><br>        <span class="hljs-variable language_">self</span>.integrator = <span class="hljs-literal">None</span><br>        <span class="hljs-variable language_">self</span>.reporter = <span class="hljs-literal">None</span><br>        <span class="hljs-variable language_">self</span>.user_proxy = <span class="hljs-literal">None</span><br>        <span class="hljs-variable language_">self</span>.group_chat = <span class="hljs-literal">None</span><br>        <span class="hljs-variable language_">self</span>._setup_agents()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_setup_agents</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;Configure all agent instances&quot;&quot;&quot;</span><br><br>        <span class="hljs-comment"># User proxy agent (human admin simulator)</span><br>        <span class="hljs-variable language_">self</span>.user_proxy = UserProxyAgent(<br>            name=<span class="hljs-string">&quot;Admin&quot;</span>,<br>            system_message=<span class="hljs-string">&quot;A human admin who provides the article and requirements.&quot;</span>,<br>            human_input_mode=<span class="hljs-string">&quot;NEVER&quot;</span>,<br>            code_execution_config=<span class="hljs-literal">False</span>,<br>            default_auto_reply=<span class="hljs-string">&quot;Task received. Passing to the team...&quot;</span>,<br>            max_consecutive_auto_reply=<span class="hljs-number">1</span>,<br>        )<br><br>        <span class="hljs-comment"># Task decomposition agent</span><br>        <span class="hljs-variable language_">self</span>.task_decomposer = AssistantAgent(<br>            name=<span class="hljs-string">&quot;Task_Decomposer&quot;</span>,<br>            system_message=<span class="hljs-string">f&quot;&quot;&quot;</span><br><span class="hljs-string">            The total task: <span class="hljs-subst">&#123;total_prompt&#125;</span></span><br><span class="hljs-string">            </span><br><span class="hljs-string"></span><br><span class="hljs-string">            You are an expert in task decomposition. Your responsibilities:</span><br><span class="hljs-string">            1. Analyze requirements: \n<span class="hljs-subst">&#123;requirements&#125;</span>\n</span><br><span class="hljs-string">            2. Read the original passage, the passage is shown below\n:<span class="hljs-subst">&#123;self.original_article&#125;</span>\n</span><br><span class="hljs-string">            3. You need to provide a more specific modification plan based on the requirements, </span><br><span class="hljs-string">            combining it with the original text, but without making specific changes. </span><br><span class="hljs-string">            For example: the relative clause in a certain sentence does not conform to specific grammatical rules and needs to be revised; </span><br><span class="hljs-string">            or the word choice in a certain part is too simplistic and needs to be optimized; </span><br><span class="hljs-string">            or the logic in a certain section needs to be further strengthened.</span><br><span class="hljs-string">            4. More detailed modification requirements are needed, covering all aspects such as grammar, logic, word choice, and sentence structure.</span><br><span class="hljs-string">            </span><br><span class="hljs-string"></span><br><span class="hljs-string">            Response format:</span><br><span class="hljs-string">            ### Specific Requirements</span><br><span class="hljs-string">            [Return specified and modified requirements]</span><br><span class="hljs-string"></span><br><span class="hljs-string">            &quot;&quot;&quot;</span>,<br>            llm_config=&#123;<br>                <span class="hljs-string">&quot;config_list&quot;</span>: <span class="hljs-variable language_">self</span>.config_list,<br>                <span class="hljs-string">&quot;temperature&quot;</span>: <span class="hljs-number">0.3</span>,<br>            &#125;,<br>        )<br><br>        <span class="hljs-comment"># Conservative editor agent</span><br>        <span class="hljs-variable language_">self</span>.editor1 = AssistantAgent(<br>            name=<span class="hljs-string">&quot;Editor_Conservative&quot;</span>,<br>            system_message=<span class="hljs-string">f&quot;&quot;&quot;</span><br><span class="hljs-string"></span><br><span class="hljs-string">            <span class="hljs-subst">&#123;total_prompt&#125;</span>\n</span><br><span class="hljs-string">            You will receive the specific requirements from the previous agents.\n</span><br><span class="hljs-string">            The original text: <span class="hljs-subst">&#123;self.original_article&#125;</span>\n</span><br><span class="hljs-string"></span><br><span class="hljs-string">            Attention!!!, particularly for you, as a more meticulous writer, your revisions should focus on the logic and organizational structure of the article, making it more coherent.</span><br><span class="hljs-string">            </span><br><span class="hljs-string">            Provide complete edited text and brief feedback (&lt;50 words).</span><br><span class="hljs-string">            Ensure native English usage and &lt;<span class="hljs-subst">&#123;<span class="hljs-number">1.2</span>*self.max_length&#125;</span> word limit.</span><br><span class="hljs-string">            </span><br><span class="hljs-string">            Response format:</span><br><span class="hljs-string">            ### Version ###</span><br><span class="hljs-string">            [full edited text]</span><br><span class="hljs-string">            </span><br><span class="hljs-string">            ### Feedback ###</span><br><span class="hljs-string">            [comments]</span><br><span class="hljs-string">            &quot;&quot;&quot;</span>,<br>            llm_config=&#123;<span class="hljs-string">&quot;config_list&quot;</span>: <span class="hljs-variable language_">self</span>.config_list, <span class="hljs-string">&quot;temperature&quot;</span>: <span class="hljs-number">0.2</span>&#125;,<br>        )<br><br>        <span class="hljs-comment"># Creative editor agent</span><br>        <span class="hljs-variable language_">self</span>.editor2 = AssistantAgent(<br>            name=<span class="hljs-string">&quot;Editor_Creative&quot;</span>,<br>            system_message=<span class="hljs-string">f&quot;&quot;&quot;</span><br><span class="hljs-string">            <span class="hljs-subst">&#123;total_prompt&#125;</span>\n</span><br><span class="hljs-string">            For the specified requirements: <span class="hljs-subst">&#123;specified_requirements&#125;</span>\n</span><br><span class="hljs-string">            The original text: <span class="hljs-subst">&#123;self.original_article&#125;</span>\n</span><br><span class="hljs-string"></span><br><span class="hljs-string">            Attention!!!, Note that, particularly for you, as a free-spirited and imaginative writer, your revisions should focus on the innovative sentence structures and rhetorical techniques in the article, making it more creative and eye-catching.</span><br><span class="hljs-string">            Provide complete edited text and brief feedback (&lt;50 words).</span><br><span class="hljs-string">            Ensure native English usage and &lt;<span class="hljs-subst">&#123;<span class="hljs-number">1.2</span>*self.max_length&#125;</span> word limit.</span><br><span class="hljs-string">            </span><br><span class="hljs-string">            Response format:</span><br><span class="hljs-string">            ### Version ###</span><br><span class="hljs-string">            [full edited text]</span><br><span class="hljs-string">            </span><br><span class="hljs-string">            ### Feedback ###</span><br><span class="hljs-string">            [comments]</span><br><span class="hljs-string">            &quot;&quot;&quot;</span>,<br>            llm_config=&#123;<span class="hljs-string">&quot;config_list&quot;</span>: <span class="hljs-variable language_">self</span>.config_list, <span class="hljs-string">&quot;temperature&quot;</span>: <span class="hljs-number">0.8</span>&#125;,<br>        )<br><br>        <span class="hljs-comment"># Integration agent</span><br>        <span class="hljs-variable language_">self</span>.integrator = AssistantAgent(<br>            name=<span class="hljs-string">&quot;Integrator&quot;</span>,<br>            system_message=<span class="hljs-string">f&quot;&quot;&quot;</span><br><span class="hljs-string">            <span class="hljs-subst">&#123;total_prompt&#125;</span>\n</span><br><span class="hljs-string">            You are the final integrator. Your responsibilities:</span><br><span class="hljs-string">            1.You will receive three documents: the original article and two modified articles by two editors(one conservative and one creative)</span><br><span class="hljs-string">            2.You need to take an overall perspective to compare the highlights of the two revised drafts against the original manuscript, and integrate the two articles, taking the strengths from each.</span><br><span class="hljs-string">            3.!!Attention: You need to make sure your passage (after integrated) is no more than <span class="hljs-subst">&#123;<span class="hljs-number">1.5</span>*self.max_length&#125;</span> words.</span><br><span class="hljs-string"></span><br><span class="hljs-string">            Response format:</span><br><span class="hljs-string">            ### Final Version ###</span><br><span class="hljs-string">            [text after integrated]</span><br><span class="hljs-string">            </span><br><span class="hljs-string">            ### Feedback ###</span><br><span class="hljs-string">            [comments]</span><br><span class="hljs-string">            &quot;&quot;&quot;</span>,<br>            llm_config=&#123;<br>                <span class="hljs-string">&quot;config_list&quot;</span>: <span class="hljs-variable language_">self</span>.config_list,<br>                <span class="hljs-string">&quot;temperature&quot;</span>: <span class="hljs-number">0.5</span>,  <span class="hljs-comment"># Balanced randomness</span><br>            &#125;,<br>        )<br><br>        <span class="hljs-variable language_">self</span>.reporter = AssistantAgent(<br>            name=<span class="hljs-string">&quot;Reporter&quot;</span>,<br>            system_message=<span class="hljs-string">f&quot;&quot;&quot;</span><br><span class="hljs-string">            <span class="hljs-subst">&#123;total_prompt&#125;</span>,\n</span><br><span class="hljs-string">            The original article is: <span class="hljs-subst">&#123;self.original_article&#125;</span>\n</span><br><span class="hljs-string">            You are the final reporter, you will receive the final scripts modified, and make the last modifications:</span><br><span class="hljs-string">            1. Make sure all your modifications adhere to the English Usage.</span><br><span class="hljs-string">            2. Make sure the total length is no more than <span class="hljs-subst">&#123;self.max_length&#125;</span> words.</span><br><span class="hljs-string">            </span><br><span class="hljs-string">            Response format:</span><br><span class="hljs-string">            ### Final version ###</span><br><span class="hljs-string">            [final text]</span><br><span class="hljs-string"></span><br><span class="hljs-string">            ### Feedback ###</span><br><span class="hljs-string">            In this section, you are asked to generate a report about the modifications between the final version and the original version.</span><br><span class="hljs-string">            &quot;&quot;&quot;</span>,<br>            llm_config=&#123;<br>                <span class="hljs-string">&quot;config_list&quot;</span>: <span class="hljs-variable language_">self</span>.config_list,<br>                <span class="hljs-string">&quot;temperature&quot;</span>: <span class="hljs-number">0.1</span>,<br>            &#125;,<br>        )<br><br>        <span class="hljs-comment"># Configure group chat without custom_speaker_order</span><br>        <span class="hljs-variable language_">self</span>.group_chat = GroupChat(<br>            agents=[<br>                <span class="hljs-variable language_">self</span>.user_proxy,<br>                <span class="hljs-variable language_">self</span>.task_decomposer,<br>                <span class="hljs-variable language_">self</span>.editor1,<br>                <span class="hljs-variable language_">self</span>.editor2,<br>                <span class="hljs-variable language_">self</span>.integrator,<br>                <span class="hljs-variable language_">self</span>.reporter,<br>            ],<br>            messages=[],<br>            max_round=<span class="hljs-number">6</span>,<br>            speaker_selection_method=<span class="hljs-string">&quot;round_robin&quot;</span>,  <br>        )<br><br>        <span class="hljs-comment"># Group chat manager</span><br>        <span class="hljs-variable language_">self</span>.manager = GroupChatManager(<br>            groupchat=<span class="hljs-variable language_">self</span>.group_chat, llm_config=&#123;<span class="hljs-string">&quot;config_list&quot;</span>: <span class="hljs-variable language_">self</span>.config_list&#125;<br>        )<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;Execute the editing workflow&quot;&quot;&quot;</span><br>        print_progress(<span class="hljs-string">&quot;Starting article editing process...&quot;</span>)<br><br>        <span class="hljs-variable language_">self</span>.user_proxy.initiate_chat(<br>            <span class="hljs-variable language_">self</span>.manager,<br>            message=<span class="hljs-string">f&quot;&quot;&quot;</span><br><span class="hljs-string">            Article to edit:</span><br><span class="hljs-string">            <span class="hljs-subst">&#123;self.original_article&#125;</span></span><br><span class="hljs-string">            </span><br><span class="hljs-string">            Requirements:</span><br><span class="hljs-string">            <span class="hljs-subst">&#123;requirements&#125;</span></span><br><span class="hljs-string">            </span><br><span class="hljs-string">            Please begin editing process.</span><br><span class="hljs-string">            &quot;&quot;&quot;</span>,<br>        )<br><br>        <span class="hljs-comment"># Process final output</span><br>        final_message = <span class="hljs-variable language_">self</span>.group_chat.messages[-<span class="hljs-number">1</span>][<span class="hljs-string">&quot;content&quot;</span>]<br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;### Final Version ###&quot;</span> <span class="hljs-keyword">in</span> final_message:<br>            final_text = (<br>                final_message.split(<span class="hljs-string">&quot;### Final Version ###&quot;</span>)[<span class="hljs-number">1</span>]<br>                .split(<span class="hljs-string">&quot;### Feedback ###&quot;</span>)[<span class="hljs-number">0</span>]<br>                .strip()<br>            )<br>            write_file(final_text)<br>            print_progress(<span class="hljs-string">f&quot;Final article saved to Final.txt.&quot;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            print_progress(<br>                <span class="hljs-string">&quot;Process completed but final version format invalid. Check logs.&quot;</span><br>            )<br><br>        print_progress(<span class="hljs-string">f&quot;Conversation log saved to <span class="hljs-subst">&#123;self.log_filename&#125;</span>&quot;</span>)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    editor = AutoGenArticleEditor()<br>    editor.run()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Project</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Agents</tag>
      
      <tag>Essay Writing</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DataStructure-RBT-Tree</title>
    <link href="/posts/DataStructure-RBT-Tree/"/>
    <url>/posts/DataStructure-RBT-Tree/</url>
    
    <content type="html"><![CDATA[<style>  html, body, .markdown-body {    font-family: Georgia, sans, serif;  }</style><h1 id="Red-Black-Tree"><a href="#Red-Black-Tree" class="headerlink" title="Red-Black Tree"></a>Red-Black Tree</h1><h2 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h2><p>红黑树需要满足如下的平衡性：</p><ul><li><p>每个结点被标记为红色或者黑色</p></li><li><p>根节点是黑色</p><ul><li>一般来说，我们也会定义nullptr为黑色，并且<strong>把这些空节点定义为“叶节点”会更有利于分析</strong>。（Due to Definition 4）</li></ul></li><li><p>节点红色 -&gt; <strong>子节点是黑色</strong></p><ul><li>不可以存在两个连续的红色节点</li></ul></li><li><p>从任何一个节点出发到空节点（通常认为空节点为<strong>黑色节点</strong>），必须包含相同数量的<strong>黑色节点</strong>。</p></li></ul><p>从红黑树的定义出发，我们可以证明：<strong>红黑树保证$O(h) &#x3D; O(\log n)$.</strong></p><ul><li>如果任何一条从根节点到空节点的路径上存在$H$个黑色的节点，则整棵树必须至少有$2^H -1$个黑色节点，至多有$2^{2H} -1$个节点。<ul><li><strong>证明</strong>:可以形象的理解为一颗被压缩的二叉树，即把所有的红色节点删除，并且每一个黑色节点都有2个儿子（叶子结点除外），则根据完全二叉树的性质，$n \le 2^H -1$，并且$H$同时还代表着全黑的最短路径（如果存在的话）。</li><li>相反的，节点数最多的情况就是<strong>红黑节点交替排列</strong>，因此是一颗高度为$2H$的满二叉树，$n \ge 2^{2H} -1 $。，同时，这也代表着最长的路径。</li></ul></li><li>有公式$n \ge 2^{2H} -1 $，取对数即可证明$O(h) &#x3D; O(\log n)$。</li></ul><h2 id="Insert"><a href="#Insert" class="headerlink" title="Insert"></a>Insert</h2><p>将新节点插入到叶子结点，此时<strong>关键需要判断树是否满足RBT的四条基本定义</strong>。为了不破坏定义4，我们需要<strong>将插入的节点</strong>染色成<strong>红色节点</strong>。接下来：</p><ul><li>如果父亲节点是<strong>黑色节点</strong>：插入过程完成。</li><li>如果父亲节点是<strong>红色节点</strong>：需要进行调整</li></ul><p>下面，分成两种情况：</p><h3 id="Case1-父亲节点P的兄弟节点S是黑色的"><a href="#Case1-父亲节点P的兄弟节点S是黑色的" class="headerlink" title="Case1: 父亲节点P的兄弟节点S是黑色的"></a>Case1: 父亲节点P的兄弟节点S是黑色的</h3><p>如果X是P的外侧节点，则操作对应LL或者RR的情况，只需要单旋转一次即可，同时保证<strong>当前根节点</strong>仍然保证黑色，这样就不用继续调整后祖先节点，并且也调整了树的结构使其不出现染色冲突的问题。</p><p><img src="https://s1.imagehub.cc/images/2025/04/10/e183ce27fcd339ae11741c0af18d405a.png" alt="外侧节点"></p><p>如果X是P的内侧节点，类似于RL旋转和LR旋转，实现结构的调整：</p><p><img src="https://s1.imagehub.cc/images/2025/04/10/f773390d7116f037db57d1ade9710871.png" alt="内侧节点"></p><p>同理，也需要注意保持当前根节点依旧是黑色的。</p><h3 id="Case2-父亲节点P的兄弟节点S是红色的"><a href="#Case2-父亲节点P的兄弟节点S是红色的" class="headerlink" title="Case2: 父亲节点P的兄弟节点S是红色的"></a>Case2: 父亲节点P的兄弟节点S是红色的</h3><p>此时<strong>祖父节点</strong>一定是黑色节点，因此只需要父亲层和祖父层的颜色交换即可，但是，此时有可能上部的结构发生了破坏，需要不断向上检查。（此时有可能会变成Case1，见下图）</p><p><img src="https://s1.imagehub.cc/images/2025/04/10/7c8d36c9903e48dbf44f85262c16b18c.png" alt="Case2"></p><p><img src="https://s1.imagehub.cc/images/2025/04/10/a6aac3eacf64776dc2175e9da19a2e0a.png" alt="Case2 to Case1"></p><p>因此，我们可以归纳出插入过程的基本思路：</p><ul><li>如果在空树上插入，直接将<strong>节点变黑</strong>。（因为RBT要求<strong>根节点必须是黑色的节点，这也是递归的终止条件</strong>）</li><li>如果是case2（叔叔节点是红色的），则祖父节点和{叔叔节点、父亲节点}之前交换颜色，同时<strong>把祖父节点作为“当前插入的节点”</strong>并不断向上递归。</li><li>如果是case1（叔叔节点是黑色的），则进行类似于AVL树的<strong>LLb，RRb，LRb和RLb</strong>操作，只通过一次调整就可以实现结构的平衡。</li></ul><div class="note note-primary">            <p><strong>红黑树相比于传统AVL树有什么优势</strong>？</p><ul><li>如果父节点是黑色节点，则<strong>不需要执行任何的操作</strong>！这带来的很大的方便。</li><li>如果父节点是红色的并且是Case1，则最多只需要进行一次旋转。（<strong>无需向上回溯</strong>）</li></ul><p>我们发现，如果采用传统的<strong>递归到达叶节点插入对应元素然后再回溯改变染色</strong>，效率肯定没有AVL树高，但是我们可以在<strong>递归向下探索的时候就完成这些操作</strong>：</p><ul><li><p><strong>在寻找插入位置的时候，如果遇到结点$X$的两个儿子节点都是红色节点的时候，就翻转颜色</strong>。（即原来是黑色节点的$X$翻转成红色节点，同时$X$的两个儿子全部染色成红色）</p><ul><li>这样并没有修改任何一条路径上黑色节点的个数（就该次操作而言）</li><li>但是可能会造成染色冲突：<ul><li>$X$的父节点和$X$本身都是红色的节点，此时需要使用旋转操作，此时保证$X$的<strong>兄弟节点一定是黑色的</strong>（满足定义3并且$X$的父亲是红色节点）</li><li>此时需要对$X$的祖父节点进行对应的旋转操作</li></ul></li></ul><p>  这里看图解：</p><p>  <img src="https://s1.imagehub.cc/images/2025/04/10/ae268e918f1bdc5eba7a612bdfce6d07.png" alt="染色过程"></p></li><li><p>如果不全为红色：往下走一层</p><ul><li>如果新的$X$是红色的，那么兄弟节点是黑色的</li><li>如果新的$X$是黑色的，那么兄弟节点是红色的</li></ul></li></ul><p>这样就<strong>在向下寻找叶节点的过程中，可以自动的调整红黑树的结构，转化为可以进行性能优化的尾递归，不需要再回溯了！</strong></p>          </div><h2 id="Delete"><a href="#Delete" class="headerlink" title="Delete"></a>Delete</h2><p>接下来我们来看红黑树的<strong>删除操作</strong>。</p><p>在普通的二叉查找树中，树的删除可以分为三种情况：</p><ul><li>只有一个儿子</li><li>没有儿子</li><li>有两个儿子</li></ul><p>其中前两种情况是比较简单的，因为只涉及较少的移动就可以保证有序性，对于第三种情况，我们<strong>巧妙地找到了一个替身节点</strong>，并且删除了在叶节点的替身节点。因此，在本质上，<strong>有序树的删除操作可以归纳为删除叶节点（case1,3）或者删除只有一个儿子的节点(case 2)。</strong></p><p>如果被删除的节点是<strong>红色的</strong>，此时删除操作结束，因为没有任何违反定义的事情发生。</p><p>如果被删除的节点是<strong>黑色的</strong>，此时肯定会违反定义（每条路径上的黑色节点一样多）。</p><p>因此，我们进行自顶向下的寻找，记$X$为当前节点，$T$为兄弟节点，$P$为他们的父节点。<strong>对于每一个X，我们都尝试将它变成红色</strong>。（我们希望最后到达叶节点的时候可以直接删掉红色节点）</p><ul><li>$X$有两个黑色儿子<ul><li>需要<strong>染色</strong>+<strong>旋转</strong></li><li>$T$有两个黑色儿子<ul><li>T的颜色反转不会产生任何影响（对T的分支而言），因此之间父子之间反转颜色</li></ul></li><li>$T$有一个外侧的红色儿子<ul><li>在颜色反转后会存在红色冲突，需要进行一次单旋转并且重新着色</li></ul></li><li>$T$有一个内侧的红色儿子<ul><li>双旋转+重新着色</li></ul></li></ul></li><li>$X$至少有一个红色儿子<ul><li>如果$X$不是被删除节点，直接进入下一层<ul><li>如果进入到红色节点处（保证存在红色节点）：万事大吉</li><li>如果进入到黑色节点处：此时需要进行一次单旋转，此时$X$完成了下沉的操作并且父节点一定是黑色的（旋转）<ul><li>但是此时$X$仍然为黑色节点，所以需要继续操作！</li></ul></li></ul></li><li>如果$X$是删除节点并且有两个儿子<ul><li>在右子树寻找替身：<ul><li>如果右孩子为红色，直接下移一层</li><li>Otherwise，左孩子为红色，此时执行LL旋转使$X$变为红色。</li></ul></li></ul></li><li>如果$X$是删除节点并且只有一个儿子<ul><li>该孩子一定为红色节点（需要满足定义4）</li><li>做一次单旋转交换即可。</li></ul></li></ul></li></ul><blockquote><p>此处还是非常复杂的。。。笔者也在努力消化。。。</p></blockquote><h2 id="Codes-Impl"><a href="#Codes-Impl" class="headerlink" title="Codes Impl"></a>Codes Impl</h2><h1 id="AA-Tree"><a href="#AA-Tree" class="headerlink" title="AA Tree"></a>AA Tree</h1>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tutorial</tag>
      
      <tag>Data Structure</tag>
      
      <tag>C/C++</tag>
      
      <tag>Set</tag>
      
      <tag>Sorting</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DataStructure-AVL-Tree</title>
    <link href="/posts/DataStructure-AVL-Tree/"/>
    <url>/posts/DataStructure-AVL-Tree/</url>
    
    <content type="html"><![CDATA[<h1 id="AVL-Tree"><a href="#AVL-Tree" class="headerlink" title="AVL Tree"></a>AVL Tree</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p><strong>Intuition</strong>: 希望保证操作后$O(h)&#x3D;O(\log n)$。</p><h3 id="理论证明"><a href="#理论证明" class="headerlink" title="理论证明"></a>理论证明</h3><p>证明如下定理：一颗有N个节点的AVL Tree，高度满足$H \le 1.44\log(N + 1) - 0.328$</p><blockquote><p>等价问题的转化：<strong>确定高度最小化节点</strong> &#x3D;&#x3D; <strong>确定节点最大化高度</strong></p></blockquote><p>设$S_H$为高度为$H$的最小的AVL树（节点最少），显然：</p><p>$|S_1| &#x3D; 1$，$|S_2| &#x3D; 2$，$|S_3| &#x3D; 4$， $|S_4| &#x3D; 7$…</p><div class="note note-info">            <p>我们需要在保证为<strong>平衡树（平衡因子）</strong>的情况下尽可能压榨这棵树，使其节点数最少。</p><p>因此，我们可以给出如下的递推公式：</p><p>$$S_1 &#x3D; 1, S_2 &#x3D; 2, S_n &#x3D; S_{n-1} + S_{n-2} + 1$$</p><p><strong>和斐波那契数列非常像！</strong>记$F_i$为斐波那契数列，很容易证明$S_H &#x3D; F_{H+2} -1$。</p><p>带入斐波那契数列的通项公式，可以得到$S_H$的通项：</p><p>$$S_H&#x3D; [(\frac{1+\sqrt{5}}{2})^{H+2} - (\frac{1-\sqrt{5}}{2})^{H+2}] \times \frac{\sqrt{5}}{5}-1$$</p><p>经过一顿放缩（这里省略），最终可以得证。</p>          </div><blockquote><p><strong>$S_n &#x3D; S_{n-1} + S_{n-2} + 1$<strong>的递推式非常关键，这表明了在AVL Tree中，同样也存在</strong>递归的思想</strong>！</p></blockquote><p><img src="https://s1.imagehub.cc/images/2025/04/10/d9895bed03c4641620fe15031c22b62b.png" alt="AVL Tree的递推公式"></p><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><ul><li><p>AVL的插入仍然在<strong>叶节点</strong>，但是相比于二叉查找树，多了一步<strong>调整的操作</strong>，需要保证二叉树的<strong>平衡性</strong></p><ul><li>因此，在插入时，仍然保持<strong>递归的插入方式</strong>，但是多了检查的一步，寻找第一个平衡因子失衡为$\pm 2$的节点（也就是危机节点），然后需要<strong>进行旋转保持树的平衡性</strong>。</li><li>在回溯的过程中，需要验证其是否失衡（在插入完成后）</li></ul><blockquote><p>由于<strong>检查&amp;旋转</strong>是在递归终止之后回溯的时候进行的，也就是说顺序是<strong>自底向上</strong>，即我们只需要rotate第一个找到不平衡的节点，也就是危机节点。</p></blockquote></li></ul><p><img src="https://s1.imagehub.cc/images/2025/04/10/87929a16c30874070e78cfbcc3f6170c.jpg" alt="AVLTree"></p><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>对于一般的二叉查找树，AVL树需要找到右子树的<strong>最靠右</strong>的节点，也就是<strong>在中序遍历中紧挨在他后面的节点</strong>。对于AVL树，同样也需要额外的旋转操作，因为删除叶节点同样也可能会导致树的失衡。</p><p>首先，我们对要被删除的结点$x$做分类讨论：</p><ul><li>$x$为叶节点</li><li>$x$有一个儿子</li><li>$x$有两个儿子</li></ul><blockquote><p>前两种情况非常简单，<strong>不会产生非平衡的情况</strong>。</p></blockquote><p>完成和二叉查找树类似的删除操作之后，有可能会带来<strong>从$x$的父节点到根节点之间的祖先节点的平衡度发生变化</strong>，导致失衡。因此，在回溯阶段，需要向上检查，并做相应的旋转操作。但是删除操作比插入操作更加复杂，有可能需要旋转多个节点。因此，我们当检查在旋转调整后对应节点的高度保持不变时，<strong>即代表更新完毕</strong>，整棵树已经达到平衡的状态。</p><p>不失一般性，<strong>我们认为删除发生在左子树</strong>，一般会出现以下这5个状态。（<strong>注意是删除后的状态，因为检查环节在回溯部分</strong>）</p><p><img src="https://s1.imagehub.cc/images/2025/04/10/bd8b80c3297f7f04f120ba88600d7a6b.png" alt="删除的若干种情况"></p><ul><li>对于情况1，树的高度并没有发生变化，并且树的平衡性不变。<strong>返回true，不用再对祖先节点做操作</strong>。</li><li>对于情况2，树的高度从$h + 1$降低到$h$，但是<strong>子树的平衡性</strong>仍然保持，此时需要返回False。</li><li>对于情况3，很遗憾，两颗子树本来是$h-1$和$h$，同时删除操作发生在高度为$h-1$的树上变成了$h-2$，此时需要RR旋转一次，满足平衡性。同时树的高度更新为$h-1$，继续向上返回false。</li><li>对于情况4，<strong>使用RL旋转</strong>，但是此时子树的高度变矮了一层，需要向上返回False</li><li>对于情况5，<strong>使用RR旋转</strong>，并且树的高度保持不变，返回True。</li></ul><p><img src="https://s1.imagehub.cc/images/2025/04/10/a2901fde43c3d3a1657e514762b78d08.jpg" alt="AVL树的删除"></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">The implementation of AVL Tree, letting the tree maintain balanced</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">KEY</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">OTHER</span>&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">set</span> &#123;<br>    KEY key;<br>    OTHER other;<br>&#125;;<br><br><br><span class="hljs-comment">// Dynamic Search Table</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Key</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">Other</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">dynamicSearchTable</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// finding elements of x</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> set&lt;Key, Other&gt; *<span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">const</span> Key &amp;x)</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// insert element, maintaining the order</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">const</span> set&lt;Key, Other&gt; &amp;x)</span> </span>= <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// remove an element, maintaining the order</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">const</span> Key &amp;x)</span> </span>= <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">dynamicSearchTable</span>() &#123;&#125;<br>&#125;;<br><br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">KEY</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">OTHER</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AVLTree</span> : <span class="hljs-keyword">public</span> dynamicSearchTable&lt;KEY, OTHER&gt; &#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">AVLNode</span> &#123;<br>        set&lt;KEY, OTHER&gt; data;<br>        AVLNode *left;<br>        AVLNode *right;<br><br>        <span class="hljs-comment">// The height of the node,letting the Tree remain balanced</span><br>        <span class="hljs-type">int</span> height;<br><br>        <span class="hljs-built_in">AVLNode</span>(<span class="hljs-type">const</span> set&lt;KEY, OTHER&gt; &amp;element, AVLNode *left_, AVLNode *right_, <span class="hljs-type">int</span> h = <span class="hljs-number">1</span>)<br>            : <span class="hljs-built_in">data</span>(element), <span class="hljs-built_in">left</span>(left_), <span class="hljs-built_in">right</span>(right_), <span class="hljs-built_in">height</span>(h) &#123;&#125;<br>    &#125;;<br><br><span class="hljs-keyword">private</span>:<br>    AVLNode *root;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// Tool functions</span><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * @brief Update the height of the node</span><br><span class="hljs-comment">         * </span><br><span class="hljs-comment">         * @param root </span><br><span class="hljs-comment">         */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">updateHeight</span><span class="hljs-params">(AVLNode *&amp;root_)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root_ == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            root_-&gt;height = std::<span class="hljs-built_in">max</span>(<span class="hljs-built_in">height</span>(root_-&gt;left), <span class="hljs-built_in">height</span>(root_-&gt;right)) + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * @brief insert the new element in the tree, adjusting structures when necessary</span><br><span class="hljs-comment">         * </span><br><span class="hljs-comment">         * @param x </span><br><span class="hljs-comment">         * @param root_ </span><br><span class="hljs-comment">         */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">const</span> set&lt;KEY, OTHER&gt; &amp;x, AVLNode *&amp;root_)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root_ == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-comment">// insert in an empty tree</span><br>            root_ = <span class="hljs-keyword">new</span> <span class="hljs-built_in">AVLNode</span>(x, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x.key &lt; root_-&gt;data.key) &#123;<br>            <span class="hljs-comment">// insert in the left tree</span><br>            <span class="hljs-built_in">insert</span>(x, root_-&gt;left);<br><br>            <span class="hljs-comment">// judging whether is is out of balanced</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">height</span>(root_-&gt;left) - <span class="hljs-built_in">height</span>(root_-&gt;right) == <span class="hljs-number">2</span>) &#123;<br>                <span class="hljs-comment">// LL rotations or LR rotations</span><br>                <span class="hljs-keyword">if</span> (x.key &lt; root_-&gt;left-&gt;data.key) &#123;<br>                    <span class="hljs-built_in">LL</span>(root_);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-built_in">LR</span>(root_);<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x.key &gt; root_-&gt;data.key) &#123;<br>            <span class="hljs-comment">// insert in the right tree</span><br>            <span class="hljs-built_in">insert</span>(x, root_-&gt;right);<br><br>            <span class="hljs-comment">// judging whether it is out of balanced</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">height</span>(root_-&gt;right) - <span class="hljs-built_in">height</span>(root_-&gt;left) == <span class="hljs-number">2</span>) &#123;<br>                <span class="hljs-comment">// RR rotations or RL rotations</span><br>                <span class="hljs-keyword">if</span> (x.key &gt; (root_-&gt;right-&gt;data).key) &#123;<br>                    <span class="hljs-built_in">RR</span>(root_);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-built_in">RL</span>(root_);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// Repetetion makes no operations</span><br><br>        <span class="hljs-comment">// Update the height properties</span><br>        <span class="hljs-built_in">updateHeight</span>(root_);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * @brief Remove the element with the value x</span><br><span class="hljs-comment">         * </span><br><span class="hljs-comment">         * @param x key value</span><br><span class="hljs-comment">         * @param root_ current root node</span><br><span class="hljs-comment">         * @return true if the tree is balanced after the deletion</span><br><span class="hljs-comment">         * @return false </span><br><span class="hljs-comment">         */</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">const</span> KEY &amp;x, AVLNode *&amp;root_)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root_ == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (x == (root_-&gt;data).key) &#123;<br>            <span class="hljs-comment">// delete the root node</span><br>            <span class="hljs-keyword">if</span> (root_-&gt;left == <span class="hljs-literal">nullptr</span> || root_-&gt;right == <span class="hljs-literal">nullptr</span>) &#123;<br>                <span class="hljs-comment">// The delete node has at most one child (just swap the position)</span><br>                AVLNode *oldNode = root_;<br><br>                <span class="hljs-keyword">if</span> (root_-&gt;left == <span class="hljs-literal">nullptr</span>) &#123;<br>                    root_ = root_-&gt;right;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    root_ = root_-&gt;left;<br>                &#125;<br><br>                <span class="hljs-keyword">delete</span> oldNode;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// The deleted Node has two child node</span><br>                AVLNode *tmp = root_-&gt;right;<br>                <span class="hljs-comment">// Go to the lead node</span><br>                <span class="hljs-keyword">while</span> (tmp-&gt;left != <span class="hljs-literal">nullptr</span>) &#123;<br>                    tmp = tmp-&gt;left;<br>                &#125;<br><br>                root_-&gt;data = tmp-&gt;data;<br>                <span class="hljs-comment">// then remove the leaf node (tmp)</span><br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">remove</span>(tmp-&gt;data.key, root_-&gt;right)) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br><br>                <span class="hljs-keyword">return</span> <span class="hljs-built_in">adjust</span>(root_, <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (x &lt; (root_-&gt;data).key) &#123;<br>            <span class="hljs-comment">// delete on the left subtree</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">remove</span>(x, root_-&gt;left)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-built_in">adjust</span>(root_, <span class="hljs-number">0</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// delete on the right subtree</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">remove</span>(x, root_-&gt;right)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-built_in">adjust</span>(root_, <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * @brief Make the AVL tree empty</span><br><span class="hljs-comment">         * </span><br><span class="hljs-comment">         * @param root_ current root node</span><br><span class="hljs-comment">         */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">makeEmpty</span><span class="hljs-params">(AVLNode *root_)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root_ == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-built_in">makeEmpty</span>(root_-&gt;left);<br>        <span class="hljs-built_in">makeEmpty</span>(root_-&gt;right);<br>        <span class="hljs-keyword">delete</span> root_;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * @brief Return the height of the tree</span><br><span class="hljs-comment">         * </span><br><span class="hljs-comment">         * @param root_ </span><br><span class="hljs-comment">         * @return int </span><br><span class="hljs-comment">         */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">height</span><span class="hljs-params">(AVLNode *root_)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root_ == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> root_-&gt;height;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// Several Rotations</span><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * @brief Rotate if the insertion happens on the left child of the left child</span><br><span class="hljs-comment">         * </span><br><span class="hljs-comment">         * @param danger danger node</span><br><span class="hljs-comment">         */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">LL</span><span class="hljs-params">(AVLNode *&amp;danger)</span> </span>&#123;<br>        AVLNode *t1 = danger-&gt;left;<br><br>        <span class="hljs-comment">// rotate to adjust the structure</span><br>        danger-&gt;left = t1-&gt;right;<br>        t1-&gt;right = danger;<br><br>        <span class="hljs-comment">// update height</span><br>        <span class="hljs-built_in">updateHeight</span>(danger);<br>        <span class="hljs-built_in">updateHeight</span>(t1);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * @brief Rotation if the insertion happens in the right child of the right child of the danger node</span><br><span class="hljs-comment">         * </span><br><span class="hljs-comment">         * @param danger The danger node</span><br><span class="hljs-comment">         */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RR</span><span class="hljs-params">(AVLNode *&amp;danger)</span> </span>&#123;<br>        <span class="hljs-comment">// The same with LL rotations</span><br>        AVLNode *t1 = danger-&gt;right;<br><br>        <span class="hljs-comment">// rotate RR</span><br>        danger-&gt;right = t1-&gt;left;<br>        t1-&gt;left = danger;<br><br>        <span class="hljs-comment">// update height</span><br>        <span class="hljs-built_in">updateHeight</span>(danger);<br>        <span class="hljs-built_in">updateHeight</span>(t1);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * @brief danger.leftchild.rightchild = insertion_place</span><br><span class="hljs-comment">         * </span><br><span class="hljs-comment">         * @param danger </span><br><span class="hljs-comment">         */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">LR</span><span class="hljs-params">(AVLNode *&amp;danger)</span> </span>&#123;<br>        <span class="hljs-built_in">RR</span>(danger-&gt;left);<br>        <span class="hljs-built_in">LL</span>(danger);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * @brief danger.rightchild.leftchild = insertion_place</span><br><span class="hljs-comment">         * </span><br><span class="hljs-comment">         * @param root_ </span><br><span class="hljs-comment">         */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RL</span><span class="hljs-params">(AVLNode *&amp;danger)</span> </span>&#123;<br>        <span class="hljs-built_in">LL</span>(danger-&gt;right);<br>        <span class="hljs-built_in">RR</span>(danger);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * @brief Judge whether the tree remain the same height after the deletion</span><br><span class="hljs-comment">         * </span><br><span class="hljs-comment">         * @param root_ the current root node</span><br><span class="hljs-comment">         * @param subTree 1 for deleting on the right child, 0 for left child</span><br><span class="hljs-comment">         * @return true </span><br><span class="hljs-comment">         * @return false </span><br><span class="hljs-comment">         */</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">adjust</span><span class="hljs-params">(AVLNode *&amp;root_, <span class="hljs-type">int</span> subTree)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (subTree) &#123;<br>            <span class="hljs-comment">// Delete on the right child</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">height</span>(root_-&gt;left) - <span class="hljs-built_in">height</span>(root_-&gt;right) == <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-comment">// Case1: the height remains unchanged</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">height</span>(root_-&gt;left) == <span class="hljs-built_in">height</span>(root_-&gt;right)) &#123;<br>                --(root_-&gt;height);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">height</span>((root_-&gt;left)-&gt;right) &gt; <span class="hljs-built_in">height</span>((root_-&gt;left)-&gt;left)) &#123;<br>                <span class="hljs-built_in">LR</span>(root_);<br>                <span class="hljs-comment">// The height changed!</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-built_in">LL</span>(root_);<br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">height</span>(root_-&gt;right) == <span class="hljs-built_in">height</span>(root_-&gt;left)) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">height</span>(root_-&gt;right) - <span class="hljs-built_in">height</span>(root_-&gt;left) == <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-comment">// Case1: the height remains unchanged</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">height</span>(root_-&gt;left) == <span class="hljs-built_in">height</span>(root_-&gt;right)) &#123;<br>                --(root_-&gt;height);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">height</span>((root_-&gt;right)-&gt;left) &gt; <span class="hljs-built_in">height</span>((root_-&gt;right)-&gt;right)) &#123;<br>                <span class="hljs-built_in">RL</span>(root_);<br>                <span class="hljs-comment">// The height changed!</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-built_in">RR</span>(root_);<br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">height</span>(root_-&gt;right) == <span class="hljs-built_in">height</span>(root_-&gt;left)) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * @brief Construct a new AVLTree object</span><br><span class="hljs-comment">         * </span><br><span class="hljs-comment">         */</span><br>    <span class="hljs-built_in">AVLTree</span>() &#123;<br>        root = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// destructor</span><br>    ~<span class="hljs-built_in">AVLTree</span>() &#123;<br>        <span class="hljs-built_in">makeEmpty</span>(root);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * @brief Finding the elements with the key value of x, the same with BST</span><br><span class="hljs-comment">         * </span><br><span class="hljs-comment">         * @param x </span><br><span class="hljs-comment">         * @return set&lt;KEY, OTHER&gt;* </span><br><span class="hljs-comment">         */</span><br>    <span class="hljs-function">set&lt;KEY, OTHER&gt; *<span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">const</span> KEY &amp;x)</span> <span class="hljs-type">const</span> </span>&#123;<br>        AVLNode *t = root;<br>        <span class="hljs-keyword">while</span> (t != <span class="hljs-literal">nullptr</span> &amp;&amp; t-&gt;data.key != x) &#123;<br>            <span class="hljs-keyword">if</span> (t-&gt;data.key &gt; x) &#123;<br>                <span class="hljs-comment">// skip to the left tree</span><br>                t = t-&gt;left;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                t = t-&gt;right;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (t == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">return</span> (set&lt;KEY, OTHER&gt; *) t;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">const</span> set&lt;KEY, OTHER&gt; &amp;x)</span> </span>&#123;<br>        <span class="hljs-built_in">insert</span>(x, root);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">const</span> KEY &amp;x)</span> </span>&#123;<br>        <span class="hljs-built_in">remove</span>(x, root);<br>    &#125;<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// Create an AVLTree instance</span><br>    AVLTree&lt;<span class="hljs-type">int</span>, std::string&gt; tree;<br><br>    <span class="hljs-comment">// Insert elements into the AVL tree</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Inserting elements into the AVL tree...&quot;</span> &lt;&lt; std::endl;<br>    tree.<span class="hljs-built_in">insert</span>(&#123;<span class="hljs-number">10</span>, <span class="hljs-string">&quot;Ten&quot;</span>&#125;);<br>    tree.<span class="hljs-built_in">insert</span>(&#123;<span class="hljs-number">20</span>, <span class="hljs-string">&quot;Twenty&quot;</span>&#125;);<br>    tree.<span class="hljs-built_in">insert</span>(&#123;<span class="hljs-number">30</span>, <span class="hljs-string">&quot;Thirty&quot;</span>&#125;);<br>    tree.<span class="hljs-built_in">insert</span>(&#123;<span class="hljs-number">40</span>, <span class="hljs-string">&quot;Forty&quot;</span>&#125;);<br>    tree.<span class="hljs-built_in">insert</span>(&#123;<span class="hljs-number">50</span>, <span class="hljs-string">&quot;Fifty&quot;</span>&#125;);<br>    tree.<span class="hljs-built_in">insert</span>(&#123;<span class="hljs-number">25</span>, <span class="hljs-string">&quot;Twenty-Five&quot;</span>&#125;);<br><br>    <span class="hljs-comment">// Search for an element in the AVL tree</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Searching for key 20 in the AVL tree...&quot;</span> &lt;&lt; std::endl;<br>    <span class="hljs-keyword">auto</span> result = tree.<span class="hljs-built_in">find</span>(<span class="hljs-number">20</span>);<br>    <span class="hljs-keyword">if</span> (result != <span class="hljs-literal">nullptr</span>) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Found: &quot;</span> &lt;&lt; result-&gt;key &lt;&lt; <span class="hljs-string">&quot; -&gt; &quot;</span> &lt;&lt; result-&gt;other &lt;&lt; std::endl;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Key 20 not found in the AVL tree.&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-comment">// Remove an element from the AVL tree</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Removing key 20 from the AVL tree...&quot;</span> &lt;&lt; std::endl;<br>    tree.<span class="hljs-built_in">remove</span>(<span class="hljs-number">20</span>);<br><br>    <span class="hljs-comment">// Search for the removed element</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Searching for key 20 after removal...&quot;</span> &lt;&lt; std::endl;<br>    result = tree.<span class="hljs-built_in">find</span>(<span class="hljs-number">20</span>);<br>    <span class="hljs-keyword">if</span> (result != <span class="hljs-literal">nullptr</span>) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Found: &quot;</span> &lt;&lt; result-&gt;key &lt;&lt; <span class="hljs-string">&quot; -&gt; &quot;</span> &lt;&lt; result-&gt;other &lt;&lt; std::endl;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Key 20 not found in the AVL tree.&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-comment">// Insert more elements to test balancing</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Inserting more elements to test balancing...&quot;</span> &lt;&lt; std::endl;<br>    tree.<span class="hljs-built_in">insert</span>(&#123;<span class="hljs-number">5</span>, <span class="hljs-string">&quot;Five&quot;</span>&#125;);<br>    tree.<span class="hljs-built_in">insert</span>(&#123;<span class="hljs-number">15</span>, <span class="hljs-string">&quot;Fifteen&quot;</span>&#125;);<br><br>    <span class="hljs-comment">// Final search to verify tree structure</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Searching for key 15 in the AVL tree...&quot;</span> &lt;&lt; std::endl;<br>    result = tree.<span class="hljs-built_in">find</span>(<span class="hljs-number">15</span>);<br>    <span class="hljs-keyword">if</span> (result != <span class="hljs-literal">nullptr</span>) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Found: &quot;</span> &lt;&lt; result-&gt;key &lt;&lt; <span class="hljs-string">&quot; -&gt; &quot;</span> &lt;&lt; result-&gt;other &lt;&lt; std::endl;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Key 15 not found in the AVL tree.&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;AVL tree test completed.&quot;</span> &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tutorial</tag>
      
      <tag>Tree</tag>
      
      <tag>Data Structure</tag>
      
      <tag>C/C++</tag>
      
      <tag>Binary Tree</tag>
      
      <tag>AVL Tree</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DataStructure-LCA</title>
    <link href="/posts/DataStructure-LCA/"/>
    <url>/posts/DataStructure-LCA/</url>
    
    <content type="html"><![CDATA[<style>  html, body, .markdown-body {    font-family: Georgia, sans, serif;  }</style><h1 id="Data-Structure-LCA"><a href="#Data-Structure-LCA" class="headerlink" title="Data Structure: LCA"></a>Data Structure: LCA</h1><p>LCA: （<strong>Lowest Common Ancestor</strong>）<strong>最近公共祖先问题</strong></p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>什么是<strong>公共祖先问题</strong>？我们进行问题重述：</p><p>给定一棵<strong>有根树</strong>$T$，考虑两个节点$u$，$v$，则要求找出树中的一个节点$target&#x3D;LCA(T,u,v)$，使节点$target$满足：</p><ul><li>$target$是节点$u$和$v$的<strong>公共祖先</strong>。</li><li>在满足性质1的条件下，要求**$target$的深度尽可能的深（即离根节点尽可能的远，离两个节点尽可能的近）**。</li></ul><p>对于该问题，我们需要对一棵节点数为$N$的树进行$M$次询问。</p><h2 id="朴素解法"><a href="#朴素解法" class="headerlink" title="朴素解法"></a>朴素解法</h2><p>解决单次询问并不是很难的一件事，我们可以在$O(h)\le O(N)$的时间复杂度下完成。</p><p>首先，我们需要移动两个节点到<strong>同一深度</strong>，即$height$相同。接下来需要两个节点不断完成<strong>找爸爸</strong>的操作，<strong>找到第一个相遇的点即为所求</strong>。</p><p>显然，对于最坏的情况，（比如一棵严重退化的树），完成$M$次查询的复杂度是$O(MN)$。</p><h2 id="倍增优化"><a href="#倍增优化" class="headerlink" title="倍增优化"></a>倍增优化</h2><p>如何优化？我们先把两个节点调整到相同的高度。由于我们计算的是<strong>最近</strong>公共祖先问题，我们显然知道：<strong>如果$S$是最近公共祖先，那么$S$的所有祖先节点</strong>肯定也都是满足条件1的公共祖先！因此，如果把<strong>是不是一个公共祖先</strong>定义为一个bool值，那么这明显是一个单调递减的序列（$111..10000..00$）,我们可以使用<strong>二分查找</strong>的方式来找到最终的答案，二分查找本身的复杂度是$O(\log n)$。</p><p>但是这样存在一个问题，<strong>我们需要在低于线性时间复杂度内知道每一个节点向上跳n次会调到哪一个节点</strong>，即$upd(u,d)$，$u$是节点，$d$是向上跳的层数，最终返回一个节点值。我们需要进行预处理，来实现这个函数的高效运算。</p><p>如何预处理？<strong>倍增法！</strong>（因为这不是一个可重复性贡献问题），我们可以使用$fa[u][i]$代表$upd(u,d&#x3D;2^i)$的值，然后使用<strong>倍增法</strong>拼起来，这样就可以实现每次查询$O(\log n)$的时间复杂度。对于预处理的过程，可以直接使用<strong>深度优先搜索</strong>，在预处理好祖先节点的时候，使用<strong>动态规划</strong>就计算当前节点的预处理的值，并且继续递归处理当前节点的子节点。</p><p>代码如下：</p>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-11763cb6" role="button" aria-expanded="false" aria-controls="collapse-11763cb6">        <div class="fold-arrow">▶</div>TOBEDONE      </div>      <div class="fold-collapse collapse" id="collapse-11763cb6">        <div class="fold-content">          <p>别看了，这没写完，快去写作业叭。</p>        </div>      </div>    </div><p>使用倍增法，我们可以实现在预处理过后<strong>单次查询的复杂度是$O(\log ^2 (n))$</strong>,同时，既然我们已经使用了倍增算法，就不必再二分查找了，我们可以从大到小枚举$2^i$，如果不一样就直接跳，一样就不要动，这样也可以在$O(\log n)$的时间内完成查询操作。</p><p><strong>最终我们实现算法的复杂度如下</strong>：</p><ul><li>预处理查询：$O(n\log n)$</li><li>$M$次查询：$O(M\log n)$</li></ul><h2 id="欧拉序"><a href="#欧拉序" class="headerlink" title="欧拉序"></a>欧拉序</h2><p>在介绍欧拉序之前先介绍一下<strong>DFS</strong>序：</p><p><strong>树的DFS序列，也就是树的深搜序，它的概念是：树的每一个节点在深度优先遍历中进出栈的时间序列。</strong></p><p>具体来说，在DFS序列中，每一个节点会出现两次，分别代表<strong>入队时刻</strong>和<strong>出队时刻</strong>，即<strong>开始探索这个节点</strong>和<strong>探索完毕离开这个节点（递归：探索完毕这个节点的所有子节点）</strong>。例如我们可以有如下的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">implementation of DFS search</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Tree</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    std::vector&lt;std::vector&lt;<span class="hljs-type">int</span>&gt;&gt; adjList; <span class="hljs-comment">// Adjacency list representation of the tree</span><br>    std::vector&lt;<span class="hljs-type">int</span>&gt; dfsOrder;            <span class="hljs-comment">// Stores the DFS order</span><br><br>    <span class="hljs-comment">// Helper function for DFS traversal</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> node, <span class="hljs-type">int</span> parent)</span> </span>&#123;<br>        dfsOrder.<span class="hljs-built_in">push_back</span>(node); <span class="hljs-comment">// Add the current node to the DFS order (entering the node)</span><br><br>        <span class="hljs-comment">// Visit all children of the current node</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> child : adjList[node]) &#123;<br>            <span class="hljs-keyword">if</span> (child != parent) &#123; <span class="hljs-comment">// Avoid revisiting the parent node</span><br>                <span class="hljs-built_in">dfs</span>(child, node);<br>            &#125;<br>        &#125;<br><br>        dfsOrder.<span class="hljs-built_in">push_back</span>(node); <span class="hljs-comment">// Add the current node to the DFS order again (leaving the node)</span><br>    &#125;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// Constructor to initialize the tree with n nodes</span><br>    <span class="hljs-built_in">Tree</span>(<span class="hljs-type">int</span> n) &#123;<br>        adjList.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">1</span>); <span class="hljs-comment">// Nodes are 1-indexed</span><br>    &#125;<br><br>    <span class="hljs-comment">// Add an edge to the tree</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addEdge</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span>&#123;<br>        adjList[u].<span class="hljs-built_in">push_back</span>(v);<br>        adjList[v].<span class="hljs-built_in">push_back</span>(u); <span class="hljs-comment">// Since it&#x27;s an undirected tree</span><br>    &#125;<br><br>    <span class="hljs-comment">// Perform DFS and return the DFS order</span><br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">getDFSOrder</span><span class="hljs-params">(<span class="hljs-type">int</span> root)</span> </span>&#123;<br>        dfsOrder.<span class="hljs-built_in">clear</span>(); <span class="hljs-comment">// Clear any previous DFS order</span><br>        <span class="hljs-built_in">dfs</span>(root, <span class="hljs-number">-1</span>);    <span class="hljs-comment">// Start DFS from the root node</span><br>        <span class="hljs-keyword">return</span> dfsOrder;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// Create a tree with 7 nodes</span><br>    <span class="hljs-function">Tree <span class="hljs-title">tree</span><span class="hljs-params">(<span class="hljs-number">7</span>)</span></span>;<br><br>    <span class="hljs-comment">// Add edges to the tree</span><br>    tree.<span class="hljs-built_in">addEdge</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>    tree.<span class="hljs-built_in">addEdge</span>(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>);<br>    tree.<span class="hljs-built_in">addEdge</span>(<span class="hljs-number">2</span>, <span class="hljs-number">4</span>);<br>    tree.<span class="hljs-built_in">addEdge</span>(<span class="hljs-number">2</span>, <span class="hljs-number">5</span>);<br>    tree.<span class="hljs-built_in">addEdge</span>(<span class="hljs-number">3</span>, <span class="hljs-number">6</span>);<br>    tree.<span class="hljs-built_in">addEdge</span>(<span class="hljs-number">3</span>, <span class="hljs-number">7</span>);<br><br>    <span class="hljs-comment">// Get the DFS order starting from node 1</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;DFS Order (with enter and leave) starting from node 1:&quot;</span> &lt;&lt; std::endl;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; dfsOrder = tree.<span class="hljs-built_in">getDFSOrder</span>(<span class="hljs-number">1</span>);<br><br>    <span class="hljs-comment">// Print the DFS order</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> node : dfsOrder) &#123;<br>        std::cout &lt;&lt; node &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    std::cout &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">DFS</span> Order (with enter and leave) starting from node <span class="hljs-number">1</span>:<br><span class="hljs-attribute">1</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">5</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">6</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">7</span> <span class="hljs-number">3</span> <span class="hljs-number">1</span> <br></code></pre></td></tr></table></figure><p>这棵树长这样：</p><pre><code class="mermaid" >graph TD    1[1] --> 2[2]    1[1] --> 3[3]    2[2] --> 4[4]    2[2] --> 5[5]    3[3] --> 6[6]    3[3] --> 7[7]</code></pre><p>我们来观察这个序列，会发现重要的性质：选择DFS序中那个$u$开始，$u$结束的子序列中长度一定是偶数，并且所有涉及的节点<strong>全部是u的子孙节点</strong>。换句话说DFS序的最大作用就是把复杂的<strong>树状结构</strong>转化成方便处理的<strong>线性结构</strong>。</p><p>在介绍完DFS序列之后，我们就可以介绍欧拉序列了，<strong>欧拉序的定义是：从根节点出发到回到根节点为止，按深度优先遍历的顺序所经过的所有点的顺序。</strong>欧拉序在顺序上反映了<strong>在遍历一棵树的时候向下递归和回溯的具体路径。</strong></p><p>例如下面的树：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Add edges to the tree</span><br>tree.<span class="hljs-built_in">addEdge</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>tree.<span class="hljs-built_in">addEdge</span>(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>);<br>tree.<span class="hljs-built_in">addEdge</span>(<span class="hljs-number">2</span>, <span class="hljs-number">4</span>);<br>tree.<span class="hljs-built_in">addEdge</span>(<span class="hljs-number">2</span>, <span class="hljs-number">5</span>);<br>tree.<span class="hljs-built_in">addEdge</span>(<span class="hljs-number">3</span>, <span class="hljs-number">6</span>);<br>tree.<span class="hljs-built_in">addEdge</span>(<span class="hljs-number">3</span>, <span class="hljs-number">7</span>);<br>tree.<span class="hljs-built_in">addEdge</span>(<span class="hljs-number">4</span>, <span class="hljs-number">8</span>);<br>tree.<span class="hljs-built_in">addEdge</span>(<span class="hljs-number">6</span>, <span class="hljs-number">9</span>);<br>tree.<span class="hljs-built_in">addEdge</span>(<span class="hljs-number">6</span>, <span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure><p>其DFS序和欧拉序的顺序如下：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">DFS</span> Order (with enter and leave) starting from node <span class="hljs-number">1</span>:<br><span class="hljs-attribute">1</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span> <span class="hljs-number">8</span> <span class="hljs-number">8</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">5</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">6</span> <span class="hljs-number">9</span> <span class="hljs-number">9</span> <span class="hljs-number">10</span> <span class="hljs-number">10</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">7</span> <span class="hljs-number">3</span> <span class="hljs-number">1</span> <br><span class="hljs-attribute">Euler</span> Order starting from node <span class="hljs-number">1</span>:<br><span class="hljs-attribute">1</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span> <span class="hljs-number">8</span> <span class="hljs-number">4</span> <span class="hljs-number">2</span> <span class="hljs-number">5</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">6</span> <span class="hljs-number">9</span> <span class="hljs-number">6</span> <span class="hljs-number">10</span> <span class="hljs-number">6</span> <span class="hljs-number">3</span> <span class="hljs-number">7</span> <span class="hljs-number">3</span> <span class="hljs-number">1</span> <br></code></pre></td></tr></table></figure><blockquote><p>欧拉序的长度为$2n-1$，而DFS序的长度为$2n$，因为<strong>每个点在欧拉序中出现的次数等于这个点的度数（该节点的子孙节点数量）</strong>，因为DFS到的时候加进一次，回去的时候也加进。</p></blockquote><p>观察欧拉序，我们很容易发现：<strong>给定两个节点$u$，$v$，从$u$到$v$的欧拉序路径上一定会经过最近公共祖先，并且只会经过一次！（而且其他的公共祖先都不会出现）</strong>。我们巧妙的利用DFS的性质实现从树结构到线性结构的转化。也就是说，我们只需要求一段区间中<strong>深度最小</strong>的点就是LCA!</p><blockquote><p>这样，通过一次欧拉序变化，<strong>我们将求LCA问题</strong>转化为<strong>经典RMQ问题</strong>！</p><p>对于RMQ问题，可以使用ST表等内容解决。（因为是可重复性贡献问题）</p></blockquote><p>代码如下：</p>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-11763cb6" role="button" aria-expanded="false" aria-controls="collapse-11763cb6">        <div class="fold-arrow">▶</div>TOBEDONE      </div>      <div class="fold-collapse collapse" id="collapse-11763cb6">        <div class="fold-content">          <p>别看了，这没写完，快去写作业叭。</p>        </div>      </div>    </div><p><strong>最终我们实现的算法复杂度如下</strong>：</p><ul><li>预处理求欧拉序数组：$O(n)$</li><li>预处理求ST表：$O(n\log n)$</li><li>M次查询，每一次都是$O(1)$的常数时间复杂度。</li></ul><p>因此整体时间复杂度为$O(n\log n+M)$。</p><blockquote><p>RMQ问题也可以转化成<strong>LCA</strong>问题来解决，将原序列转化为对应的<strong>笛卡尔树</strong>即可。 </p></blockquote><h2 id="Applications"><a href="#Applications" class="headerlink" title="Applications"></a>Applications</h2><h3 id="树上差分问题"><a href="#树上差分问题" class="headerlink" title="树上差分问题"></a>树上差分问题</h3>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tutorial</tag>
      
      <tag>Tree</tag>
      
      <tag>Data Structure</tag>
      
      <tag>C/C++</tag>
      
      <tag>LCA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Algorithm-MCTS</title>
    <link href="/posts/Algorithm-MCTS/"/>
    <url>/posts/Algorithm-MCTS/</url>
    
    <content type="html"><![CDATA[<style>  html, body, .markdown-body {    font-family: Georgia, sans, serif;  }</style><h1 id="Monte-Carlo-Tree-Search"><a href="#Monte-Carlo-Tree-Search" class="headerlink" title="Monte Carlo Tree Search"></a>Monte Carlo Tree Search</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>今天介绍非常经典的AI领域的<strong>搜索算法</strong>之一：蒙特卡洛树搜索（<strong>Monte Carlo Tree Search</strong>）！</p><h3 id="传统的树搜索算法"><a href="#传统的树搜索算法" class="headerlink" title="传统的树搜索算法"></a>传统的树搜索算法</h3><p><strong>树搜索算法</strong>是非常常见的一类算法，例如在棋类游戏中，我们需要使用树搜索算法来找到下一步（近似）最优的策略来提高胜率。但是传统的树搜索算法在解决这个问题的时候存在如下的局限性：</p><ul><li><p>搜索空间问题</p><ul><li>传统的树搜索枚举算法 ($O(b^d)$)在面对较大的搜索空间时效率非常低。</li></ul></li><li><p>高分支因子问题 (Branching Factor)</p><ul><li>Binary Tree: 2</li><li>Chess: 35</li><li>Go: 250</li></ul><p>  这里的<strong>分支因子</strong>就是上文的 $b$ ，即每扩张一个节点需要扩展出多少个子节点。显然这个提升是<strong>指数级别的</strong>，面对复杂决策问题是计算机很难在有限的时间内找到可行的算法。</p></li></ul><p>不过，一些<strong>优化算法</strong>已经对这个问题做出了大幅度的剪枝，例如 <strong>Alpha-Beta 剪枝</strong> $(O(b^{\frac{d}{2}}))$：但是无法有效解决高分支因子问题。类似的解决思路包括<strong>启发式算法</strong>的设计，但是启发式算法严格依赖专业知识和代价函数的设计，设计一个通用性的算法存在较大的难度。</p><blockquote><p>有关<strong>Alpha-Beta</strong>剪枝算法和<strong>极大值极小值算法</strong>同样非常有趣！准备开坑。</p></blockquote><h3 id="问题出在哪？"><a href="#问题出在哪？" class="headerlink" title="问题出在哪？"></a>问题出在哪？</h3><p>显然，让计算机在众多的可能性中模拟出当前最优决策是一件非常困难的事情，因此，我们不妨把问题适当放宽，<strong>我们只是希望走出相对好的一步，而并不严格要求“最好”的一步呢</strong>？（在实际比赛中，你也不可能要求每一位旗手每一步都下出最优解）。</p><p>对于传统的暴力和剪枝算法，其最终目标都是<strong>求出严格全局最小值</strong>，因此带来极大的计算成本。或许，我们并不需要计算的那么仔细！<strong>Just Randomly！</strong></p><h3 id="蒙特卡洛算法"><a href="#蒙特卡洛算法" class="headerlink" title="蒙特卡洛算法"></a>蒙特卡洛算法</h3><p>蒙特卡洛算法是基于随机数和概率的一种算法。</p><p>简单来说，就是与其进行复杂的<strong>确定性演算法</strong>，蒙特卡洛算法背靠强大的概率论，使其在较低的时空开销下就可以拟合出较高精度的结果。</p><p><img src="https://s1.imagehub.cc/images/2025/04/09/9d97ac36d33a2f3a85577ddaa8e2a332.png" alt="基于蒙特卡洛算法估算圆周率"></p><p>因此，我们便可以实现<strong>基于蒙特卡洛算法的树搜索</strong>，简称<strong>蒙特卡洛树搜索</strong>。</p><h2 id="Algorithms"><a href="#Algorithms" class="headerlink" title="Algorithms"></a>Algorithms</h2><h3 id="Nodes"><a href="#Nodes" class="headerlink" title="Nodes"></a>Nodes</h3><p>在蒙特卡洛树搜索中，我们需要在树的每一个节点中储存如下信息：</p><ul><li><strong>状态信息</strong>： 节点对应的状态（当前棋局的对弈情况）</li><li><strong>动作信息</strong>：从父节点到当前节点需要采取的动作</li><li><strong>访问次数</strong>：这个节点在算法中是否被访问过？这对后续算&#x3D;算法的计算非常关键。</li><li><strong>累计奖励</strong>：蒙特卡洛算法的核心，将决策量化的指标</li><li><strong>父节点指针和子节点列表</strong></li><li><code>bool</code>：<strong>是否完全扩展</strong>：即该节点是否完全扩展（其后续下一步可能的情况是否全部添加到树中）</li></ul><h3 id="Flowchart"><a href="#Flowchart" class="headerlink" title="Flowchart"></a>Flowchart</h3><p><img src="https://s1.imagehub.cc/images/2025/04/09/1fd155d14eb3e3f43bb72b4a4f06b9ee.png" alt="MCTS"></p><p>在每一次蒙特卡洛算法的时候，我们需要从当前状态$q_s$出发（$s$代表目前游戏的轮数），通过算法计算找到“<strong>最优的下一步</strong>”，也就是说问题可以转化为：</p><p>给定当前状态 $ q_s $（表示第 $ s $ 轮的状态），我们需要找到下一个状态 $ q_{s+1} $，它对应的动作 $ a $ 应该满足以下条件：</p><p>$$a^* &#x3D; \arg\max_{a \in \mathcal{A}(q_s)} \mathbb{E}[R(q_s, a)]$$</p><p>$\mathbb{E}[R(q_s, a)]$代表在对应动作下所获得的期望，也就是选择最能让我赢得比赛的子节点。</p><p>因此，算法是从当前节点开始的，作为<code>current_node</code>，接下来，蒙特卡洛算法会<strong>向下探索尝试更新每一个子节点的value值</strong>。首先进入第一个while循环：<strong>沿着子节点向下走直到当前节点为叶节点</strong>，那如何选择沿着哪一个子节点向下走呢？在这里给出<strong>UCB1</strong>公式，算法将会选择UCB值最大的子节点进行探索。</p><div class="note note-primary">            <h4 id="UCB1"><a href="#UCB1" class="headerlink" title="UCB1"></a>UCB1</h4><p>$$\text{UCB1}(v’) &#x3D; \frac{Q(v’)}{N(v’)} + c \times \sqrt{\frac{\ln N(v)}{N(v’)}}$$</p><ul><li><p>$v’$ 是子节点</p></li><li><p>$Q(v’)$ 是子节点的累计价值</p></li><li><p>$N(v’)$ 是子节点的访问次数</p></li><li><p>$N(v)$ 是父节点的访问次数 </p></li><li><p>$c$ 是探索参数（通常设为$\sqrt{2}$）</p></li></ul><p>关于UCB有几条很有意思的性质：</p><ul><li><strong>UCB非常鼓励对未知节点的探索</strong>，显然当$N(v’)$为0是时，UCB的值会陷入无穷大，肯定会被选择。</li><li><strong>UCB</strong>实现了对已知和未知的tradeoff，一方面，子节点访问次数少的节点会更有几率被选择到，另一方面，子节点访问次数多的节点的累计价值也会更高，如果其价值足够的高，确实能够为自己赢得<strong>再被探索一次</strong>的机会。</li></ul>          </div><p>跳出第一个循环后，马上来到<strong>第二个循环</strong>，此时我们已经来到了叶节点，我们需要判断这个节点<strong>是否被探索过</strong>，如果没有被探索过，那此时就要进行<strong>rollout</strong>的模拟操作：<strong>从这个未被探索过的节点出发，随机模拟比赛的进行，直到比赛结束</strong>。如果被探索过了，那说明这个节点已经完成了<strong>rollout</strong>的模拟，此时需要进行<strong>叶节点的扩展操作</strong>，即添加新的节点到树中。</p><p>在rollout完成过后，会得到一个游戏结果，此时需要进行<strong>反向传播</strong>，即更新“来时路”上所有节点的<strong>value</strong>值，这里采用累加的方法。例如如果最终游戏结局的分数是20，那么路径上的所有节点的value都要加20。<strong>一直到回到最开始的节点</strong>，完成一次大迭代。</p><p>最终，蒙特卡洛算法会限制每一步的迭代次数，当迭代次数满了之后，就回到<strong>最开始的节点选择value最大的节点</strong>。因此，蒙特卡洛最关键的算法其实包含四个部分：<strong>选择(selection)<strong>，</strong>扩展（expansion）</strong>，<strong>模拟（rollout）</strong>和 <strong>反向传播（Back Propagation）</strong>。</p><p><img src="https://s1.imagehub.cc/images/2025/04/09/4a146392b7ce549b920d28325b058038.png" alt="MCTS"></p><h2 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h2><blockquote><p>Powered By GPT, to be done.</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> math<br><span class="hljs-keyword">import</span> random<br><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> defaultdict<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, state, parent=<span class="hljs-literal">None</span></span>):<br>        <span class="hljs-variable language_">self</span>.state = state  <span class="hljs-comment"># 游戏状态</span><br>        <span class="hljs-variable language_">self</span>.parent = parent  <span class="hljs-comment"># 父节点</span><br>        <span class="hljs-variable language_">self</span>.children = []  <span class="hljs-comment"># 子节点列表</span><br>        <span class="hljs-variable language_">self</span>.visits = <span class="hljs-number">0</span>  <span class="hljs-comment"># 访问次数</span><br>        <span class="hljs-variable language_">self</span>.value = <span class="hljs-number">0</span>  <span class="hljs-comment"># 节点价值</span><br>        <span class="hljs-variable language_">self</span>.untried_actions = <span class="hljs-variable language_">self</span>.state.get_legal_actions()  <span class="hljs-comment"># 未尝试的动作</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">is_fully_expanded</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(<span class="hljs-variable language_">self</span>.untried_actions) == <span class="hljs-number">0</span><br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">best_child</span>(<span class="hljs-params">self, exploration_param=<span class="hljs-number">1.4</span></span>):<br>        <span class="hljs-comment"># 根据UCT公式选择最佳子节点</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(<span class="hljs-variable language_">self</span>.children, <br>                   key=<span class="hljs-keyword">lambda</span> child: child.value / (child.visits + <span class="hljs-number">1e-6</span>) + <br>                   exploration_param * math.sqrt(<span class="hljs-number">2</span> * math.log(<span class="hljs-variable language_">self</span>.visits + <span class="hljs-number">1</span>) / (child.visits + <span class="hljs-number">1e-6</span>)))<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">expand</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># 从未尝试的动作中选择一个动作进行扩展</span><br>        action = <span class="hljs-variable language_">self</span>.untried_actions.pop()<br>        next_state = <span class="hljs-variable language_">self</span>.state.perform_action(action)<br>        child_node = Node(next_state, parent=<span class="hljs-variable language_">self</span>)<br>        <span class="hljs-variable language_">self</span>.children.append(child_node)<br>        <span class="hljs-keyword">return</span> child_node<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">is_terminal_node</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.state.is_game_over()<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">rollout</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># 模拟随机对局直到游戏结束</span><br>        current_state = <span class="hljs-variable language_">self</span>.state<br>        <span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> current_state.is_game_over():<br>            possible_actions = current_state.get_legal_actions()<br>            action = random.choice(possible_actions)<br>            current_state = current_state.perform_action(action)<br>        <span class="hljs-keyword">return</span> current_state.game_result()<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">backpropagate</span>(<span class="hljs-params">self, result</span>):<br>        <span class="hljs-comment"># 反向传播模拟结果</span><br>        <span class="hljs-variable language_">self</span>.visits += <span class="hljs-number">1</span><br>        <span class="hljs-variable language_">self</span>.value += result<br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.parent:<br>            <span class="hljs-variable language_">self</span>.parent.backpropagate(result)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MCTS</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, initial_state, iterations=<span class="hljs-number">1000</span></span>):<br>        <span class="hljs-variable language_">self</span>.root = Node(initial_state)<br>        <span class="hljs-variable language_">self</span>.iterations = iterations<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">search</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-variable language_">self</span>.iterations):<br>            node = <span class="hljs-variable language_">self</span>._select()<br>            result = <span class="hljs-variable language_">self</span>._simulate(node)<br>            node.backpropagate(result)<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>._best_action()<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_select</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># 选择阶段：从根节点开始，选择一个未完全扩展或非终止节点</span><br>        current_node = <span class="hljs-variable language_">self</span>.root<br>        <span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> current_node.is_terminal_node():<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> current_node.is_fully_expanded():<br>                <span class="hljs-keyword">return</span> current_node.expand()<br>            <span class="hljs-keyword">else</span>:<br>                current_node = current_node.best_child()<br>        <span class="hljs-keyword">return</span> current_node<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_simulate</span>(<span class="hljs-params">self, node</span>):<br>        <span class="hljs-comment"># 模拟阶段：从选定节点开始随机模拟</span><br>        <span class="hljs-keyword">if</span> node.is_terminal_node():<br>            <span class="hljs-keyword">return</span> node.state.game_result()<br>        <span class="hljs-keyword">return</span> node.rollout()<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_best_action</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># 选择访问次数最多的子节点对应的动作</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-variable language_">self</span>.root.children:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(<span class="hljs-variable language_">self</span>.root.children, key=<span class="hljs-keyword">lambda</span> child: child.visits).state.last_action<br><br><span class="hljs-comment"># 示例游戏状态类（需要根据具体游戏实现）</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GameState</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># 初始化游戏状态</span><br>        <span class="hljs-keyword">pass</span><br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_legal_actions</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># 返回当前状态下合法的动作列表</span><br>        <span class="hljs-keyword">return</span> []<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">perform_action</span>(<span class="hljs-params">self, action</span>):<br>        <span class="hljs-comment"># 执行动作并返回新的游戏状态</span><br>        new_state = GameState()<br>        <span class="hljs-comment"># 更新状态...</span><br>        new_state.last_action = action<br>        <span class="hljs-keyword">return</span> new_state<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">is_game_over</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># 检查游戏是否结束</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">game_result</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># 返回游戏结果（例如：1表示玩家1胜利，-1表示玩家2胜利，0表示平局）</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><br><span class="hljs-comment"># 使用示例</span><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    initial_state = GameState()<br>    mcts = MCTS(initial_state, iterations=<span class="hljs-number">1000</span>)<br>    best_action = mcts.search()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Best action: <span class="hljs-subst">&#123;best_action&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="Applications-Nowadays"><a href="#Applications-Nowadays" class="headerlink" title="Applications Nowadays"></a>Applications Nowadays</h2><h3 id="ICLR2025-AFlow"><a href="#ICLR2025-AFlow" class="headerlink" title="ICLR2025 AFlow"></a>ICLR2025 AFlow</h3>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-11763cb6" role="button" aria-expanded="false" aria-controls="collapse-11763cb6">        <div class="fold-arrow">▶</div>TOBEDONE      </div>      <div class="fold-collapse collapse" id="collapse-11763cb6">        <div class="fold-content">          <p>别看了，这没写完，快去写作业叭。</p>        </div>      </div>    </div>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tutorial</tag>
      
      <tag>MCTS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AIBasis_Neural_Networks</title>
    <link href="/posts/AIBasis-Neural-Networks/"/>
    <url>/posts/AIBasis-Neural-Networks/</url>
    
    <content type="html"><![CDATA[<style>  html, body, .markdown-body {    font-family: Georgia, sans, serif;  }</style><h1 id="It-is-Neural-Networks"><a href="#It-is-Neural-Networks" class="headerlink" title="It is Neural Networks!"></a>It is Neural Networks!</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>在这个系列中，笔者将要介绍<strong>深度学习中常见的网络结构</strong>，同时，这也是作为<strong>SJTU人工智能基础</strong>的<strong>常见网络结构</strong>一章的学习笔记。</p><p>I will call it <strong>AINN-series</strong>!</p><h2 id="Table-of-Contents"><a href="#Table-of-Contents" class="headerlink" title="Table of Contents"></a>Table of Contents</h2><ul><li><strong>MLP (Multilayer perceptron)</strong></li><li><strong>Convolutional Neural Networks</strong><ul><li>For this passage, you can see <a href="https://xiyuanyang-code.github.io/posts/Imagenet/">This Blog</a> for more information! (Including Alexnet, Googlenet and AlexNet…)</li><li>We will focus more on the mathematical principle of CNNs in this Blog.😊</li></ul></li><li><strong>Recurrent Neural Networks</strong><ul><li><strong>Long Short-Term Memory network</strong></li></ul></li><li><strong>Graph Neural Networks</strong></li><li><strong>Generative Adversarial Networks (GAN)</strong></li><li><strong>Diffusion Model</strong></li><li><strong>Transformer</strong> (Mostly Focused!)</li></ul><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>The abstract for every blog in this session.</p><h3 id="AINN-GAN"><a href="#AINN-GAN" class="headerlink" title="AINN-GAN"></a>AINN-GAN</h3>]]></content>
    
    
    <categories>
      
      <category>Artificial Intelligence</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Artificial Intelligence</tag>
      
      <tag>Deep Learning</tag>
      
      <tag>Neural Networks</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Torch-Memo</title>
    <link href="/posts/Torch-memo/"/>
    <url>/posts/Torch-memo/</url>
    
    <content type="html"><![CDATA[<h1 id="Torch-Memo"><a href="#Torch-Memo" class="headerlink" title="Torch Memo"></a>Torch Memo</h1><h2 id="Preliminaries"><a href="#Preliminaries" class="headerlink" title="Preliminaries"></a>Preliminaries</h2><ul><li><code>.__dir__()</code>: Getting all the functions in the module (<strong>Tool function</strong>)</li></ul><h2 id="TensorBoard"><a href="#TensorBoard" class="headerlink" title="TensorBoard"></a>TensorBoard</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> torch.utils.tensorboard <span class="hljs-keyword">import</span> SummaryWriter<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image<br><br>writer = SummaryWriter(<span class="hljs-string">&quot;logs&quot;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">compute</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">return</span> (torch.sin(torch.tensor(x)) + torch.randn(<span class="hljs-number">1</span>) * torch.sin(torch.tensor(x)))<br><br><br><span class="hljs-comment"># writer.add_scalar()</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>):<br>    writer.add_scalar(<span class="hljs-string">&quot;y=x&quot;</span>, compute(i).item(), i)<br><br><br><span class="hljs-comment"># writer.add_image()</span><br>img = Image.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;003.jpg&quot;</span>)<br>img_array = np.array(img)<br><br><span class="hljs-comment"># dataformats is HWC</span><br>writer.add_image(<span class="hljs-string">&quot;test&quot;</span>, img_array, <span class="hljs-number">1</span>, dataformats=<span class="hljs-string">&#x27;HWC&#x27;</span>)<br><br></code></pre></td></tr></table></figure><h2 id="Transforms"><a href="#Transforms" class="headerlink" title="Transforms"></a>Transforms</h2><p>Use Transforms to make <strong>Data Augmentation</strong> and design your own class of data!</p><h2 id="Use-GPU-in-torch"><a href="#Use-GPU-in-torch" class="headerlink" title="Use GPU in torch"></a>Use GPU in torch</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Memo: Using GPU in Pytorch</span><br><br><span class="hljs-keyword">import</span> torch<br><br><span class="hljs-keyword">import</span> argparse<br><br><span class="hljs-comment"># Using parser</span><br>parser = argparse.ArgumentParser(description=<span class="hljs-string">&quot;Selecting device for Pytorch&quot;</span>)<br>parser.add_argument(<br>    <span class="hljs-string">&quot;--device&quot;</span>,<br>    <span class="hljs-built_in">type</span>=<span class="hljs-built_in">str</span>,<br>    choices=[<span class="hljs-string">&quot;cuda&quot;</span>, <span class="hljs-string">&quot;cpu&quot;</span>],<br>    default=<span class="hljs-string">&quot;cuda&quot;</span> <span class="hljs-keyword">if</span> torch.cuda.is_available() <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;cpu&quot;</span>,<br>    <span class="hljs-built_in">help</span>= <span class="hljs-string">&quot;Device to use, cuda or cpu&quot;</span><br>)<br>args = parser.parse_args()<br><br><span class="hljs-comment"># Usage</span><br>device = args.device<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Device selectd, using <span class="hljs-subst">&#123;device&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Code</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Updating</tag>
      
      <tag>Python</tag>
      
      <tag>Tutorial</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Blog-Update-Fetching-Script</title>
    <link href="/posts/Blog-Update-Fetching-Script/"/>
    <url>/posts/Blog-Update-Fetching-Script/</url>
    
    <content type="html"><![CDATA[<style>  html, body, .markdown-body {    font-family: Georgia, sans, serif;  }</style><h1 id="Blog-Update-Fetching-Script"><a href="#Blog-Update-Fetching-Script" class="headerlink" title="Blog Update Fetching Script"></a>Blog Update Fetching Script</h1><p>Github repo: <a href="https://github.com/xiyuanyang-code/Blog-Update-Fetching-Script">My repo</a></p><h1 id="Blog-Update-Fetching-Script-1"><a href="#Blog-Update-Fetching-Script-1" class="headerlink" title="Blog Update Fetching Script"></a>Blog Update Fetching Script</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>This is an automation script I implemented in the Hexo blog update to automatically fetch blog updates, compare them with previous update statuses, and allow users to manually determine the update status of unfinished and newly added blogs, thus obtaining the new blog update status.</p><h2 id="Preliminaries"><a href="#Preliminaries" class="headerlink" title="Preliminaries"></a>Preliminaries</h2><p>Due to the strict formatting requirements of the automation script for the text, please make sure to complete the following modifications before use!</p><h3 id="Modify-to-your-blog-directory"><a href="#Modify-to-your-blog-directory" class="headerlink" title="Modify to your blog directory"></a>Modify to your blog directory</h3><p>In <code>main.sh</code>, change the directory into your own directory:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">DIR=<span class="hljs-string">&quot;/mnt/d/Blog/source/_posts&quot;</span><br><br><span class="hljs-comment"># Change this line into your own directory!</span><br></code></pre></td></tr></table></figure><h3 id="Create-a-new-directory"><a href="#Create-a-new-directory" class="headerlink" title="Create a new directory"></a>Create a new directory</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">touch</span> <span class="hljs-built_in">log</span><br></code></pre></td></tr></table></figure><h3 id="Initialize-prev-txt"><a href="#Initialize-prev-txt" class="headerlink" title="Initialize prev.txt"></a>Initialize <code>prev.txt</code></h3><p>You need to initialize <code>prev.txt</code> for your own blog!</p><p>For this document, please maintain the following format: Each line should include a prefix status emoji and the title name. The prefix status emojis include ✅ and ❌, indicating the completion status of the blog. </p><p>An example text is as follows:  </p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">❌<span class="hljs-variable">AI</span><span class="hljs-operator">-</span><span class="hljs-variable">Paper</span><span class="hljs-operator">-</span><span class="hljs-number">2024</span><br>❌<span class="hljs-variable">AI</span><span class="hljs-operator">-</span><span class="hljs-variable">indepth</span><span class="hljs-operator">-</span><span class="hljs-variable">reading</span><span class="hljs-operator">-</span><span class="hljs-variable">AlexNet</span><br>✅<span class="hljs-built_in">Above</span><span class="hljs-operator">-</span><span class="hljs-built_in">All</span><br>❌<span class="hljs-variable">Algorithm</span><span class="hljs-operator">-</span><span class="hljs-variable">BFS</span><span class="hljs-operator">-</span><span class="hljs-variable">DFS</span><br>✅<span class="hljs-variable">Algorithm</span><span class="hljs-operator">-</span><span class="hljs-variable">BinaryTree</span><br>❌<span class="hljs-variable">Algorithm</span><span class="hljs-operator">-</span><span class="hljs-variable">Chunking</span><br>✅<span class="hljs-variable">Algorithm</span><span class="hljs-operator">-</span><span class="hljs-variable">Introduction</span><br>✅<span class="hljs-variable">Algorithm</span><span class="hljs-operator">-</span><span class="hljs-variable">Memo</span><br>✅<span class="hljs-variable">Algorithm</span><span class="hljs-operator">-</span><span class="hljs-variable">Sorting</span><br>✅<span class="hljs-variable">Bash</span><span class="hljs-operator">-</span><span class="hljs-variable">commands</span><br>✅<span class="hljs-variable">Bash</span><span class="hljs-operator">-</span><span class="hljs-variable">exercises</span><br>✅<span class="hljs-built_in">C</span><span class="hljs-operator">-</span><span class="hljs-variable">plus</span><span class="hljs-operator">-</span><span class="hljs-variable">plus</span><span class="hljs-operator">-</span><span class="hljs-variable">Primer</span><span class="hljs-operator">-</span><span class="hljs-built_in">Plus</span><span class="hljs-operator">-</span><span class="hljs-variable">tutorial</span><br>✅<span class="hljs-variable">CMake</span><span class="hljs-operator">-</span><span class="hljs-variable">tutorial</span><span class="hljs-operator">-</span><span class="hljs-variable">episode2</span><br>✅<span class="hljs-variable">CMake</span><span class="hljs-operator">-</span><span class="hljs-variable">tutorial1</span><br>✅<span class="hljs-variable">CS294</span><span class="hljs-operator">-</span><span class="hljs-number">1</span><span class="hljs-operator">-</span><span class="hljs-variable">LLM</span><span class="hljs-operator">-</span><span class="hljs-variable">Reasoning</span><br></code></pre></td></tr></table></figure><p>Please ensure that your output structure maintains alphabetical order. You can use the following command line to achieve this: </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ls</span> <span class="hljs-variable">$DIR</span> | grep -v <span class="hljs-string">&quot;.*\.md&quot;</span> | grep -v <span class="hljs-string">&quot;.*\.sh&quot;</span> &gt; ans.txt<br></code></pre></td></tr></table></figure><p>You only need to initialize it once! The scripts will update it later.</p><h2 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h2><p>For <strong>Hexo</strong> Blog users, the directory which stores your Blog posts may be like as follows:</p><ul><li>Several <code>.md</code> files</li><li>Several directories which has the same name with <code>.md</code> files</li></ul><p>The <code>main.sh</code> will automatically get all file names using the <code>grep</code> command:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ls</span> <span class="hljs-variable">$DIR</span> | grep -v <span class="hljs-string">&quot;.*\.md&quot;</span> | grep -v <span class="hljs-string">&quot;.*\.sh&quot;</span> &gt; ans.txt<br></code></pre></td></tr></table></figure><blockquote><p><code>grep -v &quot;.*\.sh&quot;</code> is because I add several <code>.sh</code> files into it. You can modify it with your own needs.</p></blockquote><p>Then, the file will compare the new status with the previous status stored in the <code>prev.txt</code>. Then the file will ask users to manually determine the update status of unfinished and newly added blogs.</p><p>The output log looks as follows:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs bash">Getting updated.<br>Checking the file exists<br>File Exists<br>Getting ready <span class="hljs-keyword">for</span> updated.<br>Blog <span class="hljs-string">&#x27;AI-Paper-2024&#x27;</span> finished? (y/n): n<br>Blog <span class="hljs-string">&#x27;AI-indepth-reading-AlexNet&#x27;</span> finished? (y/n): n<br>Blog <span class="hljs-string">&#x27;Algorithm-BFS-DFS&#x27;</span> finished? (y/n): n<br>Blog <span class="hljs-string">&#x27;Algorithm-Chunking&#x27;</span> finished? (y/n): n<br>Blog <span class="hljs-string">&#x27;CS294-3-Autogen&#x27;</span> finished? (y/n): n<br>New Blog <span class="hljs-string">&#x27;DataStructure-Fenwick-Tree-Sparse-Table&#x27;</span> finished? (y/n): n<br>Blog <span class="hljs-string">&#x27;DataStructure-Tree-Binary-Search-Tree-AVL-Tree&#x27;</span> finished? (y/n): n<br>Blog <span class="hljs-string">&#x27;Python-tutorial&#x27;</span> finished? (y/n): n<br>Blog <span class="hljs-string">&#x27;Python-visualization&#x27;</span> finished? (y/n): n<br>Blog <span class="hljs-string">&#x27;RAG-tutorial&#x27;</span> finished? (y/n): n<br>Blog <span class="hljs-string">&#x27;Taking-Notes&#x27;</span> finished? (y/n): n<br>Blog <span class="hljs-string">&#x27;Tools-Tutorial&#x27;</span> finished? (y/n): n<br>Update successfully into <span class="hljs-built_in">log</span>/20250330_200559.txt<br>Overwrite to prev.txt successfully, Done!<br>Be productive!<br></code></pre></td></tr></table></figure><p>Finally, the scripts will update <code>prev.txt</code> and generate a new blog status named <code>20250330_200559.txt</code> and you can see the updated status there!</p><p>Demo:</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs stata">❌AI-Paper-2024<br>❌AI-indepth-reading-AlexNet<br>✅Above-All<br>❌Algorithm-BFS-DFS<br>✅Algorithm-BinaryTree<br>❌Algorithm-Chunking<br>✅Algorithm-Introduction<br>✅Algorithm-Memo<br>...<br>✅RAG-Blog-Content-Retrieval<br>❌RAG-<span class="hljs-keyword">tutorial</span><br>✅RL-speeches<br>✅Regular-Expression<br>❌Taking-<span class="hljs-keyword">Notes</span><br>❌Tools-<span class="hljs-keyword">Tutorial</span><br>✅Vim-<span class="hljs-keyword">tutorial</span><br></code></pre></td></tr></table></figure><p><strong>Enjoy Coding</strong></p><h2 id="Discussion"><a href="#Discussion" class="headerlink" title="Discussion"></a>Discussion</h2><p>Just for fun, and just for <code>hexo</code> users.</p>]]></content>
    
    
    <categories>
      
      <category>Project</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Finished</tag>
      
      <tag>Bash</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DataStructure-Sparse-Table</title>
    <link href="/posts/DataStructure-Sparse-Table/"/>
    <url>/posts/DataStructure-Sparse-Table/</url>
    
    <content type="html"><![CDATA[<style>  html, body, .markdown-body {    font-family: Georgia, sans, serif;  }</style><h1 id="Sparse-Table-ST"><a href="#Sparse-Table-ST" class="headerlink" title="Sparse Table (ST)"></a>Sparse Table (ST)</h1><h2 id="倍增"><a href="#倍增" class="headerlink" title="倍增"></a>倍增</h2><p>倍增法，顾名思义就是「成倍增长」。我们在进行递推时，如果状态空间很大，<strong>通常的线性递推</strong>无法满足时间与空间复杂度的要求，那么我们可以通过成倍增长的方式，只递推状态空间中在 <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="k"> 的整数次幂位置上的值作为代表。当需要其他位置上的值时，我们通过<strong>「任意整数可以表示成若干个$k$的次幂项的和」这一性质，使用之前求出的代表值拼成所需的值。所以使用倍增算法也要求我们递推的问题的状态空间关于$k$的次幂具有可划分性</strong>。通常情况下$k$取$2$。</p><p>倍增思想可以解决<strong>RMQ</strong>问题。</p><h3 id="倍增例题"><a href="#倍增例题" class="headerlink" title="倍增例题"></a>倍增例题</h3><p><img src="https://s1.imagehub.cc/images/2025/04/01/e12e250bc16c69f064e435b5630b671b.png" alt="倍增"></p><p>在m很大时，我们可以对$m$进行二进制分解，而预处理的数组就是对于$2^j$次跳跃的处理！</p><blockquote><p><strong>倍增的关键</strong>就是在于将一个很长的模拟过程分割成已经预处理好的小段。</p></blockquote><h2 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h2><p>ST表的核心是一个二维数组 <code>st[i][j]</code>，表示从数组的第$i$个位置开始，长度为 $2^j$的区间内的最值（最小值或最大值）。</p><p>假设输入数组为 <code>arr</code>，其长度为$n$。则 <code>st[i][j]</code> 的含义如下：</p><p>$$st[i][j]&#x3D;\min &#x2F;\max(arr[i],arr[i+1],…,arr[i+2^j−1])$$</p><p>我们需要根据输入数组 <code>arr</code> 构建这个二维数组。</p><p>至于预处理的核心过程，<strong>我们可以采用动态规划</strong>的思想，<strong>j从小到大</strong>，因为保证是2的整数幂次，所以能够实现快速的预处理填充过程。</p><h2 id="RMQ-Problem"><a href="#RMQ-Problem" class="headerlink" title="RMQ Problem"></a>RMQ Problem</h2><p>给出模版题：<strong>求区间中的最大值</strong></p><p>如果使用传统的二进制倍增算法，在做完预处理之后对于区间进行<strong>二进制切分</strong>再统计对应的分块即可。这样对于多次问询的情况可以极大提升时间复杂度。</p><p>但是这样仍然不太好，因为<strong>二进制的严格切分</strong>其实会变得非常松散（最坏的情况就是$O(\log n)$），如果我们只是希望求区间的最值（<strong>可重复贡献问题</strong>），我们可以<strong>进行稀疏的切分</strong>，哪怕两份切分之间存在重叠部分也没有关系，因为我们已经预处理好了，最后只是一个查表的事情。</p><p>这样，倍增切分的时间复杂度就保持在<strong>常数级别</strong>。</p><blockquote><p><strong>注意</strong>，只有<strong>可重复贡献问题</strong>才可以重叠区间！如果是对于求区间和，就必须严格进行二进制的切分之后再运算。</p></blockquote><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><blockquote><p>注意这里是 <strong>0-based</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @Author: Xiyuan Yang   xiyuan_yang@outlook.com</span><br><span class="hljs-comment"> * @Date: 2025-04-01 21:20:31</span><br><span class="hljs-comment"> * @LastEditors: Xiyuan Yang   xiyuan_yang@outlook.com</span><br><span class="hljs-comment"> * @LastEditTime: 2025-04-01 21:20:47</span><br><span class="hljs-comment"> * @FilePath: /20250331_fenwick/template/ST_RMQ.cpp</span><br><span class="hljs-comment"> * @Description: </span><br><span class="hljs-comment"> * Do you code and make progress today?</span><br><span class="hljs-comment"> * Copyright (c) 2025 by Xiyuan Yang, All Rights Reserved. </span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN = <span class="hljs-number">1e6</span> + <span class="hljs-number">5</span>; <span class="hljs-comment">// 输入数组的最大长度</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> LOG = <span class="hljs-number">20</span>;       <span class="hljs-comment">// log2(MAXN) 的上界</span><br><br><span class="hljs-type">int</span> st[MAXN][LOG]; <span class="hljs-comment">// ST表，st[i][j]表示从i开始长度为2^j的区间的最小值</span><br><span class="hljs-type">int</span> arr[MAXN];     <span class="hljs-comment">// 输入数组</span><br><span class="hljs-type">int</span> n;             <span class="hljs-comment">// 数组长度</span><br><br><span class="hljs-comment">// 预处理函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">preprocess</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 初始化长度为 2^0 的区间</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        st[i][<span class="hljs-number">0</span>] = arr[i];<br>    &#125;<br><br>    <span class="hljs-comment">// 动态规划填充表格</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; LOG; ++j) &#123; <span class="hljs-comment">// 区间长度从 2^1 到 2^(LOG-1)</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i + (<span class="hljs-number">1</span> &lt;&lt; j) &lt;= n; ++i) &#123; <span class="hljs-comment">// 确保区间不越界</span><br>            st[i][j] = <span class="hljs-built_in">min</span>(st[i][j - <span class="hljs-number">1</span>], st[i + (<span class="hljs-number">1</span> &lt;&lt; (j - <span class="hljs-number">1</span>))][j - <span class="hljs-number">1</span>]);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 查询 [L, R] 区间的最小值</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> L, <span class="hljs-type">int</span> R)</span> </span>&#123;<br>    <span class="hljs-type">int</span> len = R - L + <span class="hljs-number">1</span>; <span class="hljs-comment">// 查询区间的长度</span><br>    <span class="hljs-type">int</span> k = <span class="hljs-built_in">log2</span>(len);   <span class="hljs-comment">// 找到最大的 k 满足 2^k &lt;= len</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(st[L][k], st[R - (<span class="hljs-number">1</span> &lt;&lt; k) + <span class="hljs-number">1</span>][k]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 输入数组长度和元素</span><br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        cin &gt;&gt; arr[i];<br>    &#125;<br><br>    <span class="hljs-comment">// 预处理 ST 表</span><br>    <span class="hljs-built_in">preprocess</span>();<br><br>    <span class="hljs-comment">// 查询操作</span><br>    <span class="hljs-type">int</span> q; <span class="hljs-comment">// 查询次数</span><br>    cin &gt;&gt; q;<br>    <span class="hljs-keyword">while</span> (q--) &#123;<br>        <span class="hljs-type">int</span> L, R;<br>        cin &gt;&gt; L &gt;&gt; R; <span class="hljs-comment">// 查询区间 [L, R]</span><br>        cout &lt;&lt; <span class="hljs-built_in">query</span>(L, R) &lt;&lt; endl; <span class="hljs-comment">// 输出区间最小值</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="ST表例题"><a href="#ST表例题" class="headerlink" title="ST表例题"></a>ST表例题</h2><p>A 是某公司的 CEO，每个月都会有员工把公司的盈利数据送给 A，A 是个与众不同的怪人，A 不注重盈利还是亏本，而是喜欢研究「完美序列」：一段连续的序列满足序列中的数互不相同。</p><p>A 想知道区间 [L,R] 之间最长的完美序列长度。</p><p>第一行两个整数 N,M，N 表示连续 N 个月，编号为 0 到 N-1，M 表示询问的次数；</p><p>第二行 N 个整数，第 i 个数表示该公司第 i 个月的盈利值 $a_i$；</p><p>接下来 M 行每行两个整数 L,R，表示 A 询问的区间。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>记 $f(i)$ 表示以第 $i$ 个位置为结尾的最长完美序列的左端点位置。容易发现$ f(i)$ 是不降的。对于一个$ [l,r]$ 的询问，将区间中的点分成左右两部分：左边的点满足 $f(i)&lt;L$ ，右边的点满足$ f(i)≥L$ 。对于左边的点可以直接算出答案，对于右边的点可以用 ST 表区间询问求得答案。</p><p>此处ST表储存的是对应区间每一个i在<strong>无限延伸</strong>的情况下满足i为右端点可以达到的最长长度。<strong>对于这个左端点，其满足可重复贡献问题</strong>，因此可以使用ST表解决。如果<strong>并非无限延伸而是限制了区间</strong>，那么无法使用动态规划的思路构建ST表，因为很明显其并不满足<strong>结合律</strong>，无法将小问题简单合并成大问题，无法使用ST表</p><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN = <span class="hljs-number">2e5</span> + <span class="hljs-number">5</span>; <span class="hljs-comment">// 数组最大长度</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> LOG = <span class="hljs-number">20</span>;       <span class="hljs-comment">// log2(MAXN) 的上界</span><br><br><span class="hljs-type">int</span> f[MAXN];              <span class="hljs-comment">// f[i] 表示以第 i 个位置为结尾的最长完美序列的左端点位置</span><br><span class="hljs-type">int</span> st[MAXN][LOG];        <span class="hljs-comment">// ST表，st[i][j]表示从i开始长度为2^j的区间内的最小值</span><br><span class="hljs-type">int</span> last[<span class="hljs-number">2</span>][<span class="hljs-number">1000005</span>];         <span class="hljs-comment">// last[x]表示数字x最后一次出现的位置</span><br><span class="hljs-type">int</span> arr[MAXN];            <span class="hljs-comment">// 输入数组</span><br><span class="hljs-type">int</span> n;                    <span class="hljs-comment">// 数组长度</span><br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">getpos</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(x &gt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-comment">// 预处理函数：计算 f[i]</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">preprocess_f</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">memset</span>(last, <span class="hljs-number">-1</span>, <span class="hljs-built_in">sizeof</span>(last)); <span class="hljs-comment">// 初始化 last 数组</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; last[<span class="hljs-built_in">getpos</span>(arr[i])][<span class="hljs-built_in">abs</span>(arr[i])] &gt;= f[i - <span class="hljs-number">1</span>]) &#123;<br>            f[i] = last[<span class="hljs-built_in">getpos</span>(arr[i])][<span class="hljs-built_in">abs</span>(arr[i])] + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 如果 arr[i] 是第一次出现，f[i] = f[i-1]</span><br>            f[i] = (i &gt; <span class="hljs-number">0</span> ? f[i - <span class="hljs-number">1</span>] : <span class="hljs-number">0</span>);<br>        &#125;<br>        last[<span class="hljs-built_in">getpos</span>(arr[i])][<span class="hljs-built_in">abs</span>(arr[i])] = i; <span class="hljs-comment">// 更新 arr[i] 的最后一次出现位置</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 预处理 ST 表</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">preprocess_st</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        st[i][<span class="hljs-number">0</span>] = i - f[i] + <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//cout &lt;&lt; st[i][0] &lt;&lt; &quot; &quot;;</span><br>    &#125;<br>    <span class="hljs-comment">//cout &lt;&lt; endl;</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; LOG; ++j) &#123; <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i + (<span class="hljs-number">1</span> &lt;&lt; j) - <span class="hljs-number">1</span> &lt; n; ++i) &#123; <br>            st[i][j] = <span class="hljs-built_in">max</span>(st[i][j - <span class="hljs-number">1</span>], st[i + (<span class="hljs-number">1</span> &lt;&lt; (j - <span class="hljs-number">1</span>))][j - <span class="hljs-number">1</span>]);<br>            <span class="hljs-comment">//cout &lt;&lt; st[i][j] &lt;&lt; &quot; &quot;;</span><br>        &#125;<br>        <span class="hljs-comment">//cout &lt;&lt; endl;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//no restriction here</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query_max</span><span class="hljs-params">(<span class="hljs-type">int</span> L, <span class="hljs-type">int</span> R)</span> </span>&#123;<br>    <span class="hljs-type">int</span> len = R - L + <span class="hljs-number">1</span>; <br>    <span class="hljs-type">int</span> k = <span class="hljs-built_in">log2</span>(len);<br>    <span class="hljs-comment">//cout &lt;&lt; &quot;k&quot; &lt;&lt; k &lt;&lt; endl;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(st[L][k], st[R - (<span class="hljs-number">1</span> &lt;&lt; k) + <span class="hljs-number">1</span>][k]);<br>&#125;<br><br><span class="hljs-comment">//Binary search</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">binary_search</span><span class="hljs-params">(<span class="hljs-type">int</span> L, <span class="hljs-type">int</span> R, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>    <span class="hljs-type">int</span> low = L, high = R;<br>    <span class="hljs-keyword">while</span> (low &lt;= high) &#123;<br>        <span class="hljs-type">int</span> mid = (low + high) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (f[mid] &gt;= target) &#123;<br>            high = mid - <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            low = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> low;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-type">int</span> m;<br>    cin &gt;&gt; m; <br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        cin &gt;&gt; arr[i];<br>    &#125;<br><br>    <span class="hljs-built_in">preprocess_f</span>();<br>    <span class="hljs-built_in">preprocess_st</span>();<br><br>    <br><br>    <br>    <span class="hljs-keyword">while</span> (m--) &#123;<br>        <span class="hljs-type">int</span> L, R;<br>        cin &gt;&gt; L &gt;&gt; R; <br>        <span class="hljs-type">int</span> p = <span class="hljs-built_in">binary_search</span>(L, R, L);<br>        <span class="hljs-comment">//cout &lt;&lt; &quot;p&quot; &lt;&lt; p &lt;&lt; endl;</span><br><br>        <span class="hljs-type">int</span> left_len = (p &gt; L) ? (p - L) : <span class="hljs-number">0</span>;<br><br>        <span class="hljs-type">int</span> right_len = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (p &lt;= R) &#123;<br>            right_len = <span class="hljs-built_in">query_max</span>(p, R);<br>            <span class="hljs-comment">//cout &lt;&lt; &quot;rightlen&quot; &lt;&lt; right_len &lt;&lt; endl;</span><br>        &#125;<br><br>        cout &lt;&lt; <span class="hljs-built_in">max</span>(left_len, right_len) &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="再来一道例题"><a href="#再来一道例题" class="headerlink" title="再来一道例题"></a>再来一道例题</h2><p>给定一个数组$a[i]$, 长度为$n$。(为了方便这里使用<strong>1-based</strong>)，给出$m$次问询，每次问询在区间$[l,r]$上是否存在$i,j(i \ne j)$，使得$a_i \otimes a_j &#x3D; x$，$x$是给定好的值。($\otimes$是异或符号)</p><p><strong>使用ST表的模版</strong>就是可以计算区间的<strong>可重复贡献问题</strong>，如何转化？</p><p>我们可以构造数组$f(i)$，定义$f(i):&#x3D;\max { j \in [1,i) \mid a_i \otimes a_j &#x3D; x }$，因为区间的限制，我们判断<strong>存在</strong>只需要比较<strong>最近的</strong>是否在区间里面。具体来说，$f(i)$代表在下标$i$之前的满足$a_i \otimes a_j &#x3D; x$的最大$j$下标，而对于区间$[l,r]$，只需要判断是否存在$i \in [l,r]$，使得$f(i) \ge l$。</p><blockquote><p>这里并不需要考虑<strong>另一边的r边界</strong>，因为如果这个区间真的存在$(i,j)$，不失一般性假设$i &lt; j$，那么对于$f(j)$是肯定能够找到i的，也就不需要重复计算了。</p></blockquote><p>这样我们就把这个问题转化了对$f[i]$的区间求最大值的问题，使用ST表轻松解决。</p><p>最后一个问题，如何预处理$f[i]$？使用哈希（桶）线性扫描一遍数组就行啦。</p><h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @Author: Xiyuan Yang   xiyuan_yang@outlook.com</span><br><span class="hljs-comment"> * @Date: 2025-04-06 20:47:27</span><br><span class="hljs-comment"> * @LastEditors: Xiyuan Yang   xiyuan_yang@outlook.com</span><br><span class="hljs-comment"> * @LastEditTime: 2025-04-07 10:49:12</span><br><span class="hljs-comment"> * @FilePath: /20250406_Test3/2_2.cpp</span><br><span class="hljs-comment"> * @Description: </span><br><span class="hljs-comment"> * Do you code and make progress today?</span><br><span class="hljs-comment"> * Copyright (c) 2025 by Xiyuan Yang, All Rights Reserved. </span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">100001</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> LOG = <span class="hljs-number">20</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> HASH = (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">20</span>) + <span class="hljs-number">2</span>;<br><br><span class="hljs-type">int</span> st[MAX][LOG];<br><span class="hljs-type">long</span> arr[MAX];<br><span class="hljs-type">long</span> f[MAX];<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> Hash[HASH];<br><span class="hljs-type">int</span> n, m, x;<br><br><span class="hljs-comment">// 预处理 使用f</span><br><span class="hljs-comment">// 对于每个位置i，f(i)表示在i之前（包括i）满足a[j] = a[i] ⊕ x的最大j值。如果不存在这样的j，则f(i) = -1</span><br><span class="hljs-comment">// ! all 1-based</span><br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">process_f</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">// traverse for i</span><br>    <span class="hljs-built_in">memset</span>(Hash, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(Hash));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> val = arr[i];<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> target = val ^ x;<br>        <span class="hljs-comment">// 储存target到对应的哈希数组中</span><br>        Hash[target] = i;<br>        <span class="hljs-comment">// cout &lt;&lt; &quot;hash&quot; &lt;&lt; target &lt;&lt; i &lt;&lt; endl;</span><br><br>        <span class="hljs-comment">// 得到f[i]的值（扫描完全部的之前的数）</span><br>        f[i] = Hash[arr[i]];<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 预处理 st表</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">process_st</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">// for j = 0</span><br>    <span class="hljs-built_in">memset</span>(st, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(st));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>        st[i][<span class="hljs-number">0</span>] = f[i];<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; LOG; ++j) &#123; <span class="hljs-comment">// 区间长度从 2^1 到 2^(LOG-1)</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i + (<span class="hljs-number">1</span> &lt;&lt; j) &lt;= n + <span class="hljs-number">1</span>; ++i) &#123; <span class="hljs-comment">// 确保区间不越界</span><br>            st[i][j] = <span class="hljs-built_in">max</span>(st[i][j - <span class="hljs-number">1</span>], st[i + (<span class="hljs-number">1</span> &lt;&lt; (j - <span class="hljs-number">1</span>))][j - <span class="hljs-number">1</span>]);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//no restriction here</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">query_max</span><span class="hljs-params">(<span class="hljs-type">int</span> L, <span class="hljs-type">int</span> R)</span> </span>&#123;<br>    <span class="hljs-type">int</span> len = R - L + <span class="hljs-number">1</span>; <br>    <span class="hljs-type">int</span> k = <span class="hljs-built_in">log2</span>(len);<br>    <span class="hljs-comment">//cout &lt;&lt; &quot;k&quot; &lt;&lt; k &lt;&lt; endl;</span><br>    <span class="hljs-keyword">return</span> (<span class="hljs-built_in">max</span>(st[L][k], st[R - (<span class="hljs-number">1</span> &lt;&lt; k) + <span class="hljs-number">1</span>][k]) &gt;= L);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m &gt;&gt; x;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>        cin &gt;&gt; arr[i];<br>    &#125;<br><br>    <span class="hljs-built_in">process_f</span>();<br>    <span class="hljs-built_in">process_st</span>();<br>    <br>    <span class="hljs-type">int</span> l,r;<br>    <span class="hljs-keyword">while</span>(m--)&#123;<br>        <span class="hljs-comment">// query</span><br>        cin &gt;&gt; l &gt;&gt; r;<br>        cout &lt;&lt; (<span class="hljs-built_in">query_max</span>(l,r) ? <span class="hljs-string">&quot;Yes&quot;</span>: <span class="hljs-string">&quot;No&quot;</span>)&lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tutorial</tag>
      
      <tag>Tree</tag>
      
      <tag>Finished</tag>
      
      <tag>Data Structure</tag>
      
      <tag>C/C++</tag>
      
      <tag>Sparse Table</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DataStructure-Fenwick-Tree</title>
    <link href="/posts/DataStructure-Fenwick-Tree/"/>
    <url>/posts/DataStructure-Fenwick-Tree/</url>
    
    <content type="html"><![CDATA[<style>  html, body, .markdown-body {    font-family: Georgia, sans, serif;  }</style><h1 id="Fenwick-Tree-树状数组"><a href="#Fenwick-Tree-树状数组" class="headerlink" title="Fenwick Tree (树状数组)"></a>Fenwick Tree (树状数组)</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p><strong>树状数组</strong>的核心在于高效处理前缀和，并且使用树状结构。</p><blockquote><p>为了方便计算，<strong>这里的数组全部使用1-based</strong>.</p></blockquote><p><img src="https://oi-wiki.org/ds/images/fenwick.svg" alt="树状数组"></p><p>如上图所示，$a_i$是原数组的值，而$c_i$是根据$a_i$所生成的树状数组</p><h2 id="Template-Operations"><a href="#Template-Operations" class="headerlink" title="Template Operations"></a>Template Operations</h2><h3 id="预处理（区间管辖）"><a href="#预处理（区间管辖）" class="headerlink" title="预处理（区间管辖）"></a>预处理（区间管辖）</h3><p>上面的图非常清晰，每一个$c_i$都管辖了对应区间的前缀和，那如何使用代码表示？</p><p>给出函数<code>lowbit(x)</code>，返回在二进制下<strong>最低位1和后面的0组成的数</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> x &amp; -x;<br>&#125;<br></code></pre></td></tr></table></figure><p>不难发现，$c_i$管辖的区间就是$[x-lowbit(x)+1,x]$.</p><p>具体而言，<code>lowbit()</code>函数就是把这个值减去了<strong>小于他的最小的二进制组成的幂次</strong>。这一个部分在后文详细解释。</p><h3 id="区间求和查询"><a href="#区间求和查询" class="headerlink" title="区间求和查询"></a>区间求和查询</h3><p>本质上就是二进制的拆解过程。</p><p>例如$7&#x3D;1+2+4$，因此</p><p>$$ {\textstyle \sum_{i&#x3D;1}^{7}a_i}&#x3D; {\textstyle \sum_{i&#x3D;1}^{4}a_i} + {\textstyle \sum_{i&#x3D;5}^{6}a_i} + {\textstyle \sum_{i&#x3D;7}^{7}a_i}$$</p><p>$${\textstyle \sum_{i&#x3D;1}^{7}a_i} &#x3D; c_4 + c_6 + c_7$$</p><p>一般的，${\textstyle \sum_{i&#x3D;a}^{b}a_i} &#x3D; {\textstyle \sum_{i&#x3D;1}^{b}a_i} - {\textstyle \sum_{i&#x3D;1}^{a}a_i}$</p><p>那如何使用<code>lowbit()</code>实现这个<strong>前缀切分的过程</strong>？以7为例，考虑下面的程序</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> x &amp; (-x);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Hello world&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">7</span>;<br>    <span class="hljs-keyword">while</span>(x &gt; <span class="hljs-number">0</span>)&#123;<br>        cout &lt;&lt; <span class="hljs-built_in">lowbit</span>(x) &lt;&lt; endl;<br>        x -= <span class="hljs-built_in">lowbit</span>(x);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">Hello</span> world<br><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>换句话说，$lowbit(7)&#x3D;1$ ,这个1就代表$a_7$这一个元素，储存在$c_7$中。</p><p>接下来更新$x$的值，此时7变成了6，$lowbit(6)&#x3D;2$，代表$c_6$中储存了<strong>2个元素（$a_5,a_6$）</strong>。</p><p>这样，我们就找到了区间查询的做法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">!区间查询</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">getsum</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> x)</span></span>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(x &gt; <span class="hljs-number">0</span>)&#123;<br>        ans += c[x];<br>        x -= <span class="hljs-built_in">lowbit</span>(x);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="单点修改"><a href="#单点修改" class="headerlink" title="单点修改"></a>单点修改</h3><h4 id="Propositions"><a href="#Propositions" class="headerlink" title="Propositions"></a>Propositions</h4><p>（这一段截自OI wiki，讲的太好了）</p><ul><li>$x \le y$，则$c[x]$和$c[y]$不交或存在包含关系。</li><li>$c[x]$真包含于$c[x+lowbit(x)]$</li><li>对于$x$和$x + lowbit(x)$之间的元素，$c[x]$和$c[y]$严格不交</li></ul><p><img src="https://oi-wiki.org/ds/images/fenwick.svg" alt="千言万语不如再看看这张图"></p><ul><li>$height_x&#x3D;\log_{2}lowbit(x)$</li><li>$lowbit(x) &lt; lowbit(fa[x])$</li></ul><p><strong>基本思路</strong>：以$a_i$为起点，沿着树不断往上一直走到头（所有包含这个元素的前缀和都需要修改）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>  <span class="hljs-keyword">while</span> (x &lt;= n) &#123;  <br>    c[x] = c[x] + k;<br>    x = x + <span class="hljs-built_in">lowbit</span>(x);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意，在考虑树状数组的树形态时，我们不考虑树状数组大小的影响，即我们认为这是一棵无限大的树，方便分析。实际实现时，我们只需保证$x \le n$，其中$n$是原数组长度。</p></blockquote><p>因此，我们给出完整的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">fenwick_1</span><br><span class="hljs-comment">//</span><br>&#123;<br>    <span class="hljs-type">int</span> N;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> C[MAXN];<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123;<br>        N = n;<br>        <span class="hljs-built_in">memset</span>(C, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(C));<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addSingle</span><span class="hljs-params">(<span class="hljs-type">int</span> pos, <span class="hljs-type">long</span> <span class="hljs-type">long</span> val)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = pos; i &lt;= N; i += <span class="hljs-built_in">lowbit</span>(i))&#123;<br>            C[i] += val;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">rangeAsk</span><span class="hljs-params">(<span class="hljs-type">int</span> pos)</span> </span>&#123;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = pos; i &gt; <span class="hljs-number">0</span>; i -= <span class="hljs-built_in">lowbit</span>(i))&#123;<br>            ans += C[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">rangeAsk2</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">rangeAsk</span>(r) - <span class="hljs-built_in">rangeAsk</span>(l - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h3 id="建树"><a href="#建树" class="headerlink" title="建树"></a>建树</h3><p>在建树操作中，可以首先全部初始化为0，然后单点插入$n$个元素，时间复杂度$O(n\log n)$。</p><p>对于上述两种基本操作，均可以达到$O(\log n)$的时间复杂度。</p><h2 id="区间修改和单点查询"><a href="#区间修改和单点查询" class="headerlink" title="区间修改和单点查询"></a>区间修改和单点查询</h2><blockquote><p>以下内容节选自<strong>OI Wiki</strong></p></blockquote><p>考虑序列 $a$ 的差分数组 $d$，其中 $d[i] &#x3D; a[i] - a[i-1]$。由于差分数组的前缀和就是原数组，所以</p><p>$$<br>a_i &#x3D; \sum_{j&#x3D;1}^{i} d_j.<br>$$</p><p>一样地，我们考虑将查询区间和通过差分转化为查询前缀和。那么考虑查询 $a[1 \dots r]$ 的和，即 $\sum_{i&#x3D;1}^{r} a_i$，进行推导：</p><p>$$<br>\sum_{i&#x3D;1}^{r} a_i &#x3D; \sum_{i&#x3D;1}^{r} \sum_{j&#x3D;1}^{i} d_j<br>$$</p><p>观察这个式子，不难发现每个 $d_j$ 总共被加了 $r-j+1$ 次。接着推导：</p><p>$$<br>\sum_{i&#x3D;1}^{r} \sum_{j&#x3D;1}^{i} d_j &#x3D; \sum_{i&#x3D;1}^{r} d_i \times (r-i+1)&#x3D; \sum_{i&#x3D;1}^{r} d_i \times (r+1) - \sum_{i&#x3D;1}^{r} d_i \times i<br>$$</p><p>$\sum_{i&#x3D;1}^{r} d_i$ 并不能推出 $\sum_{i&#x3D;1}^{r} d_i \times i$ 的值，所以要用<strong>两个树状数组分别维护 $d_i$ 和 $d_i \times i$ 的和信息</strong>。</p><p><strong>使用差分数组</strong>的优势在于<strong>对于区间内部的点，同增不会改变差分的值</strong>，因此，区间修改可以转化为<strong>对差分数组的单点修改</strong>，之后使用模版即可。</p><p>因此，我们在额外维护两个数组的情况下，可以实现如下操作：</p><p>已知模版操作：<strong>区间求和查询</strong> &amp; <strong>单点修改</strong></p><ul><li>区间修改：<strong>对差分数组的单点修改</strong></li><li>区间求和：<strong>对两个差分数组（$d_i * i$）</strong>的单点查询</li><li>单点操作就是<strong>区间操作的退化情况</strong></li></ul><blockquote><p>截至，我们就可以完成四种<strong>一维数组</strong>的基本操作了！值得一题的是，在这里我们并不需要维护<strong>对原数组的树状数组</strong>，我们应该维护<strong>两个差分数组的树状数组</strong>，并转化为相对应的模版操作。</p></blockquote><p>给出代码实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">fenwick_2</span><br>&#123;<br>    <span class="hljs-type">int</span> N;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> C1[MAXN];<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> C2[MAXN];<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123;<br>        N = n;<br>        <span class="hljs-built_in">memset</span>(C1, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(C1));<br>        <span class="hljs-built_in">memset</span>(C2, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(C2));<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addRange1</span><span class="hljs-params">(<span class="hljs-type">int</span> pos, <span class="hljs-type">long</span> <span class="hljs-type">long</span> val)</span></span>&#123;<br>        <span class="hljs-comment">//对于差分数组的单点修改操作</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = pos; i &lt;= N; i += <span class="hljs-built_in">lowbit</span>(i))&#123;<br>            C1[i] += val;<br>            C2[i] += val * pos;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addRange2</span><span class="hljs-params">(<span class="hljs-type">int</span> posl, <span class="hljs-type">int</span> posr, <span class="hljs-type">long</span> <span class="hljs-type">long</span> val)</span></span>&#123;<br>        <span class="hljs-comment">//对差分数组使用两次单点修改操作，就可以得到区间修改</span><br>        <span class="hljs-built_in">addRange1</span>(posl, val);<br>        <span class="hljs-built_in">addRange1</span>(posr + <span class="hljs-number">1</span>, -val);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">askRange1</span><span class="hljs-params">(<span class="hljs-type">int</span> pos)</span></span>&#123;<br>        <span class="hljs-comment">//从1到pos的区间求和</span><br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = pos; i &gt; <span class="hljs-number">0</span>; i -= <span class="hljs-built_in">lowbit</span>(i)) &#123;<br>            ans += (pos + <span class="hljs-number">1</span>)*C1[i] - C2[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">askRange2</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">askRange1</span>(r) - <span class="hljs-built_in">askRange1</span>(l - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//退化为单点的修改和查询</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Addsingle</span><span class="hljs-params">(<span class="hljs-type">int</span> pos, <span class="hljs-type">long</span> <span class="hljs-type">long</span> val)</span></span>&#123;<br>        <span class="hljs-built_in">addRange2</span>(pos, pos, val);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">Asksingle</span><span class="hljs-params">(<span class="hljs-type">int</span> pos)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">askRange2</span>(pos, pos);<br>    &#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="二维树状数组"><a href="#二维树状数组" class="headerlink" title="二维树状数组"></a>二维树状数组</h2><h3 id="问题重述"><a href="#问题重述" class="headerlink" title="问题重述"></a>问题重述</h3><p>给定一个二维数组$A_{m \times n}$，要求实现如下操作：</p><ul><li>单点修改$A[x][y]$</li><li>单点查询$A[x][y]$</li><li>区间和查询，查询左上角为$(x_1,y_1)$右下角为$(x_2,y_2)$的矩阵和</li><li>区间修改，左上角为$(x_1,y_1)$右下角为$(x_2,y_2)$的矩阵统一加上$x$</li></ul><h3 id="建立新的树状数组"><a href="#建立新的树状数组" class="headerlink" title="建立新的树状数组"></a>建立新的树状数组</h3><p>在一维树状数组中，数组$C[x]$记录了的是右端点为$x$、长度为$lowbit(x)$的区间的区间和。</p><p>那么我们也可以类似地定义$C[x][y]$记录的是右下角为$(x,y)$，高为 $lowbit(x)$，宽为 $lowbit(y)$ 的区间的区间和。</p><p>这样的过渡非常自然，我们因此也可以类似完成上面的4个基本操作。</p><h3 id="单点修改-区间查询（模版操作）"><a href="#单点修改-区间查询（模版操作）" class="headerlink" title="单点修改 &amp; 区间查询（模版操作）"></a>单点修改 &amp; 区间查询（模版操作）</h3><p><strong>单点修改</strong>的基本思路保持不变：沿着最开始的叶节点不断向上修改祖先节点的值，最终到达最大值。</p><p>在二维数组中，修改一个单点，那么对于横轴和纵轴，相当于套两层循环，并且不断的迭代，代码同理：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> v)</span> </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = x; i &lt;= n; i += <span class="hljs-built_in">lowbit</span>(i)) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = y; j &lt;= m; j += <span class="hljs-built_in">lowbit</span>(j)) &#123;<br>      c[i][j] += v;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>对于子矩阵的查询</strong>，先给出查询<strong>左上角起点为$(1,1)$的矩阵</strong>的和的公式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//ask for the submatrix (1,1) -&gt; (x,y)</span><br>    <span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">ask</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span>&#123;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = x; i &gt; <span class="hljs-number">0</span>; i -= <span class="hljs-built_in">lowbit</span>(i))&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = y; j &gt; <span class="hljs-number">0</span>; j -= <span class="hljs-built_in">lowbit</span>(j))&#123;<br>                ans += C[i][j];<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br></code></pre></td></tr></table></figure><p>在二维数组中，${\textstyle \sum_{i&#x3D;a}^{b}a_i} &#x3D; {\textstyle \sum_{i&#x3D;1}^{b}a_i} - {\textstyle \sum_{i&#x3D;1}^{a}a_i}$ 需要被推广，也就是</p><p><img src="https://s1.imagehub.cc/images/2025/04/01/07522d131e834adfb89b55cac7d02e71.png" alt="Sum"></p><p>这样，最基本的模版操作就可以推广了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXM = <span class="hljs-number">100000</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN = <span class="hljs-number">100000</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> x &amp; (-x);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief only for two operations: modify a single point and sum a submatrix</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">fenwick_2d_1</span>&#123;<br>    <span class="hljs-type">int</span> m,n;<span class="hljs-comment">//size</span><br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> C[MAXM][MAXN];<span class="hljs-comment">//fenwick tree</span><br><br>    <span class="hljs-built_in">fenwick_2d_1</span>(<span class="hljs-type">int</span> m_, <span class="hljs-type">int</span> n_)&#123;<br>        m = m_;<br>        n = n_;<br>        <span class="hljs-built_in">memset</span>(C, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(C));<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * @brief Modify a single element</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param x x-index (1-based)</span><br><span class="hljs-comment">     * @param y y-index (1-based)</span><br><span class="hljs-comment">     * @param val plus val</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">long</span> <span class="hljs-type">long</span> val)</span></span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = x; i &lt;= m; i += <span class="hljs-built_in">lowbit</span>(i))&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = y; j &lt; n; j += <span class="hljs-built_in">lowbit</span>(j))&#123;<br>                C[i][j] += val;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//ask for the submatrix (1,1) -&gt; (x,y)</span><br>    <span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">ask</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span>&#123;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = x; i &gt; <span class="hljs-number">0</span>; i -= <span class="hljs-built_in">lowbit</span>(i))&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = y; j &gt; <span class="hljs-number">0</span>; j -= <span class="hljs-built_in">lowbit</span>(j))&#123;<br>                ans += C[i][j];<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-comment">//(p,q) -&gt; (x,y)</span><br>    <span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">ask_sub</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> q, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">ask</span>(x, y)-<span class="hljs-built_in">ask</span>(p - <span class="hljs-number">1</span>, y)-<span class="hljs-built_in">ask</span>(q - <span class="hljs-number">1</span>, y)+<span class="hljs-built_in">ask</span>(p, q);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="使用差分数组完成四个基本操作"><a href="#使用差分数组完成四个基本操作" class="headerlink" title="使用差分数组完成四个基本操作"></a>使用差分数组完成四个基本操作</h3><p>本质上还是<strong>一维变二维</strong>的过程。</p><p>首先给出二维条件下差分数组的定义：</p><p>$$d[i][j]&#x3D;a[i][j]−a[i−1][j]-a[i][j−1]+a[i−1][j−1]$$</p><blockquote><p>此处需要保证<strong>前缀和</strong>和<strong>差分</strong>是一对逆运算。</p></blockquote><h4 id="区间修改和单点查询-1"><a href="#区间修改和单点查询-1" class="headerlink" title="区间修改和单点查询"></a>区间修改和单点查询</h4><p>对于区间修改，同理，<strong>对于差分数组来说只有四个顶角的点会发生变动</strong>（），证明略。</p><p>对于单点查询，可以转化为<strong>对差分数组</strong>的区间查询。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">fenwick_2d_2</span><br>&#123;<br>    <span class="hljs-type">int</span> m, n;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> C[MAXM][MAXN];<span class="hljs-comment">//此处维护差分数组</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> m_, <span class="hljs-type">int</span> n_)</span></span>&#123;<br>        m = m_;<br>        n = n_;<br>        <span class="hljs-built_in">memset</span>(C, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(C));<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * @brief submatrix(1,1) -&gt; (x,y) all add val</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param x </span><br><span class="hljs-comment">     * @param y </span><br><span class="hljs-comment">     * @param val </span><br><span class="hljs-comment">     * 这里的代码和上一个代码的add完全相同，但是意义不一样，因为这里的C维护的是差分数组</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">long</span> <span class="hljs-type">long</span> val)</span></span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = x; i &lt;= m; i += <span class="hljs-built_in">lowbit</span>(i))&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = y; j &lt;= n; j += <span class="hljs-built_in">lowbit</span>(y))&#123;<br>                C[i][j] += val;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * @brief submatrix(x1, y1) -&gt; (x2, y2) all adds x</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param x1 </span><br><span class="hljs-comment">     * @param y1 </span><br><span class="hljs-comment">     * @param x2 </span><br><span class="hljs-comment">     * @param y2 </span><br><span class="hljs-comment">     * @param x </span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">range_add</span><span class="hljs-params">(<span class="hljs-type">int</span> x1,<span class="hljs-type">int</span> y1,<span class="hljs-type">int</span> x2,<span class="hljs-type">int</span> y2,<span class="hljs-type">long</span> <span class="hljs-type">long</span> x)</span> </span>&#123;<br>        <span class="hljs-built_in">add</span>(x1,y1,x);<br>        <span class="hljs-built_in">add</span>(x1,y2<span class="hljs-number">+1</span>,-x);<br>        <span class="hljs-built_in">add</span>(x2<span class="hljs-number">+1</span>,y1,-x);<br>        <span class="hljs-built_in">add</span>(x2<span class="hljs-number">+1</span>,y2<span class="hljs-number">+1</span>,x);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * @brief return the value of index (x,y)</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param x </span><br><span class="hljs-comment">     * @param y </span><br><span class="hljs-comment">     * @return long long </span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">ask</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> ret=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = x; i &gt; <span class="hljs-number">0</span>; i -= <span class="hljs-built_in">lowbit</span>(i))&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = y;j &gt; <span class="hljs-number">0</span>;j -= <span class="hljs-built_in">lowbit</span>(j))&#123;<br>                ret += C[i][j];<br>            &#125;<br>        &#125;<br>            <br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="更加复杂的一般化？"><a href="#更加复杂的一般化？" class="headerlink" title="更加复杂的一般化？"></a>更加复杂的一般化？</h4><p>如果我需要<strong>同时支持四种操作</strong>？此时会更加复杂，贴上来自<strong>OI wiki</strong>的补充证明：</p><div class="note note-primary">            <p>对于点 $(x, y)$，它的二维前缀和可以表示为：</p><p>$$<br>\sum_{i&#x3D;1}^{x} \sum_{j&#x3D;1}^{y} \sum_{h&#x3D;1}^{i} \sum_{k&#x3D;1}^{j} d(h, k)<br>$$</p><p>原因就是差分的前缀和的前缀和就是原本的前缀和。</p><p>和一维树状数组的「区间加区间和」问题类似，统计 $d(h, k)$ 的出现次数，为 $(x - h + 1) \times (y - k + 1)$。</p><p>然后接着推导：</p><p>$$<br> \sum_{i&#x3D;1}^{x} \sum_{j&#x3D;1}^{y} \sum_{h&#x3D;1}^{i} \sum_{k&#x3D;1}^{j} d(h, k) &#x3D; \sum_{i&#x3D;1}^{x} \sum_{j&#x3D;1}^{y} d(i, j) \times (x - i + 1) \times (y - j + 1)<br>$$<br>$$&#x3D;  \sum_{i&#x3D;1}^{x} \sum_{j&#x3D;1}^{y} d(i, j) \times (xy + x + y + 1) - d(i, j) \times i \times (y + 1) - d(i, j) \times j \times (x + 1) + d(i, j) \times i \times j$$</p>          </div><p><strong>因此，在二维数组中，需要额外维护4个差分数组！</strong></p><ul><li>区间修改：对差分数组做操作</li><li>区间查询：对差分数组做操作</li><li>单点查询：<strong>退化</strong>，可以转化为对一个1*1的子矩阵进行查询</li><li>单点修改：<strong>退化</strong>，可以转化为对一个1*1的子矩阵进行修改</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">fenwick_2d_3</span><br>&#123;<br>    <span class="hljs-type">int</span> m, n;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> C1[MAXM][MAXN];<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> C2[MAXM][MAXN];<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> C3[MAXM][MAXN];<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> C4[MAXM][MAXN];<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> m,<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">this</span>-&gt;n = n;<br>        <span class="hljs-keyword">this</span>-&gt;m = m;<br>        <span class="hljs-built_in">memset</span>(C1,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(C1));<br>        <span class="hljs-built_in">memset</span>(C2,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(C2));<br>        <span class="hljs-built_in">memset</span>(C3,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(C3));<br>        <span class="hljs-built_in">memset</span>(C4,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(C4));<br>    &#125;<br><br>    <span class="hljs-comment">//区间修改</span><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * @brief Add val for single element (x,y)</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param x </span><br><span class="hljs-comment">     * @param y </span><br><span class="hljs-comment">     * @param val </span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">long</span> <span class="hljs-type">long</span> val)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = x;i &lt;= m;i += <span class="hljs-built_in">lowbit</span>(i))<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = y;j &lt;= n;j += <span class="hljs-built_in">lowbit</span>(j))<br>            &#123;<br>                C1[i][j] += val;<br>                C2[i][j] += val * x;<br>                C3[i][j] += val * y;<br>                C4[i][j] += val * x * y;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * @brief Add val for all elements in the submatrix </span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param x </span><br><span class="hljs-comment">     * @param y </span><br><span class="hljs-comment">     * @param val </span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add_submatrix</span><span class="hljs-params">(<span class="hljs-type">int</span> x1, <span class="hljs-type">int</span> y1, <span class="hljs-type">int</span> x2, <span class="hljs-type">int</span> y2, <span class="hljs-type">long</span> <span class="hljs-type">long</span> val)</span> </span>&#123;<br>        <span class="hljs-built_in">add</span>(x1,y1,val);<br>        <span class="hljs-built_in">add</span>(x1,y2<span class="hljs-number">+1</span>,-val);<br>        <span class="hljs-built_in">add</span>(x2<span class="hljs-number">+1</span>,y1,-val);<br>        <span class="hljs-built_in">add</span>(x2<span class="hljs-number">+1</span>,y2<span class="hljs-number">+1</span>,val);<br>    &#125;<br><br>    <span class="hljs-comment">//区间查询</span><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * @brief the sum of the submatrix (1,1) -&gt; (x,y)</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param x </span><br><span class="hljs-comment">     * @param y </span><br><span class="hljs-comment">     * @return long long </span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">rangeAsk1</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span>&#123;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = x; i &gt; <span class="hljs-number">0</span>; i -= <span class="hljs-built_in">lowbit</span>(i))&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &gt; <span class="hljs-number">0</span>; j -= <span class="hljs-built_in">lowbit</span>(j))&#123;<br>                ans += (x + <span class="hljs-number">1</span>)*(y + <span class="hljs-number">1</span>)*C1[i][j];<br>                ans -= (y + <span class="hljs-number">1</span>)*C2[i][j] + (x + <span class="hljs-number">1</span>)*C3[i][j];<br>                ans += C4[i][j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">rangeAsk2</span><span class="hljs-params">(<span class="hljs-type">int</span> x1, <span class="hljs-type">int</span> y1, <span class="hljs-type">int</span> x2, <span class="hljs-type">int</span> y2)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">rangeAsk1</span>(x2,y2) - <span class="hljs-built_in">rangeAsk1</span>(x1<span class="hljs-number">-1</span>,y2) - <span class="hljs-built_in">rangeAsk1</span>(x2,y1<span class="hljs-number">-1</span>) + <span class="hljs-built_in">rangeAsk1</span>(x1<span class="hljs-number">-1</span>,y1<span class="hljs-number">-1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//单点查询</span><br>    <span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">ask</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">rangeAsk2</span>(x, y, x, y);<br>    &#125;<br><br>    <span class="hljs-comment">//单点修改的退化情况</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modifySingle</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">long</span> <span class="hljs-type">long</span> val)</span></span>&#123;<br>        <span class="hljs-built_in">add_submatrix</span>(x, y, x, y, val);<br>    &#125;<br>&#125;;<br><br><br></code></pre></td></tr></table></figure><p>至此，我们已经实现了<strong>四种最基本的模版操作！</strong></p><h2 id="权值树状数组"><a href="#权值树状数组" class="headerlink" title="权值树状数组"></a>权值树状数组</h2><blockquote><p>一个序列$a[x]$的权值数组$b[x]$，满足$b[x]$的值为$x$在$a[\ ]$中的出现次数。在权值数组中，<strong>值与值之间的相对关系</strong>比<strong>值的绝对大小</strong>要更加重要。因此，如果对于值域过大的情况，可以先使用<strong>离散化</strong>操作后再建立等效的权值数组。另外，权值数组是原数组无序性的一种表示：它重点描述数组的元素内容，忽略了数组的顺序，若两数组只是顺序不同，所含内容一致，则它们的权值数组相同。</p></blockquote><p>由于权值数组考虑<strong>值与值之间的大小关系</strong>，因此将重点放在<strong>查询排名</strong>而并非区间和上面。</p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tutorial</tag>
      
      <tag>Tree</tag>
      
      <tag>Finished</tag>
      
      <tag>Data Structure</tag>
      
      <tag>C/C++</tag>
      
      <tag>Fenwick Tree</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Algorithm-Sorting</title>
    <link href="/posts/Algorithm-Sorting/"/>
    <url>/posts/Algorithm-Sorting/</url>
    
    <content type="html"><![CDATA[<h1 id="Sorting-Algorithms"><a href="#Sorting-Algorithms" class="headerlink" title="Sorting Algorithms"></a>Sorting Algorithms</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p><strong>Sorting</strong> is of great importance when learning algorithms for beginners! This blog shows the basic principles of several sorting algorithms and its implementation of C++.</p><h2 id="Merge-Sort"><a href="#Merge-Sort" class="headerlink" title="Merge Sort"></a>Merge Sort</h2><h2 id="Quick-Sort"><a href="#Quick-Sort" class="headerlink" title="Quick Sort"></a>Quick Sort</h2><h2 id="Heap-Sort"><a href="#Heap-Sort" class="headerlink" title="Heap Sort"></a>Heap Sort</h2><p>The basic principle of <strong>Heap sort</strong> is from the data structure: <strong>Heap</strong>, where all nodes (or elements) are formed in order (ascending or descending). Heap maintain this properties, so every time you pop out the top element in the heap (or priority queue), it must be the biggest or the smallest element with highest priority in the queue.</p><p>For more information, you can search <a href="https://xiyuanyang-code.github.io/posts/DataStructure-Tree-Binary-Heap/">Binary Heap</a></p><p>We can use several ways to construct a heap (Binary heap, leftist heap, skew heap, binomial heap), the code demonstrated below shows the basic implementation of <strong>Binary Heap</strong>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctime&gt;</span></span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">priorityQueue</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">size_t</span> currentsize;<br>    T* array;<br>    <span class="hljs-type">size_t</span> maxsize;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doublespace</span><span class="hljs-params">()</span> </span>&#123;<br>        T* tmp = array;<br>        maxsize *= <span class="hljs-number">2</span>;<br>        array = <span class="hljs-keyword">new</span> T[maxsize];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt;= currentsize; ++i) &#123;<br>            array[i] = tmp[i];<br>        &#125;<br>        <span class="hljs-keyword">delete</span>[] tmp;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">buildheap</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = currentsize / <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">1</span>; --i) &#123;<br>            <span class="hljs-built_in">percolateDown</span>(i);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">percolateDown</span><span class="hljs-params">(<span class="hljs-type">size_t</span> hole)</span> </span>&#123;<br>        <span class="hljs-type">size_t</span> child = <span class="hljs-number">0</span>;<br>        T tmp = array[hole];<br><br>        <span class="hljs-keyword">while</span> (hole * <span class="hljs-number">2</span> &lt;= currentsize) &#123;<br>            child = hole * <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (child &lt; currentsize &amp;&amp; array[child + <span class="hljs-number">1</span>] &lt; array[child]) &#123;<br>                ++child;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (array[child] &lt; tmp) &#123;<br>                array[hole] = array[child];<br>                hole = child;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        array[hole] = tmp;<br>    &#125;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">priorityQueue</span>(<span class="hljs-type">size_t</span> capacity = <span class="hljs-number">100</span>) : <span class="hljs-built_in">currentsize</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">maxsize</span>(capacity) &#123;<br>        array = <span class="hljs-keyword">new</span> T[maxsize];<br>    &#125;<br><br>    ~<span class="hljs-built_in">priorityQueue</span>() &#123;<br>        <span class="hljs-keyword">delete</span>[] array;<br>    &#125;<br><br>    <span class="hljs-built_in">priorityQueue</span>(<span class="hljs-type">const</span> T* data, <span class="hljs-type">size_t</span> size) : <span class="hljs-built_in">currentsize</span>(size), <span class="hljs-built_in">maxsize</span>(size + <span class="hljs-number">10</span>) &#123;<br>        array = <span class="hljs-keyword">new</span> T[maxsize];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; size; ++i) &#123;<br>            array[i + <span class="hljs-number">1</span>] = data[i];<br>        &#125;<br>        <span class="hljs-built_in">buildheap</span>();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> currentsize == <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">enQueue</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; x)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (currentsize == maxsize - <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-built_in">doublespace</span>();<br>        &#125;<br><br>        <span class="hljs-type">size_t</span> hole = ++currentsize;<br>        <span class="hljs-keyword">while</span> (hole &gt; <span class="hljs-number">1</span> &amp;&amp; x &lt; array[hole / <span class="hljs-number">2</span>]) &#123;<br>            array[hole] = array[hole / <span class="hljs-number">2</span>];<br>            hole /= <span class="hljs-number">2</span>;<br>        &#125;<br>        array[hole] = x;<br>    &#125;<br><br>    <span class="hljs-function">T <span class="hljs-title">deQueue</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">underflow_error</span>(<span class="hljs-string">&quot;Priority queue is empty&quot;</span>);<br>        &#125;<br><br>        T minItem = array[<span class="hljs-number">1</span>];<br>        array[<span class="hljs-number">1</span>] = array[currentsize--];<br>        <span class="hljs-built_in">percolateDown</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> minItem;<br>    &#125;<br><br>    <span class="hljs-function">T <span class="hljs-title">getHead</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">underflow_error</span>(<span class="hljs-string">&quot;Priority queue is empty&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> array[<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pqsort</span><span class="hljs-params">(T* unsorted, T* sorted, <span class="hljs-type">size_t</span> size)</span> </span>&#123;<br>    <span class="hljs-function">priorityQueue&lt;T&gt; <span class="hljs-title">pq</span><span class="hljs-params">(unsorted, size)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; size; ++i) &#123;<br>        sorted[i] = pq.<span class="hljs-built_in">deQueue</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">heapSort</span><span class="hljs-params">(T*&amp; arr, <span class="hljs-type">size_t</span> size)</span> </span>&#123;<br>    <span class="hljs-comment">//default for ascending order</span><br>    <span class="hljs-function">priorityQueue&lt;T&gt; <span class="hljs-title">pq</span><span class="hljs-params">(arr, size)</span></span>;<br>    T* sorted = <span class="hljs-keyword">new</span> T [size];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; size; ++i) &#123;<br>        sorted[i] = pq.<span class="hljs-built_in">deQueue</span>();<br>    &#125;<br>    <span class="hljs-keyword">delete</span>[] arr;<br>    arr = sorted;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> size = <span class="hljs-number">50</span>;<br>    <span class="hljs-type">int</span> *arr = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span> [size];<br>    <br>    <span class="hljs-comment">//using the random seed</span><br>    std::<span class="hljs-built_in">srand</span>(<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(std::<span class="hljs-built_in">time</span>(<span class="hljs-literal">nullptr</span>)));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++)&#123;<br>        arr[i] = std::<span class="hljs-built_in">rand</span>();<br>    &#125;<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Before the sort&quot;</span> &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++)&#123;<br>        std::cout &lt;&lt; arr[i] &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-built_in">heapSort</span>(arr, size);<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;After the sort&quot;</span> &lt;&lt; std::endl;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; ++i)&#123;<br>        std::cout &lt;&lt; arr[i] &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Counting-Sort"><a href="#Counting-Sort" class="headerlink" title="Counting Sort"></a>Counting Sort</h2>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C/C++</tag>
      
      <tag>Sorting Algorithms</tag>
      
      <tag>Merge Sort</tag>
      
      <tag>Quick Sort</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DataStructure-Tree-Binary-Search-Tree-AVL-Tree</title>
    <link href="/posts/DataStructure-Tree-Binary-Search-Tree/"/>
    <url>/posts/DataStructure-Tree-Binary-Search-Tree/</url>
    
    <content type="html"><![CDATA[<style>  html, body, .markdown-body {    font-family: Georgia, sans, serif;  }</style><h1 id="Binary-Search-Tree"><a href="#Binary-Search-Tree" class="headerlink" title="Binary Search Tree"></a>Binary Search Tree</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p><strong>动态查找表</strong>：支持元素的增添、删除操作的集合。</p><p>在动态查找表中涉及<strong>元素频繁的插入和删除操作</strong>，因此使用顺序存储是不合适的。在此处，可以使用<strong>二叉树</strong>，在保证结构性和有序性的同时，将对应的时间操作降低到对数级别。<strong>用于处理动态查找表</strong>的树称为查找树，另一种动态查找表的实现是<strong>散列表</strong>，用于集合的数据结构（哈希）。</p><p><strong>二叉查找树</strong>：就是<strong>二分查找的树实现</strong>！</p><p><strong>Definition</strong>：</p><ul><li><p><strong>若左子树不空，则左子树的所有元素的键值严格小于根节点</strong></p></li><li><p><strong>若右子树不空，则右子树的所有元素的键值严格大于根节点</strong></p></li><li><p><strong>Define it recursively !</strong></p></li></ul><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><ul><li><p><strong>插入操作</strong>：插入的操作在本质上也是一个递归操作</p><ul><li>实现需要<strong>查找</strong>操作，因为要保证键值的唯一性</li><li>在插入新元素的同时是<strong>插入在叶节点的位置</strong>，这样能够保证BST的有序性。</li></ul></li><li><p><strong>删除操作</strong></p><p>  删除操作相对来说比较复杂，因为删除涉及到<strong>树的分裂</strong>，我们可以从特殊情况说起。</p><ul><li>首先，我们还是需要进行查找操作（递归），如果没有找到，那么直接return。</li><li>如果找到了对应的<strong>节点</strong>，此时分类讨论：<ul><li>如果节点为叶节点，即没有孩子，则<strong>直接delete即可</strong>。</li><li>如果节点只有一个孩子，也是比较简单的，直接让<strong>孩子节点上移</strong>替代对应的节点即可。</li><li><strong>如果节点有两个孩子</strong>，请看下面的分析。</li></ul></li></ul></li></ul><p>回过头来，<strong>删除操作</strong>需要保证维护<strong>二叉查找树</strong>的结构，什么是二叉查找树的结构，可以从定义出发，同时，我们可以给出第二种等价定义：<strong>二叉树的中序遍历必须保证是有序的</strong>！</p><div class="note note-primary">            <p><strong>这是二叉查找树</strong>的核心。</p>          </div><p>也就是说，只要我们保证中序遍历的有序性，我们更希望保证<strong>删除的节点是叶节点</strong>，因此，我们可以找到对应节点的下一个节点，而这个节点一定是其右子树的中序遍历的第一个节点！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @Author: Xiyuan Yang   xiyuan_yang@outlook.com</span><br><span class="hljs-comment"> * @Date: 2025-04-03 14:10:59</span><br><span class="hljs-comment"> * @LastEditors: Xiyuan Yang   xiyuan_yang@outlook.com</span><br><span class="hljs-comment"> * @LastEditTime: 2025-04-03 15:19:49</span><br><span class="hljs-comment"> * @FilePath: /Data_structure/single_files/Class_implementation/BST.cpp</span><br><span class="hljs-comment"> * @Description: Dynamic Search Table</span><br><span class="hljs-comment"> * Do you code and make progress today?</span><br><span class="hljs-comment"> * Copyright (c) 2025 by Xiyuan Yang, All Rights Reserved. </span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">KEY</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">OTHER</span>&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">set</span><br>&#123;<br>    KEY key;<br>    OTHER other;<br>&#125;;<br><br><br><span class="hljs-comment">// Dynamic Search Table</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Key</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">Other</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">dynamicSearchTable</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-comment">// finding elements of x</span><br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> set&lt;Key, Other&gt;* <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">const</span> Key&amp; x)</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// insert element, maintaining the order</span><br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">const</span> set&lt;Key, Other&gt; &amp;x)</span> </span>= <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// remove an element, maintaining the order</span><br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">const</span> Key &amp;x)</span> </span>= <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">dynamicSearchTable</span>() &#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Key</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">Other</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BST</span>: <span class="hljs-keyword">public</span> dynamicSearchTable&lt;Key, Other&gt; &#123;<br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BinaryNode</span>&#123;<br>            set &lt;Key, Other&gt; data;<br>            BinaryNode* left;<br>            BinaryNode* right;<br><br>            <span class="hljs-built_in">BinaryNode</span>(<span class="hljs-type">const</span> set&lt;Key, Other&gt;&amp; data_, BinaryNode* left_ = <span class="hljs-literal">nullptr</span>, BinaryNode* right_ = <span class="hljs-literal">nullptr</span>): <span class="hljs-built_in">data</span>(data_), <span class="hljs-built_in">left</span>(left_), <span class="hljs-built_in">right</span>(right_) &#123;&#125;<br>        &#125;;<br><br>        <span class="hljs-comment">// root node</span><br>        BinaryNode* root;<br><br><br>    <span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// tool function</span><br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * @brief insert the struct into the binary tree</span><br><span class="hljs-comment">         * </span><br><span class="hljs-comment">         * @param x </span><br><span class="hljs-comment">         * @param t the root node (for recursion)</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">const</span> set&lt;Key, Other&gt;&amp;x, BinaryNode*&amp; t)</span> </span>&#123;<br>            <span class="hljs-keyword">if</span>(t == <span class="hljs-literal">nullptr</span>)&#123;<br>                <span class="hljs-comment">// Adding a new element on the leaf node</span><br>                t = <span class="hljs-keyword">new</span> <span class="hljs-built_in">BinaryNode</span>(x, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>);<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x.key &lt; t -&gt; data.key)&#123;<br>                <span class="hljs-built_in">insert</span>(x, t -&gt; left);<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x.key &gt; t -&gt; data.key)&#123;<br>                <span class="hljs-built_in">insert</span>(x, t -&gt; right);<br>            &#125;<br>            <span class="hljs-comment">// If x.key = t -&gt; data.key, won&#x27;t do anything</span><br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * @brief remove element with the key value of x</span><br><span class="hljs-comment">         * </span><br><span class="hljs-comment">         * @param x </span><br><span class="hljs-comment">         * @param t the root node</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">const</span> Key&amp; x, BinaryNode*&amp; t)</span> </span>&#123;<br>            <span class="hljs-comment">// if nullptr, return and end the recursion</span><br>            <span class="hljs-keyword">if</span>(t == <span class="hljs-literal">nullptr</span>)&#123;<br>                <span class="hljs-keyword">return</span> ;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span>(x &lt; t -&gt; data.key)&#123;<br>                <span class="hljs-built_in">remove</span>(x, t -&gt; left);<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x &gt; (t -&gt; data.key))&#123;<br>                <span class="hljs-built_in">remove</span>(x, t -&gt; right);<br>            &#125;<br>            <span class="hljs-comment">// If we find the element...</span><br>            <span class="hljs-comment">// If it has one child:just replace it with is child</span><br>            <span class="hljs-comment">// If it has zero child: just delete it</span><br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span>(t -&gt; left != <span class="hljs-literal">nullptr</span> &amp;&amp; t -&gt; right != <span class="hljs-literal">nullptr</span>)&#123;<br>                    BinaryNode *tmp = t -&gt; right;<br>                    <span class="hljs-keyword">while</span>(tmp -&gt; left != <span class="hljs-literal">nullptr</span>)&#123;<br>                        <span class="hljs-comment">//traverse the next element in the traversal order</span><br>                        tmp = tmp -&gt; left;<br>                    &#125;<br>                    t -&gt; data = tmp -&gt; data;<br>                    <span class="hljs-built_in">remove</span>(t -&gt; data.key, t-&gt; right);<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    BinaryNode* oldnode = t;<br>                    <span class="hljs-comment">// If it has one child, replace it</span><br>                    t = (t -&gt; left != <span class="hljs-literal">nullptr</span>) ? t -&gt; left : t -&gt; right;<br>                    <span class="hljs-keyword">delete</span> oldnode;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * @brief Make the tree empty</span><br><span class="hljs-comment">         * </span><br><span class="hljs-comment">         * @param t the root node</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">makeEmpty</span><span class="hljs-params">(BinaryNode* t)</span> </span>&#123;<br>            <span class="hljs-keyword">if</span>(t == <span class="hljs-literal">nullptr</span>)&#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br><br>            <span class="hljs-built_in">makeEmpty</span>(t -&gt; left);<br>            <span class="hljs-built_in">makeEmpty</span>(t -&gt; right);<br>            <span class="hljs-keyword">delete</span> t;<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * @brief find the specific element using the recursion</span><br><span class="hljs-comment">         * </span><br><span class="hljs-comment">         * @param x key value</span><br><span class="hljs-comment">         * @param t root node</span><br><span class="hljs-comment">         * @return set&lt;Key, Other&gt;* </span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-function">set&lt;Key, Other&gt;* <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">const</span> Key&amp; x, BinaryNode* t)</span> <span class="hljs-type">const</span> </span>&#123;<br>            <span class="hljs-keyword">if</span>(t == <span class="hljs-literal">nullptr</span>)&#123;<br>                <span class="hljs-comment">// goto the end (leaf node)</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// finding the element successfully</span><br>            <span class="hljs-keyword">if</span>(t -&gt; data.key == x)&#123;<br>                <span class="hljs-comment">// successfully</span><br>                <span class="hljs-keyword">return</span> (set&lt;Key, Other&gt;*)t;<br>            &#125;<br><br>            <span class="hljs-comment">// recursively searching for the left &amp; right subtree</span><br>            <span class="hljs-keyword">if</span>(x &lt; t -&gt; data.key) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(x, t -&gt; left);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(x, t -&gt; right);<br>            &#125;<br>        &#125;<br><br><br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">BST</span>() &#123;<br>            <span class="hljs-comment">// create an empty tree</span><br>            root = <span class="hljs-literal">nullptr</span>;<br>        &#125;<br><br>        ~<span class="hljs-built_in">BST</span>() &#123;<br>            <span class="hljs-built_in">makeEmpty</span>(root);<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * @brief Insert value x in the BST</span><br><span class="hljs-comment">         * </span><br><span class="hljs-comment">         * @param x </span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">const</span> set&lt;Key, Other&gt; &amp;x)</span> </span>&#123;<br>            <span class="hljs-built_in">insert</span>(x, root);<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * @brief remove the value with the key value of x</span><br><span class="hljs-comment">         * </span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">const</span> Key&amp; x)</span> </span>&#123;<br>            <span class="hljs-built_in">remove</span>(x, root);<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * @brief find the element with the key value of x</span><br><span class="hljs-comment">         * </span><br><span class="hljs-comment">         * @param x </span><br><span class="hljs-comment">         * @return set&lt;Key, Other&gt;* </span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-function">set&lt;Key, Other&gt;* <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">const</span> Key&amp; x)</span> <span class="hljs-type">const</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(x, root);<br>        &#125;<br>&#125;;<br><br><br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 创建一个BST实例</span><br>    BST&lt;<span class="hljs-type">int</span>, std::string&gt; bst;<br><br>    <span class="hljs-comment">// 插入一些元素</span><br>    set&lt;<span class="hljs-type">int</span>, std::string&gt; elements[] = &#123;<br>        &#123;<span class="hljs-number">10</span>, <span class="hljs-string">&quot;Alice&quot;</span>&#125;,<br>        &#123;<span class="hljs-number">5</span>, <span class="hljs-string">&quot;Bob&quot;</span>&#125;,<br>        &#123;<span class="hljs-number">15</span>, <span class="hljs-string">&quot;Charlie&quot;</span>&#125;,<br>        &#123;<span class="hljs-number">3</span>, <span class="hljs-string">&quot;David&quot;</span>&#125;,<br>        &#123;<span class="hljs-number">7</span>, <span class="hljs-string">&quot;Eve&quot;</span>&#125;,<br>        &#123;<span class="hljs-number">12</span>, <span class="hljs-string">&quot;Frank&quot;</span>&#125;,<br>        &#123;<span class="hljs-number">18</span>, <span class="hljs-string">&quot;Grace&quot;</span>&#125;<br>    &#125;;<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Inserting elements into the BST:&quot;</span> &lt;&lt; std::endl;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; elem : elements) &#123;<br>        bst.<span class="hljs-built_in">insert</span>(elem);<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Inserted: Key = &quot;</span> &lt;&lt; elem.key &lt;&lt; <span class="hljs-string">&quot;, Value = &quot;</span> &lt;&lt; elem.other &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-comment">// 测试查找功能</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;\nTesting find function:&quot;</span> &lt;&lt; std::endl;<br>    <span class="hljs-type">int</span> keysToFind[] = &#123;<span class="hljs-number">10</span>, <span class="hljs-number">5</span>, <span class="hljs-number">15</span>, <span class="hljs-number">100</span>&#125;; <span class="hljs-comment">// 100 is not in the tree</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> key : keysToFind) &#123;<br>        set&lt;<span class="hljs-type">int</span>, std::string&gt;* result = bst.<span class="hljs-built_in">find</span>(key);<br>        <span class="hljs-keyword">if</span> (result) &#123;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;Found: Key = &quot;</span> &lt;&lt; result-&gt;key &lt;&lt; <span class="hljs-string">&quot;, Value = &quot;</span> &lt;&lt; result-&gt;other &lt;&lt; std::endl;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;Key &quot;</span> &lt;&lt; key &lt;&lt; <span class="hljs-string">&quot; not found.&quot;</span> &lt;&lt; std::endl;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 测试删除功能</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;\nTesting remove function:&quot;</span> &lt;&lt; std::endl;<br>    <span class="hljs-type">int</span> keysToRemove[] = &#123;<span class="hljs-number">5</span>, <span class="hljs-number">15</span>, <span class="hljs-number">100</span>&#125;; <span class="hljs-comment">// 100 is not in the tree</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> key : keysToRemove) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Removing key &quot;</span> &lt;&lt; key &lt;&lt; <span class="hljs-string">&quot;...&quot;</span> &lt;&lt; std::endl;<br>        bst.<span class="hljs-built_in">remove</span>(key);<br><br>        <span class="hljs-comment">// 验证删除后的查找结果</span><br>        set&lt;<span class="hljs-type">int</span>, std::string&gt;* result = bst.<span class="hljs-built_in">find</span>(key);<br>        <span class="hljs-keyword">if</span> (result) &#123;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;Key &quot;</span> &lt;&lt; key &lt;&lt; <span class="hljs-string">&quot; still exists after removal.&quot;</span> &lt;&lt; std::endl;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;Key &quot;</span> &lt;&lt; key &lt;&lt; <span class="hljs-string">&quot; successfully removed.&quot;</span> &lt;&lt; std::endl;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 再次测试查找功能以确认删除效果</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;\nRe-testing find function after removals:&quot;</span> &lt;&lt; std::endl;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> key : keysToFind) &#123;<br>        set&lt;<span class="hljs-type">int</span>, std::string&gt;* result = bst.<span class="hljs-built_in">find</span>(key);<br>        <span class="hljs-keyword">if</span> (result) &#123;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;Found: Key = &quot;</span> &lt;&lt; result-&gt;key &lt;&lt; <span class="hljs-string">&quot;, Value = &quot;</span> &lt;&lt; result-&gt;other &lt;&lt; std::endl;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;Key &quot;</span> &lt;&lt; key &lt;&lt; <span class="hljs-string">&quot; not found.&quot;</span> &lt;&lt; std::endl;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="时间性能"><a href="#时间性能" class="headerlink" title="时间性能"></a>时间性能</h2><p>二叉树并不能保证树的平衡，也就是说存在<strong>退化为单链表</strong>的情况。对于最优的情况，时间复杂度是$O(\log n)$，对于<strong>平均情况</strong>，时间复杂度是其$1.38$倍。</p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tutorial</tag>
      
      <tag>Tree</tag>
      
      <tag>Data Structure</tag>
      
      <tag>C/C++</tag>
      
      <tag>Binary Tree</tag>
      
      <tag>AVL Tree</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RAG-Blog-Content-Retrieval</title>
    <link href="/posts/RAG-Blog-Content-Retrieval/"/>
    <url>/posts/RAG-Blog-Content-Retrieval/</url>
    
    <content type="html"><![CDATA[<style>  html, body, .markdown-body {    font-family: Georgia, sans, serif;  }</style><h1 id="RAG-Blog-content-retrieval"><a href="#RAG-Blog-content-retrieval" class="headerlink" title="RAG Blog content retrieval"></a>RAG Blog content retrieval</h1><p>This is My github Project: <a href="https://github.com/xiyuanyang-code/RAG_blog_content_retrieval">RAG Blog Content Retrieval</a>.</p><p>The contents following is copied from the <code>README.md</code> file:</p><h2 id="😊Introduction"><a href="#😊Introduction" class="headerlink" title="😊Introduction"></a>😊Introduction</h2><p>This is a simple application for blog content retrieval implemented using RAG as the core technology.</p><h2 id="🚀Installation"><a href="#🚀Installation" class="headerlink" title="🚀Installation"></a>🚀Installation</h2><h3 id="Requirements"><a href="#Requirements" class="headerlink" title="Requirements"></a>Requirements</h3><ul><li>Make sure you have <strong>OpenAI API Key</strong> and <strong>LangSmith</strong> API key!</li></ul><h4 id="Install-Python-requirements"><a href="#Install-Python-requirements" class="headerlink" title="Install Python requirements"></a>Install Python requirements</h4><p>After cloning the project, run:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip install -r requirements.txt<br></code></pre></td></tr></table></figure><h4 id="Set-up-env-file"><a href="#Set-up-env-file" class="headerlink" title="Set up .env file"></a>Set up <code>.env</code> file</h4><p>Set up a file named <code>.env</code> in your current directory:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">touch</span> .<span class="hljs-built_in">env</span><br></code></pre></td></tr></table></figure><p>Fill in your keys and other information in the <code>.env</code> file, a demo is shown below:</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">API_KEY</span>=<span class="hljs-number">123456</span><br><span class="hljs-attr">BASE_URL</span>=<span class="hljs-number">123456</span><br><span class="hljs-attr">Langchain_api</span>=<span class="hljs-number">123456</span><br></code></pre></td></tr></table></figure><p><strong>Remember to replace your api key value into the key value</strong>!</p><h2 id="💓Usage"><a href="#💓Usage" class="headerlink" title="💓Usage"></a>💓Usage</h2><p><strong>Make sure you have passed through the <code>installation</code> section successfully.</strong> </p><h3 id="Run-Streamlit-code-Locally"><a href="#Run-Streamlit-code-Locally" class="headerlink" title="Run Streamlit code Locally"></a>Run <code>Streamlit</code> code Locally</h3><p>run following commands:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">streamlit run ./main.py<br></code></pre></td></tr></table></figure><p>Then you can see the webpages like this:</p><p><img src="https://s1.imagehub.cc/images/2025/03/29/e78604608a8deae5a20b687fd9f65689.png" alt="demo"></p><p>Then you can run this locally in your computer, enjoy RAG now!</p><p>A demo:</p><p><img src="https://s1.imagehub.cc/images/2025/03/29/b736eb5e2afe5029a2c2f1b4011605ca.png" alt="demo2"></p><p>You can freely search send queries regarding the blog passage and get answers.</p><h3 id="Run-Streamlit-demo-online"><a href="#Run-Streamlit-demo-online" class="headerlink" title="Run Streamlit demo online"></a>Run <code>Streamlit</code> demo online</h3><p>I will finish it later…</p><p>But actually I don’t recommend this for it is unsafe to input your secret key to the internet!</p><h2 id="🤖Discussion"><a href="#🤖Discussion" class="headerlink" title="🤖Discussion"></a>🤖Discussion</h2><p>Just for fun, don’t be serious.</p><p>If you have any issues, don’t hesitate to contact the author.</p><h2 id="👍Advertisement"><a href="#👍Advertisement" class="headerlink" title="👍Advertisement"></a>👍Advertisement</h2><p>My personal Blog: <a href="https://xiyuanyang-code.github.io/">Xiyuan Yang’s Blog</a></p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><p>I will demonstrate the codes here, which can be used like a demonstration for freshman to learn <code>bs4</code>, <code>streamlit</code>, <code>langchain</code> and <strong>RAG</strong>!</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">Author: Xiyuan Yang   xiyuan_yang@outlook.com</span><br><span class="hljs-string">Date: 2025-03-29 15:17:02</span><br><span class="hljs-string">LastEditors: Xiyuan Yang   xiyuan_yang@outlook.com</span><br><span class="hljs-string">LastEditTime: 2025-03-29 16:26:27</span><br><span class="hljs-string">FilePath: /RAG_try/RAG/main.py</span><br><span class="hljs-string">Description: </span><br><span class="hljs-string">Do you code and make progress today?</span><br><span class="hljs-string">Copyright (c) 2025 by Xiyuan Yang, All Rights Reserved. </span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><br><span class="hljs-comment"># Several Requirements</span><br><span class="hljs-keyword">import</span> bs4<br><span class="hljs-keyword">import</span> dotenv<br><span class="hljs-keyword">import</span> openai<br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> streamlit <span class="hljs-keyword">as</span> st<br><span class="hljs-keyword">from</span> langchain <span class="hljs-keyword">import</span> hub<br><span class="hljs-keyword">from</span> langchain.text_splitter <span class="hljs-keyword">import</span> RecursiveCharacterTextSplitter<br><span class="hljs-keyword">from</span> langchain_community.document_loaders <span class="hljs-keyword">import</span> WebBaseLoader<br><span class="hljs-keyword">from</span> langchain_community.vectorstores <span class="hljs-keyword">import</span> Chroma<br><span class="hljs-keyword">from</span> langchain_core.output_parsers <span class="hljs-keyword">import</span> StrOutputParser<br><span class="hljs-keyword">from</span> langchain_core.runnables <span class="hljs-keyword">import</span> RunnablePassthrough<br><span class="hljs-keyword">from</span> langchain_openai <span class="hljs-keyword">import</span> ChatOpenAI, OpenAIEmbeddings<br><br><br><br><span class="hljs-comment"># getting environments done</span><br>dotenv.load_dotenv()<br>openai.api_key = os.getenv(<span class="hljs-string">&quot;API_KEY&quot;</span>)<br>openai.base_url = os.getenv(<span class="hljs-string">&quot;BASE_URL&quot;</span>)<br><br><span class="hljs-comment"># langchain api</span><br>os.environ[<span class="hljs-string">&#x27;LANGCHAIN_TRACING_V2&#x27;</span>] = <span class="hljs-string">&#x27;true&#x27;</span><br>os.environ[<span class="hljs-string">&#x27;LANGCHAIN_ENDPOINT&#x27;</span>] = <span class="hljs-string">&#x27;https://api.smith.langchain.com&#x27;</span><br>os.environ[<span class="hljs-string">&#x27;LANGCHAIN_API_KEY&#x27;</span>] = os.getenv(<span class="hljs-string">&quot;Langchain_api&quot;</span>)<br><br><span class="hljs-comment"># Define LLMs and prompts</span><br>LLM = ChatOpenAI(model_name=<span class="hljs-string">&quot;gpt-3.5-turbo&quot;</span>, temperature=<span class="hljs-number">0</span>,<br>                    api_key = openai.api_key,<br>                    base_url = openai.base_url)<br><br>prompt = hub.pull(<span class="hljs-string">&quot;rlm/rag-prompt&quot;</span>)<br><br><span class="hljs-comment"># load documents:</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">loader_documents</span>(<span class="hljs-params">url</span>):<br>    loader = WebBaseLoader(<br>    web_paths=(url,),<br><br>    )<br>    docs = loader.load()<br>    <span class="hljs-keyword">return</span> docs<br><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">text_splitter</span>(<span class="hljs-params">docs</span>):<br>    text_splitter = RecursiveCharacterTextSplitter(chunk_size=<span class="hljs-number">1000</span>, chunk_overlap=<span class="hljs-number">200</span>)<br>    splits = text_splitter.split_documents(docs)<br><br>    <span class="hljs-keyword">return</span> splits<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">embedding</span>(<span class="hljs-params">splits</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27;Embeding the vector&#x27;&#x27;&#x27;</span><br>    vectorstore = Chroma.from_documents(documents=splits, <br>                                        embedding=OpenAIEmbeddings(<br>                                            base_url=<span class="hljs-string">&quot;https://api.zhizengzeng.com/v1&quot;</span>,<br>                                            api_key=os.environ[<span class="hljs-string">&quot;OPENAI_API_KEY&quot;</span>]<br>                                        ))<br><br>    retriever = vectorstore.as_retriever()<br><br>    <span class="hljs-keyword">return</span> vectorstore, retriever<br><br><span class="hljs-comment"># Post-processing</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">format_docs</span>(<span class="hljs-params">docs</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;\n\n&quot;</span>.join(doc.page_content <span class="hljs-keyword">for</span> doc <span class="hljs-keyword">in</span> docs)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_answer</span>(<span class="hljs-params">retriever, prompt, llm, question</span>):<br>    rag_chain = (<br>        &#123;<span class="hljs-string">&quot;context&quot;</span>: retriever | format_docs, <span class="hljs-string">&quot;question&quot;</span>: RunnablePassthrough()&#125;<br>        | prompt<br>        | llm<br>        | StrOutputParser()<br>    )<br><br>    answer = rag_chain.invoke(question)<br><br>    <span class="hljs-keyword">return</span> answer <br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">getstreamlit_UI</span>(<span class="hljs-params">prompt, LLM</span>):<br>    <br>    st.title(<span class="hljs-string">&quot;RAG-Based Blog System&quot;</span>)<br>    st.subheader(<span class="hljs-string">&quot;Author: Xiyuan Yang (xiyuanyang-code)&quot;</span>)<br>    st.session_state[<span class="hljs-string">&quot;Prompt&quot;</span>] = prompt<br>    st.session_state[<span class="hljs-string">&quot;LLM&quot;</span>] = LLM<br><br>    <span class="hljs-comment"># Introduction Part</span><br>    st.write(<span class="hljs-string">&quot;## About this website&quot;</span>)<br>    st.write(<span class="hljs-string">&quot;This website is my **RAG implementation** for searching and retrieving my own blog posts, you can see my own blog posts\</span><br><span class="hljs-string">                and choose the blog url down here!&quot;</span>)<br>    st.write(<span class="hljs-string">&quot;My Blog posts: [xiyuanyang-code](https://xiyuanyang-code.github.io)&quot;</span>)<br><br>    <span class="hljs-comment"># Choose website</span><br>    st.write(<span class="hljs-string">&quot;default url: https://xiyuanyang-code.github.io/posts/Algorithm-BinaryTree/&quot;</span>)<br>    st.write(<span class="hljs-string">&quot;**Make sure your url is valid!**&quot;</span>)<br>    url = st.text_input(<span class="hljs-string">&quot;Choose your website: &quot;</span>)<br><br><br><br><br>    default_url = <span class="hljs-string">&quot;https://xiyuanyang-code.github.io/posts/Algorithm-BinaryTree/&quot;</span><br>    <span class="hljs-keyword">if</span> st.button(<span class="hljs-string">&quot;Scrape Blog Content&quot;</span>):<br>        <span class="hljs-keyword">with</span> st.spinner(<span class="hljs-string">&quot;Scraping blog content...&quot;</span>):<br>            blog_content = loader_documents(url)<br>            <span class="hljs-keyword">if</span> blog_content:<br>                st.success(<span class="hljs-string">&quot;Blog content scraped successfully!&quot;</span>)<br>                st.session_state[<span class="hljs-string">&quot;blog_content&quot;</span>] = blog_content<br>            <span class="hljs-keyword">else</span>:<br>                st.error(<span class="hljs-string">&quot;Failed to scrape blog content.&quot;</span>,icon=<span class="hljs-string">&quot;🚨&quot;</span>)<br>                st.write(<span class="hljs-string">&quot;Using the default url&quot;</span>)<br>                blog_content = loader_documents(default_url)<br><br><br>    <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;blog_content&quot;</span> <span class="hljs-keyword">in</span> st.session_state:<br>        blog_content = st.session_state[<span class="hljs-string">&quot;blog_content&quot;</span>]<br>        <span class="hljs-keyword">if</span> st.button(<span class="hljs-string">&quot;Process and Store Content&quot;</span>):<br>            <span class="hljs-keyword">with</span> st.spinner(<span class="hljs-string">&quot;Processing and storing content...&quot;</span>):<br>                splits = text_splitter(blog_content)<br>                vectorstore, retriever = embedding(splits)<br>                st.session_state[<span class="hljs-string">&quot;vectorstore&quot;</span>] = vectorstore<br>                st.session_state[<span class="hljs-string">&quot;retriever&quot;</span>] = retriever<br>                st.success(<span class="hljs-string">&quot;Content processed and stored in Chroma!&quot;</span>)<br><br><br>    <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;vectorstore&quot;</span> <span class="hljs-keyword">in</span> st.session_state:<br>        vectorstore = st.session_state[<span class="hljs-string">&quot;vectorstore&quot;</span>]<br>        retriever = st.session_state[<span class="hljs-string">&quot;retriever&quot;</span>]<br>        prompt = st.session_state[<span class="hljs-string">&quot;Prompt&quot;</span>]<br>        LLM = st.session_state[<span class="hljs-string">&quot;LLM&quot;</span>]<br><br>        query = st.text_input(<span class="hljs-string">&quot;Ask a question about the blog:&quot;</span>)<br>        <span class="hljs-keyword">if</span> query:<br>            <span class="hljs-keyword">with</span> st.spinner(<span class="hljs-string">&quot;Generating answer...&quot;</span>):<br>                answer = get_answer(retriever=retriever, prompt=prompt, llm=LLM, question=query)<br>                st.write(<span class="hljs-string">&quot;**Answer:**&quot;</span>)<br>                st.write(answer)<br>    <br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    getstreamlit_UI(prompt=prompt, LLM=LLM)<br></code></pre></td></tr></table></figure><div class="note note-primary">            <p>That is Python! You can use code of less than 150 lines top build a complex <strong>RAG</strong> system, generating a neat Web UI interface and implement all the needs you want! What about C++? Maybe a guessing number game…</p><p>But C++ is very important too. Just for en </p>          </div>]]></content>
    
    
    <categories>
      
      <category>Project</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>RAG</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RAG-Tutorial</title>
    <link href="/posts/RAG-tutorial/"/>
    <url>/posts/RAG-tutorial/</url>
    
    <content type="html"><![CDATA[<style>  html, body, .markdown-body {    font-family: Georgia, sans, serif;  }</style><h1 id="Learn-RAG-from-scratch"><a href="#Learn-RAG-from-scratch" class="headerlink" title="Learn RAG from scratch!"></a>Learn RAG from scratch!</h1><p>Lecture Notes for This Youtube Class.<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://www.youtube.com/watch?v=sVcwVQRHIc8">[1]</span></a></sup></p><h2 id="Basic-Knowledge"><a href="#Basic-Knowledge" class="headerlink" title="Basic Knowledge"></a>Basic Knowledge</h2><p>Retrieval-Augmented Generation (RAG) is a hybrid framework that combines the strengths of retrieval-based and generative models for natural language processing tasks. The basic principle of RAG involves two key components: <strong>a retriever and a generator</strong>. </p><p>The retriever is responsible for fetching relevant documents or information from a large corpus or knowledge base, typically using dense vector representations to find the most pertinent data for a given query. This ensures that the model has access to accurate, up-to-date external information beyond its training data.</p><p>The generator, usually a pre-trained language model, then uses this retrieved information to produce coherent and contextually appropriate responses. By grounding its outputs in retrieved facts, RAG reduces hallucinations and improves factual accuracy compared to purely generative models.</p><p>Basic Steps:</p><ul><li><p><strong>Load documents using <code>bs4</code> using Crawler</strong>.</p></li><li><p>Split text using function of <code>RecursiveCharacterTextSplitter()</code> from <code>langchain.text_splitter</code>.</p></li><li><p><strong>Embedding splits into vectors</strong>, using <code>Chroma</code> from <code>langchain_community.vectorstores</code> and <code>OpenAIEmbeddings</code> and return the vector store retriever.</p></li><li><p>Define RAG-chain (including <strong>prompt</strong> and <strong>LLM</strong>)</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Chain</span><br>rag_chain = (<br>    &#123;<span class="hljs-string">&quot;context&quot;</span>: retriever | format_docs, <span class="hljs-string">&quot;question&quot;</span>: RunnablePassthrough()&#125;<br>    | prompt<br>    | llm<br>    | StrOutputParser()<br>)<br></code></pre></td></tr></table></figure></li><li><p>Using the <code>invoke</code> function to get the generation text!</p></li></ul><h2 id="Query-Translation"><a href="#Query-Translation" class="headerlink" title="Query-Translation"></a>Query-Translation</h2><h3 id="Multi-Query"><a href="#Multi-Query" class="headerlink" title="Multi Query"></a>Multi Query</h3><p><strong>Intuition</strong>: For a large problem, it is likely to encounter situations where “words fail to convey meaning,” and if the answer to the problem is relatively complex, a simple RAG system may not achieve good results through direct vector comparison. Therefore, we can <strong>decompose the problem and use parallel retrieval</strong>.</p><p>How to make the splitting works? You can use <strong>Prompt Engineering</strong> and add templates:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> langchain.prompts <span class="hljs-keyword">import</span> ChatPromptTemplate<br><br><span class="hljs-comment"># Multi Query: Different Perspectives</span><br>template = <span class="hljs-string">&quot;&quot;&quot;You are an AI language model assistant. Your task is to generate five </span><br><span class="hljs-string">different versions of the given user question to retrieve relevant documents from a vector </span><br><span class="hljs-string">database. By generating multiple perspectives on the user question, your goal is to help</span><br><span class="hljs-string">the user overcome some of the limitations of the distance-based similarity search. </span><br><span class="hljs-string">Provide these alternative questions separated by newlines. Original question: &#123;question&#125;&quot;&quot;&quot;</span><br>prompt_perspectives = ChatPromptTemplate.from_template(template)<br><br><span class="hljs-keyword">from</span> langchain_core.output_parsers <span class="hljs-keyword">import</span> StrOutputParser<br><span class="hljs-keyword">from</span> langchain_openai <span class="hljs-keyword">import</span> ChatOpenAI<br><br>generate_queries = (<br>    prompt_perspectives <br>    | ChatOpenAI(temperature=<span class="hljs-number">0</span>,<br>                 api_key= openai.api_key,<br>                 base_url= BaseUrl) <br>    | StrOutputParser() <br>    | (<span class="hljs-keyword">lambda</span> x: x.split(<span class="hljs-string">&quot;\n&quot;</span>))<br>)<br></code></pre></td></tr></table></figure><p>In this code, we define the workchain of <strong><code>generate_queries</code></strong>, where we let OpenAI model to split question using prompts.</p><p>This is a demo of how AI generate:</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs txt">1. How do LLM agents utilize task decomposition in their operations?<br>2. Can you explain the concept of task decomposition as applied to LLM agents?<br>3. What role does task decomposition play in the functioning of LLM agents?<br>4. How is task decomposition integrated into the workflow of LLM agents?<br>5. In what way does task decomposition enhance the capabilities of LLM agents?<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> langchain.load <span class="hljs-keyword">import</span> dumps, loads<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_unique_union</span>(<span class="hljs-params">documents: <span class="hljs-built_in">list</span>[<span class="hljs-built_in">list</span>]</span>):<br>    <span class="hljs-string">&quot;&quot;&quot; Unique union of retrieved docs &quot;&quot;&quot;</span><br>    <span class="hljs-comment"># Flatten list of lists, and convert each Document to string</span><br>    flattened_docs = [dumps(doc) <span class="hljs-keyword">for</span> sublist <span class="hljs-keyword">in</span> documents <span class="hljs-keyword">for</span> doc <span class="hljs-keyword">in</span> sublist]<br>    <span class="hljs-comment"># Get unique documents</span><br>    unique_docs = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">set</span>(flattened_docs))<br>    <span class="hljs-comment"># Return</span><br>    <span class="hljs-keyword">return</span> [loads(doc) <span class="hljs-keyword">for</span> doc <span class="hljs-keyword">in</span> unique_docs]<br><br><span class="hljs-comment"># Retrieve</span><br>question = <span class="hljs-string">&quot;What is task decomposition for LLM agents?&quot;</span><br>retrieval_chain = generate_queries | retriever.<span class="hljs-built_in">map</span>() | get_unique_union<br>docs = retrieval_chain.invoke(&#123;<span class="hljs-string">&quot;question&quot;</span>:question&#125;)<br><span class="hljs-built_in">len</span>(docs)<br><br><span class="hljs-built_in">print</span>(docs)<br></code></pre></td></tr></table></figure><p>The core chain of retrieval is <strong><code>retrieval_chain = generate_queries | retriever.map() | get_unique_union</code></strong>, where the input questions is first splitted into subquestions using <code>genegrate_queries</code> and through a <strong>mapping</strong> from the queries to the retriever (for every subquestion, search for the ans_vectors). Finally, using <code>get_unique_union</code> to get the unique answer.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> operator <span class="hljs-keyword">import</span> itemgetter<br><span class="hljs-keyword">from</span> langchain_openai <span class="hljs-keyword">import</span> ChatOpenAI<br><span class="hljs-keyword">from</span> langchain_core.runnables <span class="hljs-keyword">import</span> RunnablePassthrough<br><br><span class="hljs-comment"># RAG</span><br>template = <span class="hljs-string">&quot;&quot;&quot;Answer the following question based on this context:</span><br><span class="hljs-string"></span><br><span class="hljs-string">&#123;context&#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">Question: &#123;question&#125;</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br>prompt = ChatPromptTemplate.from_template(template)<br><br>llm = ChatOpenAI(temperature=<span class="hljs-number">0</span>,<br>                 api_key= openai.api_key,<br>                 base_url= BaseUrl)<br><br>final_rag_chain = (<br>    &#123;<span class="hljs-string">&quot;context&quot;</span>: retrieval_chain, <span class="hljs-string">&quot;question&quot;</span>: itemgetter(<span class="hljs-string">&quot;question&quot;</span>)&#125; <br>    | prompt<br>    | llm<br>    | StrOutputParser()<br>)<br><br>final_rag_chain.invoke(&#123;<span class="hljs-string">&quot;question&quot;</span>:question&#125;)<br></code></pre></td></tr></table></figure><p>Finally, it is the <strong>RAG</strong> time! The <code>final_rag-chain</code> looks as follows:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">final_rag_chain = (<br>    &#123;<span class="hljs-string">&quot;context&quot;</span>: retrieval_chain, <span class="hljs-string">&quot;question&quot;</span>: itemgetter(<span class="hljs-string">&quot;question&quot;</span>)&#125; <br>    | prompt<br>    | llm<br>    | StrOutputParser()<br>)<br></code></pre></td></tr></table></figure><p>We first use <code>retrieval_chain</code> defined above to get the related texts in the documents, add use the <code>itemgetter</code> to get the original problem. Then we feed these into a LLM with the predefined prompt. Finally, we use <code>StrOutputParser()</code> to get the final answer of LLM.</p><h3 id="RAG-Fusions"><a href="#RAG-Fusions" class="headerlink" title="RAG Fusions"></a>RAG Fusions</h3><p><strong>Intuition</strong>: In Multi Query, RAG performs a crude deduplication and merging operation on the documents obtained for each subproblem, which is unreasonable because the weights corresponding to each problem are different, and the weights (similarities) of the answers obtained for each subproblem are also different. Therefore, the core idea of RAG fusion is to <strong>use a multi-retrieval fusion method based on Reciprocal Rank Fusion (RRF)</strong>, calculating the corresponding weights for each document before outputting them to obtain more reasonable results.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> langchain.load <span class="hljs-keyword">import</span> dumps, loads<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">reciprocal_rank_fusion</span>(<span class="hljs-params">results: <span class="hljs-built_in">list</span>[<span class="hljs-built_in">list</span>], k=<span class="hljs-number">60</span></span>):<br>    <span class="hljs-string">&quot;&quot;&quot; Reciprocal_rank_fusion that takes multiple lists of ranked documents </span><br><span class="hljs-string">        and an optional parameter k used in the RRF formula &quot;&quot;&quot;</span><br>    <br>    <span class="hljs-comment"># Initialize a dictionary to hold fused scores for each unique document</span><br>    fused_scores = &#123;&#125;<br><br>    <span class="hljs-comment"># Iterate through each list of ranked documents</span><br>    <span class="hljs-keyword">for</span> docs <span class="hljs-keyword">in</span> results:<br>        <span class="hljs-comment"># Iterate through each document in the list, with its rank (position in the list)</span><br>        <span class="hljs-keyword">for</span> rank, doc <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(docs):<br>            <span class="hljs-comment"># Convert the document to a string format to use as a key (assumes documents can be serialized to JSON)</span><br>            doc_str = dumps(doc)<br>            <span class="hljs-comment"># If the document is not yet in the fused_scores dictionary, add it with an initial score of 0</span><br>            <span class="hljs-keyword">if</span> doc_str <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> fused_scores:<br>                fused_scores[doc_str] = <span class="hljs-number">0</span><br>            <span class="hljs-comment"># Retrieve the current score of the document, if any</span><br>            previous_score = fused_scores[doc_str]<br>            <span class="hljs-comment"># Update the score of the document using the RRF formula: 1 / (rank + k)</span><br>            fused_scores[doc_str] += <span class="hljs-number">1</span> / (rank + k)<br><br>    <span class="hljs-comment"># Sort the documents based on their fused scores in descending order to get the final reranked results</span><br>    reranked_results = [<br>        (loads(doc), score)<br>        <span class="hljs-keyword">for</span> doc, score <span class="hljs-keyword">in</span> <span class="hljs-built_in">sorted</span>(fused_scores.items(), key=<span class="hljs-keyword">lambda</span> x: x[<span class="hljs-number">1</span>], reverse=<span class="hljs-literal">True</span>)<br>    ]<br><br>    <span class="hljs-comment"># Return the reranked results as a list of tuples, each containing the document and its fused score</span><br>    <span class="hljs-keyword">return</span> reranked_results<br><br>retrieval_chain_rag_fusion = generate_queries | retriever.<span class="hljs-built_in">map</span>() | reciprocal_rank_fusion<br>docs = retrieval_chain_rag_fusion.invoke(&#123;<span class="hljs-string">&quot;question&quot;</span>: question&#125;)<br><span class="hljs-built_in">len</span>(docs)<br></code></pre></td></tr></table></figure><h3 id="Decomposition"><a href="#Decomposition" class="headerlink" title="Decomposition"></a>Decomposition</h3><p>Decomposition essentially uses a simpler concatenation method to hierarchically link problems together, similar to the step-by-step reasoning in Chain of Thought (CoT). It guides the model to decompose problems through prompts and, based on the solutions to previous problems, adds new retrievals on top of the previous problem’s retrievals.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> langchain.prompts <span class="hljs-keyword">import</span> ChatPromptTemplate<br><br><span class="hljs-comment"># Decomposition</span><br>template = <span class="hljs-string">&quot;&quot;&quot;You are a helpful assistant that generates multiple sub-questions related to an input question. \n</span><br><span class="hljs-string">The goal is to break down the input into a set of sub-problems / sub-questions that can be answers in isolation. \n</span><br><span class="hljs-string">Generate multiple search queries related to: &#123;question&#125; \n</span><br><span class="hljs-string">Output (3 queries):&quot;&quot;&quot;</span><br>prompt_decomposition = ChatPromptTemplate.from_template(template)<br></code></pre></td></tr></table></figure><p>Answer recursively</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Prompt</span><br>template = <span class="hljs-string">&quot;&quot;&quot;Here is the question you need to answer:</span><br><span class="hljs-string"></span><br><span class="hljs-string">\n --- \n &#123;question&#125; \n --- \n</span><br><span class="hljs-string"></span><br><span class="hljs-string">Here is any available background question + answer pairs:</span><br><span class="hljs-string"></span><br><span class="hljs-string">\n --- \n &#123;q_a_pairs&#125; \n --- \n</span><br><span class="hljs-string"></span><br><span class="hljs-string">Here is additional context relevant to the question: </span><br><span class="hljs-string"></span><br><span class="hljs-string">\n --- \n &#123;context&#125; \n --- \n</span><br><span class="hljs-string"></span><br><span class="hljs-string">Use the above context and any background question + answer pairs to answer the question: \n &#123;question&#125;</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br>decomposition_prompt = ChatPromptTemplate.from_template(template)<br></code></pre></td></tr></table></figure><blockquote><p><strong>Parallel structures are suitable for parallel problems, while hierarchical structures are appropriate for reasoning problems</strong>. It is necessary to choose the appropriate RAG architecture based on different inquiries.</p></blockquote><h3 id="Step-Back"><a href="#Step-Back" class="headerlink" title="Step Back"></a>Step Back</h3><p>Step Back Prompting<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://arxiv.org/pdf/2310.06117">[2]</span></a></sup> is a fancy way proposed by Google DeepMind, which uses Prompt Engineering to make the Queries more abstract in order to decrease noise.</p><p><img src="https://s1.imagehub.cc/images/2025/04/04/b2538ca755acad7e0bae5e08cbd91fb0.png" alt="Step Back Prompting"> </p><p>It is quite similar to <strong>Chain of Thought</strong>, but it will focus more on the <strong>abstraction</strong> process, which will distill key questions from specific contexts to achieve better results in the RAG process.</p><p>Let’s just see the prompt!</p><p>Moreover, it uses <strong>few-shot learning</strong> for learning template, which performs better than <strong>zero-shot learning</strong>.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Few Shot Examples</span><br><span class="hljs-keyword">from</span> langchain_core.prompts <span class="hljs-keyword">import</span> ChatPromptTemplate, FewShotChatMessagePromptTemplate<br>examples = [<br>    &#123;<br>        <span class="hljs-string">&quot;input&quot;</span>: <span class="hljs-string">&quot;Could the members of The Police perform lawful arrests?&quot;</span>,<br>        <span class="hljs-string">&quot;output&quot;</span>: <span class="hljs-string">&quot;what can the members of The Police do?&quot;</span>,<br>    &#125;,<br>    &#123;<br>        <span class="hljs-string">&quot;input&quot;</span>: <span class="hljs-string">&quot;Jan Sindel’s was born in what country?&quot;</span>,<br>        <span class="hljs-string">&quot;output&quot;</span>: <span class="hljs-string">&quot;what is Jan Sindel’s personal history?&quot;</span>,<br>    &#125;,<br>]<br><span class="hljs-comment"># We now transform these to example messages</span><br>example_prompt = ChatPromptTemplate.from_messages(<br>    [<br>        (<span class="hljs-string">&quot;human&quot;</span>, <span class="hljs-string">&quot;&#123;input&#125;&quot;</span>),<br>        (<span class="hljs-string">&quot;ai&quot;</span>, <span class="hljs-string">&quot;&#123;output&#125;&quot;</span>),<br>    ]<br>)<br>few_shot_prompt = FewShotChatMessagePromptTemplate(<br>    example_prompt=example_prompt,<br>    examples=examples,<br>)<br>prompt = ChatPromptTemplate.from_messages(<br>    [<br>        (<br>            <span class="hljs-string">&quot;system&quot;</span>,<br>            <span class="hljs-string">&quot;&quot;&quot;You are an expert at world knowledge. Your task is to step back and paraphrase a question to a more generic step-back question, which is easier to answer. Here are a few examples:&quot;&quot;&quot;</span>,<br>        ),<br>        <span class="hljs-comment"># Few shot examples</span><br>        few_shot_prompt,<br>        <span class="hljs-comment"># New question</span><br>        (<span class="hljs-string">&quot;user&quot;</span>, <span class="hljs-string">&quot;&#123;question&#125;&quot;</span>),<br>    ]<br>)<br></code></pre></td></tr></table></figure><p>And for the response prompt:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Response prompt </span><br>response_prompt_template = <span class="hljs-string">&quot;&quot;&quot;You are an expert of world knowledge. I am going to ask you a question. Your response should be comprehensive and not contradicted with the following context if they are relevant. Otherwise, ignore them if they are not relevant.</span><br><span class="hljs-string"></span><br><span class="hljs-string"># &#123;normal_context&#125;</span><br><span class="hljs-string"># &#123;step_back_context&#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string"># Original Question: &#123;question&#125;</span><br><span class="hljs-string"># Answer:&quot;&quot;&quot;</span><br>response_prompt = ChatPromptTemplate.from_template(response_prompt_template)<br><br>chain = (<br>    &#123;<br>        <span class="hljs-comment"># Retrieve context using the normal question</span><br>        <span class="hljs-string">&quot;normal_context&quot;</span>: RunnableLambda(<span class="hljs-keyword">lambda</span> x: x[<span class="hljs-string">&quot;question&quot;</span>]) | retriever,<br>        <span class="hljs-comment"># Retrieve context using the step-back question</span><br>        <span class="hljs-string">&quot;step_back_context&quot;</span>: generate_queries_step_back | retriever,<br>        <span class="hljs-comment"># Pass on the question</span><br>        <span class="hljs-string">&quot;question&quot;</span>: <span class="hljs-keyword">lambda</span> x: x[<span class="hljs-string">&quot;question&quot;</span>],<br>    &#125;<br>    | response_prompt<br>    | ChatOpenAI(temperature=<span class="hljs-number">0</span>)<br>    | StrOutputParser()<br>)<br><br>chain.invoke(&#123;<span class="hljs-string">&quot;question&quot;</span>: question&#125;)<br></code></pre></td></tr></table></figure><p>It feed AI with both the answers <strong>with normal questions and with step_back contents</strong>.</p><h3 id="HyDE"><a href="#HyDE" class="headerlink" title="HyDE"></a>HyDE</h3><p>In practical situations, questions and texts exist in two completely different spaces. Directly embedding them can lead to errors and noise interference. Therefore, we need to <strong>ensure consistency between the two spaces</strong>.</p><div class="note note-primary">            <p>The difficulty of zero-shot dense retrieval lies precisely: it requires learning of two embedding functions (for query and document respectively) <strong>into the same embedding space</strong> where inner product captures relevance. Without relevance judgments&#x2F;scores to fit, learning becomes intractable.</p>          </div><p>Let’s just see the abstract part for the passage:</p><div class="note note-primary">            <p>Given a query, HyDE first <strong>zero-shot instructs an instruction-following language model</strong> (e.g. <code>InstructGPT</code>) to generate a hypothetical document. The document captures relevance patterns but is unreal and may contain false details. Then, <strong>an unsupervised contrastively learned encoder</strong><del>(e.g. <code>Contriever</code>) encodes the document into an embedding vector. This vector identifies a neighborhood in the corpus embedding space, <strong>where similar real documents are retrieved based on vector similarity</strong>. This second step ground the generated document to the actual corpus, with the encoder’s dense bottleneck filtering out the incorrect details. Our experiments show that HyDE significantly outperforms the state-of-the-art unsupervised dense retriever Contriever and shows strong performance comparable to fine-tuned retrievers, across various tasks (e.g. web search, QA, fact verification) and languages</del>(e.g. sw, ko, ja).</p>          </div><p>That is what <strong>HyDE</strong><sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://arxiv.org/abs/2212.10496">[3]</span></a></sup> for! The core idea of HyDE is to generate a hypothetical document that provides richer contextual information for the retrieval process. In HyDE, we need to generate a new hypothetical passage to simulate all possible answers.</p><p>Firstly, we need to generate a new hypothetical passage:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> langchain.prompts <span class="hljs-keyword">import</span> ChatPromptTemplate<br><br><span class="hljs-comment"># HyDE document genration</span><br>template = <span class="hljs-string">&quot;&quot;&quot;Please write a scientific paper passage to answer the question</span><br><span class="hljs-string">Question: &#123;question&#125;</span><br><span class="hljs-string">Passage:&quot;&quot;&quot;</span><br>prompt_hyde = ChatPromptTemplate.from_template(template)<br><br><span class="hljs-keyword">from</span> langchain_core.output_parsers <span class="hljs-keyword">import</span> StrOutputParser<br><span class="hljs-keyword">from</span> langchain_openai <span class="hljs-keyword">import</span> ChatOpenAI<br><br>generate_docs_for_retrieval = (<br>    prompt_hyde | ChatOpenAI(temperature=<span class="hljs-number">0</span>) | StrOutputParser() <br>)<br><br><span class="hljs-comment"># Run</span><br>question = <span class="hljs-string">&quot;What is task decomposition for LLM agents?&quot;</span><br>generate_docs_for_retrieval.invoke(&#123;<span class="hljs-string">&quot;question&quot;</span>:question&#125;)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Retrieve</span><br>retrieval_chain = generate_docs_for_retrieval | retriever <br>retireved_docs = retrieval_chain.invoke(&#123;<span class="hljs-string">&quot;question&quot;</span>:question&#125;)<br>retireved_docs<br></code></pre></td></tr></table></figure><p><code>retrieval_chain = generate_docs_for_retrieval | retriever</code> is the most fundamental part! After generating a hypothetical passage for retrieval, we then feed the answer into the retriever.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># RAG</span><br>template = <span class="hljs-string">&quot;&quot;&quot;Answer the following question based on this context:</span><br><span class="hljs-string"></span><br><span class="hljs-string">&#123;context&#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">Question: &#123;question&#125;</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br>prompt = ChatPromptTemplate.from_template(template)<br><br>final_rag_chain = (<br>    prompt<br>    | llm<br>    | StrOutputParser()<br>)<br><br>final_rag_chain.invoke(&#123;<span class="hljs-string">&quot;context&quot;</span>:retireved_docs,<span class="hljs-string">&quot;question&quot;</span>:question&#125;)<br></code></pre></td></tr></table></figure><h2 id="Routing"><a href="#Routing" class="headerlink" title="Routing"></a>Routing</h2><p><strong>Basic Principle</strong>: Routing the decomposed question into the right vector space.</p><p>It includes:</p><ul><li>Logical Routing</li><li>Semantic Routing</li></ul><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://www.youtube.com/watch?v=sVcwVQRHIc8">https://www.youtube.com/watch?v=sVcwVQRHIc8</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://arxiv.org/pdf/2310.06117">https://arxiv.org/pdf/2310.06117</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://arxiv.org/abs/2212.10496">https://arxiv.org/abs/2212.10496</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Artificial Intelligence</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Artificial Intelligence</tag>
      
      <tag>Deep Learning</tag>
      
      <tag>LLMs</tag>
      
      <tag>RAG</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Algorithm-BFS-DFS</title>
    <link href="/posts/Algorithm-BFS-DFS/"/>
    <url>/posts/Algorithm-BFS-DFS/</url>
    
    <content type="html"><![CDATA[<h1 id="BFS-DFS"><a href="#BFS-DFS" class="headerlink" title="BFS &amp; DFS"></a>BFS &amp; DFS</h1><h2 id="Terminology"><a href="#Terminology" class="headerlink" title="Terminology"></a>Terminology</h2><h3 id="Graph"><a href="#Graph" class="headerlink" title="Graph"></a>Graph</h3><p><img src="https://s1.imagehub.cc/images/2025/04/09/41374e84db4a0b25fe40323baf8b9a3f.png" alt="Graph"></p><ul><li><p>We first give the definitions of <strong>graphs</strong>! $G(V,E)$ is a set of vertices $V$ and a set of <strong>Binary Relations</strong>: $E \subseteq V \times V$.</p></li><li><p>We don’t consider graphs <strong>outside the simple graph</strong>, like edges of $(u,u)$.</p></li><li><p>We define $\left | E \right |$ as the numbers of edges in the set $E$. Obviously, $\left |  E\right | \le C_{\left | V \right |}^{2} &#x3D; O(\left | V\right |^2 )$ for undirected, and $\left |  E\right | \le 2\times C_{\left | V \right |}^{2} &#x3D; O(\left | V\right |^2 )$ for directed.</p></li></ul><h3 id="Neighbor-Sets-Adjacencies"><a href="#Neighbor-Sets-Adjacencies" class="headerlink" title="Neighbor Sets&#x2F;Adjacencies"></a>Neighbor Sets&#x2F;Adjacencies</h3><ul><li>The outgoing neighbor set of u ∈ V is $Adj^+(u) &#x3D; {v ∈ V | (u, v) ∈ E}$</li><li>The incoming neighbor set of u ∈ V is $Adj^−(u) &#x3D; {v ∈ V | (v, u) ∈ E}$</li><li>The out-degree of a vertex u ∈ V is $deg^+(u) &#x3D; |Adj^+(u)|$</li><li>The in-degree of a vertex u ∈ V is $deg^−(u) &#x3D; |Adj^−(u)|$</li><li>For undirected graphs, $Adj^−(u) &#x3D; Adj^+(u)$ and $deg^−(u) &#x3D; deg^+(u)$</li><li>Dropping superscript defaults to outgoing, i.e., $Adj(u) &#x3D; Adj^+(u)$ and $deg(u) &#x3D; deg^+(u)$</li></ul><h3 id="Adjacency-list"><a href="#Adjacency-list" class="headerlink" title="Adjacency list"></a>Adjacency list</h3><p> A <strong>Set</strong> data structure to map $u$ to $Adj(u)$. Like every node in the tree needs to store the parent and child node, every elements need to store <strong>all its neighbors</strong>!</p><ul><li>Common to use <strong>direct access array or hash table</strong> for $Adj$, since want lookup fast by vertex.</li><li>Common to use <strong>array or linked list</strong> for each $Adj(u)$ since usually only iteration is needed.</li></ul><h3 id="Paths"><a href="#Paths" class="headerlink" title="Paths"></a>Paths</h3><ul><li>A path is a sequence of vertices $p &#x3D; (v_1, v_2, . . . , v_k)$ where $(v_i, v_{i+1}) ∈ E, \ \forall 1 ≤ i &lt; k$.</li><li>A path is simple if it does not <strong>repeat vertices</strong>.</li><li>The length ($p$) of a path p is the number of edges in the path</li><li>The distance $δ(u, v)$ from $u ∈ V$ to $v ∈ V$ is the <strong>minimum length of any path from $u$ to $v$</strong>, i.e., the length of a shortest path from $u$ to $v$. (by convention, $δ(u, v) &#x3D; ∞ $ if $u$ is not connected to $v$)</li></ul><h3 id="Model-Graph-Problems"><a href="#Model-Graph-Problems" class="headerlink" title="Model Graph Problems"></a>Model Graph Problems</h3><p><img src="https://s1.imagehub.cc/images/2025/04/09/9ae6883f7fe45a85bfba103b58b92af6.png" alt="Model Graph Problems"></p><p>We can construct a <strong>shortest path tree</strong> based on the graph with $O(\left |V \right |)$ size. To explain it more clearly, given $a \in V$, then the <strong>shortest path tree</strong> of $a$ is a tree whose root node is $a$ and contains all elements that are reachable to $a$ in the graph. Moreover, the way from the root node $a$ to the node $b$ is <strong>just the shortest path</strong> from $a$ to $b$ in the graph.</p><h2 id="Breadth-First-Search"><a href="#Breadth-First-Search" class="headerlink" title="Breadth First Search"></a>Breadth First Search</h2><p>How to return a shortest path from <strong>source vertex</strong> $s$ for every vertex in graph? We can define $P(x)$ as the <strong>second to last vertex</strong> on a shortest path from $s$, or you can just imagine it as the parent of $x$ in the constructed shortest path tree of source vertex $s$.</p><ul><li>Define $P(s) &#x3D;&#x3D; null$.</li><li>Set of parents comprise <strong>a shortest paths tree</strong> with $O(|V|)$ size!<ul><li>Math principles: Assume vertex $u$ appears in the shortest path from the source vertex $s$ to the vertex $x$, which is more remote. <strong>Then the shortest of vertex $u$</strong> is just a subset of this path!</li></ul></li><li>In the BFS algorithm, we need to compute $δ(s, v)$ and $P(v)$ for all $v \in V$.</li></ul><p> Compute level sets $L_i &#x3D; {v | v ∈ V \ \text{and} \ d(s, v) &#x3D; i}$ (i.e., all vertices at distance $i$)</p><p><img src="https://s1.imagehub.cc/images/2025/04/09/9b7a93a15a48fd8854a508068bf94504.png" alt="BFS"></p><p>The key to BFS is to categorize <strong>vertices by levels</strong>. For vertices at the same level, continuously traverse until all are visited, then proceed to the next level. Obviously, we know the shortest distance from $s$ to $s$ is 0. Then we can <strong>grow</strong> the tree based on it and find the shortest path for all vertex in the graph.</p><blockquote><p>In real world simulations, we can use <strong>queue</strong> to store different levels of vertices, which means <strong>no vertices in $L_i$ is touched until all vertices in $L_{i-1}$ is traversed</strong>.</p></blockquote><p><strong>Time complexity analysis</strong>: $O(|V| + |E|)$. (Linear Time!)</p><h2 id="Depth-First-Search"><a href="#Depth-First-Search" class="headerlink" title="Depth First Search"></a>Depth First Search</h2><h3 id="Single-source-reachability"><a href="#Single-source-reachability" class="headerlink" title="Single source reachability"></a>Single source reachability</h3><ul><li>Graph Path Problems</li><li>Single Pair Reachability(G,s,t)</li><li><strong>Single Source Reachability(G,s)</strong></li><li>Single Pair Shortest Path(G,s,t)</li><li>Single Source Shortest Paths(G,s) (SSSP)</li></ul><p>If we don’t need to solve the <strong>SSSP</strong> problem, we can use another algorithm! <strong>Intuition: Visit outgoing adjacencies recursively, but never revisit a vertex</strong>.</p><blockquote><p>Of course, we can use the <strong>shortest path tree to solve a harder problem (SSSP)</strong>, but it takes linear time! We can actually take less time by using the BFS algorithms.</p></blockquote><h3 id="Algorithms"><a href="#Algorithms" class="headerlink" title="Algorithms"></a>Algorithms</h3><p>For DFS algorithms, we use <strong>recursion</strong> to reach to the deepest depth and then traceback to the previous height.</p><p>Before finishing the algorithms, we define $P(u)&#x3D;v$, there exists a path from $u$ to $v$.</p><p><img src="https://s1.imagehub.cc/images/2025/04/12/05369681ede643f4fc83edb46d32e7f7.png" alt="DFS algorithms"></p><p>There maybe some problems! For example, if there exists $(u_1, v)$ and $(u_2, v)$ at the same time, definitely we can say $P(v) &#x3D; u_1$ and $P(v) &#x3D; u_2$. But what $P(v)$ actually is the last vertex that is assigned to $P(v)$. Then can this algorithm correctly finds all the reachable vertexes?</p><p>Let’s do the proof! Claim: <strong>DFS visits $v$ and correctly sets $P(v)$ for every vertex $v$ reachable from $s$</strong>.</p><p>We use <strong>induction</strong>, induct on $k$, where $k$ means vertices that can be reachable from source $s$ with the $k$ steps.</p><ul><li>$k &#x3D; 0$ : is just the source vertex $s$!</li><li>Inductive step: Consider vertex v with $δ(s, v) &#x3D; k’ + 1$. (The minimum length of the two vertexes)</li><li>Consider vertex $u$, <strong>the second to last vertex</strong> on some shortest path from $s$ to $v$.</li><li>By induction, since $δ(s, u) &#x3D; k’$, DFS visits $u$ and sets $P (u)$ correctly.</li><li>While visiting u, DFS considers $v ∈ Adj(u)$.</li><li>Either $v$ is in $P$ , so has already been visited, or $v$ will be visited while visiting $u$.</li><li>In either case, v will be visited by DFS and will be added correctly to $P$.</li></ul><p>Depth First Search: $O(|E|)$. (The number of edges)</p><h3 id="Connectivity-of-undirected-graphs-Full-DFS"><a href="#Connectivity-of-undirected-graphs-Full-DFS" class="headerlink" title="Connectivity of undirected graphs: Full DFS"></a>Connectivity of undirected graphs: Full DFS</h3><p>Obviously, use DFS in one single vertex $s$ cannot reach all vertex in the node. Thus, if we want to reach all vertex in the graph (Graph Traverse), we can actually use <strong>Full-DFS</strong> algorithms.</p><p>Iterate for all vertexes in the loop:</p><ul><li>Choose an <strong>arbitrary unvisited vertex $s$</strong>, use <strong>BFS&#x2F;DFS</strong> to explore all vertices reachable from $s$.</li><li>If the vertex $s$ is reached, then we don’t need to use DFS($s$) (let s to be the source node) again!</li><li>Time complexity: $O(|V|+|E|)$.</li></ul><p>Full DFS can be used to detect how many <strong>connected components (for undirected graphs) or strongly connected components (for directed graphs)</strong> exist in a graph. Each time a new DFS is initiated, it indicates the discovery of a new connected component.</p><p><img src="https://s1.imagehub.cc/images/2025/04/12/77846aff8face45b5acbf56324eb63d5.png" alt="Graph Connectivity"></p><h3 id="Topological-Sort"><a href="#Topological-Sort" class="headerlink" title="Topological Sort"></a>Topological Sort</h3><h4 id="Several-Definitions"><a href="#Several-Definitions" class="headerlink" title="Several Definitions"></a>Several Definitions</h4><ul><li><strong>DAGs (Directed Acyclic Graph)</strong>: a directed graph that contains cycles.<ul><li>Of course, a Binary Tree is a DAG😂.</li></ul></li><li>A <strong>Topological Order</strong> of a graph $G &#x3D; (V, E)$ is an ordering $f$ on the vertices such that: every edge $(u, v) ∈ E$ satisfies $f(u) &lt; f(v)$.</li><li>A topological order only appears in the DAGs, or it will cause problems! (<strong>iff</strong>)<ul><li>Assume $(u,v)\in E$ and $(v,u) \in E$, which means $f(u) &lt; f(v)$ and $f(v) &lt; f(u)$. Contradiction!</li></ul></li><li><strong>A Finishing Order</strong> is the order in which <strong>a Full-DFS finishes visiting each vertex in G</strong>.</li></ul><h4 id="Claim"><a href="#Claim" class="headerlink" title="Claim"></a>Claim</h4><p>The reverse of finishing order is just the <strong>topological order</strong> of the graph.</p><p><img src="https://s1.imagehub.cc/images/2025/04/12/c95d929f8fd570a477d4573bd2303797.png" alt="Proof"></p><p> <strong>Basic principle</strong>: We need to prove the ending of function $visit(u)$ is after the ending of the function $visit(v)$. In Full DFS, every vertex will only be visited once, and the existence of $(u,v)$ enables that:</p><p>In the first exploration of $u$, for the recursive function, the ending of function $visit(v)$ is before $visit(u)$. ($u$ is in the lower stack frame.) (Unless that $v$ has been explored previously, which is obviously right).</p><h3 id="Cycle-detection"><a href="#Cycle-detection" class="headerlink" title="Cycle detection"></a>Cycle detection</h3><p>How can we find a graph is <strong>Acyclic</strong>?</p><p>Consider the full-DFS algorithms, if <strong>reverse finishing order for Full-DFS is not a topological order, then G must contain a cycle</strong>. Check if G is <strong>acyclic: for each edge (u, v), check if v is before u in reverse finishing order</strong>.</p><p><strong>Claim</strong>: If $G$ contains a cycle, Full-DFS will <strong>traverse an edge</strong> from $v$ to an ancestor of $v$.</p><p>To return such a cycle, maintain the set of ancestors along the path back to s in Full-DFS. (Or just the stackframe for the recufunction!)</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://www.youtube.com/watch?v=WbzNRTTrX0g&list=PLhQjrBD2T381PopUTYtMSstgk-hsTGkVm&index=2">Harvard 50.3 Introduction to artificial intelligence</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tutorial</tag>
      
      <tag>Tree</tag>
      
      <tag>Finished</tag>
      
      <tag>BFS/DFS</tag>
      
      <tag>Data Structure</tag>
      
      <tag>Algorithm</tag>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AI-Paper-2024</title>
    <link href="/posts/AI-Paper-2024/"/>
    <url>/posts/AI-Paper-2024/</url>
    
    <content type="html"><![CDATA[<h1 id="Most-Valuable-AI-Research-Papers-in-2024"><a href="#Most-Valuable-AI-Research-Papers-in-2024" class="headerlink" title="Most Valuable AI Research Papers in 2024"></a>Most Valuable AI Research Papers in 2024</h1><h2 id="Mixture-of-Experts-Approach-MoE"><a href="#Mixture-of-Experts-Approach-MoE" class="headerlink" title="Mixture of Experts Approach (MoE)"></a>Mixture of Experts Approach (MoE)</h2><p>You can find the original paper<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://arxiv.org/abs/2401.04088">[3]</span></a></sup> here.</p><h2 id="DoRA-Weight-decomposed-LoRA"><a href="#DoRA-Weight-decomposed-LoRA" class="headerlink" title="DoRA: Weight-decomposed LoRA"></a>DoRA: Weight-decomposed LoRA</h2><p>You can find the original paper<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><span class="hint--top hint--rounded" aria-label="http://arxiv.org/abs/2402.09353">[4]</span></a></sup> here.</p><h2 id="Simple-and-Scalable-Strategies-to-Continually-Pre-train-Large-Language-Models"><a href="#Simple-and-Scalable-Strategies-to-Continually-Pre-train-Large-Language-Models" class="headerlink" title="Simple and Scalable Strategies to Continually Pre-train Large Language Models"></a>Simple and Scalable Strategies to Continually Pre-train Large Language Models</h2><p>You can find the original paper<sup id="fnref:5" class="footnote-ref"><a href="#fn:5" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://arxiv.org/abs/2403.08763">[5]</span></a></sup> here.</p><h2 id="Is-DPO-Superior-to-PPO-for-LLM-Alignment-A-Comprehensive-Study"><a href="#Is-DPO-Superior-to-PPO-for-LLM-Alignment-A-Comprehensive-Study" class="headerlink" title="Is DPO Superior to PPO for LLM Alignment? A Comprehensive Study"></a>Is DPO Superior to PPO for LLM Alignment? A Comprehensive Study</h2><p>You can find the original paper<sup id="fnref:6" class="footnote-ref"><a href="#fn:6" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://arxiv.org/abs/2404.10719">[6]</span></a></sup> here.</p><h2 id="LoRA-Learns-Less-and-Forgets-Less"><a href="#LoRA-Learns-Less-and-Forgets-Less" class="headerlink" title="LoRA Learns Less and Forgets Less"></a>LoRA Learns Less and Forgets Less</h2><p>You can find the original paper<sup id="fnref:7" class="footnote-ref"><a href="#fn:7" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://arxiv.org/abs/2405.09673">[7]</span></a></sup> here.</p><h2 id="The-FineWeb-Datasets-Decanting-the-Web-for-the-Finest-Text-Data-at-Scale"><a href="#The-FineWeb-Datasets-Decanting-the-Web-for-the-Finest-Text-Data-at-Scale" class="headerlink" title="The FineWeb Datasets: Decanting the Web for the Finest Text Data at Scale"></a>The FineWeb Datasets: Decanting the Web for the Finest Text Data at Scale</h2><p>You can find the original paper<sup id="fnref:8" class="footnote-ref"><a href="#fn:8" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://arxiv.org/abs/2406.17557">[8]</span></a></sup> here.</p><h2 id="The-Llama-3-Herd-of-Models"><a href="#The-Llama-3-Herd-of-Models" class="headerlink" title="The Llama 3 Herd of Models"></a>The Llama 3 Herd of Models</h2><p>You can find the original paper<sup id="fnref:9" class="footnote-ref"><a href="#fn:9" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://arxiv.org/abs/2407.21783">[9]</span></a></sup> here.</p><h2 id="Scaling-LLM-Test-Time-Compute-Optimally-can-be-More-Effective-than-Scaling-Model-Parameters"><a href="#Scaling-LLM-Test-Time-Compute-Optimally-can-be-More-Effective-than-Scaling-Model-Parameters" class="headerlink" title="Scaling LLM Test-Time Compute Optimally can be More Effective than Scaling Model Parameters"></a>Scaling LLM Test-Time Compute Optimally can be More Effective than Scaling Model Parameters</h2><p>You can find the original paper<sup id="fnref:10" class="footnote-ref"><a href="#fn:10" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://arxiv.org/abs/2408.03314">[10]</span></a></sup> here.</p><h2 id="NVLM-Open-Frontier-Class-Multimodal-LLMs"><a href="#NVLM-Open-Frontier-Class-Multimodal-LLMs" class="headerlink" title="NVLM: Open Frontier-Class Multimodal LLMs"></a>NVLM: Open Frontier-Class Multimodal LLMs</h2><p>You can find the original paper<sup id="fnref:11" class="footnote-ref"><a href="#fn:11" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://arxiv.org/abs/2409.11402">[11]</span></a></sup> here.</p><h2 id="O1-Replication-Journey-A-Strategic-Progress-Report-–-Part-1"><a href="#O1-Replication-Journey-A-Strategic-Progress-Report-–-Part-1" class="headerlink" title="O1 Replication Journey: A Strategic Progress Report – Part 1"></a>O1 Replication Journey: A Strategic Progress Report – Part 1</h2><p>You can find the original paper<sup id="fnref:12" class="footnote-ref"><a href="#fn:12" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://arxiv.org/abs/2410.18982">[12]</span></a></sup> here.</p><h2 id="Scaling-Laws-for-Precision"><a href="#Scaling-Laws-for-Precision" class="headerlink" title="Scaling Laws for Precision"></a>Scaling Laws for Precision</h2><p>You can find the original paper<sup id="fnref:13" class="footnote-ref"><a href="#fn:13" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://arxiv.org/abs/2411.04330">[13]</span></a></sup> here.</p><h2 id="DeepSeek-V3-Technical-Report"><a href="#DeepSeek-V3-Technical-Report" class="headerlink" title="DeepSeek-V3 Technical Report"></a>DeepSeek-V3 Technical Report</h2><p>You can find the original paper<sup id="fnref:14" class="footnote-ref"><a href="#fn:14" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://arxiv.org/abs/2412.19437">[14]</span></a></sup> here.</p><h2 id="Phi-4-Technical-Report"><a href="#Phi-4-Technical-Report" class="headerlink" title="Phi-4 Technical Report"></a>Phi-4 Technical Report</h2><p>You can find the original paper<sup id="fnref:15" class="footnote-ref"><a href="#fn:15" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://arxiv.org/abs/2412.08905">[15]</span></a></sup> here.</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><h3 id="papers-related"><a href="#papers-related" class="headerlink" title="papers related"></a>papers related</h3><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://substack.com/home/post/p-153341037">https://substack.com/home/post/p-153341037</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://substack.com/home/post/p-153692738">https://substack.com/home/post/p-153692738</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://arxiv.org/abs/2401.04088">https://arxiv.org/abs/2401.04088</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span><a href="http://arxiv.org/abs/2402.09353">http://arxiv.org/abs/2402.09353</a><a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:5" class="footnote-text"><span><a href="https://arxiv.org/abs/2403.08763">https://arxiv.org/abs/2403.08763</a><a href="#fnref:5" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:6" class="footnote-text"><span><a href="https://arxiv.org/abs/2404.10719">https://arxiv.org/abs/2404.10719</a><a href="#fnref:6" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:7" class="footnote-text"><span><a href="https://arxiv.org/abs/2405.09673">https://arxiv.org/abs/2405.09673</a><a href="#fnref:7" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:8" class="footnote-text"><span><a href="https://arxiv.org/abs/2406.17557">https://arxiv.org/abs/2406.17557</a><a href="#fnref:8" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:9" class="footnote-text"><span><a href="https://arxiv.org/abs/2407.21783">https://arxiv.org/abs/2407.21783</a><a href="#fnref:9" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:10" class="footnote-text"><span><a href="https://arxiv.org/abs/2408.03314">https://arxiv.org/abs/2408.03314</a><a href="#fnref:10" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:11" class="footnote-text"><span><a href="https://arxiv.org/abs/2409.11402">https://arxiv.org/abs/2409.11402</a><a href="#fnref:11" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:12" class="footnote-text"><span><a href="https://arxiv.org/abs/2410.18982">https://arxiv.org/abs/2410.18982</a><a href="#fnref:12" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:13" class="footnote-text"><span><a href="https://arxiv.org/abs/2411.04330">https://arxiv.org/abs/2411.04330</a><a href="#fnref:13" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:14" class="footnote-text"><span><a href="https://arxiv.org/abs/2412.19437">https://arxiv.org/abs/2412.19437</a><a href="#fnref:14" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:15" class="footnote-text"><span><a href="https://arxiv.org/abs/2412.08905">https://arxiv.org/abs/2412.08905</a><a href="#fnref:15" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Artificial Intelligence</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AI research</tag>
      
      <tag>Artificial Intelligence</tag>
      
      <tag>Deep Learning</tag>
      
      <tag>LLMs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DataStructure-Set</title>
    <link href="/posts/DataStructure-Set/"/>
    <url>/posts/DataStructure-Set/</url>
    
    <content type="html"><![CDATA[<style>  html, body, .markdown-body {    font-family: Georgia, sans, serif;  }</style><h1 id="Data-Structure-Set"><a href="#Data-Structure-Set" class="headerlink" title="Data Structure: Set"></a>Data Structure: Set</h1><p>Lecture notes for MIT6.006 Lec8 <strong>Set and Sorting</strong>.</p><p>In this Lecture, we will implement a simple interface, <strong>set</strong>.</p><h2 id="Set-Interface"><a href="#Set-Interface" class="headerlink" title="Set Interface"></a>Set Interface</h2><p>Remember Data Structure is an <strong>interface</strong>, don’t do some dumb jobs… All you need to do is understanding the first principle of several data structures through practicing it.</p><p><img src="https://s1.imagehub.cc/images/2025/03/29/564afb3d8029f1273d4ee1f1ff07b471.png" alt="Set interface"></p><p>If you use simply an array, it will cost $O(n)$ time！</p><h1 id="Data-Structure-Set-1"><a href="#Data-Structure-Set-1" class="headerlink" title="Data Structure Set"></a>Data Structure Set</h1><p>Lecture Notes from SJTU DS</p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><ul><li>散列表：实现<strong>映射</strong>（集合提升性能的核心问题）</li></ul><h2 id="集合的定义"><a href="#集合的定义" class="headerlink" title="集合的定义"></a>集合的定义</h2><p>集合包含两个部分：<strong>键值</strong>和<strong>关键字值</strong>。</p><h2 id="静态查找表"><a href="#静态查找表" class="headerlink" title="静态查找表"></a>静态查找表</h2><p>问题的定义：给定一个集合，需要查找关键字$X$对应的元素是否存在。</p><p>从最基本的顺序查找（$O(n)$）到对于有序集合的<strong>二分查找</strong>($O(\log n)$），还可以进一步优化为<strong>插值查找</strong>，对于数据均匀分布的情况，可以进一步优化时间复杂度：</p><p>$$pos &#x3D; low + \left\lfloor \frac{(high - low - 1) \cdot (target - arr[low])}{arr[high] - arr[low]} \right\rfloor$$</p><p>使用<strong>分块查找</strong>也可以进一步优化（详见分块思想）</p><ul><li>为了最大化发挥分块的效率，我们需要对块内元素的性质做出规定：<ul><li>例如，第$i$块的元素一定大于第$i+ 1$块的元素（并且建立索引表）<ul><li>每个索引包括块内元素的最大值和该索引块的起始位置</li><li>这样就可以在多次查询的时候减少很多无效的比较，但是<strong>代价是需要额外空间储存索引并且在修改数组时需要更新维护这个索引表</strong>。</li></ul></li><li>如果查找表很大，内存放不下，可以使用分块的思想高效的实现分块查找。</li></ul></li></ul><h3 id="STL-中的静态查找表"><a href="#STL-中的静态查找表" class="headerlink" title="STL 中的静态查找表"></a>STL 中的静态查找表</h3><ul><li><p><code>find()</code>：</p><ul><li><strong>模版参数</strong><ul><li>迭代器类型</li><li>集合元素的类型</li></ul></li><li><strong>形式参数</strong><ul><li>两个迭代器对象（左闭右开）</li><li>需要查找的对象值</li></ul></li><li>返回一个迭代器</li></ul></li><li><p><code>binary_search()</code>：使用二分查找的方式查找一个有序序列，返回是否存在</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tutorial</tag>
      
      <tag>Data Structure</tag>
      
      <tag>C/C++</tag>
      
      <tag>Set</tag>
      
      <tag>Sorting</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DataStructure-Tree-Binary-Heap</title>
    <link href="/posts/DataStructure-Tree-Binary-Heap/"/>
    <url>/posts/DataStructure-Tree-Binary-Heap/</url>
    
    <content type="html"><![CDATA[<style>  html, body, .markdown-body {    font-family: Georgia, sans, serif;  }</style><h1 id="Data-Structure-Binary-Heap"><a href="#Data-Structure-Binary-Heap" class="headerlink" title="Data Structure: Binary Heap"></a>Data Structure: Binary Heap</h1><p>The lecture note of <strong>MIT6.006</strong>, Lec8: Binary Heaps.</p><h2 id="Priority-Queue-Interface"><a href="#Priority-Queue-Interface" class="headerlink" title="Priority Queue Interface"></a>Priority Queue Interface</h2><ul><li><code>build(X)</code>: Init to items in $X$.</li><li><code>insert(x)</code>: add item $x$.</li><li><code>delete_max()</code>: delete and return the max-key item.</li><li><code> find_max()</code>: return max_key item.</li></ul><p>Queue is a Linear List, but if I want to place different priorities into different elements, we need to use <strong>Priority Queue</strong> implemented by Tree!</p><p><img src="https://s1.imagehub.cc/images/2025/03/27/e5276b2fe19a07a43d885bf4eb68f9d1.png" alt="Heap Sort"></p><p>For dynamic array, <code>insert</code> is max but <code>delete_max()</code> is too slow ($O(n)$)! However, in <strong>Sorted Dynamic Array</strong>, it is just the opposite. It’s a tradeoff for inserting and deleting if you stick to the sequential data structure. However, we can use <strong>Set AVL</strong> for getting both operations $O(\log n)$ time complexity!</p><blockquote><p><strong>In place</strong> means when sorting, the data structure doesn’t need extra space (or $O(1)$ time complexity) to finish sorting. AVL set is very complex, where we need extra space to do several rotations in order to get the sorting.</p></blockquote><h2 id="Priority-Queue-Sort"><a href="#Priority-Queue-Sort" class="headerlink" title="Priority Queue Sort"></a>Priority Queue Sort</h2><p>Time complexity $O(n\log n)$.</p><ul><li>insert $x$ for $x$ in array (A) (<code>build(A)</code>)</li><li>using <code>delete_max</code> until the priority queue is empty.</li><li>Then we get sorted for using the Priority Queue Sort.</li></ul><h2 id="Arrays-as-a-Complete-Binary-Tree"><a href="#Arrays-as-a-Complete-Binary-Tree" class="headerlink" title="Arrays as a Complete Binary Tree"></a>Arrays as a Complete Binary Tree</h2><p>Consider the <strong>complete binary tree</strong>, there is a bijection (one to one correspondence) between this binary tree and an array traversed by a sequential order.</p><p><img src="https://s1.imagehub.cc/images/2025/03/27/41df4ffab183b2adf0062c6d2473af1b.png" alt="Arrays as a complete binary tree"></p><h1 id="Data-Structure-Priority-Queue"><a href="#Data-Structure-Priority-Queue" class="headerlink" title="Data Structure Priority Queue"></a>Data Structure Priority Queue</h1><p>Lecture note for Data Structure in SJTU</p><h2 id="基于线性表的优先级队列"><a href="#基于线性表的优先级队列" class="headerlink" title="基于线性表的优先级队列"></a>基于线性表的优先级队列</h2><p>如何处理优先级？</p><ul><li>进队插入，出队直接出队队首元素（Dynamic Sorted Array）</li><li>进队尾端进队，出队查找优先级最高的元素出队 （Dynamic Array）</li></ul><h2 id="基于树的优先级队列"><a href="#基于树的优先级队列" class="headerlink" title="基于树的优先级队列"></a>基于树的优先级队列</h2><h3 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h3><p>堆可以分为两种主要类型：<strong>最大堆（Max-Heap）</strong> 和 <strong>最小堆（Min-Heap）</strong> ，它们的核心性质如下：</p><h4 id="最大堆（Max-Heap）"><a href="#最大堆（Max-Heap）" class="headerlink" title="最大堆（Max-Heap）"></a>最大堆（Max-Heap）</h4><p>对于一个最大堆：</p><ul><li>堆中的每个节点的值都<strong>大于或等于</strong> 其子节点的值。</li><li>数学上，设 $h[i]$ 表示堆中第 <em>i</em> 个节点的值，则对于任意节点 $i$ 满足以下条件：$h[i]≥h[2i+1]$和$h[i]≥h[2i+2]$其中 $2i+1$ 和 $2i+2$ 分别是节点 <em>i</em> 的左子节点和右子节点的索引。</li></ul><h4 id="最小堆（Min-Heap）"><a href="#最小堆（Min-Heap）" class="headerlink" title="最小堆（Min-Heap）"></a>最小堆（Min-Heap）</h4><p>对于一个最小堆：</p><ul><li><p>堆中的每个节点的值都<strong>小于或等于</strong> 其子节点的值。</p></li><li><p>数学上，设 $h[i]$ 表示堆中第 <em>i</em> 个节点的值，则对于任意节点 $i$ 满足以下条件：$h[i]\le[2i+1]$和$h[i]\le h[2i+2]$其中 $2i+1$ 和 $2i+2$ 分别是节点 <em>i</em> 的左子节点和右子节点的索引。</p></li><li><p>二叉堆完全符合完全二叉树的结构性质，同时满足有序性。</p></li><li><p>由于二叉堆是完全二叉树，故可以使用顺序存储的形式来存储一个完全二叉树。</p></li></ul><h3 id="优先级队列的存储实现-二叉堆"><a href="#优先级队列的存储实现-二叉堆" class="headerlink" title="优先级队列的存储实现 二叉堆"></a>优先级队列的存储实现 二叉堆</h3><p>二叉堆的数学性质保证了<strong>根节点</strong>始终是最大值和最小值。假设数值越大，优先级越高，故可以使用一个<strong>最大化堆</strong>来存储优先级队列。一旦保持了二叉堆的性质，我们只需要返回根节点就可以找到最优先的元素。因此，<strong>二叉堆的重点是进队和出队的操作</strong>，来保持二叉堆的有序性质和完全二叉树的操作。</p><h4 id="进队操作"><a href="#进队操作" class="headerlink" title="进队操作"></a>进队操作</h4><ul><li>满足结构性：添加在叶子结点，保证还是<strong>完全二叉树</strong>。<ul><li>在最大序号的元素之后</li></ul></li><li>为了满足<strong>有序性</strong>：<strong>新节点不断向上过滤（对于父亲比儿子小的情况）</strong>，直到满足父亲比儿子大，满足有序性<ul><li>在向上过滤的过程中，优先级是递增的</li></ul></li></ul><h4 id="出队操作"><a href="#出队操作" class="headerlink" title="出队操作"></a>出队操作</h4><p>在根节点出队后，为了保证结构性，把<strong>最后一个节点</strong>放进根节点，使其变成完全二叉树。</p><p>为了满足有序性，此处可以<strong>向下过滤</strong>，将两个儿子中更大的元素与父亲交换。</p><h4 id="建堆操作"><a href="#建堆操作" class="headerlink" title="建堆操作"></a>建堆操作</h4><ul><li>递归调用左右子树</li><li>也可以<strong>自下而上</strong>，对每一个非叶结点向上过滤。</li></ul><p>这样的建堆过程能够达到<strong>线性时间复杂度</strong>，证明见下：</p><div class="note note-primary">            <p><img src="https://s1.imagehub.cc/images/2025/03/27/a178bcb6283355c12a333108f575cccf.png" alt="Linear Time Complexity"></p>          </div><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><p>因此，我们给出二叉堆的具体实现，保持<strong>完全二叉树的有序性和结构性</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">priorityQueue</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">size_t</span> currentsize;<br>    T* array;<br>    <span class="hljs-type">size_t</span> maxsize;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doublespace</span><span class="hljs-params">()</span> </span>&#123;<br>        T* tmp = array;<br>        maxsize *= <span class="hljs-number">2</span>;<br>        array = <span class="hljs-keyword">new</span> T[maxsize];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt;= currentsize; ++i) &#123;<br>            array[i] = tmp[i];<br>        &#125;<br>        <span class="hljs-keyword">delete</span>[] tmp;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">buildheap</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = currentsize / <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">1</span>; --i) &#123;<br>            <span class="hljs-built_in">percolateDown</span>(i);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">percolateDown</span><span class="hljs-params">(<span class="hljs-type">size_t</span> hole)</span> </span>&#123;<br>        <span class="hljs-type">size_t</span> child = <span class="hljs-number">0</span>;<br>        T tmp = array[hole];<br><br>        <span class="hljs-keyword">while</span> (hole * <span class="hljs-number">2</span> &lt;= currentsize) &#123;<br>            child = hole * <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (child &lt; currentsize &amp;&amp; array[child + <span class="hljs-number">1</span>] &lt; array[child]) &#123;<br>                ++child;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (array[child] &lt; tmp) &#123;<br>                array[hole] = array[child];<br>                hole = child;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        array[hole] = tmp;<br>    &#125;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">priorityQueue</span>(<span class="hljs-type">size_t</span> capacity = <span class="hljs-number">100</span>) : <span class="hljs-built_in">currentsize</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">maxsize</span>(capacity) &#123;<br>        array = <span class="hljs-keyword">new</span> T[maxsize];<br>    &#125;<br><br>    ~<span class="hljs-built_in">priorityQueue</span>() &#123;<br>        <span class="hljs-keyword">delete</span>[] array;<br>    &#125;<br><br>    <span class="hljs-built_in">priorityQueue</span>(<span class="hljs-type">const</span> T* data, <span class="hljs-type">size_t</span> size) : <span class="hljs-built_in">currentsize</span>(size), <span class="hljs-built_in">maxsize</span>(size + <span class="hljs-number">10</span>) &#123;<br>        array = <span class="hljs-keyword">new</span> T[maxsize];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; size; ++i) &#123;<br>            array[i + <span class="hljs-number">1</span>] = data[i];<br>        &#125;<br>        <span class="hljs-built_in">buildheap</span>();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> currentsize == <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">enQueue</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; x)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (currentsize == maxsize - <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-built_in">doublespace</span>();<br>        &#125;<br><br>        <span class="hljs-type">size_t</span> hole = ++currentsize;<br>        <span class="hljs-keyword">while</span> (hole &gt; <span class="hljs-number">1</span> &amp;&amp; x &lt; array[hole / <span class="hljs-number">2</span>]) &#123;<br>            array[hole] = array[hole / <span class="hljs-number">2</span>];<br>            hole /= <span class="hljs-number">2</span>;<br>        &#125;<br>        array[hole] = x;<br>    &#125;<br><br>    <span class="hljs-function">T <span class="hljs-title">deQueue</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">underflow_error</span>(<span class="hljs-string">&quot;Priority queue is empty&quot;</span>);<br>        &#125;<br><br>        T minItem = array[<span class="hljs-number">1</span>];<br>        array[<span class="hljs-number">1</span>] = array[currentsize--];<br>        <span class="hljs-built_in">percolateDown</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> minItem;<br>    &#125;<br><br>    <span class="hljs-function">T <span class="hljs-title">getHead</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">underflow_error</span>(<span class="hljs-string">&quot;Priority queue is empty&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> array[<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pqsort</span><span class="hljs-params">(T* unsorted, T* sorted, <span class="hljs-type">size_t</span> size)</span> </span>&#123;<br>    <span class="hljs-function">priorityQueue&lt;T&gt; <span class="hljs-title">pq</span><span class="hljs-params">(unsorted, size)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; size; ++i) &#123;<br>        sorted[i] = pq.<span class="hljs-built_in">deQueue</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> size = <span class="hljs-number">5</span>;<br>    <span class="hljs-type">int</span> unsorted[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">3</span>&#125;;<br>    <span class="hljs-type">int</span>* sorted = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[size];<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-built_in">pqsort</span>(unsorted, sorted, size);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; size; ++i) &#123;<br>            std::cout &lt;&lt; sorted[i] &lt;&lt; std::endl;<br>        &#125;<br>    &#125; <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::exception&amp; e) &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;Error: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-keyword">delete</span>[] sorted;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>同时，我们利用priority queue实现了priority queue sort函数，通过对原始数组建立<strong>二叉堆</strong>，接着不断的删除根节点元素，得到排序后的元素（in the Ascending order），因为这里是一个最小堆。</p></blockquote><h3 id="D堆"><a href="#D堆" class="headerlink" title="D堆"></a>D堆</h3><p>延伸：每个节点有$D$个儿子。</p><p>当D较大时，对于入队操作，二叉树的高度更低，因此<strong>向上过滤</strong>的速度更快（每个儿子只有一个爸爸），但是代价是对于出队操作，<strong>需要查找的节点数上升</strong>，导致<strong>向下过滤</strong>的速度变慢。并且在二叉树中，移位的操作是依靠位运算（乘2或除2）来实现的，速度较快，而如果D不是2的幂次。</p><p>使用二叉堆能够高效地实现优先级队列，但是二叉堆结构实现非常的严格，必须要同时满足<strong>完全二叉树的结构性</strong>和最大（最小）的<strong>排序性</strong>。</p><p>如果在不考虑结构性的情况下仍然保证<strong>有序性</strong>？我们就可以产生各种各样的堆！</p><p>由于<strong>不再保持完全二叉树的严格结构</strong>，我们可以生成很多很多个堆，因此此时，<strong>堆之间的合并</strong>是非常重要的操作。</p><p>D堆的作用：</p><ul><li><p>对于<strong>插入操作远多于删除操作</strong>的情况</p></li><li><p>对于<strong>较大的优先级队列导致无法装入内存的情况</strong>，D堆可以减少内外存的交换。</p><ul><li><p>D堆的每个节点有 $D$个子节点，因此每个节点可以表示更多的信息。当$D$较大时，堆的宽度增加，而高度降低。这使得堆的每一层可以更好地适应内存分页机制：</p><ul><li>更少的层数意味着更少的页面切换。</li><li>每次访问的节点更集中，减少了跨页访问的概率。</li></ul></li><li><p>减少了内外存之间的数据交换次数，提升了整体性能。</p></li></ul></li></ul><h2 id="归并优先级队列"><a href="#归并优先级队列" class="headerlink" title="归并优先级队列"></a>归并优先级队列</h2><h3 id="左堆"><a href="#左堆" class="headerlink" title="左堆"></a>左堆</h3><h4 id="Definition-1"><a href="#Definition-1" class="headerlink" title="Definition"></a>Definition</h4><ul><li><strong>空路径长度 $npl$ <strong>：x到</strong>不满两个个儿子节点的最短路径</strong>。<ul><li>具有1个或0个儿子节点的<code>npl</code>为0</li><li>空节点（<code>nullptr</code>）的$npl &#x3D; -1$</li></ul></li><li><strong>左堆</strong>保证左儿子的$npl$ &gt;&#x3D; 右儿子的$npl$</li></ul><blockquote><p>形象来说，就是不满足平衡性（完全二叉树）但是向左倾斜的堆。</p></blockquote><h4 id="左堆的递归归并"><a href="#左堆的递归归并" class="headerlink" title="左堆的递归归并"></a>左堆的递归归并</h4><p>我们实现<strong>对两个子堆的合并操作</strong>：</p><ul><li>将<strong>根节点稍大的堆</strong>与另一个堆的右子树进行归并。</li><li>如果产生的堆违反了左堆的定义，则交换左右子树（<strong>这一步在“归”的步骤上实现</strong>）</li><li>递归的终止条件：<strong>当某个堆为空，另一个堆就是归并的结果</strong>。</li></ul><div class="note note-info">            <ol><li>假设 $H_1$ 的根节点值小于等于 $H_2$ 的根节点值（不失一般性）。</li><li>将$H_2$与 $H_1$ 的右子树进行递归合并，结果是一个新的右子树。</li><li>将这个新的右子树重新赋值给 $H_1.right$。</li><li>检查并调整 $H_1$ 的左偏性质（即确保左子树的零路径长度大于等于右子树的零路径长度）。</li><li>更新 $H_1$ 的零路径长度</li></ol>          </div><p><img src="https://s1.imagehub.cc/images/2025/03/27/d89ff689497c6fa68f24eb8157021e9d.png" alt="Merge"></p><h4 id="左堆进队和出队"><a href="#左堆进队和出队" class="headerlink" title="左堆进队和出队"></a>左堆进队和出队</h4><ul><li><p>看做归并的特例（单元素堆）</p></li><li><p>删除根节点后再<strong>归并</strong>两个堆。</p></li></ul><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @Author: Xiyuan Yang   xiyuan_yang@outlook.com</span><br><span class="hljs-comment"> * @Date: 2025-03-27 17:25:03</span><br><span class="hljs-comment"> * @LastEditors: Xiyuan Yang   xiyuan_yang@outlook.com</span><br><span class="hljs-comment"> * @LastEditTime: 2025-03-27 17:39:34</span><br><span class="hljs-comment"> * @FilePath: /Data_structure/single_files/Class_implementation/LeftistHeap.cpp</span><br><span class="hljs-comment"> * @Description: </span><br><span class="hljs-comment"> * Do you code and make progress today?</span><br><span class="hljs-comment"> * Copyright (c) 2025 by Xiyuan Yang, All Rights Reserved. </span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">LeftistNode</span> &#123;<br>    <span class="hljs-type">int</span> key;<br>    <span class="hljs-type">int</span> npl; <span class="hljs-comment">// Null Path Length</span><br>    LeftistNode* left;<br>    LeftistNode* right;<br><br>    <span class="hljs-built_in">LeftistNode</span>(<span class="hljs-type">int</span> k) : <span class="hljs-built_in">key</span>(k), <span class="hljs-built_in">npl</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">left</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">right</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LeftistHeap</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">LeftistHeap</span>() : <span class="hljs-built_in">root</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> </span>&#123;<br>        LeftistNode* newNode = <span class="hljs-keyword">new</span> <span class="hljs-built_in">LeftistNode</span>(key);<br>        root = <span class="hljs-built_in">merge</span>(root, newNode);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deleteMin</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span>;<br>        LeftistNode* temp = root;<br>        root = <span class="hljs-built_in">merge</span>(root-&gt;left, root-&gt;right);<br>        <span class="hljs-keyword">delete</span> temp;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getMin</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;Heap is empty!&quot;</span>);<br>        <span class="hljs-keyword">return</span> root-&gt;key;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    LeftistNode* root;<br><br>    <span class="hljs-function">LeftistNode* <span class="hljs-title">merge</span><span class="hljs-params">(LeftistNode* h1, LeftistNode* h2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!h1) <span class="hljs-keyword">return</span> h2;<br>        <span class="hljs-keyword">if</span> (!h2) <span class="hljs-keyword">return</span> h1;<br><br>        <span class="hljs-keyword">if</span> (h1-&gt;key &gt; h2-&gt;key) std::<span class="hljs-built_in">swap</span>(h1, h2);<br><br>        h1-&gt;right = <span class="hljs-built_in">merge</span>(h1-&gt;right, h2);<br><br>        <span class="hljs-keyword">if</span> (!h1-&gt;left || h1-&gt;left-&gt;npl &lt; h1-&gt;right-&gt;npl) &#123;<br>            std::<span class="hljs-built_in">swap</span>(h1-&gt;left, h1-&gt;right);<br>        &#125;<br><br>        h1-&gt;npl = h1-&gt;right ? h1-&gt;right-&gt;npl + <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> h1;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> size = <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> unsorted [size] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">8</span>,<span class="hljs-number">92</span>,<span class="hljs-number">31</span>&#125;;<br><br>    <span class="hljs-comment">//creating a new leftist heap</span><br>    LeftistHeap lfh;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; ++i)&#123;<br>        lfh.<span class="hljs-built_in">insert</span>(unsorted[i]);<br>    &#125;<br><br>    <span class="hljs-type">int</span>* sorted = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span> [size];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; ++i)&#123;<br>        sorted[i] = lfh.<span class="hljs-built_in">getMin</span>();<br>        lfh.<span class="hljs-built_in">deleteMin</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++)&#123;<br>        std::cout &lt;&lt; sorted[i] &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-keyword">delete</span> [] sorted;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="斜堆"><a href="#斜堆" class="headerlink" title="斜堆"></a>斜堆</h3><p>左堆对完全二叉树的严格显示做了适当的宽松，但是代价是<strong>仍然需要维护左堆的性质（即维护每个结点的npl）</strong>。我们可以进一步简化，于是我们可以构造<strong>斜堆</strong>来实现<strong>没有任何平衡条件限定</strong>的二叉树实现。</p><p>斜堆是<strong>仅满足有序性不满足任何结构性的二叉树</strong>。最坏时间复杂度为$O(N)$，平均时间复杂度为$O(\log N)$。（这一点会在后面的代码中详细分析）</p><p>斜堆相当于是一个<strong>自调整的左堆</strong>，在归并的过程中，无需判断是否满足左堆，但是在<strong>归</strong>的过程中<strong>左右子树的交换是必须的</strong>。并且也无需维护<code>npl</code>。</p><p>具体而言，在斜堆的归并操作中：</p><ul><li><strong>将根节点较大的堆和根节点较小的右子堆</strong>归并。（这一点和左堆完全相同），作为新的右子堆。</li><li>递归终止条件：两个需要合并的堆中有一个为空。</li><li><strong>每一次归并完成后</strong>需要将归并起来的堆的左右子树交换。</li></ul><p>为什么要实现第三点？因为交换左右子树本质上是实现一种<strong>洗牌的操作</strong>，否则斜堆很有可能会退化为二叉链表类（这样的退化情况会让$O(h)$退化为$O(n)$，是我们最不想看到的）</p><blockquote><p>这一点从<strong>感觉</strong>上来说非常好理解，因为我们相当于在更新$H_2$的右节点，这样会导致<strong>右侧的子树</strong>比左边的更大，因此为了保证平衡，我们需要不断的交换左右节点。因为只有平衡二叉树才能保证$O(h)&#x3D;O(\log n)$，否则会出现退化链表的情况。 </p></blockquote><h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @Author: Xiyuan Yang   xiyuan_yang@outlook.com</span><br><span class="hljs-comment"> * @Date: 2025-03-27 19:10:30</span><br><span class="hljs-comment"> * @LastEditors: Xiyuan Yang   xiyuan_yang@outlook.com</span><br><span class="hljs-comment"> * @LastEditTime: 2025-03-27 19:13:34</span><br><span class="hljs-comment"> * @FilePath: /Data_structure/single_files/Class_implementation/skewHeap.cpp</span><br><span class="hljs-comment"> * @Description: </span><br><span class="hljs-comment"> * Do you code and make progress today?</span><br><span class="hljs-comment"> * Copyright (c) 2025 by Xiyuan Yang, All Rights Reserved. </span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">SkewNode</span> &#123;<br>    <span class="hljs-type">int</span> key;<br>    SkewNode* left;<br>    SkewNode* right;<br><br>    <span class="hljs-built_in">SkewNode</span>(<span class="hljs-type">int</span> k) : <span class="hljs-built_in">key</span>(k), <span class="hljs-built_in">left</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">right</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SkewHeap</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">SkewHeap</span>() : <span class="hljs-built_in">root</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> </span>&#123;<br>        SkewNode* newNode = <span class="hljs-keyword">new</span> <span class="hljs-built_in">SkewNode</span>(key);<br>        root = <span class="hljs-built_in">merge</span>(root, newNode);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deleteMin</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span>;<br>        SkewNode* temp = root;<br>        root = <span class="hljs-built_in">merge</span>(root-&gt;left, root-&gt;right);<br>        <span class="hljs-keyword">delete</span> temp;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getMin</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;Heap is empty!&quot;</span>);<br>        <span class="hljs-keyword">return</span> root-&gt;key;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    SkewNode* root;<br><br>    <span class="hljs-function">SkewNode* <span class="hljs-title">merge</span><span class="hljs-params">(SkewNode* h1, SkewNode* h2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!h1) <span class="hljs-keyword">return</span> h2;<br>        <span class="hljs-keyword">if</span> (!h2) <span class="hljs-keyword">return</span> h1;<br><br>        <span class="hljs-keyword">if</span> (h1-&gt;key &gt; h2-&gt;key) std::<span class="hljs-built_in">swap</span>(h1, h2);<br><br>        <span class="hljs-comment">// Swap the children of h1</span><br>        h1-&gt;right = <span class="hljs-built_in">merge</span>(h1-&gt;right, h2);<br>        std::<span class="hljs-built_in">swap</span>(h1-&gt;left, h1-&gt;right);<br><br>        <span class="hljs-keyword">return</span> h1;<br>    &#125;<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> size = <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> unsorted [size] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">8</span>,<span class="hljs-number">92</span>,<span class="hljs-number">31</span>&#125;;<br><br>    <span class="hljs-comment">//creating a new leftist heap</span><br>    SkewHeap skh;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; ++i)&#123;<br>        skh.<span class="hljs-built_in">insert</span>(unsorted[i]);<br>    &#125;<br><br>    <span class="hljs-type">int</span>* sorted = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span> [size];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; ++i)&#123;<br>        sorted[i] = skh.<span class="hljs-built_in">getMin</span>();<br>        skh.<span class="hljs-built_in">deleteMin</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++)&#123;<br>        std::cout &lt;&lt; sorted[i] &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-keyword">delete</span> [] sorted;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>左堆和斜堆在代码实现上都是比较简单的，因为都是递归函数。但是笔者在初学的时候不仅产生了如下的疑惑：</p><ul><li>二叉堆那么完美，为什么我们希望这个堆保持<strong>左倾</strong>？（左堆）</li><li><strong>归并的本质</strong>就是让两个堆在<strong>合并</strong>只会仍然保持<strong>堆的两条性质：有序性（这是优先级队列的核心）和 结构性</strong>，那为什么在斜堆中我们需要强制交换<strong>左右子树</strong>呢？</li></ul><div class="note note-primary">            <h4 id="左堆相对于斜堆有什么优势？"><a href="#左堆相对于斜堆有什么优势？" class="headerlink" title="左堆相对于斜堆有什么优势？"></a>左堆相对于斜堆有什么优势？</h4><ul><li><strong>左堆</strong> ：左堆的合并、插入和删除最小值操作的时间复杂度为 <em>O</em>(log<em>n</em>)，这是一个确定性的上界。这种确定性使得左堆在对性能要求严格的场景中更有优势。</li><li><strong>斜堆</strong> ：斜堆的合并、插入和删除最小值操作的均摊时间复杂度也是 <em>O</em>(log<em>n</em>)，但这只是均摊意义上的结果。在最坏情况下，斜堆的操作可能会退化到 <em>O</em>(<em>n</em>)。</li></ul><p><strong>优势总结</strong> ：</p><ul><li>左堆提供了更强的时间复杂度保证，适合需要稳定性能的场景。</li><li>斜堆虽然在均摊意义上与左堆相当，但在最坏情况下可能表现不佳。</li></ul><table><thead><tr><th>特性</th><th>左堆</th><th>斜堆</th></tr></thead><tbody><tr><td>时间复杂度</td><td>确定性<em>O</em>(log<em>n</em>)</td><td>均摊<em>O</em>(log<em>n</em>)，最坏<em>O</em>(<em>n</em>)</td></tr><tr><td>实现复杂度</td><td>较高（需要维护零路径长度）</td><td>较低（无需额外信息）</td></tr><tr><td>空间开销</td><td>较高（需要存储额外信息）</td><td>较低</td></tr></tbody></table>          </div><h3 id="二项堆"><a href="#二项堆" class="headerlink" title="二项堆"></a>二项堆</h3><p>我们可以再大胆一点！如果我们不使用二叉树，而是用广义的树进行储存呢？下面介绍<strong>二项堆</strong>，使用广义的树实现储存。</p><p>二项树构成的森林：</p><ul><li>每一颗二项树都满足<strong>堆的有序性</strong>。</li><li>高度为$k$的二项树$B_{k-1}$是$B_{k-2}$加到另一棵$B_{k-2}$的根上形成的。</li></ul><p><strong>二项树不是二叉树</strong>。</p><p><img src="https://s1.imagehub.cc/images/2025/03/27/643bdda39558c376a137d459c2f29c60.png" alt="Binomial heap"></p><h4 id="基于二项树的优先级队列表示"><a href="#基于二项树的优先级队列表示" class="headerlink" title="基于二项树的优先级队列表示"></a>基于二项树的优先级队列表示</h4><p>也就是说，我们可以使用<strong>二项树</strong>的集合（也就是森林）来实现优先级队列的存储。首先对于给定的元素个数$k$，根据二进制原理，可以使用二进制编码编码$k$，如果第$i$为是1，那么二项树$B_i$就在森林中，可以储存$2^i$个元素。这样就可以把每一个元素都填入到这个优先级队列中！</p><p>因为每一个二项树都满足有序性，因此只需要<strong>挑选所有二项树</strong>的根节点的最大值（或者最小值），就可以找到最大元素或者最小元素。因此，<strong>二项树</strong>实现的最关键环节还是<strong>归并操作</strong>！</p><p>对于<strong>归并操作</strong>，非常类似于二进制的加法。首先明确<strong>队列中元素的个数</strong>可以唯一确定<strong>不同高度子树的分布情况</strong>，因此一旦队列的元素个数发生了改变（删除元素或者插入元素），那么此时对应的二进制编码发生了改变，我们需要<strong>对某些树进行操作</strong>，使其高度发生变化。下面考虑两个二项堆发生归并的情况：</p><ul><li>从低到高归并两个优先级队列中相同的树<ul><li>如果是两棵树，<strong>把根节点值大的作为根节点值小的树的子树</strong>，这样2个$B_k$就可以合并成一个$B_{k+1}$，满足有序性。</li><li>如果是三棵树，随机选择两颗合并即可。</li><li><strong>关键就是保持相同高度二项树</strong>只能为1或0。</li></ul></li></ul><p>对于入队和出队操作，同样也可以看做归并的特殊情况。此处不再具体分析。</p><h4 id="归并的时间复杂度"><a href="#归并的时间复杂度" class="headerlink" title="归并的时间复杂度"></a>归并的时间复杂度</h4><p>对于归并运算，相当于<strong>二进制的进位过程</strong>，因此，最倒霉的情况是每个高度都发生了进位。</p><h5 id="最坏情况分析"><a href="#最坏情况分析" class="headerlink" title="最坏情况分析"></a>最坏情况分析</h5><p>在最坏的情况下相当于$B_0, B_1, B_2, \dots, B_k$全部存在，这个时候在加入一个单节点就会不断进位，此时元素总数为：</p><p>$$n&#x3D;2^0+2^1+2^2+2^3+\dots+2^k&#x3D;2^{k+1} - 1$$</p><p>也就是说，此时时间复杂度是$O(\log n)$级别的。</p><h5 id="平均情况分析"><a href="#平均情况分析" class="headerlink" title="平均情况分析"></a>平均情况分析</h5><ul><li>$B_0, B_1, B_2, \dots, B_k$ 出现的概率均为 $1&#x2F;2$，所以</li><li>$B_0, B_1$ 同时出现的概率为 $1&#x2F;4$，归并 2 次</li><li>$B_0, B_1, B_2$ 同时出现的概率为 $1&#x2F;8$，归并 3 次，$\dots$</li></ul><p>于是，平均情况的时间复杂度为：<br>$$T &#x3D; \sum_{i&#x3D;1}^{K} i \cdot (1&#x2F;2)^i \$$</p><p>使用错位相减法，可以得到：</p><p>$$T &#x3D; 2 - (1&#x2F;2)^K - K \cdot (1&#x2F;2)^K &lt; 2$$</p><p><strong>也就是说，归并的平均时间复杂度是常数级别的！</strong></p><h4 id="二项堆的时间性能"><a href="#二项堆的时间性能" class="headerlink" title="二项堆的时间性能"></a>二项堆的时间性能</h4><h5 id="归并"><a href="#归并" class="headerlink" title="归并"></a>归并</h5><ul><li>$N$ 元素队列至多有 $\log N + 1$ 棵树，每两棵树归并只需要常量$O(1)$的常数时间复杂度，</li><li>最坏情况时间复杂度为 $O(\log N)$</li></ul><h5 id="进队"><a href="#进队" class="headerlink" title="进队"></a>进队</h5><ul><li>平均情况时间复杂度为 $O(1)$</li></ul><h5 id="出队"><a href="#出队" class="headerlink" title="出队"></a>出队</h5><ul><li>找出根结点值最小的树，耗时 $O(\log N) &#x2F; O(\log N)$</li><li>归并若干个优先级队列，耗时 $O(1) &#x2F; O(\log N)$</li><li>平均&#x2F;最坏时间复杂度是 $O(\log N) &#x2F; O(\log N)$ 的</li></ul><h4 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">BinomialNode</span> &#123;<br>    <span class="hljs-comment">// Node structure for storing the tree, using linked storage</span><br>    <span class="hljs-type">int</span> key;                <span class="hljs-comment">// Key value of the node</span><br>    <span class="hljs-type">int</span> degree;             <span class="hljs-comment">// Degree of the binomial tree (number of children)</span><br>    BinomialNode* parent;   <span class="hljs-comment">// Pointer to the parent node</span><br>    BinomialNode* child;    <span class="hljs-comment">// Pointer to the first child node</span><br>    BinomialNode* sibling;  <span class="hljs-comment">// Pointer to the next sibling node</span><br><br>    <span class="hljs-built_in">BinomialNode</span>(<span class="hljs-type">int</span> k) : <span class="hljs-built_in">key</span>(k), <span class="hljs-built_in">degree</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">parent</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">child</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">sibling</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BinomialHeap</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">BinomialHeap</span>() : <span class="hljs-built_in">head</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br><br>    <span class="hljs-comment">// Insert a new key into the heap</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> </span>&#123;<br>        BinomialNode* newNode = <span class="hljs-keyword">new</span> <span class="hljs-built_in">BinomialNode</span>(key); <span class="hljs-comment">// Create a new node with the given key</span><br>        BinomialHeap tempHeap;                        <span class="hljs-comment">// Create a temporary heap</span><br>        tempHeap.head = newNode;                      <span class="hljs-comment">// Set the new node as the head of the temporary heap</span><br>        <span class="hljs-built_in">merge</span>(tempHeap);                              <span class="hljs-comment">// Merge the temporary heap with the current heap</span><br>    &#125;<br><br>    <span class="hljs-comment">// Delete the minimum key from the heap</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deleteMin</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!head) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// If the heap is empty, do nothing</span><br><br>        BinomialNode* minNode = head; <span class="hljs-comment">// Initialize minNode with the head of the heap</span><br>        BinomialNode* prev = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// Pointer to the previous node of minNode</span><br>        BinomialNode* curr = head;    <span class="hljs-comment">// Pointer to traverse the heap</span><br><br>        <span class="hljs-comment">// Find the minimum node in the root list</span><br>        <span class="hljs-keyword">while</span> (curr) &#123;<br>            <span class="hljs-keyword">if</span> (curr-&gt;key &lt; minNode-&gt;key) &#123;<br>                minNode = curr;<br>                prev = curr;<br>            &#125;<br>            curr = curr-&gt;sibling;<br>        &#125;<br><br>        <span class="hljs-comment">// Remove the minimum node from the root list</span><br>        <span class="hljs-keyword">if</span> (prev) &#123;<br>            prev-&gt;sibling = minNode-&gt;sibling; <span class="hljs-comment">// Bypass the minNode</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            head = minNode-&gt;sibling; <span class="hljs-comment">// Update the head if minNode is the first node</span><br>        &#125;<br><br>        <span class="hljs-comment">// Reverse the child list of minNode to create a new heap</span><br>        BinomialHeap tempHeap;<br>        tempHeap.head = <span class="hljs-built_in">reverseChildren</span>(minNode-&gt;child);<br><br>        <span class="hljs-comment">// Merge the new heap with the original heap</span><br>        <span class="hljs-built_in">merge</span>(tempHeap);<br><br>        <span class="hljs-keyword">delete</span> minNode; <span class="hljs-comment">// Free the memory of the deleted node</span><br>    &#125;<br><br>    <span class="hljs-comment">// Get the minimum key in the heap</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getMin</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!head) &#123;<br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;Heap is empty!&quot;</span>); <span class="hljs-comment">// Throw an exception if the heap is empty</span><br>        &#125;<br>        <span class="hljs-type">int</span> minVal = head-&gt;key; <span class="hljs-comment">// Initialize minVal with the key of the head node</span><br>        <span class="hljs-keyword">for</span> (BinomialNode* curr = head; curr; curr = curr-&gt;sibling) &#123;<br>            minVal = <span class="hljs-built_in">min</span>(minVal, curr-&gt;key); <span class="hljs-comment">// Traverse the root list to find the minimum key</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> minVal;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    BinomialNode* head; <span class="hljs-comment">// Pointer to the head of the root list</span><br><br>    <span class="hljs-comment">// Reverse the child list of a node</span><br>    <span class="hljs-function">BinomialNode* <span class="hljs-title">reverseChildren</span><span class="hljs-params">(BinomialNode* node)</span> </span>&#123;<br>        BinomialNode* prev = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// Pointer to the previous node</span><br>        BinomialNode* curr = node;    <span class="hljs-comment">// Pointer to traverse the child list</span><br>        <span class="hljs-keyword">while</span> (curr) &#123;<br>            BinomialNode* next = curr-&gt;sibling; <span class="hljs-comment">// Store the next sibling</span><br>            curr-&gt;sibling = prev;               <span class="hljs-comment">// Reverse the sibling pointer</span><br>            curr-&gt;parent = <span class="hljs-literal">nullptr</span>;            <span class="hljs-comment">// Clear the parent pointer</span><br>            prev = curr;                        <span class="hljs-comment">// Move prev to the current node</span><br>            curr = next;                        <span class="hljs-comment">// Move curr to the next node</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> prev; <span class="hljs-comment">// Return the new head of the reversed list</span><br>    &#125;<br><br>    <span class="hljs-comment">// Merge two binomial heaps</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(BinomialHeap&amp; other)</span> </span>&#123;<br>        BinomialNode* newHead = <span class="hljs-literal">nullptr</span>;      <span class="hljs-comment">// New head of the merged heap</span><br>        BinomialNode** tail = &amp;newHead;       <span class="hljs-comment">// Pointer to the tail of the merged heap</span><br>        BinomialNode* h1 = head;              <span class="hljs-comment">// Pointer to traverse the first heap</span><br>        BinomialNode* h2 = other.head;        <span class="hljs-comment">// Pointer to traverse the second heap</span><br><br>        <span class="hljs-comment">// Merge the root lists of the two heaps</span><br>        <span class="hljs-keyword">while</span> (h1 &amp;&amp; h2) &#123;<br>            <span class="hljs-keyword">if</span> (h1-&gt;degree &lt; h2-&gt;degree) &#123;    <span class="hljs-comment">// Compare degrees and add the smaller one to the merged list</span><br>                *tail = h1;<br>                h1 = h1-&gt;sibling;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                *tail = h2;<br>                h2 = h2-&gt;sibling;<br>            &#125;<br>            tail = &amp;((*tail)-&gt;sibling);       <span class="hljs-comment">// Move the tail pointer forward</span><br>        &#125;<br><br>        <span class="hljs-comment">// Append the remaining nodes from either heap</span><br>        *tail = h1 ? h1 : h2;<br>        head = newHead;                       <span class="hljs-comment">// Update the head of the merged heap</span><br><br>        <span class="hljs-built_in">consolidate</span>();                        <span class="hljs-comment">// Consolidate the merged heap to ensure unique degrees</span><br>    &#125;<br><br>    <span class="hljs-comment">// Consolidate the heap to ensure each degree appears only once</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">consolidate</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;BinomialNode*&gt; <span class="hljs-title">degreeTable</span><span class="hljs-params">(<span class="hljs-number">32</span>, <span class="hljs-literal">nullptr</span>)</span></span>; <span class="hljs-comment">// Table to store nodes by degree (max degree assumed to be 32)</span><br><br>        BinomialNode* curr = head;            <span class="hljs-comment">// Pointer to traverse the heap</span><br>        BinomialNode* next;<br><br>        <span class="hljs-keyword">while</span> (curr) &#123;<br>            next = curr-&gt;sibling;             <span class="hljs-comment">// Store the next sibling</span><br>            <span class="hljs-keyword">while</span> (degreeTable[curr-&gt;degree]) &#123; <span class="hljs-comment">// Check if there is another node with the same degree</span><br>                BinomialNode* other = degreeTable[curr-&gt;degree]; <span class="hljs-comment">// Get the other node</span><br>                <span class="hljs-keyword">if</span> (curr-&gt;key &gt; other-&gt;key) <span class="hljs-built_in">swap</span>(curr, other);   <span class="hljs-comment">// Ensure curr has the smaller key</span><br>                <span class="hljs-built_in">link</span>(other, curr);                               <span class="hljs-comment">// Link the two nodes</span><br>                degreeTable[curr-&gt;degree - <span class="hljs-number">1</span>] = <span class="hljs-literal">nullptr</span>;         <span class="hljs-comment">// Clear the previous degree entry</span><br>            &#125;<br>            degreeTable[curr-&gt;degree] = curr; <span class="hljs-comment">// Store the current node in the table</span><br>            curr = next;                      <span class="hljs-comment">// Move to the next node</span><br>        &#125;<br><br>        head = <span class="hljs-literal">nullptr</span>;                       <span class="hljs-comment">// Reset the head of the heap</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> node : degreeTable) &#123;       <span class="hljs-comment">// Rebuild the root list from the degree table</span><br>            <span class="hljs-keyword">if</span> (node) &#123;<br>                node-&gt;sibling = head;         <span class="hljs-comment">// Add the node to the front of the root list</span><br>                head = node;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// Link two binomial trees together</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">link</span><span class="hljs-params">(BinomialNode* child, BinomialNode* parent)</span> </span>&#123;<br>        child-&gt;parent = parent;               <span class="hljs-comment">// Set the parent of the child node</span><br>        child-&gt;sibling = parent-&gt;child;       <span class="hljs-comment">// Add the child to the front of the parent&#x27;s child list</span><br>        parent-&gt;child = child;                <span class="hljs-comment">// Update the parent&#x27;s child pointer</span><br>        parent-&gt;degree++;                     <span class="hljs-comment">// Increment the degree of the parent</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// Test the BinomialHeap class</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        BinomialHeap bh;<br><br>        <span class="hljs-comment">// Insert elements into the heap</span><br>        bh.<span class="hljs-built_in">insert</span>(<span class="hljs-number">10</span>);<br>        bh.<span class="hljs-built_in">insert</span>(<span class="hljs-number">5</span>);<br>        bh.<span class="hljs-built_in">insert</span>(<span class="hljs-number">7</span>);<br>        bh.<span class="hljs-built_in">insert</span>(<span class="hljs-number">3</span>);<br>        bh.<span class="hljs-built_in">insert</span>(<span class="hljs-number">8</span>);<br><br>        <span class="hljs-comment">// Print the minimum element</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;Minimum element: &quot;</span> &lt;&lt; bh.<span class="hljs-built_in">getMin</span>() &lt;&lt; endl;<br><br>        <span class="hljs-comment">// Delete the minimum element and print the new minimum</span><br>        bh.<span class="hljs-built_in">deleteMin</span>();<br>        cout &lt;&lt; <span class="hljs-string">&quot;Minimum element after deletion: &quot;</span> &lt;&lt; bh.<span class="hljs-built_in">getMin</span>() &lt;&lt; endl;<br><br>        <span class="hljs-comment">// Delete the minimum element again and print the new minimum</span><br>        bh.<span class="hljs-built_in">deleteMin</span>();<br>        cout &lt;&lt; <span class="hljs-string">&quot;Minimum element after second deletion: &quot;</span> &lt;&lt; bh.<span class="hljs-built_in">getMin</span>() &lt;&lt; endl;<br><br>    &#125; <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> exception&amp; e) &#123;<br>        cerr &lt;&lt; <span class="hljs-string">&quot;Error: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Priority-Queue-in-STL"><a href="#Priority-Queue-in-STL" class="headerlink" title="Priority Queue in STL"></a>Priority Queue in STL</h2><p>在头文件<code>queue</code>中，存在使用二叉堆实现的类模板容器<code>priority_queue</code>，其有三个模版参数：</p><ul><li>队列中的元素类型</li><li>底层储存二叉堆的容器类型（数组，因为是完全二叉树）</li><li>最大堆还是最小堆</li></ul><p><code>std::priority_queue</code> 是 C++ 标准模板库（STL）中的一个容器适配器，用于实现优先队列。优先队列是一种特殊的队列，其中每个元素都有一个优先级，优先级高的元素会被优先处理。默认情况下，<code>std::priority_queue</code> 是一个最大堆，即优先级最高的元素（即最大值）位于队列的顶部。</p><h3 id="自定义比较函数"><a href="#自定义比较函数" class="headerlink" title="自定义比较函数"></a>自定义比较函数</h3><p>默认情况下，<code>std::priority_queue</code> 是最大堆。如果想实现最小堆或其他自定义排序规则，可以通过自定义比较函数来实现。</p><h4 id="最小堆示例："><a href="#最小堆示例：" class="headerlink" title="最小堆示例："></a>最小堆示例：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-comment">// 使用 std::greater 实现最小堆</span><br>std::priority_queue&lt;<span class="hljs-type">int</span>, std::vector&lt;<span class="hljs-type">int</span>&gt;, std::greater&lt;<span class="hljs-type">int</span>&gt;&gt; minHeap;<br><br>minHeap.<span class="hljs-built_in">push</span>(<span class="hljs-number">10</span>);<br>minHeap.<span class="hljs-built_in">push</span>(<span class="hljs-number">30</span>);<br>minHeap.<span class="hljs-built_in">push</span>(<span class="hljs-number">20</span>);<br><br>std::cout &lt;&lt; <span class="hljs-string">&quot;Top element: &quot;</span> &lt;&lt; minHeap.<span class="hljs-built_in">top</span>() &lt;&lt; std::endl;  <span class="hljs-comment">// 输出 10</span><br></code></pre></td></tr></table></figure><h4 id="自定义比较函数示例："><a href="#自定义比较函数示例：" class="headerlink" title="自定义比较函数示例："></a>自定义比较函数示例：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">CustomCompare</span> &#123;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; lhs, <span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; rhs)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> lhs &gt; rhs;  <span class="hljs-comment">// 最小堆</span><br>    &#125;<br>&#125;;<br><br>std::priority_queue&lt;<span class="hljs-type">int</span>, std::vector&lt;<span class="hljs-type">int</span>&gt;, CustomCompare&gt; customPQ;<br><br>customPQ.<span class="hljs-built_in">push</span>(<span class="hljs-number">10</span>);<br>customPQ.<span class="hljs-built_in">push</span>(<span class="hljs-number">30</span>);<br>customPQ.<span class="hljs-built_in">push</span>(<span class="hljs-number">20</span>);<br><br>std::cout &lt;&lt; <span class="hljs-string">&quot;Top element: &quot;</span> &lt;&lt; customPQ.<span class="hljs-built_in">top</span>() &lt;&lt; std::endl;  <span class="hljs-comment">// 输出 10</span><br></code></pre></td></tr></table></figure><h2 id="Application-The-simulation-of-Queueing-system"><a href="#Application-The-simulation-of-Queueing-system" class="headerlink" title="Application: The simulation of Queueing system"></a>Application: The simulation of Queueing system</h2><blockquote><p>TBD</p></blockquote><h2 id="Extension-Fibonacci-Heap"><a href="#Extension-Fibonacci-Heap" class="headerlink" title="Extension: Fibonacci Heap"></a>Extension: Fibonacci Heap</h2><p><strong>Powered By GPT-4o</strong></p><p>斐波那契堆（Fibonacci Heap）是一种高效的优先队列数据结构，由Michael L. Fredman 和 Robert E. Tarjan 在1984年提出。它在许多操作上具有优秀的渐进时间复杂度，特别适合需要频繁插入和合并的场景。</p><ol><li><p><strong>高效的操作时间复杂度</strong>：</p><ul><li>插入（Insert）：O(1) 摊还时间。</li><li>合并（Union）：O(1) 摊还时间。</li><li>查找最小值（Find-Min）：O(1) 时间。</li><li>删除最小值（Extract-Min）：O(log n) 摊还时间。</li><li>减小键值（Decrease-Key）：O(1) 摊还时间。</li><li>删除节点（Delete）：O(log n) 摊还时间。</li></ul></li><li><p><strong>松散的树形结构</strong>：</p><ul><li>斐波那契堆由一组最小堆有序树组成，这些树之间没有严格的形状约束（与二叉堆不同）。</li><li>树之间的合并和拆分非常灵活，这使得斐波那契堆在某些操作中表现优异。</li></ul></li><li><p><strong>延迟合并策略</strong>：</p><ul><li>许多操作（如删除最小值）会延迟执行实际的结构调整，直到必要时才进行清理（consolidation），从而摊还时间复杂度更低</li></ul></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;<br>    <span class="hljs-type">int</span> key;<br>    <span class="hljs-type">int</span> degree = <span class="hljs-number">0</span>; <span class="hljs-comment">// 子节点的数量</span><br>    <span class="hljs-type">bool</span> marked = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 是否失去了一个子节点</span><br>    Node* parent = <span class="hljs-literal">nullptr</span>;<br>    Node* child = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// 指向第一个子节点</span><br>    Node* left = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// 左兄弟</span><br>    Node* right = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// 右兄弟</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Node</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span> : key(k), left(this), right(this) &#123;</span>&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FibonacciHeap</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    Node* minNode = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// 指向当前最小节点</span><br>    <span class="hljs-type">int</span> nodeCount = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">consolidate</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-type">int</span> maxDegree = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(std::<span class="hljs-built_in">log2</span>(nodeCount)) + <span class="hljs-number">1</span>;<br>        <span class="hljs-function">std::vector&lt;Node*&gt; <span class="hljs-title">degreeTable</span><span class="hljs-params">(maxDegree, <span class="hljs-literal">nullptr</span>)</span></span>;<br><br>        std::vector&lt;Node*&gt; roots;<br>        Node* current = minNode;<br>        <span class="hljs-keyword">if</span> (current) &#123;<br>            <span class="hljs-keyword">do</span> &#123;<br>                roots.<span class="hljs-built_in">push_back</span>(current);<br>                current = current-&gt;right;<br>            &#125; <span class="hljs-keyword">while</span> (current != minNode);<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (Node* x : roots) &#123;<br>            <span class="hljs-type">int</span> d = x-&gt;degree;<br>            <span class="hljs-keyword">while</span> (degreeTable[d] != <span class="hljs-literal">nullptr</span>) &#123;<br>                Node* y = degreeTable[d];<br>                <span class="hljs-keyword">if</span> (x-&gt;key &gt; y-&gt;key) &#123;<br>                    std::<span class="hljs-built_in">swap</span>(x, y);<br>                &#125;<br>                <span class="hljs-built_in">link</span>(y, x);<br>                degreeTable[d] = <span class="hljs-literal">nullptr</span>;<br>                d++;<br>            &#125;<br>            degreeTable[d] = x;<br>        &#125;<br><br>        minNode = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">for</span> (Node* root : degreeTable) &#123;<br>            <span class="hljs-keyword">if</span> (root) &#123;<br>                <span class="hljs-keyword">if</span> (!minNode || root-&gt;key &lt; minNode-&gt;key) &#123;<br>                    minNode = root;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">link</span><span class="hljs-params">(Node* y, Node* x)</span> </span>&#123;<br>        <span class="hljs-comment">// Remove y from the root list</span><br>        y-&gt;left-&gt;right = y-&gt;right;<br>        y-&gt;right-&gt;left = y-&gt;left;<br><br>        <span class="hljs-comment">// Make y a child of x</span><br>        y-&gt;parent = x;<br>        <span class="hljs-keyword">if</span> (!x-&gt;child) &#123;<br>            x-&gt;child = y;<br>            y-&gt;left = y;<br>            y-&gt;right = y;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            y-&gt;left = x-&gt;child;<br>            y-&gt;right = x-&gt;child-&gt;right;<br>            x-&gt;child-&gt;right-&gt;left = y;<br>            x-&gt;child-&gt;right = y;<br>        &#125;<br>        x-&gt;degree++;<br>        y-&gt;marked = <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addChild</span><span class="hljs-params">(Node* parent, Node* child)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!parent-&gt;child) &#123;<br>            parent-&gt;child = child;<br>            child-&gt;left = child;<br>            child-&gt;right = child;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            child-&gt;left = parent-&gt;child;<br>            child-&gt;right = parent-&gt;child-&gt;right;<br>            parent-&gt;child-&gt;right-&gt;left = child;<br>            parent-&gt;child-&gt;right = child;<br>        &#125;<br>        child-&gt;parent = parent;<br>        parent-&gt;degree++;<br>    &#125;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">FibonacciHeap</span>() = <span class="hljs-keyword">default</span>;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> minNode == <span class="hljs-literal">nullptr</span>;<br>    &#125;<br><br>    <span class="hljs-function">Node* <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> </span>&#123;<br>        Node* newNode = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(key);<br>        <span class="hljs-keyword">if</span> (!minNode) &#123;<br>            minNode = newNode;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// Add to root list</span><br>            newNode-&gt;left = minNode;<br>            newNode-&gt;right = minNode-&gt;right;<br>            minNode-&gt;right-&gt;left = newNode;<br>            minNode-&gt;right = newNode;<br><br>            <span class="hljs-keyword">if</span> (newNode-&gt;key &lt; minNode-&gt;key) &#123;<br>                minNode = newNode;<br>            &#125;<br>        &#125;<br>        nodeCount++;<br>        <span class="hljs-keyword">return</span> newNode;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findMin</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!minNode) <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;Heap is empty&quot;</span>);<br>        <span class="hljs-keyword">return</span> minNode-&gt;key;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">extractMin</span><span class="hljs-params">()</span> </span>&#123;<br>        Node* z = minNode;<br>        <span class="hljs-keyword">if</span> (z) &#123;<br>            <span class="hljs-keyword">if</span> (z-&gt;child) &#123;<br>                Node* child = z-&gt;child;<br>                <span class="hljs-keyword">do</span> &#123;<br>                    Node* nextChild = child-&gt;right;<br>                    <span class="hljs-comment">// Add child to root list</span><br>                    child-&gt;left = minNode;<br>                    child-&gt;right = minNode-&gt;right;<br>                    minNode-&gt;right-&gt;left = child;<br>                    minNode-&gt;right = child;<br>                    child-&gt;parent = <span class="hljs-literal">nullptr</span>;<br>                    child = nextChild;<br>                &#125; <span class="hljs-keyword">while</span> (child != z-&gt;child);<br>            &#125;<br><br>            <span class="hljs-comment">// Remove z from root list</span><br>            z-&gt;left-&gt;right = z-&gt;right;<br>            z-&gt;right-&gt;left = z-&gt;left;<br><br>            <span class="hljs-keyword">if</span> (z == z-&gt;right) &#123;<br>                minNode = <span class="hljs-literal">nullptr</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                minNode = z-&gt;right;<br>                <span class="hljs-built_in">consolidate</span>();<br>            &#125;<br>            nodeCount--;<br>            <span class="hljs-type">int</span> key = z-&gt;key;<br>            <span class="hljs-keyword">delete</span> z;<br>            <span class="hljs-keyword">return</span> key;<br>        &#125;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;Heap is empty&quot;</span>);<br>    &#125;<br><br>    ~<span class="hljs-built_in">FibonacciHeap</span>() &#123;<br>        <span class="hljs-keyword">if</span> (minNode) &#123;<br>            std::vector&lt;Node*&gt; stack;<br>            stack.<span class="hljs-built_in">push_back</span>(minNode);<br>            <span class="hljs-keyword">while</span> (!stack.<span class="hljs-built_in">empty</span>()) &#123;<br>                Node* current = stack.<span class="hljs-built_in">back</span>();<br>                stack.<span class="hljs-built_in">pop_back</span>();<br>                Node* child = current-&gt;child;<br>                <span class="hljs-keyword">if</span> (child) &#123;<br>                    Node* temp = child;<br>                    <span class="hljs-keyword">do</span> &#123;<br>                        stack.<span class="hljs-built_in">push_back</span>(temp);<br>                        temp = temp-&gt;right;<br>                    &#125; <span class="hljs-keyword">while</span> (temp != child);<br>                &#125;<br>                <span class="hljs-keyword">delete</span> current;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    FibonacciHeap heap;<br>    heap.<span class="hljs-built_in">insert</span>(<span class="hljs-number">10</span>);<br>    heap.<span class="hljs-built_in">insert</span>(<span class="hljs-number">5</span>);<br>    heap.<span class="hljs-built_in">insert</span>(<span class="hljs-number">20</span>);<br>    heap.<span class="hljs-built_in">insert</span>(<span class="hljs-number">1</span>);<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Minimum: &quot;</span> &lt;&lt; heap.<span class="hljs-built_in">findMin</span>() &lt;&lt; std::endl; <span class="hljs-comment">// 输出 1</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Extract Min: &quot;</span> &lt;&lt; heap.<span class="hljs-built_in">extractMin</span>() &lt;&lt; std::endl; <span class="hljs-comment">// 输出 1</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;New Minimum: &quot;</span> &lt;&lt; heap.<span class="hljs-built_in">findMin</span>() &lt;&lt; std::endl; <span class="hljs-comment">// 输出 5</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li><p><strong>节点结构</strong>：</p><ul><li>每个节点包含 <code>key</code> 值、度数（<code>degree</code>）、标记状态（<code>marked</code>）、父节点指针（<code>parent</code>）、子节点指针（<code>child</code>）以及左右兄弟指针（<code>left</code> 和 <code>right</code>）。</li></ul></li><li><p><strong>核心操作</strong>：</p><ul><li><code>insert</code>：将新节点插入根链表，并更新最小节点。</li><li><code>findMin</code>：返回当前最小节点的键值。</li><li><code>extractMin</code>：删除最小节点，并重新调整堆结构。</li><li><code>consolidate</code>：通过合并相同度数的树来优化堆结构。</li></ul></li><li><p><strong>辅助函数</strong>：</p><ul><li><code>link</code>：将一个节点作为另一个节点的子节点。</li><li><code>addChild</code>：将子节点添加到父节点的子链表中。</li></ul></li><li><p><strong>析构函数</strong>：</p><ul><li>递归释放所有节点的内存，避免内存泄漏。</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tutorial</tag>
      
      <tag>Tree</tag>
      
      <tag>Finished</tag>
      
      <tag>Data Structure</tag>
      
      <tag>C/C++</tag>
      
      <tag>Binary Heap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Algorithm-Memo</title>
    <link href="/posts/Algorithm-Memo/"/>
    <url>/posts/Algorithm-Memo/</url>
    
    <content type="html"><![CDATA[<style>  html, body, .markdown-body {    font-family: Georgia, sans, serif;  }</style><h1 id="Algorithm-Memo"><a href="#Algorithm-Memo" class="headerlink" title="Algorithm Memo"></a>Algorithm Memo</h1><h2 id="Several-STL-functions"><a href="#Several-STL-functions" class="headerlink" title="Several STL functions"></a>Several STL functions</h2><h3 id="Read-Fast"><a href="#Read-Fast" class="headerlink" title="Read Fast!"></a>Read Fast!</h3><p>Close the synchronous stream if you want to use <code>cin/cout</code>.</p><p>or just simply use the <code>read()</code> func:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">0</span>, f = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">char</span> ch = <span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">while</span> (ch &lt; <span class="hljs-string">&#x27;0&#x27;</span> || ch &gt; <span class="hljs-string">&#x27;9&#x27;</span>) &#123;<br>        <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;-&#x27;</span>) f = <span class="hljs-number">-1</span>;<br>        ch = <span class="hljs-built_in">getchar</span>();<br>    &#125;<br>    <span class="hljs-keyword">while</span> (ch &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) x = x * <span class="hljs-number">10</span> + ch - <span class="hljs-string">&#x27;0&#x27;</span>, ch = <span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">return</span> x * f;<br>&#125;<br></code></pre></td></tr></table></figure><p>Remember to change this if the number is very large:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> x = <span class="hljs-number">0</span>, f = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">char</span> ch = <span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">while</span> (ch &lt; <span class="hljs-string">&#x27;0&#x27;</span> || ch &gt; <span class="hljs-string">&#x27;9&#x27;</span>) &#123;<br>        <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;-&#x27;</span>) f = <span class="hljs-number">-1</span>;<br>        ch = <span class="hljs-built_in">getchar</span>();<br>    &#125;<br>    <span class="hljs-keyword">while</span> (ch &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) x = x * <span class="hljs-number">10</span> + ch - <span class="hljs-string">&#x27;0&#x27;</span>, ch = <span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">return</span> x * f;<br>&#125;<br></code></pre></td></tr></table></figure><p>And you should use <code>cout &lt;&lt; &#39;\n&#39;;</code> instead of <code>cout &lt;&lt; endl;</code>!</p><h3 id="Sort-very-quickly"><a href="#Sort-very-quickly" class="headerlink" title="Sort very quickly"></a>Sort very quickly</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span> <span class="hljs-comment">// 用于 std::rand 和 std::srand</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctime&gt;</span>   <span class="hljs-comment">// 用于 std::time</span></span><br><br><span class="hljs-comment">// 模板函数：快速排序的核心函数，用于分区</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">partition</span><span class="hljs-params">(T* arr, <span class="hljs-type">long</span> <span class="hljs-type">long</span> low, <span class="hljs-type">long</span> <span class="hljs-type">long</span> high)</span> </span>&#123;<br>    <span class="hljs-comment">// 随机选择基准值</span><br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> random_pivot_index = low + <span class="hljs-built_in">rand</span>() % (high - low + <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">swap</span>(arr[low], arr[random_pivot_index]); <span class="hljs-comment">// 将随机选择的基准值放到第一个位置</span><br><br>    <span class="hljs-comment">// 正常的分区逻辑</span><br>    T pivot = arr[low];<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> i = low + <span class="hljs-number">1</span>;  <span class="hljs-comment">// i 指向当前处理的元素</span><br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> j = high;     <span class="hljs-comment">// j 指向末尾元素</span><br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-comment">// 向右移动 i，直到找到大于 pivot 的元素</span><br>        <span class="hljs-keyword">while</span> (i &lt;= j &amp;&amp; arr[i] &lt;= pivot) &#123;<br>            i++;<br>        &#125;<br>        <span class="hljs-comment">// 向左移动 j，直到找到小于等于 pivot 的元素</span><br>        <span class="hljs-keyword">while</span> (i &lt;= j &amp;&amp; arr[j] &gt; pivot) &#123;<br>            j--;<br>        &#125;<br>        <span class="hljs-comment">// 如果 i 和 j 交错，则停止循环</span><br>        <span class="hljs-keyword">if</span> (i &gt;= j) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-comment">// 交换 arr[i] 和 arr[j]</span><br>        <span class="hljs-built_in">swap</span>(arr[i], arr[j]);<br>    &#125;<br>    <span class="hljs-comment">// 将基准值放到正确的位置</span><br>    <span class="hljs-built_in">swap</span>(arr[low], arr[j]);<br>    <span class="hljs-keyword">return</span> j; <span class="hljs-comment">// 返回基准值的最终位置</span><br>&#125;<br><br><span class="hljs-comment">// 模板函数：快速排序的递归实现</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(T* arr, <span class="hljs-type">long</span> <span class="hljs-type">long</span> low, <span class="hljs-type">long</span> <span class="hljs-type">long</span> high)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (low &lt; high) &#123;<br>        <span class="hljs-comment">// 获取分区点</span><br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> pivot_index = <span class="hljs-built_in">partition</span>(arr, low, high);<br>        <span class="hljs-comment">// 对左子数组进行快速排序</span><br>        <span class="hljs-built_in">quick_sort</span>(arr, low, pivot_index - <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 对右子数组进行快速排序</span><br>        <span class="hljs-built_in">quick_sort</span>(arr, pivot_index + <span class="hljs-number">1</span>, high);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Remember to use <code>srand(time(0)); </code> in your <code>main</code> function!</p><h2 id="Several-STL-containers"><a href="#Several-STL-containers" class="headerlink" title="Several STL containers"></a>Several STL containers</h2><h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> SJTU_VECTOR_HPP</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SJTU_VECTOR_HPP</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;exceptions.hpp&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;climits&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstddef&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">namespace</span> sjtu &#123;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * a data container like std::vector</span><br><span class="hljs-comment"> * store data in a successive memory and support random access.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">vector</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    T *data; <span class="hljs-comment">// for data storage</span><br>    <span class="hljs-type">size_t</span> current_size; <span class="hljs-comment">// the size of vector</span><br>    <span class="hljs-type">size_t</span> max_size; <span class="hljs-comment">// default value is 16</span><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * @brief expand the memory (the maxsize and data) to its double size</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * just expand the memory without allocating new members</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">expandDouble</span><span class="hljs-params">()</span> </span>&#123;<br>        std::allocator&lt;T&gt; alloc;<br>        <span class="hljs-type">size_t</span> new_max_size = max_size * <span class="hljs-number">2</span>;<br>        T* new_data = alloc.<span class="hljs-built_in">allocate</span>(new_max_size);<br><br>        <span class="hljs-comment">// move to the new memory space</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; current_size; ++i) &#123;<br>            std::<span class="hljs-built_in">construct_at</span>(new_data + i, std::<span class="hljs-built_in">move</span>(data[i]));<br>            std::<span class="hljs-built_in">destroy_at</span>(data + i);<br>        &#125;<br><br>        <span class="hljs-comment">// release old memory</span><br>        <span class="hljs-keyword">if</span> (data) &#123;<br>            alloc.<span class="hljs-built_in">deallocate</span>(data, max_size);<br>        &#125;<br><br>        <span class="hljs-comment">// update the pointer</span><br>        data = new_data;<br>        new_data = <span class="hljs-literal">nullptr</span>;<br>        max_size = new_max_size;<br>    &#125;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * @brief Tool function, delete all the elements but does not free the memory</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span> </span>&#123;<br>        std::allocator&lt;T&gt; alloc;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; current_size; ++i) &#123;<br>            std::<span class="hljs-built_in">destroy_at</span>(data + i);<br>        &#125;<br>        current_size = <span class="hljs-number">0</span>;<br>    &#125;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">const_iterator</span>;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">iterator</span> &#123;<br>        <span class="hljs-comment">// The following code is written for the C++ type_traits library.</span><br>        <span class="hljs-comment">// Type traits is a C++ feature for describing certain properties of a type.</span><br>        <span class="hljs-comment">// For instance, for an iterator, iterator::value_type is the type that the</span><br>        <span class="hljs-comment">// iterator points to.</span><br>        <span class="hljs-comment">// STL algorithms and containers may use these type_traits (e.g. the following</span><br>        <span class="hljs-comment">// typedef) to work properly. In particular, without the following code,</span><br>        <span class="hljs-comment">// @code&#123;std::sort(iter, iter1);&#125; would not compile.</span><br>        <span class="hljs-comment">// See these websites for more information:</span><br>        <span class="hljs-comment">// https://en.cppreference.com/w/cpp/header/type_traits</span><br>        <span class="hljs-comment">// About value_type: https://blog.csdn.net/u014299153/article/details/72419713</span><br>        <span class="hljs-comment">// About iterator_category: https://en.cppreference.com/w/cpp/iterator</span><br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-keyword">using</span> difference_type = std::<span class="hljs-type">ptrdiff_t</span>;<br>        <span class="hljs-keyword">using</span> value_type = T;<br>        <span class="hljs-keyword">using</span> pointer = T*;<br>        <span class="hljs-keyword">using</span> reference = T&amp;;<br>        <span class="hljs-keyword">using</span> iterator_category = std::output_iterator_tag;<br><br>    <span class="hljs-keyword">private</span>:<br>        T* ptr; <span class="hljs-comment">// the pointer</span><br>        vector&lt;T&gt;* which_vector; <span class="hljs-comment">// judge whether two pointers are pointing to the same vector</span><br><br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-comment">// constructor</span><br>        <span class="hljs-built_in">iterator</span>(T* ptr_, vector&lt;T&gt;* which_vec) : <span class="hljs-built_in">ptr</span>(ptr_), <span class="hljs-built_in">which_vector</span>(which_vec) &#123;&#125;<br><br>        iterator <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; n) <span class="hljs-type">const</span> &#123;<br>            iterator tmp = <span class="hljs-built_in">iterator</span>(ptr + n, <span class="hljs-keyword">this</span>-&gt;which_vector);<br>            <span class="hljs-keyword">if</span> (tmp &lt; (*which_vector).<span class="hljs-built_in">begin</span>() || (*which_vector).<span class="hljs-built_in">end</span>() &lt; tmp) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-built_in">invalid_iterator</span>();<br>            &#125;<br>            <span class="hljs-keyword">return</span> tmp;<br>        &#125;<br><br>        iterator <span class="hljs-keyword">operator</span>-(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; n) <span class="hljs-type">const</span> &#123;<br>            iterator tmp = <span class="hljs-built_in">iterator</span>(ptr - n, <span class="hljs-keyword">this</span>-&gt;which_vector);<br>            <span class="hljs-keyword">if</span> (tmp &lt; (*which_vector).<span class="hljs-built_in">begin</span>() || (*which_vector).<span class="hljs-built_in">end</span>() &lt; tmp) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-built_in">invalid_iterator</span>();<br>            &#125;<br>            <span class="hljs-keyword">return</span> tmp;<br>        &#125;<br><br>        <span class="hljs-comment">// return the distance between two iterators,</span><br>        <span class="hljs-comment">// if these two iterators point to different vectors, throw invalid_iterator.</span><br>        <span class="hljs-type">int</span> <span class="hljs-keyword">operator</span>-(<span class="hljs-type">const</span> iterator&amp; rhs) <span class="hljs-type">const</span> &#123;<br>            <span class="hljs-keyword">if</span> (which_vector != rhs.which_vector) &#123;<br>                <span class="hljs-comment">// two iterators point to different vectors!</span><br>                <span class="hljs-keyword">throw</span> <span class="hljs-built_in">invalid_iterator</span>();<br>            &#125;<br>            <span class="hljs-keyword">return</span> ptr - rhs.ptr;<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * @brief let the iterator to move towards n steps</span><br><span class="hljs-comment">         * </span><br><span class="hljs-comment">         * @param n </span><br><span class="hljs-comment">         * @return iterator&amp; </span><br><span class="hljs-comment">         */</span><br>        iterator&amp; <span class="hljs-keyword">operator</span>+=(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; n) &#123;<br>            ptr += n; <span class="hljs-comment">// movement</span><br>            <span class="hljs-keyword">if</span> (*<span class="hljs-keyword">this</span> &lt; (*which_vector).<span class="hljs-built_in">begin</span>() || (*which_vector).<span class="hljs-built_in">end</span>() &lt; *<span class="hljs-keyword">this</span>) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-built_in">invalid_iterator</span>();<br>            &#125;<br>            <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>        &#125;<br><br>        iterator&amp; <span class="hljs-keyword">operator</span>-=(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; n) &#123;<br>            ptr = ptr - n;<br>            <span class="hljs-keyword">if</span> (*<span class="hljs-keyword">this</span> &lt; (*which_vector).<span class="hljs-built_in">begin</span>() || (*which_vector).<span class="hljs-built_in">end</span>() &lt; *<span class="hljs-keyword">this</span>) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-built_in">invalid_iterator</span>();<br>            &#125;<br>            <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>        &#125;<br><br>        iterator <span class="hljs-keyword">operator</span>++(<span class="hljs-type">int</span>) &#123;<br>            iterator temp = *<span class="hljs-keyword">this</span>;<br>            ++ptr;<br>            <span class="hljs-keyword">return</span> temp;<br>        &#125;<br><br>        iterator&amp; <span class="hljs-keyword">operator</span>++() &#123;<br>            ++ptr;<br>            <span class="hljs-keyword">if</span> (*<span class="hljs-keyword">this</span> &lt; (*which_vector).<span class="hljs-built_in">begin</span>() || (*which_vector).<span class="hljs-built_in">end</span>() &lt; *<span class="hljs-keyword">this</span>) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-built_in">invalid_iterator</span>();<br>            &#125;<br>            <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>        &#125;<br><br>        iterator <span class="hljs-keyword">operator</span>--(<span class="hljs-type">int</span>) &#123;<br>            iterator tmp = *<span class="hljs-keyword">this</span>;<br>            --ptr;<br>            <span class="hljs-keyword">return</span> tmp;<br>        &#125;<br><br>        iterator <span class="hljs-keyword">operator</span>--() &#123;<br>            --ptr;<br>            <span class="hljs-keyword">if</span> (*<span class="hljs-keyword">this</span> &lt; (*which_vector).<span class="hljs-built_in">begin</span>() || (*which_vector).<span class="hljs-built_in">end</span>() &lt; *<span class="hljs-keyword">this</span>) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-built_in">invalid_iterator</span>();<br>            &#125;<br>            <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>        &#125;<br><br>        T&amp; <span class="hljs-keyword">operator</span>*() <span class="hljs-type">const</span> &#123;<br>            <span class="hljs-keyword">return</span> *ptr;<br>        &#125;<br><br>        <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> iterator&amp; rhs) <span class="hljs-type">const</span> &#123;<br>            <span class="hljs-built_in">return</span> (which_vector == rhs.which_vector) &amp;&amp; (ptr == rhs.ptr);<br>        &#125;<br><br>        <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> const_iterator&amp; rhs) <span class="hljs-type">const</span> &#123;<br>            <span class="hljs-built_in">return</span> (which_vector == rhs.which_vector) &amp;&amp; (ptr == rhs.ptr);<br>        &#125;<br><br>        <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-type">const</span> iterator&amp; rhs) <span class="hljs-type">const</span> &#123;<br>            <span class="hljs-keyword">return</span> !(*<span class="hljs-keyword">this</span> == rhs);<br>        &#125;<br><br>        <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-type">const</span> const_iterator&amp; rhs) <span class="hljs-type">const</span> &#123;<br>            <span class="hljs-keyword">return</span> !(*<span class="hljs-keyword">this</span> == rhs);<br>        &#125;<br><br>        <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> iterator&amp; rhs) <span class="hljs-type">const</span> &#123;<br>            <span class="hljs-keyword">return</span> (*<span class="hljs-keyword">this</span> - rhs) &lt; <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">const_iterator</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-keyword">using</span> difference_type = std::<span class="hljs-type">ptrdiff_t</span>;<br>        <span class="hljs-keyword">using</span> value_type = T;<br>        <span class="hljs-keyword">using</span> pointer = T*;<br>        <span class="hljs-keyword">using</span> reference = T&amp;;<br>        <span class="hljs-keyword">using</span> iterator_category = std::output_iterator_tag;<br><br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-type">const</span> T* ptr;<br>        <span class="hljs-type">const</span> vector&lt;T&gt;* which_vector;<br><br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">const_iterator</span>(<span class="hljs-type">const</span> T* p, <span class="hljs-type">const</span> vector&lt;T&gt;* which_vec) : <span class="hljs-built_in">ptr</span>(p), <span class="hljs-built_in">which_vector</span>(which_vec) &#123;&#125;<br><br>        const_iterator <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> <span class="hljs-type">int</span> n) <span class="hljs-type">const</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">const_iterator</span>(ptr + n);<br>        &#125;<br><br>        const_iterator <span class="hljs-keyword">operator</span>-(<span class="hljs-type">const</span> <span class="hljs-type">int</span> n) <span class="hljs-type">const</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">const_iterator</span>(ptr - n);<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-keyword">operator</span>-(<span class="hljs-type">const</span> const_iterator&amp; rhs) <span class="hljs-type">const</span> &#123;<br>            <span class="hljs-keyword">if</span> (which_vector != rhs.which_vector) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-built_in">invalid_iterator</span>();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> ptr - rhs.ptr;<br>            &#125;<br>        &#125;<br><br>        const_iterator&amp; <span class="hljs-keyword">operator</span>+=(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; n) &#123;<br>            ptr = ptr + n;<br>            <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>        &#125;<br><br>        const_iterator&amp; <span class="hljs-keyword">operator</span>-=(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; n) &#123;<br>            ptr = ptr - n;<br>            <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>        &#125;<br><br>        const_iterator <span class="hljs-keyword">operator</span>++(<span class="hljs-type">int</span>) &#123;<br>            const_iterator temp = *<span class="hljs-keyword">this</span>;<br>            ++ptr;<br>            <span class="hljs-keyword">return</span> temp;<br>        &#125;<br><br>        const_iterator&amp; <span class="hljs-keyword">operator</span>++() &#123;<br>            ++ptr;<br>            <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>        &#125;<br><br>        const_iterator <span class="hljs-keyword">operator</span>--() &#123;<br>            --ptr;<br>            <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>        &#125;<br><br>        const_iterator <span class="hljs-keyword">operator</span>--(<span class="hljs-type">int</span>) &#123;<br>            const_iterator tmp = *<span class="hljs-keyword">this</span>;<br>            --ptr;<br>            <span class="hljs-keyword">return</span> tmp;<br>        &#125;<br><br>        T <span class="hljs-keyword">operator</span>*() <span class="hljs-type">const</span> &#123;<br>            <span class="hljs-keyword">return</span> *ptr;<br>        &#125;<br><br>        <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> const_iterator&amp; rhs) <span class="hljs-type">const</span> &#123;<br>            <span class="hljs-keyword">return</span> ptr == rhs.ptr;<br>        &#125;<br><br>        <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> iterator&amp; rhs) <span class="hljs-type">const</span> &#123;<br>            <span class="hljs-keyword">return</span> ptr == rhs.ptr;<br>        &#125;<br><br>        <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-type">const</span> iterator&amp; rhs) <span class="hljs-type">const</span> &#123;<br>            <span class="hljs-keyword">return</span> !(*<span class="hljs-keyword">this</span> == rhs);<br>        &#125;<br><br>        <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-type">const</span> const_iterator&amp; rhs) <span class="hljs-type">const</span> &#123;<br>            <span class="hljs-keyword">return</span> !(*<span class="hljs-keyword">this</span> == rhs);<br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * @brief Construct a new vector object (default)</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-built_in">vector</span>() : <span class="hljs-built_in">current_size</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">max_size</span>(<span class="hljs-number">16</span>) &#123;<br>        <span class="hljs-comment">// default</span><br>        std::allocator&lt;T&gt; alloc;<br>        data = alloc.<span class="hljs-built_in">allocate</span>(max_size);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * @brief Construct a new vector object</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param size_</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-built_in">vector</span>(<span class="hljs-type">size_t</span> size_) &#123;<br>        current_size = <span class="hljs-number">0</span>;<br>        max_size = (current_size &lt; <span class="hljs-number">16</span>) ? <span class="hljs-number">16</span> : current_size;<br>        std::allocator&lt;T&gt; alloc;<br>        data = alloc.<span class="hljs-built_in">allocate</span>(max_size);<br>    &#125;<br><br>    <span class="hljs-built_in">vector</span>(<span class="hljs-type">const</span> vector&amp; other) &#123;<br>        current_size = other.current_size;<br>        max_size = other.max_size;<br>        std::allocator&lt;T&gt; alloc;<br>        data = alloc.<span class="hljs-built_in">allocate</span>(max_size);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; current_size; ++i) &#123;<br>            std::<span class="hljs-built_in">construct_at</span>(data + i, other.data[i]);<br>        &#125;<br>    &#125;<br><br>    ~<span class="hljs-built_in">vector</span>() &#123;<br>        <span class="hljs-built_in">clear</span>(); <span class="hljs-comment">// destroy all data, not release memory</span><br>        <span class="hljs-keyword">if</span> (data) &#123;<br>            std::allocator&lt;T&gt; alloc;<br>            alloc.<span class="hljs-built_in">deallocate</span>(data, max_size);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * @brief assignment operator</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param other </span><br><span class="hljs-comment">     * @return vector&amp; the assigned operator</span><br><span class="hljs-comment">     */</span><br>    vector&lt;T&gt;&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> vector&amp; other) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;other) &#123;<br>            <span class="hljs-built_in">clear</span>();<br>            std::allocator&lt;T&gt; alloc;<br>            <span class="hljs-keyword">if</span> (data) &#123;<br>                alloc.<span class="hljs-built_in">deallocate</span>(data, max_size);<br>            &#125;<br>            data = alloc.<span class="hljs-built_in">allocate</span>(other.max_size);<br>            max_size = other.max_size;<br>            current_size = other.current_size;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; current_size; ++i) &#123;<br>                std::<span class="hljs-built_in">construct_at</span>(data + i, other.data[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * assigns specified element with bounds checking</span><br><span class="hljs-comment">     * throw index_out_of_bound if pos is not in [0, size)</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">T&amp; <span class="hljs-title">at</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">size_t</span>&amp; pos)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (pos &lt; <span class="hljs-number">0</span> || pos &gt;= current_size) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">index_out_of_bound</span>();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> data[pos];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">const</span> T&amp; <span class="hljs-title">at</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">size_t</span>&amp; pos)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (pos &lt; <span class="hljs-number">0</span> || pos &gt;= current_size) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">index_out_of_bound</span>();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> data[pos];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * assigns specified element with bounds checking</span><br><span class="hljs-comment">     * throw index_out_of_bound if pos is not in [0, size)</span><br><span class="hljs-comment">     * !!! Pay attentions</span><br><span class="hljs-comment">     *   In STL this operator does not check the boundary but I want you to do.</span><br><span class="hljs-comment">     */</span><br>    T&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">const</span> <span class="hljs-type">size_t</span>&amp; pos) &#123;<br>        <span class="hljs-keyword">if</span> (pos &lt; <span class="hljs-number">0</span> &amp;&amp; pos &gt;= current_size) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">index_out_of_bound</span>();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> data[pos];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-type">const</span> T&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">const</span> <span class="hljs-type">size_t</span>&amp; pos) <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">if</span> (pos &lt; <span class="hljs-number">0</span> &amp;&amp; pos &gt;= current_size) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">index_out_of_bound</span>();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> data[pos];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * access the first element.</span><br><span class="hljs-comment">     * throw container_is_empty if size == 0</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">const</span> T&amp; <span class="hljs-title">front</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (current_size == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">container_is_empty</span>();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> data[<span class="hljs-number">0</span>];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * access the last element.</span><br><span class="hljs-comment">     * throw container_is_empty if size == 0</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">const</span> T&amp; <span class="hljs-title">back</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (current_size == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">container_is_empty</span>();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> data[current_size - <span class="hljs-number">1</span>];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * returns an iterator to the beginning.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">iterator <span class="hljs-title">begin</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">container_is_empty</span>();<br>        &#125;<br>        <span class="hljs-function">iterator <span class="hljs-title">tmp</span><span class="hljs-params">(data, <span class="hljs-keyword">this</span>)</span></span>;<br>        <span class="hljs-keyword">return</span> tmp;<br>    &#125;<br><br>    <span class="hljs-function">const_iterator <span class="hljs-title">begin</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">container_is_empty</span>();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            const_iterator <span class="hljs-built_in">tmp</span>(data, <span class="hljs-keyword">this</span>);<br>            <span class="hljs-keyword">return</span> tmp;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function">const_iterator <span class="hljs-title">cbegin</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">container_is_empty</span>();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            const_iterator <span class="hljs-built_in">tmp</span>(data, <span class="hljs-keyword">this</span>);<br>            <span class="hljs-keyword">return</span> tmp;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * returns an iterator to the end.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">iterator <span class="hljs-title">end</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">container_is_empty</span>();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            iterator <span class="hljs-built_in">tmp</span>(data + current_size, <span class="hljs-keyword">this</span>);<br>            <span class="hljs-keyword">return</span> tmp;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function">const_iterator <span class="hljs-title">end</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">container_is_empty</span>();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            const_iterator <span class="hljs-built_in">tmp</span>(data + current_size, <span class="hljs-keyword">this</span>);<br>            <span class="hljs-keyword">return</span> tmp;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function">const_iterator <span class="hljs-title">cend</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">container_is_empty</span>();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            const_iterator <span class="hljs-built_in">tmp</span>(data + current_size, <span class="hljs-keyword">this</span>);<br>            <span class="hljs-keyword">return</span> tmp;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * checks whether the container is empty</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> current_size == <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * returns the number of elements</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> current_size;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * inserts value before pos</span><br><span class="hljs-comment">     * returns an iterator pointing to the inserted value.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">iterator <span class="hljs-title">insert</span><span class="hljs-params">(iterator pos, <span class="hljs-type">const</span> T&amp; value)</span> </span>&#123;<br>        <span class="hljs-comment">// getting the inserted index</span><br>        <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> index = pos - (<span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">begin</span>());<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">insert</span>(index, value);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * inserts value at index ind.</span><br><span class="hljs-comment">     * after inserting, this-&gt;at(ind) == value</span><br><span class="hljs-comment">     * returns an iterator pointing to the inserted value.</span><br><span class="hljs-comment">     * throw index_out_of_bound if ind &gt; size (in this situation ind can be size because after inserting the size will increase 1.)</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">iterator <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">size_t</span>&amp; pos, <span class="hljs-type">const</span> T&amp; value)</span> </span>&#123;<br>        <span class="hljs-comment">//check if it is valid</span><br>        <span class="hljs-keyword">if</span> (pos &gt; current_size) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">index_out_of_bound</span>();<br>        &#125;<br>        <span class="hljs-comment">//expand memory</span><br>        <span class="hljs-keyword">if</span> (current_size == max_size) &#123;<br>            <span class="hljs-built_in">expandDouble</span>();<br>        &#125;<br>        std::<span class="hljs-built_in">construct_at</span>(data + current_size, value);<br><br>        <span class="hljs-comment">//move backwards</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = current_size; i &gt; pos; --i) &#123;<br>            data[i] = std::<span class="hljs-built_in">move</span>(data[i - <span class="hljs-number">1</span>]);<br>        &#125;<br><br>        <span class="hljs-comment">//create a new element</span><br>        data[pos] = value;<br>        ++current_size;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">begin</span>() + pos;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * removes the element at pos.</span><br><span class="hljs-comment">     * return an iterator pointing to the following element.</span><br><span class="hljs-comment">     * If the iterator pos refers the last element, the end() iterator is returned.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">iterator <span class="hljs-title">erase</span><span class="hljs-params">(iterator pos)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (pos == <span class="hljs-built_in">end</span>()) &#123;<br>            <span class="hljs-comment">// like the push back</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">end</span>();<br>        &#125;<br>        iterator next_pos = pos + <span class="hljs-number">1</span>;<br>        std::<span class="hljs-built_in">move</span>(next_pos, <span class="hljs-built_in">end</span>(), pos);<br><br>        <span class="hljs-comment">// update the vector</span><br>        std::<span class="hljs-built_in">destroy_at</span>(data + current_size - <span class="hljs-number">1</span>);<br>        --current_size;<br>        <span class="hljs-keyword">return</span> pos;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * removes the element with index ind.</span><br><span class="hljs-comment">     * return an iterator pointing to the following element.</span><br><span class="hljs-comment">     * throw index_out_of_bound if ind &gt;= size</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">iterator <span class="hljs-title">erase</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">size_t</span>&amp; ind)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (ind &gt;= current_size) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">index_out_of_bound</span>();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            std::<span class="hljs-built_in">move</span>(data + ind + <span class="hljs-number">1</span>, data + current_size, data + ind);<br>            std::<span class="hljs-built_in">destroy_at</span>(data + current_size - <span class="hljs-number">1</span>);<br>            --current_size;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">begin</span>() + ind;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * adds an element to the end.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_back</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; value)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (current_size == max_size) &#123;<br>            <span class="hljs-comment">// needs to expand</span><br>            <span class="hljs-built_in">expandDouble</span>();<br>        &#125;<br>        std::<span class="hljs-built_in">construct_at</span>(data + current_size, value);<br>        ++current_size;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * remove the last element from the end.</span><br><span class="hljs-comment">     * throw container_is_empty if size() == 0</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop_back</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">container_is_empty</span>();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            std::<span class="hljs-built_in">destroy_at</span>(data + current_size - <span class="hljs-number">1</span>);<br>            --current_size;<br>        &#125;<br>    &#125;<br>&#125;;<br><br>&#125; <span class="hljs-comment">// namespace sjtu</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 顺序循环队列类的定义及基本操作实现</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> SEQQUEUE_H_INCLUDED</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SEQQUEUE_H_INCLUDED</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">illegalSize</span>&#123;&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">outOfBound</span>&#123;&#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">seqQueue</span><br>&#123;    <br>    <span class="hljs-keyword">private</span>:<br>        elemType *array;<br>        <span class="hljs-type">int</span> maxSize;<br>        <span class="hljs-type">int</span> Front, Rear;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doubleSpace</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//扩展队队列元素的存储空间为原来的2倍</span><br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">seqQueue</span>(<span class="hljs-type">int</span> size=<span class="hljs-number">10</span>); <span class="hljs-comment">//初始化队列元素的存储空间</span><br>        <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//判断队空否，空返回true，否则为false</span><br>        <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isFull</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">//判断队满否，满返回true，否则为false</span><br>        <span class="hljs-function">elemType <span class="hljs-title">front</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//读取队首元素的值，队首不变</span><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">enQueue</span><span class="hljs-params">(<span class="hljs-type">const</span> elemType &amp;x)</span></span>; <span class="hljs-comment">//将x进队，成为新的队尾</span><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deQueue</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//将队首元素出队</span><br>        ~<span class="hljs-built_in">seqQueue</span>(); <span class="hljs-comment">//释放队列元素所占据的动态数组</span><br>&#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br>seqQueue&lt;elemType&gt;::<span class="hljs-built_in">seqQueue</span>(<span class="hljs-type">int</span> size) <span class="hljs-comment">//初始化队列元素的存储空间</span><br>&#123;<br>    array = <span class="hljs-keyword">new</span> elemType[size]; <span class="hljs-comment">//申请实际的队列存储空间</span><br><br>    <span class="hljs-keyword">if</span> (!array) <span class="hljs-keyword">throw</span> <span class="hljs-built_in">illegalSize</span>();<br><br>    maxSize = size;<br>    Front = Rear = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-type">bool</span> seqQueue&lt;elemType&gt;::<span class="hljs-built_in">isEmpty</span>() <span class="hljs-comment">//判断队空否，空返回 true,否则为false</span><br>&#123;<br>    <span class="hljs-keyword">return</span> Front == Rear;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-type">bool</span> seqQueue&lt;elemType&gt;::<span class="hljs-built_in">isFull</span>() <span class="hljs-comment">//判断队满否，满返回 true,否则为false</span><br>&#123;<br>    <span class="hljs-keyword">return</span> (Rear<span class="hljs-number">+1</span>)%maxSize == Front;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br>elemType seqQueue&lt;elemType&gt;::<span class="hljs-built_in">front</span>() <span class="hljs-comment">//读取队首元素的值，队首不变</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isEmpty</span>()) <span class="hljs-keyword">throw</span> <span class="hljs-built_in">outOfBound</span>(); <span class="hljs-comment">//先判断</span><br><br>    <span class="hljs-keyword">return</span> array[Front]; <br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-type">void</span> seqQueue&lt;elemType&gt;::<span class="hljs-built_in">enQueue</span>(<span class="hljs-type">const</span> elemType &amp;x)  <span class="hljs-comment">//将x进队，成为新的队尾</span><br>&#123;  <br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isFull</span>()) <span class="hljs-built_in">doubleSpace</span>();<br><br>    array[Rear] = x;<br>    Rear = (Rear<span class="hljs-number">+1</span>)%maxSize;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-type">void</span> seqQueue&lt;elemType&gt;::<span class="hljs-built_in">deQueue</span>() <span class="hljs-comment">//将队首元素出队</span><br>&#123;  <br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isEmpty</span>()) <span class="hljs-keyword">throw</span> <span class="hljs-built_in">outOfBound</span>();<br><br>    Front = (Front<span class="hljs-number">+1</span>)%maxSize;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br>seqQueue&lt;elemType&gt;::~<span class="hljs-built_in">seqQueue</span>() <span class="hljs-comment">//释放队列元素所占据的动态数组</span><br>&#123; <br>    <span class="hljs-keyword">delete</span> []array;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-type">void</span> seqQueue&lt;elemType&gt;::<span class="hljs-built_in">doubleSpace</span>() <span class="hljs-comment">//扩展队列元素的存储空间为原来的2倍</span><br>&#123;<br>    elemType* newArray;<br>    <span class="hljs-type">int</span> i, j;<br><br>    newArray = <span class="hljs-keyword">new</span> elemType[<span class="hljs-number">2</span>*maxSize];<br>    <span class="hljs-keyword">if</span> (!newArray) <span class="hljs-keyword">throw</span> <span class="hljs-built_in">illegalSize</span>();<br><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, j = Front; j != Rear; i++, j = (j<span class="hljs-number">+1</span>)%maxSize) <span class="hljs-comment">//直接重排</span><br>        newArray[i] = array[j];<br><br>    <span class="hljs-keyword">delete</span> []array; <span class="hljs-comment">//释放原来的小空间</span><br><br>    array = newArray;<br>    Front = <span class="hljs-number">0</span>;<br>    Rear = i;<br>    maxSize = <span class="hljs-number">2</span>*maxSize;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><h3 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 顺序栈结构定义及基本操作的实现</span><br><br><span class="hljs-comment">// 顺序栈的描述：数组指针array，数组大小maxSize，栈顶下标Top</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">illegalSize</span>&#123;&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">outOfBound</span>&#123;&#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">seqStack</span><br>&#123;  <br>    <span class="hljs-keyword">private</span>:<br>        elemType *array;    <span class="hljs-comment">//栈存储数组，存放实际的数据元素。</span><br>        <span class="hljs-type">int</span> Top;            <span class="hljs-comment">//栈顶下标。</span><br>        <span class="hljs-type">int</span> maxSize;    <span class="hljs-comment">//栈中最多能存放的元素个数。</span><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doubleSpace</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">seqStack</span>(<span class="hljs-type">int</span> initSize = <span class="hljs-number">100</span>); <span class="hljs-comment">//初始化顺序栈</span><br>        <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span></span>&#123; <span class="hljs-keyword">return</span> (Top == <span class="hljs-number">-1</span> ); &#125; ; <span class="hljs-comment">//栈空返回true,否则返回false</span><br>        <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isFull</span><span class="hljs-params">()</span></span>&#123; <span class="hljs-keyword">return</span> (Top == maxSize<span class="hljs-number">-1</span>); &#125;; <span class="hljs-comment">//栈满返回true,否则返回false</span><br>        <span class="hljs-function">elemType <span class="hljs-title">top</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//返回栈顶元素的值，不改变栈顶</span><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">const</span> elemType &amp;e)</span></span>; <span class="hljs-comment">//将元素e压入栈顶，使其成为新的栈顶</span><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//将栈顶元素弹栈</span><br>        ~<span class="hljs-built_in">seqStack</span>()&#123; <span class="hljs-keyword">delete</span> []array; &#125;; <span class="hljs-comment">//释放栈占用的动态数组</span><br>&#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br>seqStack&lt;elemType&gt;::<span class="hljs-built_in">seqStack</span>(<span class="hljs-type">int</span> initSize)<span class="hljs-comment">//初始化顺序栈</span><br>&#123;<br>    array = <span class="hljs-keyword">new</span> elemType[initSize];<br><br><span class="hljs-keyword">if</span> (!array) <span class="hljs-keyword">throw</span> <span class="hljs-built_in">illegalSize</span>();<br><br>Top = <span class="hljs-number">-1</span>;    <br>    maxSize = initSize;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-type">void</span> seqStack&lt;elemType&gt;::<span class="hljs-built_in">doubleSpace</span>() <span class="hljs-comment">//分配2倍的空间</span><br>&#123;<br>    elemType *tmp;<br>    <span class="hljs-type">int</span> i;<br><br>    tmp = <span class="hljs-keyword">new</span> elemType[maxSize*<span class="hljs-number">2</span>];<br><br>    <span class="hljs-keyword">if</span> (!tmp) <span class="hljs-keyword">throw</span> <span class="hljs-built_in">illegalSize</span>();<br><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt;= Top; i++)<br>        tmp[i] = array[i];<br><br>    <span class="hljs-keyword">delete</span> []array;<br>    array = tmp;<br>    maxSize = <span class="hljs-number">2</span>*maxSize;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br>elemType seqStack&lt;elemType&gt;::<span class="hljs-built_in">top</span> () <span class="hljs-comment">//返回栈顶元素的值，不改变栈顶</span><br>&#123;   <br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isEmpty</span>()) <span class="hljs-keyword">throw</span> <span class="hljs-built_in">outOfBound</span>();<br><br>    <span class="hljs-keyword">return</span> array[Top];<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-type">void</span> seqStack&lt;elemType&gt;::<span class="hljs-built_in">push</span>(<span class="hljs-type">const</span> elemType &amp;e )<br><span class="hljs-comment">//将元素e压入栈顶，使其成为新的栈顶元素</span><br>&#123;     <br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isFull</span>()) <span class="hljs-built_in">doubleSpace</span>(); <span class="hljs-comment">//栈满时重新分配2倍的空间，并将原空间内容拷入</span><br>      <br>    array[++Top] = e; <span class="hljs-comment">// 新结点放入新的栈顶位置。</span><br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-type">void</span> seqStack&lt;elemType&gt;::<span class="hljs-built_in">pop</span>() <span class="hljs-comment">//将栈顶元素弹栈</span><br>&#123;  <br>    <span class="hljs-keyword">if</span> (Top == <span class="hljs-number">-1</span>) <span class="hljs-keyword">throw</span> <span class="hljs-built_in">outOfBound</span>();<br><br>    Top--; <span class="hljs-comment">//不管此元素</span><br>&#125;<br><br><span class="hljs-comment">// 函数initialize(seqStack)、isEmpty、isFull、top、pop、destroy（~seqStack）的时间复杂度均为O(1)</span><br><span class="hljs-comment">// push因某时可能扩大空间，造成O(n)时间消耗，但按照“分期付款式”法，分摊到单次的插入操作，时间复杂度仍为O(1)</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tutorial</tag>
      
      <tag>Data Structure</tag>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DataStructure-Stack-Queue-Advanced</title>
    <link href="/posts/DataStructure-Stack-Queue-Advanced/"/>
    <url>/posts/DataStructure-Stack-Queue-Advanced/</url>
    
    <content type="html"><![CDATA[<style>  html, body, .markdown-body {    font-family: Georgia, sans, serif;  }</style><h1 id="Stack-and-Queue-Advanced"><a href="#Stack-and-Queue-Advanced" class="headerlink" title="Stack and Queue: Advanced"></a>Stack and Queue: Advanced</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><ul><li>Increasing &#x2F; Decreasing stack</li><li>Increasing &#x2F; Decreasing queue</li><li>simulation of recursion using stack</li></ul><h2 id="Increasing-Stack"><a href="#Increasing-Stack" class="headerlink" title="Increasing Stack"></a>Increasing Stack</h2><p>I just use Chinese…</p><p><strong>基本思路</strong>：在线性扫描一个数组的时候，维护一个单调栈（可以是单调递增的，也可以是单调递减的，甚至可以是自己定义的一些<code>compare_function</code>）。以单调递减栈为例，为了保证单调性不被破坏，我们需要做一下操作：</p><ul><li>首先将第一个元素入栈，all is well</li><li>接着讲新的元素不断入栈：<ul><li>如果栈的<strong>单调递减性质</strong>未被打破，那么正常入栈</li><li>如果栈的<strong>单调递减性质</strong>被打破，意味着<strong>将要入栈的元素小于栈顶元素</strong>：<ul><li>那就开始弹出栈顶元素，直到变成情况1！</li></ul></li></ul></li><li>完成所有的扫描工作</li></ul><p>经过$O(n)$的线性扫描之后，我们可以得到这样的性质：</p><ul><li><p>对于将要入栈的元素，我们可以找到<strong>第一个比该元素小的元素</strong>即为栈顶元素。</p><ul><li>因为所有比该元素大的元素都会储存在栈中。</li></ul><blockquote><p>这一条并不常用，也可以采用反向再遍历一遍的笨方法。</p></blockquote></li><li><p>对于栈顶元素，我们可以找到<strong>第一个比栈顶元素大的</strong>的元素即为那个导致其被弹出的入栈元素。</p><ul><li>也就是在该元素（栈顶元素）右边第一个大于栈顶元素的元素索引！</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @Author: Xiyuan Yang   xiyuan_yang@outlook.com</span><br><span class="hljs-comment"> * @Date: 2025-03-23 11:47:09</span><br><span class="hljs-comment"> * @LastEditors: Xiyuan Yang   xiyuan_yang@outlook.com</span><br><span class="hljs-comment"> * @LastEditTime: 2025-03-23 15:04:18</span><br><span class="hljs-comment"> * @FilePath: /20250316_stack_and_queue/template_stack.cpp</span><br><span class="hljs-comment"> * @Description: Template of increasing stack</span><br><span class="hljs-comment"> * Do you code and make progress today?</span><br><span class="hljs-comment"> * Copyright (c) 2025 by Xiyuan Yang, All Rights Reserved. </span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">template of increasing stack</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> size = <span class="hljs-number">10</span>;<br>    <span class="hljs-comment">//the list that needs to be scanned</span><br>    <span class="hljs-type">int</span> *list = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[size];<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; ++i)&#123;<br>        std::cin &gt;&gt; list[i];<br>    &#125;<br><br>    <span class="hljs-comment">//the simulation of stack using traditional array</span><br>    <span class="hljs-comment">//the stack stores the index of several numbers, but not the value of them!</span><br>    <span class="hljs-type">int</span> *st = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[size];<br>    <span class="hljs-type">int</span> top = <span class="hljs-number">0</span>;<br>    st[top] = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-comment">//模版目标：找到每一个元素后面第一个比其大的元素，如果不存在则为-1</span><br>    <span class="hljs-type">int</span> *ans = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[size];<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    在此处使用了单调递减的栈，可以找到其后面第一个比其大的元素</span><br><span class="hljs-comment">    同理，使用单调递增栈，可以找到其后面第一个比其小的元素</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    当然也可以自定义其他的比较函数，那么while循环里面的内容就需要更改</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; size; i++)&#123;<br>        <span class="hljs-comment">//the stack is not empty and maintain the increasing sequence</span><br>        <span class="hljs-keyword">while</span>(top &gt;= <span class="hljs-number">0</span> &amp;&amp; list[st[top]] &lt; list[i])&#123;<br>            <span class="hljs-comment">//now the top of the stack has been poped, which means the first element that is bigger than the top index has appeared!</span><br>            ans[st[top]] = i;<br>            top --;<br>        &#125;<br><br>        <span class="hljs-comment">//if the stack has been cleaned, then top = -1, doens&#x27;t lead to contradiction</span><br>        <span class="hljs-comment">//push new element</span><br>        st[++ top] = i;<br>    &#125;<br><br>    <span class="hljs-comment">//for the elemnet remaining, there is no element backwards which is bigger than it.</span><br>    <span class="hljs-keyword">while</span>(top &gt;= <span class="hljs-number">0</span>)&#123;<br>        ans[st[top --]] = <span class="hljs-number">-1</span>;<br>    &#125;<br>    <br><br>    <span class="hljs-comment">//check the answers</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; ++i)&#123;<br>        std::cout &lt;&lt; list[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    std::cout &lt;&lt; std::endl;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; ++i)&#123;<br>        std::cout &lt;&lt; ans[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    <br><br>    <span class="hljs-keyword">delete</span>[] list;<br>    <span class="hljs-keyword">delete</span>[] st;<br>    <span class="hljs-keyword">delete</span>[] ans;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="Increasing-Queue"><a href="#Increasing-Queue" class="headerlink" title="Increasing Queue"></a>Increasing Queue</h2><p>在单调栈的基础限定之上加上了<strong>滑动窗口</strong>：</p><ul><li>从栈变成队列，元素的进入和出去不再在同一个位置.</li><li>规定滑动窗口的长度不可以大于$m$.</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @Author: Xiyuan Yang   xiyuan_yang@outlook.com</span><br><span class="hljs-comment"> * @Date: 2025-03-23 11:47:09</span><br><span class="hljs-comment"> * @LastEditors: Xiyuan Yang   xiyuan_yang@outlook.com</span><br><span class="hljs-comment"> * @LastEditTime: 2025-03-23 15:39:34</span><br><span class="hljs-comment"> * @FilePath: /20250316_stack_and_queue/template_queue.cpp</span><br><span class="hljs-comment"> * @Description: template of increasing queue</span><br><span class="hljs-comment"> * Do you code and make progress today?</span><br><span class="hljs-comment"> * Copyright (c) 2025 by Xiyuan Yang, All Rights Reserved. </span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">Template of Increasing Queue</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> size = <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> windows_size = <span class="hljs-number">3</span>;<br>    <span class="hljs-comment">//the list that needs to be scanned</span><br>    <span class="hljs-type">int</span> *list = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[size];<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; ++i)&#123;<br>        std::cin &gt;&gt; list[i];<br>    &#125;<br><br>    <span class="hljs-comment">//the simulation of queue using traditional array</span><br>    <span class="hljs-type">int</span> *qu = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[windows_size + <span class="hljs-number">1</span>];<br>    <span class="hljs-type">int</span> left_index = <span class="hljs-number">0</span>, right_index = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-comment">//模版目标：找到每一个元素后面第一个比其大的元素，如果不存在则为-1</span><br>    <span class="hljs-type">int</span> *ans = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[size - windows_size + <span class="hljs-number">1</span>];<br><br>    <br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    此处使用单调递减的队列，可以用来求得每一个滑动窗口中的最小值</span><br><span class="hljs-comment">    此处left_index是出队列的地方：</span><br><span class="hljs-comment">        1.如果新加入的元素超过了windows的限制</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; size; i++)&#123;<br>        <span class="hljs-comment">//exceed the window</span><br>        <span class="hljs-keyword">while</span>(left_index &lt;= right_index &amp;&amp; qu[left_index] &lt;= i - windows_size)&#123;<br>            ++ left_index;<br>        &#125;<br><br>        <span class="hljs-comment">// maintain the decreasing size of the queue</span><br>        <span class="hljs-keyword">while</span>(left_index &lt;= right_index &amp;&amp; list[qu[right_index]] &lt; list[i])&#123;<br>            -- right_index;<br>        &#125;<br>        <span class="hljs-comment">//此处和单调栈很类似，为了维护单调性，我们需要pop掉一些不满足单调性的元素（此处是为了满足单调递减的性质）</span><br><br>        qu[++right_index] = i;<br><br>        <span class="hljs-keyword">if</span>(i &gt;= windows_size - <span class="hljs-number">1</span>)&#123;<br>            ans[i - windows_size + <span class="hljs-number">1</span>] = list[qu[left_index]];<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-comment">//check the answers</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; ++i)&#123;<br>        std::cout &lt;&lt; list[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    std::cout &lt;&lt; std::endl;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size - windows_size + <span class="hljs-number">1</span>; ++i)&#123;<br>        std::cout &lt;&lt; ans[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    <br><br>    <span class="hljs-keyword">delete</span>[] list;<br>    <span class="hljs-keyword">delete</span>[] qu;<br>    <span class="hljs-keyword">delete</span>[] ans;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p><strong>单调队列</strong>最经典的问题就是可以求出一个滑动窗口的最小值，并且在$O(n)$的时间复杂度下便可完成整个数组的扫描和求解。例如下面的题目：</p><p>给定一个数组，求最大的子数组的区间求和，在此处规定**子数组的长度不超过<code>limit</code>**。</p><p>解决思路：<strong>前缀和 + 单调队列</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @Author: Xiyuan Yang   xiyuan_yang@outlook.com</span><br><span class="hljs-comment"> * @Date: 2025-03-20 19:46:36</span><br><span class="hljs-comment"> * @LastEditors: Xiyuan Yang   xiyuan_yang@outlook.com</span><br><span class="hljs-comment"> * @LastEditTime: 2025-03-20 23:42:42</span><br><span class="hljs-comment"> * @FilePath: /20250316_stack_and_queue/1798.cpp</span><br><span class="hljs-comment"> * @Description: </span><br><span class="hljs-comment"> * Do you code and make progress today?</span><br><span class="hljs-comment"> * Copyright (c) 2025 by Xiyuan Yang, All Rights Reserved. </span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">0</span>, f = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">char</span> ch = <span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">while</span> (ch &lt; <span class="hljs-string">&#x27;0&#x27;</span> || ch &gt; <span class="hljs-string">&#x27;9&#x27;</span>) &#123;<br>        <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;-&#x27;</span>) f = <span class="hljs-number">-1</span>;<br>        ch = <span class="hljs-built_in">getchar</span>();<br>    &#125;<br>    <span class="hljs-keyword">while</span> (ch &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) x = x * <span class="hljs-number">10</span> + ch - <span class="hljs-string">&#x27;0&#x27;</span>, ch = <span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">return</span> x * f;<br>&#125;<br><br><span class="hljs-type">long</span> <span class="hljs-type">long</span> total_trees, max_length;<br><span class="hljs-type">int</span> *tree_height;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    total_trees = <span class="hljs-built_in">read</span>();<br>    max_length = <span class="hljs-built_in">read</span>();<br>    tree_height = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[total_trees];<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> ans = <span class="hljs-number">-9000000000000</span>;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span>* q = <span class="hljs-keyword">new</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> [total_trees];<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span>* prefix_sum = <span class="hljs-keyword">new</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> [total_trees + <span class="hljs-number">1</span>]();<br><br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> left_index = <span class="hljs-number">0</span>, right_index = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; total_trees; ++i)&#123;<br>        tree_height[i] = <span class="hljs-built_in">read</span>();<br>        prefix_sum[i + <span class="hljs-number">1</span>] = prefix_sum[i] + tree_height[i];<br>        <span class="hljs-keyword">while</span>(left_index &lt;= right_index &amp;&amp; i - q[left_index] &gt; max_length)&#123;<br>            left_index++;<br>        &#125; <br>        <span class="hljs-keyword">while</span>(left_index &lt;= right_index &amp;&amp; prefix_sum[i] &lt; prefix_sum[q[right_index]])&#123;<br>            -- right_index;<br>        &#125;<br><br>        q[++ right_index] = i;<br>        ans = <span class="hljs-built_in">max</span>(ans, prefix_sum[i] - prefix_sum[q[left_index]]);<br><br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, ans);<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>再来一个例子！</p><h3 id="Example2"><a href="#Example2" class="headerlink" title="Example2"></a>Example2</h3><p>给定一个数组，并且规定一个区间$[S,T]$，求一个连续子数组，满足：</p><ul><li>子数组的长度在该区间中</li><li>子数组的平均值为最大</li></ul><p>只要求精读保持到小数点后三位。</p><p>此处在使用<strong>单调队列</strong>之前还需要一些预处理的工作，在这里使用<strong>二分答案</strong>来寻找精度解。而单调队列就是来找是否存在符合条件的子数组使其平均值大于当前的二分查找值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @Author: Xiyuan Yang   xiyuan_yang@outlook.com</span><br><span class="hljs-comment"> * @Date: 2025-03-23 20:48:17</span><br><span class="hljs-comment"> * @LastEditors: Xiyuan Yang   xiyuan_yang@outlook.com</span><br><span class="hljs-comment"> * @LastEditTime: 2025-03-23 22:10:53</span><br><span class="hljs-comment"> * @FilePath: /Test2/2_advance.cpp</span><br><span class="hljs-comment"> * @Description: </span><br><span class="hljs-comment"> * Do you code and make progress today?</span><br><span class="hljs-comment"> * Copyright (c) 2025 by Xiyuan Yang, All Rights Reserved. </span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iomanip&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(<span class="hljs-type">double</span> mid, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> S, <span class="hljs-type">int</span> T, <span class="hljs-type">int</span>* a)</span> </span>&#123;<br><br>    <span class="hljs-type">bool</span> ans = <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">double</span>* prefix = <span class="hljs-keyword">new</span> <span class="hljs-type">double</span> [n + <span class="hljs-number">1</span>]();<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>        prefix[i] = prefix[i - <span class="hljs-number">1</span>] + (a[i - <span class="hljs-number">1</span>] - mid);<br>    &#125;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    prefix 是维护前缀和的数组，此处对数组归一化方便计算</span><br><span class="hljs-comment">    */</span><br><br><br>    <span class="hljs-comment">//using the increase queue</span><br>    <span class="hljs-type">int</span>* qu = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[n + <span class="hljs-number">1</span>];<br>    <br>    <span class="hljs-comment">//the simulation of queue using traditional array</span><br>    <span class="hljs-type">int</span> left_index = <span class="hljs-number">0</span>, right_index = <span class="hljs-number">-1</span>;<br>    <span class="hljs-type">int</span> windows_size = T - S;<br><br>    <br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    此处使用单调递减的队列，可以用来求得每一个滑动窗口中的最小值</span><br><span class="hljs-comment">    此处left_index是出队列的地方：</span><br><span class="hljs-comment">        1.如果新加入的元素超过了windows的限制</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = S; j &lt;= n; ++j)&#123;<br>        <span class="hljs-comment">//j represents the right index</span><br>        <span class="hljs-comment">//exceed the window</span><br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        在给定右端点j的情况下，我们需要找到i的prefix最小值，得到求和的最大值，在判断是否存在</span><br><span class="hljs-comment">        i此时可以转化为一个滑动窗口的问题：</span><br><span class="hljs-comment">        j - T &lt;= i &lt;= j - S，窗口大小为T-S</span><br><span class="hljs-comment">        正向遍历i的可能取值，使用单调队列的思想</span><br><span class="hljs-comment">        */</span><br><br>        <br>        <span class="hljs-keyword">while</span>(left_index &lt;= right_index &amp;&amp; qu[left_index] &lt; j - T)&#123;<br>            ++ left_index;<br>        &#125;<br><br>        <span class="hljs-comment">// maintain the decreasing size of the queue</span><br>        <span class="hljs-keyword">while</span>(left_index &lt;= right_index &amp;&amp; prefix[qu[right_index]] &gt; prefix[j - S])&#123;<br>            -- right_index;<br>        &#125;<br>        <span class="hljs-comment">//此处和单调栈很类似，为了维护单调性，我们需要pop掉一些不满足单调性的元素（此处是为了满足单调递减的性质）</span><br><br>        qu[++right_index] = j - S;<br><br>        <span class="hljs-keyword">if</span>(prefix[j] - prefix[qu[left_index]] &gt;= <span class="hljs-number">0</span>)&#123;<br>            ans = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">delete</span>[] prefix;<br>    <span class="hljs-keyword">delete</span>[] qu;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-comment">// 主函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>    std::cout.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>    <span class="hljs-type">int</span> n, S, T;<br>    cin &gt;&gt; n &gt;&gt; S &gt;&gt; T;<br>    <br><br>    <span class="hljs-type">int</span> * a = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[n];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        cin &gt;&gt; a[i];<br>    &#125;<br><br>    <span class="hljs-comment">// 二分答案</span><br>    <span class="hljs-type">double</span> low = <span class="hljs-number">-1e6</span>, high = <span class="hljs-number">1e6</span>;<br>    <span class="hljs-type">double</span> precision = <span class="hljs-number">1e-5</span>; <br>    <span class="hljs-keyword">while</span> (high - low &gt; precision) &#123;<br>        <span class="hljs-type">double</span> mid = (low + high) / <span class="hljs-number">2.0</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isValid</span>(mid, n, S, T, a)) &#123;<br>            low = mid;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            high = mid;<br>        &#125;<br>    &#125;<br><br>    cout &lt;&lt; fixed &lt;&lt; <span class="hljs-built_in">setprecision</span>(<span class="hljs-number">3</span>) &lt;&lt; low;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Simulating-Recursion"><a href="#Simulating-Recursion" class="headerlink" title="Simulating Recursion"></a>Simulating Recursion</h2><p>在这里使用栈模拟递归的调用：</p><p><strong>递归的调用</strong>的核心在于栈帧空间，因此可以手动使用栈来模拟。那么这些<strong>栈帧空间</strong>需要维护哪些内容？</p><ul><li><strong>元素的状态</strong></li><li>这一层函数调用的<strong>所有参数列表</strong></li><li>这一层函数调用的<strong>返回值</strong></li></ul><div class="note note-primary">            <p>1.执行代码块0</p><p>2.保存现场准备进入下一层</p><p>3.接受下层返回的数据</p><p>4.恢复现场</p><p>5.继续执行代码块1</p>          </div><p><strong>Example</strong>：给出如下函数调用的示例：</p><p>$$f(0) &#x3D;f(1)&#x3D;1,\ g(0) &#x3D; g(1) &#x3D;1$$</p><p>$$f(n)&#x3D;f(n-1)+g(n-2),\ g(n)&#x3D;f(n-1)+g(n-1)$$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">char</span> func;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span><br>&#123;<br>    func fu;<br>    <span class="hljs-type">int</span> n;<span class="hljs-comment">//the input</span><br>    <span class="hljs-type">int</span> pc;<span class="hljs-comment">//the status</span><br>    <span class="hljs-type">int</span> fr, gr;<span class="hljs-comment">//the return value</span><br>    <span class="hljs-built_in">node</span>(func f, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> p, <span class="hljs-type">int</span> fr, <span class="hljs-type">int</span> gr):<span class="hljs-built_in">fu</span>(f), <span class="hljs-built_in">n</span>(n), <span class="hljs-built_in">pc</span>(p), <span class="hljs-built_in">fr</span>(fr), <span class="hljs-built_in">gr</span>(gr)&#123;&#125;<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">computefunc</span><span class="hljs-params">(func which_func, <span class="hljs-type">int</span> input)</span></span>&#123;<br>    stack &lt;node&gt; frame;<br>    <span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<br>    frame.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">node</span>(which_func, input, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>));<br>    <span class="hljs-keyword">while</span>(!frame.<span class="hljs-built_in">empty</span>())&#123;<br>        <span class="hljs-keyword">auto</span>&amp; top = frame.<span class="hljs-built_in">top</span>();<br>        <span class="hljs-keyword">switch</span> (top.fu)&#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;f&#x27;</span>:<br>                <span class="hljs-keyword">switch</span> (top.pc)&#123;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>                        <span class="hljs-keyword">if</span>(top.n &lt;= <span class="hljs-number">1</span>)&#123;<br>                            ret = <span class="hljs-number">1</span>;<br>                            frame.<span class="hljs-built_in">pop</span>();<br>                        &#125;<span class="hljs-keyword">else</span>&#123;<br>                            top.pc++;<br>                            frame.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">node</span>(<span class="hljs-string">&#x27;f&#x27;</span>, top.n - <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span> ,<span class="hljs-number">0</span>));<br>                        &#125;<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>                        top.pc ++;<br>                        top.fr = ret;<br>                        frame.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">node</span>(<span class="hljs-string">&#x27;g&#x27;</span>, top.n - <span class="hljs-number">2</span>, <span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>));<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>                        ret += top.fr;<br>                        <span class="hljs-comment">//此时f和g的子函数返回值全部已经计算完毕，ret来返回到上一层的栈帧空间</span><br>                        frame.<span class="hljs-built_in">pop</span>();<br>                        <span class="hljs-keyword">break</span>;<br>                &#125;<span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;g&#x27;</span>:<br>                <span class="hljs-keyword">switch</span>(top.pc)&#123;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>                        <span class="hljs-keyword">if</span>(top.n &lt;= <span class="hljs-number">1</span>)&#123;<br>                            ret = <span class="hljs-number">1</span>;<br>                            frame.<span class="hljs-built_in">pop</span>();<br>                        &#125;<span class="hljs-keyword">else</span>&#123;<br>                            top.pc++;<br>                            frame.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">node</span>(<span class="hljs-string">&#x27;g&#x27;</span>, top.n - <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span> ,<span class="hljs-number">0</span>));<br>                        &#125;<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>                        top.pc ++;<br>                        top.gr = ret;<br>                        frame.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">node</span>(<span class="hljs-string">&#x27;f&#x27;</span>, top.n + <span class="hljs-number">1</span>, <span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>));<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>                        ret += top.gr;<br>                        frame.<span class="hljs-built_in">pop</span>();<br>                        <span class="hljs-keyword">break</span>;<br>                &#125;<span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cout &lt;&lt; <span class="hljs-built_in">computefunc</span>(<span class="hljs-string">&#x27;f&#x27;</span>, <span class="hljs-number">5</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>在这里<strong>最重要的几点</strong>：</p><ul><li><p><strong>栈帧状态的设计</strong>：</p><ul><li>1：最原始的栈帧状态</li><li>2：进入2代表已经得到第一个（+号左边）的子函数的返回值</li><li>3：进入3代表已经得到第二个（+号右边）的子函数的返回值</li></ul></li><li><p>有一个变量<code>ret</code>， 这个变量是程序成功的核心，代表上一层栈帧的<strong>返回值</strong>，通过<code>ret</code>会更新当前栈帧的相关参数。</p><ul><li>当栈被清空之后，很有趣！此时ret就是主函数的返回值。（因为主函数的第一个状态就是栈帧的最底层）</li></ul></li></ul><h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example"></a>Example</h3><p><strong>理论上</strong>，任何递归函数都可以使用<strong>栈的模拟递归</strong>来实现，只不过是实现复杂度的问题，我们只是<strong>替代</strong>了编译器帮我们完成的工作，而且，我们可以在<strong>堆内存</strong>上实现，防止<strong>爆栈</strong>。</p><p>在此处给出一道经典例题：二叉树的后根遍历（其递归实现略）</p><p>题目链接：<a href="https://acm.sjtu.edu.cn/OnlineJudge/problem/2595">OJ 2595</a></p><p>给定一棵二叉树，以栈模拟递归的方式返回其节点值的<strong>后序遍历</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> SRC_HPP</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SRC_HPP</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">The recursive implementation:</span><br><span class="hljs-comment">traverse(x.left)</span><br><span class="hljs-comment">traverse(x.right)</span><br><span class="hljs-comment">traverse(x)</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">the default function</span><br><span class="hljs-comment">if(node.left == nullptr &amp;&amp; node.right == nullptr)&#123;</span><br><span class="hljs-comment">    traverse the node of x</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Info</span> &#123;<br>  <span class="hljs-comment">// Add whatever you want here</span><br>  <span class="hljs-type">int</span> current_size; <span class="hljs-comment">// now the traversa has gone to which section</span><br>  <span class="hljs-type">int</span> pc;<br>  <span class="hljs-comment">//pc = 1: The initial statement</span><br>  <span class="hljs-comment">//pc = 2: Has been traversed the left node</span><br>  <span class="hljs-comment">//pc = 3: has been traversed the right node</span><br>  <span class="hljs-type">const</span> Node*  root_node;<br>  <span class="hljs-type">int</span> *arr;<br>  <span class="hljs-type">int</span> total_treesize;<br>  <br><br><br><br><br>  <span class="hljs-built_in">Info</span>(<span class="hljs-type">int</span> current= <span class="hljs-number">0</span>, <span class="hljs-type">int</span> pc= <span class="hljs-number">1</span>, <span class="hljs-type">const</span> Node*  root= <span class="hljs-literal">nullptr</span>, <span class="hljs-type">int</span> *arr =<span class="hljs-literal">nullptr</span>, <span class="hljs-type">int</span> total_treesize = <span class="hljs-number">0</span>)<br>  :<span class="hljs-built_in">current_size</span>(current), <span class="hljs-built_in">pc</span>(pc),<span class="hljs-built_in">root_node</span>(root), <span class="hljs-built_in">arr</span>(arr),<span class="hljs-built_in">total_treesize</span>(total_treesize) &#123;<br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span></span><br>  &#125;<br><br>  ~<span class="hljs-built_in">Info</span>() &#123;<br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span></span><br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;  <span class="hljs-comment">// DO NOT edit this part</span><br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">int</span> _data;<br>  Node *_lson, *_rson;<br>  <span class="hljs-keyword">mutable</span> Info _info;  <span class="hljs-comment">// custom data</span><br><br>  <span class="hljs-function"><span class="hljs-keyword">friend</span> Node *<span class="hljs-title">genTree</span><span class="hljs-params">()</span></span>;<br><br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">Node</span>();<br><br>  <span class="hljs-built_in">Node</span>(<span class="hljs-type">int</span> data);<br><br>  ~<span class="hljs-built_in">Node</span>();<br><br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">data</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">const</span> Node *<span class="hljs-type">const</span> <span class="hljs-title">lson</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">const</span> Node *<span class="hljs-type">const</span> <span class="hljs-title">rson</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>  <span class="hljs-function">Info &amp;<span class="hljs-title">info</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversePostOrder</span><span class="hljs-params">(<span class="hljs-type">const</span> Node *<span class="hljs-type">const</span> root, <span class="hljs-type">int</span> *arr, <span class="hljs-type">int</span> tree_size)</span> </span>&#123;<br>  <span class="hljs-comment">// TODO</span><br>  <span class="hljs-type">int</span> currentsize = <span class="hljs-number">0</span>;<br>  Info* st = <span class="hljs-keyword">new</span> Info[tree_size];<span class="hljs-comment">//the simulation of stack</span><br>  <span class="hljs-type">int</span> top = <span class="hljs-number">0</span>;<br>  st[top] = <span class="hljs-built_in">Info</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, root, arr, tree_size);<br><br>  <span class="hljs-keyword">while</span>(top &gt;= <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-keyword">auto</span>&amp; top_val = st[top];<br>    <span class="hljs-keyword">switch</span>(top_val.pc)&#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">if</span>(top_val.root_node-&gt;<span class="hljs-built_in">lson</span>() == <span class="hljs-literal">nullptr</span> &amp;&amp; top_val.root_node-&gt;<span class="hljs-built_in">rson</span>() == <span class="hljs-literal">nullptr</span>)&#123;<br>                <span class="hljs-comment">//fill in the root node!</span><br>                arr[currentsize] = top_val.root_node-&gt;<span class="hljs-built_in">data</span>();<br>                currentsize ++;<br>                <span class="hljs-keyword">if</span>(currentsize &gt; tree_size)&#123;<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>                top --;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(top_val.root_node-&gt;<span class="hljs-built_in">lson</span>() == <span class="hljs-literal">nullptr</span>)&#123;<br>                top_val.pc = <span class="hljs-number">3</span>;<br>                st[++top] = <span class="hljs-built_in">Info</span>(currentsize, <span class="hljs-number">1</span>, top_val.root_node-&gt;<span class="hljs-built_in">rson</span>(), arr, tree_size);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                top_val.pc = <span class="hljs-number">2</span>;<br>                st[++top] = <span class="hljs-built_in">Info</span>(currentsize, <span class="hljs-number">1</span>, top_val.root_node-&gt;<span class="hljs-built_in">lson</span>(), arr, tree_size);<br>            &#125;<span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">if</span>(top_val.root_node-&gt;<span class="hljs-built_in">rson</span>() == <span class="hljs-literal">nullptr</span>)&#123;<br>                arr[currentsize] = top_val.root_node-&gt;<span class="hljs-built_in">data</span>();<br>                currentsize ++;<br>                <span class="hljs-keyword">if</span>(currentsize &gt; tree_size)&#123;<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>                top --;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                top_val.pc = <span class="hljs-number">3</span>;<br>                st[++top] = <span class="hljs-built_in">Info</span>(currentsize, <span class="hljs-number">1</span>, top_val.root_node-&gt;<span class="hljs-built_in">rson</span>(), arr, tree_size);<br>            &#125;<span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>            arr[currentsize] = top_val.root_node-&gt;<span class="hljs-built_in">data</span>();<br>                currentsize ++;<br>                <span class="hljs-keyword">if</span>(currentsize &gt; tree_size)&#123;<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>                top --;<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tutorial</tag>
      
      <tag>Finished</tag>
      
      <tag>BFS/DFS</tag>
      
      <tag>Data Structure</tag>
      
      <tag>C/C++</tag>
      
      <tag>Queue</tag>
      
      <tag>Stack</tag>
      
      <tag>Increasing stack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RL_speeches</title>
    <link href="/posts/RL-speeches/"/>
    <url>/posts/RL-speeches/</url>
    
    <content type="html"><![CDATA[<style>  html, body, .markdown-body {    font-family: Georgia, sans, serif;  }</style><h1 id="Reward-is-All-you-need"><a href="#Reward-is-All-you-need" class="headerlink" title="Reward is All you need?"></a>Reward is All you need?</h1><p>Several speeches regarding reinforcement learning.</p><h2 id="Speech-1-TURING-AWARD-WINNER-Richard-S-Sutton-in-Conversation-with-Cam-Linke-No-Authorities-in-Science"><a href="#Speech-1-TURING-AWARD-WINNER-Richard-S-Sutton-in-Conversation-with-Cam-Linke-No-Authorities-in-Science" class="headerlink" title="Speech_1: TURING AWARD WINNER Richard S. Sutton in Conversation with Cam Linke | No Authorities in Science"></a>Speech_1: TURING AWARD WINNER Richard S. Sutton in Conversation with Cam Linke | No Authorities in Science</h2><p><a href="https://www.youtube.com/watch?v=9_PepvnqIfU">Link on Y2b</a></p><p>Turing award, wow!</p><h3 id="About-RL"><a href="#About-RL" class="headerlink" title="About RL"></a>About RL</h3><p>The essence of Reinforcement Learning is <strong>learning from experiences</strong>, which differs from current large language models <strong>mimic people</strong>. Learning from experience is the obvious way to learn, thus this is the first principle of reinforcement learning.</p><p>The basic learning is learning from <strong>rewards and penalties</strong>, like interacting the world gives you instructive feedback.</p><h3 id="How-to-be-through-keeping-focus-on-what-you-believe-is-right"><a href="#How-to-be-through-keeping-focus-on-what-you-believe-is-right" class="headerlink" title="How to be through keeping focus on what you believe is right"></a>How to be through keeping focus on what you believe is right</h3><p>Let’s make it a field!</p><p>The process of AI is a marathon, we still have far to go the greatest impactful aspects of AI.</p><p><strong>To be ambitious, rather arrogant</strong>. Despite the different perspectives, stay humble enough to support each other. <strong>There is no one who can just say well this is the direction for AI</strong>!</p><div class="note note-primary">            <p><strong>This is an introduction of RL</strong>! (Partly a celebrity speech, rather than a lecture or something academically.) Just wait for the contents below!</p>          </div><h2 id="Speech-2-About-Policy-gradient"><a href="#Speech-2-About-Policy-gradient" class="headerlink" title="Speech_2: About Policy gradient"></a>Speech_2: About Policy gradient</h2><p>Excerpted from the reinforcement learning lecture at Shanghai Jiao Tong University.</p><p>In reinforcement learning (RL), a <strong>policy</strong> $(pi(a|s; \theta))$ defines the probability of taking action ($a$) in state ($s$) given parameters ($\theta$). The goal is to <strong>maximize the expected cumulative reward</strong>.</p><h3 id="Objective-Function"><a href="#Objective-Function" class="headerlink" title="Objective Function"></a><strong>Objective Function</strong></h3><p>The objective function we want to maximize is the expected return:</p><p>$$J(\theta) &#x3D; \mathbb{E}_{\tau \sim \pi_\theta} \left[ R(\tau) \right]$$</p><p>where ($\tau$) is a <strong>trajectory (sequence of states and actions)</strong>, and ($R(\tau)$) is the total reward obtained from trajectory ($\tau$).</p><h3 id="Gradient-Calculation"><a href="#Gradient-Calculation" class="headerlink" title="Gradient Calculation"></a><strong>Gradient Calculation</strong></h3><p>According to the <strong>policy gradient theorem</strong>, the gradient of the objective function can be expressed as:</p><p>$$\nabla J(\theta) &#x3D; \mathbb{E}_{\tau \sim \pi_\theta} \left[ \nabla \log \pi(a|s; \theta) R(\tau) \right]$$</p><p>This indicates that we can update the policy parameters by weighting the gradient of the log-probability of actions taken by the total reward.</p><p>Using gradient ascent, we update the parameters as follows:</p><p>$$\theta \leftarrow \theta + \alpha \nabla J(\theta)$$</p><p>where ($\alpha$) is the learning rate.</p><h3 id="Comparison-Between-Reinforcement-Learning-and-Supervised-Learning"><a href="#Comparison-Between-Reinforcement-Learning-and-Supervised-Learning" class="headerlink" title="Comparison Between Reinforcement Learning and Supervised Learning"></a>Comparison Between Reinforcement Learning and Supervised Learning</h3><p>Powered by GPT, but I think it truly make sense.</p><h4 id="1-Objective"><a href="#1-Objective" class="headerlink" title="1. Objective"></a>1. <strong>Objective</strong></h4><ul><li><p><strong>Reinforcement Learning</strong>: The objective is to learn a policy that maximizes cumulative rewards through interaction with the environment. The agent learns through trial and error, and rewards can be sparse and delayed.</p></li><li><p><strong>Supervised Learning</strong>: The objective is to learn a mapping function from inputs to outputs by minimizing the error between predicted values and true labels. The data is labeled, and the learning process relies on these labels.</p></li></ul><h4 id="2-Data-Handling"><a href="#2-Data-Handling" class="headerlink" title="2. Data Handling"></a>2. <strong>Data Handling</strong></h4><ul><li><p><strong>Reinforcement Learning</strong>: Data is generated through interactions with the environment. The agent selects actions at each time step and observes the results. The data is dynamic and may be influenced by changes in the policy.</p></li><li><p><strong>Supervised Learning</strong>: Data is static, typically obtained from a fixed dataset. The model learns from these fixed input-output pairs during training.</p></li></ul><h4 id="3-Feedback-Mechanism"><a href="#3-Feedback-Mechanism" class="headerlink" title="3. Feedback Mechanism"></a>3. <strong>Feedback Mechanism</strong></h4><ul><li><p><strong>Reinforcement Learning</strong>: Feedback is provided through reward signals, which may be delayed. The agent must explore to discover which actions are effective.</p></li><li><p><strong>Supervised Learning</strong>: Feedback is direct, with the model receiving explicit label information during each training iteration, and the learning process is based on these labels.</p></li></ul><h4 id="4-Mathematical-Principles"><a href="#4-Mathematical-Principles" class="headerlink" title="4. Mathematical Principles"></a>4. <strong>Mathematical Principles</strong></h4><ul><li><p><strong>Reinforcement Learning</strong>: It uses Markov Decision Processes (MDPs) to model the environment. Policy gradient methods optimize expected returns and involve concepts from stochastic processes and dynamic programming.</p></li><li><p><strong>Supervised Learning</strong>: It typically uses a loss function (e.g., mean squared error, cross-entropy) to measure model performance and employs optimization algorithms like gradient descent to update model parameters, involving statistical learning and optimization theory.</p></li></ul>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-541ac937" role="button" aria-expanded="false" aria-controls="collapse-541ac937">        <div class="fold-arrow">▶</div>TBD      </div>      <div class="fold-collapse collapse" id="collapse-541ac937">        <div class="fold-content">          <ul><li>数据是交互出来的</li><li>每个数据具有“强化”和“弱化”的规定</li></ul><p>强化学习的历史</p><ul><li><p>从游戏AI到强化学习</p></li><li><p>强化学习 + 深度神经网络</p></li><li><p>模仿学习</p><ul><li>数据并非由策略本身交互出来的</li><li>本质上还是<strong>大数据量</strong>的有监督学习拟合</li><li><strong>学习的关键是和环境的交互</strong>！</li><li>Offline RL 是专家数据集的交互，与传统神经网络的拟合存在差异</li></ul></li><li><p><strong>Reward is all you need</strong></p></li></ul><p>定义好奖励函数是交互的关键。</p><p><strong>Next-token prediction</strong>: 如果大语言模型的本质还是监督学习，那模型如何实现<strong>推理能力的提升</strong>？如今Pre-training已经陷入瓶颈。强化学习是构建推理模型的有效方法之一，<strong>但RL is all you need</strong>.</p><p>强化学习和<strong>LLMs</strong></p><ul><li><p>Prompt Engineering</p></li><li><p>传统的API调用的问题？prompt的描述过于笨重，计算代价很高</p><ul><li>Agent的API调用 without having API descriptions</li><li><strong>使用强化学习的必要性</strong></li></ul></li><li><p>The Bitter Lessons</p><ul><li><strong>瞄准方向很重要</strong></li></ul></li></ul>        </div>      </div>    </div><h2 id="Lecture-3-Classics-The-Bitter-Lesson"><a href="#Lecture-3-Classics-The-Bitter-Lesson" class="headerlink" title="Lecture_3: Classics: The Bitter Lesson"></a>Lecture_3: Classics: The Bitter Lesson</h2><div class="note note-primary">            <p>The “bitter lesson” originates from a classic 2019 article by AI pioneer Rich Sutton titled “The Bitter Lesson.” By examining the detours artificial intelligence has taken over the past few decades, he presents a core argument: for AI to achieve long-term improvement, leveraging powerful computational resources is paramount. <strong>This computational power inherently implies the use of vast amounts of training data and large models</strong>.</p>          </div><p><strong>The biggest lesson that can be read from 70 years of AI research is that general methods that leverage computation are ultimately the most effective, and by a large margin.</strong></p><p>The only thing that matters in the long run is <strong>the leveraging of computations</strong>. Researchers’ initial effort was directed towards utilizing human understanding (so that less search was needed) and only much later was much greater success had by <strong>embracing search and learning</strong>.</p><p>(The initial state of <strong>Scaling Law</strong>?)</p><p>The bitter lesson is based on the historical observations that 1) AI researchers have often tried to build knowledge into their agents, 2) this always helps in the short term, and is personally satisfying to the researcher, but 3) in the long run it plateaus and even inhibits further progress, and 4) <strong>breakthrough progress eventually arrives by an opposing approach based on scaling computation by search and learning</strong>. The eventual success is tinged with bitterness, and often incompletely digested, because it is success over a favored, human-centric approach.</p><div class="note note-info">            <p>My own <strong>inspections</strong> of this passage:</p><p>TBD</p>          </div><h2 id="Speech-4-Jason-Wei-Scaling-Paradigms-for-Large-Language-Models"><a href="#Speech-4-Jason-Wei-Scaling-Paradigms-for-Large-Language-Models" class="headerlink" title="Speech_4: Jason Wei: Scaling Paradigms for Large Language Models"></a>Speech_4: Jason Wei: Scaling Paradigms for Large Language Models</h2><p>The original video on Youtube is <a href="https://www.youtube.com/watch?v=yhpjpNXJDco">here</a>.<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="[Jason's sp](https://www.youtube.com/watch?v=yhpjpNXJDco)">[1]</span></a></sup></p><h3 id="Paradigm-Scaling-RL-on-chain-of-thought"><a href="#Paradigm-Scaling-RL-on-chain-of-thought" class="headerlink" title="Paradigm: Scaling RL on chain-of-thought"></a>Paradigm: Scaling RL on chain-of-thought</h3><p><img src="https://s1.imagehub.cc/images/2025/03/18/abb2f17809f5f030ff81e0dc42218401.png" alt="AI fu"></p><h2 id="Speech-5-LLMs-self-enhancement-based-on-reinforcement-learning"><a href="#Speech-5-LLMs-self-enhancement-based-on-reinforcement-learning" class="headerlink" title="Speech_5: LLMs self-enhancement based on reinforcement learning"></a>Speech_5: LLMs self-enhancement based on reinforcement learning</h2><p>从人类抽象化的符号化表达————&gt; 多模态大模型</p><p><strong>The next token prediction</strong> at essence is the simulation of labeled data!</p><h3 id="霍尔德和海因"><a href="#霍尔德和海因" class="headerlink" title="霍尔德和海因"></a>霍尔德和海因</h3><p>生物智能不仅和感知相关，也和具身行为与环境交互有关！</p><h3 id="The-World-Scope-of-Natural-Language-Processing"><a href="#The-World-Scope-of-Natural-Language-Processing" class="headerlink" title="The World Scope of Natural Language Processing"></a>The World Scope of Natural Language Processing</h3><ul><li>WS 3 Multi-model</li><li>WS 4 Interact with the environment</li><li>WS 5 Interact with the society</li></ul><h3 id="The-Basis-of-Reinforcement-Learning"><a href="#The-Basis-of-Reinforcement-Learning" class="headerlink" title="The Basis of Reinforcement Learning"></a>The Basis of Reinforcement Learning</h3><ul><li>Environment</li><li>action and observation</li><li>reward function<ul><li>巴浦洛夫的狗（交互与奖励）</li></ul></li><li>Yann’s Cake</li></ul><p><img src="https://miro.medium.com/v2/resize:fit:4416/1*bvMhd_xpVxfJYoKXYp5hug.png" alt="Yann&#39;s Cake"></p><h3 id="Reinforcement-Learning-for-LLM"><a href="#Reinforcement-Learning-for-LLM" class="headerlink" title="Reinforcement Learning for LLM"></a>Reinforcement Learning for LLM</h3><p>In early stages, reinforcement learning is for alignment and finetuning.</p><h4 id="Policy-Optimization"><a href="#Policy-Optimization" class="headerlink" title="Policy Optimization"></a>Policy Optimization</h4><blockquote><p><strong>TBD</strong></p></blockquote><p>Several Limitations:</p><ul><li>The space of LLMs is huge but sparse.<ul><li>It’s time-consuming for LLMs to use Reinforcement Learning</li></ul></li><li>Limited Enhancement</li></ul><h3 id="LLM-reasoning-is-all-you-need"><a href="#LLM-reasoning-is-all-you-need" class="headerlink" title="LLM reasoning is all you need"></a>LLM reasoning is all you need</h3><p>We need inference models!</p><ul><li>OpenAI o1 illustrates that <strong>leveraging reinforcement learning</strong> explicitly incorporate reasoning steps can significantly enhance the performance.</li></ul><h4 id="Non-autoregressive-reasoning"><a href="#Non-autoregressive-reasoning" class="headerlink" title="Non-autoregressive reasoning"></a>Non-autoregressive reasoning</h4><p>MDP environment is important</p><h4 id="The-bitter-lesson"><a href="#The-bitter-lesson" class="headerlink" title="The bitter lesson"></a>The bitter lesson</h4><h3 id="Reward-is-Enough"><a href="#Reward-is-Enough" class="headerlink" title="Reward is Enough (?)"></a>Reward is Enough (?)</h3><p>Reward is enough to <strong>drive behavior that exhibits abilities</strong> studied in natural and AI.</p><h3 id="Attempts"><a href="#Attempts" class="headerlink" title="Attempts"></a>Attempts</h3><ul><li>CoT</li></ul><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://www.youtube.com/watch?v=yhpjpNXJDco">Jason’s sp</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Artificial Intelligence</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Artificial Intelligence</tag>
      
      <tag>Deep Learning</tag>
      
      <tag>reinforcement learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python-Visualization</title>
    <link href="/posts/Python-visualization/"/>
    <url>/posts/Python-visualization/</url>
    
    <content type="html"><![CDATA[<style>  html, body, .markdown-body {    font-family: Georgia, sans, serif;  }</style><h1 id="Python-Visualization"><a href="#Python-Visualization" class="headerlink" title="Python Visualization"></a>Python Visualization</h1><h2 id="Github-Repo"><a href="#Github-Repo" class="headerlink" title="Github Repo"></a>Github Repo</h2><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p><strong>Visualization</strong> is of great importance in python! It’s very easy to learn several modules including <code>matplotlib</code> and <code>seaborn</code>, however, when you try to draw a picture in python without using the help of AI assistance, it may be like this:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">Author: Xiyuan Yang   xiyuan_yang@outlook.com</span><br><span class="hljs-string">Date: 2025-03-14 17:37:11</span><br><span class="hljs-string">LastEditors: Xiyuan Yang   xiyuan_yang@outlook.com</span><br><span class="hljs-string">LastEditTime: 2025-03-14 17:37:16</span><br><span class="hljs-string">FilePath: /visualzation/src/ugly_paint.py</span><br><span class="hljs-string">Description: </span><br><span class="hljs-string">Do you code and make progress today?</span><br><span class="hljs-string">Copyright (c) 2025 by Xiyuan Yang, All Rights Reserved. </span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-keyword">import</span> matplotlib <span class="hljs-keyword">as</span> mlp<br>mlp.use(<span class="hljs-string">&quot;Agg&quot;</span>)<br><br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br><span class="hljs-comment"># Simple data</span><br>x = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br>y = [<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>]<br><br><span class="hljs-comment"># Basic plot with default settings</span><br>plt.plot(x, y)<br><br><span class="hljs-comment"># Set title and labels with minimal styling</span><br>plt.title(<span class="hljs-string">&#x27;Ugly Plot&#x27;</span>)<br>plt.xlabel(<span class="hljs-string">&#x27;X Axis&#x27;</span>)<br>plt.ylabel(<span class="hljs-string">&#x27;Y Axis&#x27;</span>)<br><br><span class="hljs-comment"># Display the plot</span><br>plt.savefig(<span class="hljs-string">&quot;figure/ugly plot.pdf&quot;</span>)<br><br></code></pre></td></tr></table></figure><p>You can make the pictures more advanced by adding several commands and customizations.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">Author: Xiyuan Yang   xiyuan_yang@outlook.com</span><br><span class="hljs-string">Date: 2025-03-14 14:53:43</span><br><span class="hljs-string">LastEditors: Xiyuan Yang   xiyuan_yang@outlook.com</span><br><span class="hljs-string">LastEditTime: 2025-03-14 17:38:23</span><br><span class="hljs-string">FilePath: /visualzation/src/advanced.py</span><br><span class="hljs-string">Description: </span><br><span class="hljs-string">Do you code and make progress today?</span><br><span class="hljs-string">Copyright (c) 2025 by Xiyuan Yang, All Rights Reserved. </span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-keyword">import</span> matplotlib <span class="hljs-keyword">as</span> mlp<br>mlp.use(<span class="hljs-string">&quot;Agg&quot;</span>)<br><br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>np.random.seed(<span class="hljs-number">2024</span>)<br><br><span class="hljs-comment"># Generating data</span><br>X = np.linspace(<span class="hljs-number">0</span>, <span class="hljs-number">10</span> ,<span class="hljs-number">5000</span>)<br><br><span class="hljs-comment"># Define the linear relation</span><br><span class="hljs-comment"># The relation: y = k * x + b</span><br>k = <span class="hljs-number">2.0</span><br>b = <span class="hljs-number">2.0</span><br><br><span class="hljs-comment"># Generating the true value of Y</span><br>Y_true = k * X + b<br><br><span class="hljs-comment"># Adding noise</span><br>noise = np.random.normal(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, size=Y_true.shape)<br>Y_noise = Y_true + noise<br><br><span class="hljs-comment"># Plotting</span><br>plt.figure(figsize=(<span class="hljs-number">10</span>, <span class="hljs-number">6</span>))<br>plt.scatter(x=X, y=Y_noise, color=<span class="hljs-string">&#x27;red&#x27;</span>, label=<span class="hljs-string">&#x27;Noisy data&#x27;</span>, alpha=<span class="hljs-number">0.3</span>, s=<span class="hljs-number">5</span>)<br><span class="hljs-comment"># plt.plot(X, Y_true, color=&#x27;blue&#x27;, label=&quot;Real Data&quot;, linewidth=3)</span><br>plt.title(<span class="hljs-string">&quot;Linear Relations with noise&quot;</span>)<br>plt.xlabel(<span class="hljs-string">&quot;X values&quot;</span>)<br>plt.ylabel(<span class="hljs-string">&quot;Y values (with noise)&quot;</span>)<br>plt.legend()<br>plt.savefig(<span class="hljs-string">&quot;figure/Advanced.pdf&quot;</span>)<br>plt.close()<br></code></pre></td></tr></table></figure><p>Actually, this is what I can draw independently… Python gives users great freedom to customize their visualization, which at the same time increasing the learning cost for beginners. It’s unwise for Python beginners to learn how to draw a great picture by <strong>mastering all commands in matplotlib</strong>! It’s time-consuming and meaningless. Thus, I would like to introduce my drawing template in this blog, you can just clone and use it, saving lots of time for thinking more meaningful tasks!</p><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="https://s1.imagehub.cc/images/2025/03/14/9cde81ef63d7b0f48ee39f8096637f9c.png" alt="Ugly Plot"></div><div class="group-image-wrap"><img src="https://s1.imagehub.cc/images/2025/03/14/130855fe44d922753f74d4ef4d233bb9.png" alt="Advanced Plot"></div></div></div><h2 id="Basic-Principles"><a href="#Basic-Principles" class="headerlink" title="Basic Principles"></a>Basic Principles</h2><p>The basic principles:</p><ul><li>Only introduce the 20% most basic yet most useful commands.</li><li>Giving</li></ul><h2 id="Templates"><a href="#Templates" class="headerlink" title="Templates"></a>Templates</h2><div class="note note-primary">            <h3 id="Preliminaries-Attention-for-Linux-Users"><a href="#Preliminaries-Attention-for-Linux-Users" class="headerlink" title="Preliminaries: Attention for Linux Users"></a>Preliminaries: Attention for Linux Users</h3><p>In lack of QT platform in my WSL system, I have to make several modifications like this:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib <span class="hljs-keyword">as</span> mpl<br>mpl.use(<span class="hljs-string">&#x27;Agg&#x27;</span>)<br><span class="hljs-comment">#...</span><br><span class="hljs-comment">#...</span><br><span class="hljs-keyword">import</span> matplotlib.plt <span class="hljs-keyword">as</span> plt<br><span class="hljs-comment"># forbid scientific notation</span><br>np.set_printoptions(suppress=<span class="hljs-literal">True</span>)<br><br><br><span class="hljs-comment"># Then showing the figure by saving the figures.</span><br><br>plt.savefig(<span class="hljs-string">&quot;save/img.png&quot;</span>)<br><br></code></pre></td></tr></table></figure>          </div><h1 id="Templates-fonts"><a href="#Templates-fonts" class="headerlink" title="Templates: fonts"></a>Templates: fonts</h1><blockquote><p>The part below is cloned from my github repo.</p></blockquote><p>In [ ]:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Preliminaries</span><br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">from</span> scipy.stats <span class="hljs-keyword">import</span> norm, entropy<br><span class="hljs-keyword">from</span> matplotlib.font_manager <span class="hljs-keyword">import</span> FontProperties<br></code></pre></td></tr></table></figure><h2 id="Before-setting-font"><a href="#Before-setting-font" class="headerlink" title="Before setting font"></a>Before setting font</h2><p>In [ ]:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python">np.random.seed(<span class="hljs-number">2024</span>)<br><br><span class="hljs-comment"># Generating data</span><br>X = np.linspace(<span class="hljs-number">0</span>, <span class="hljs-number">10</span> ,<span class="hljs-number">5000</span>)<br><br><span class="hljs-comment"># Define the linear relation</span><br><span class="hljs-comment"># The relation: y = k * x + b</span><br>k = <span class="hljs-number">2.0</span><br>b = <span class="hljs-number">2.0</span><br><br><span class="hljs-comment"># Generating the true value of Y</span><br>Y_true = k * X + b<br><br><span class="hljs-comment"># Adding noise</span><br>noise = np.random.normal(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, size=Y_true.shape)<br>Y_noise = Y_true + noise<br><br><span class="hljs-comment"># Plotting</span><br>plt.figure(figsize=(<span class="hljs-number">10</span>, <span class="hljs-number">6</span>))<br>plt.scatter(x=X, y=Y_noise, color=<span class="hljs-string">&#x27;red&#x27;</span>, label=<span class="hljs-string">&#x27;Noisy data&#x27;</span>, alpha=<span class="hljs-number">0.3</span>, s=<span class="hljs-number">5</span>)<br><span class="hljs-comment"># plt.plot(X, Y_true, color=&#x27;blue&#x27;, label=&quot;Real Data&quot;, linewidth=3)</span><br>plt.title(<span class="hljs-string">&quot;Linear Relations with noise&quot;</span>)<br>plt.xlabel(<span class="hljs-string">&quot;X values&quot;</span>)<br>plt.ylabel(<span class="hljs-string">&quot;Y values (with noise)&quot;</span>)<br>plt.legend()<br>plt.show()<br>plt.close()<br></code></pre></td></tr></table></figure><h2 id="How-to-set-font"><a href="#How-to-set-font" class="headerlink" title="How to set font"></a>How to set font</h2><p>All the operations below are for <strong>Linux</strong> (or <strong>WSL</strong>) users, if you have Windows operating systems, I strongly recommend you to install WSL in your computer!</p><p>Firstly, use this command to check default type in your system.</p><p>In [ ]:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Print the default font family</span><br><span class="hljs-built_in">print</span>(plt.rcParams[<span class="hljs-string">&#x27;font.family&#x27;</span>])<br></code></pre></td></tr></table></figure><p>Secondly, you can use the command below to check <strong>all fonts available</strong> in your operating system.</p><p>In [ ]:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.font_manager <span class="hljs-keyword">as</span> fm<br><br><span class="hljs-comment"># Find all system fonts</span><br>font_paths = fm.findSystemFonts(fontpaths=<span class="hljs-literal">None</span>)<br><br><span class="hljs-comment"># Print the list of available font paths</span><br><span class="hljs-keyword">for</span> font <span class="hljs-keyword">in</span> font_paths:<br>    <span class="hljs-built_in">print</span>(font)<br></code></pre></td></tr></table></figure><p>My output: [‘sans-serif’]</p><p>You can search all the fonts you like, but it’s time-consuming. In this tutorial, I only like to introduce <strong>two types</strong> of fonts that it’s most frequently used by myself: <strong>georgia</strong> (English) and <strong>songti</strong> (Chinese).</p><p>All the demonstrations are based on these two fonts.</p><p>In [ ]:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Check whether the fonts available is included in the list:</span><br>!fc-<span class="hljs-built_in">list</span> | grep -i <span class="hljs-string">&quot;songti&quot;</span><br>!fc-<span class="hljs-built_in">list</span> | grep -i <span class="hljs-string">&quot;georgia&quot;</span><br></code></pre></td></tr></table></figure><p>If you can see some outputs like the contents shown below (my contents):</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">/home/xiyuanyang/.local/share/fonts/songti.ttc: STSong:style=Regular,標準體,Ordinær,Normal,Normaali,Regolare,レギュラー,일반체,Regulier,Обычный,常规体<br>/home/xiyuanyang/.local/share/fonts/songti.ttc: Songti SC,宋體\-簡,宋体\-简:style=Regular,標準體,常规体<br>/home/xiyuanyang/.local/share/fonts/songti.ttc: Songti SC,宋體\-簡,宋体\-简:style=Black,黑體,黑体<br>/home/xiyuanyang/.local/share/fonts/songti.ttc: Songti TC,宋體\-繁,宋体\-繁:style=Regular,標準體,常规体<br>/home/xiyuanyang/.local/share/fonts/songti.ttc: Songti TC,宋體\-繁,宋体\-繁:style=Bold,粗體,粗体<br>/home/xiyuanyang/.local/share/fonts/songti.ttc: Songti SC,宋體\-簡,宋体\-简:style=Bold,粗體,粗体<br>/home/xiyuanyang/.local/share/fonts/songti.ttc: Songti TC,宋體\-繁,宋体\-繁:style=Light,細體,细体<br>/home/xiyuanyang/.local/share/fonts/songti.ttc: Songti SC,宋體\-簡,宋体\-简:style=Light,細體,细体<br>/home/xiyuanyang/.local/share/fonts/georgia.ttf: Georgia:style=Regular,Normal,obyčejné,Standard,Κανονικά,Normaali,Normál,Normale,Standaard,Normalny,Обычный,Normálne,Navadno,Arrunta<br></code></pre></td></tr></table></figure><p>If you can see some files names <code>songti.ttc</code> and <code>georgia.ttf</code>, then means that you have installed these fonts successfully!</p><h3 id="Not-successfully-Skip-optinally"><a href="#Not-successfully-Skip-optinally" class="headerlink" title="Not successfully? (Skip optinally)"></a>Not successfully? (Skip optinally)</h3><p>Then <strong>you need to install fonts munually</strong>. You can google it for getting fonts packages like <code>songti.ttc</code>.</p><p>In [ ]:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">!cd ~/.local/share/<br><br><span class="hljs-comment"># create directory to store fonts</span><br>!mkdir fonts<br><br><span class="hljs-comment"># Remember to change to your own locations!</span><br>!mv ~/songti.ttc .<br><br><span class="hljs-comment"># Update cache</span><br>!fc-cache -fv<br></code></pre></td></tr></table></figure><p>After operating these commands, check by using <code>fc-list</code> command again. If you can see the target font, just skip to the next part!</p><h3 id="Installed-successfully"><a href="#Installed-successfully" class="headerlink" title="Installed successfully"></a>Installed successfully</h3><p>Add these three commands in your python scripts, and you can then use the font freely in your python scripts!</p><p>In [ ]:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">plt.rcParams[<span class="hljs-string">&#x27;font.family&#x27;</span>] = <span class="hljs-string">&#x27;Serif&#x27;</span><br>plt.rcParams[<span class="hljs-string">&#x27;font.size&#x27;</span>] = <span class="hljs-number">12</span><br>font = FontProperties(fname=<span class="hljs-string">&quot;/home/xiyuanyang/.local/share/fonts/songti.ttc&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="After-setting-font"><a href="#After-setting-font" class="headerlink" title="After setting font"></a>After setting font</h2><p>In [ ]:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python">plt.rcParams[<span class="hljs-string">&#x27;font.family&#x27;</span>] = <span class="hljs-string">&#x27;Serif&#x27;</span><br>plt.rcParams[<span class="hljs-string">&#x27;font.size&#x27;</span>] = <span class="hljs-number">12</span><br>font = FontProperties(fname=<span class="hljs-string">&quot;/home/xiyuanyang/.local/share/fonts/georgia.ttf&quot;</span>)<br><span class="hljs-comment"># Example</span><br>np.random.seed(<span class="hljs-number">2024</span>)<br><br><span class="hljs-comment"># Generating data</span><br>X = np.linspace(<span class="hljs-number">0</span>, <span class="hljs-number">10</span> ,<span class="hljs-number">5000</span>)<br><br><span class="hljs-comment"># Define the linear relation</span><br><span class="hljs-comment"># The relation: y = k * x + b</span><br>k = <span class="hljs-number">2.0</span><br>b = <span class="hljs-number">2.0</span><br><br><span class="hljs-comment"># Generating the true value of Y</span><br>Y_true = k * X + b<br><br><span class="hljs-comment"># Adding noise</span><br>noise = np.random.normal(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, size=Y_true.shape)<br>Y_noise = Y_true + noise<br><br><span class="hljs-comment"># Plotting</span><br>plt.figure(figsize=(<span class="hljs-number">10</span>, <span class="hljs-number">6</span>))<br>plt.scatter(x=X, y=Y_noise, color=<span class="hljs-string">&#x27;red&#x27;</span>, label=<span class="hljs-string">&#x27;Noisy data&#x27;</span>, alpha=<span class="hljs-number">0.3</span>, s=<span class="hljs-number">5</span>)<br><span class="hljs-comment"># plt.plot(X, Y_true, color=&#x27;blue&#x27;, label=&quot;Real Data&quot;, linewidth=3)</span><br>plt.title(<span class="hljs-string">&quot;Linear Relations with noise&quot;</span>)<br>plt.xlabel(<span class="hljs-string">&quot;X values&quot;</span>)<br>plt.ylabel(<span class="hljs-string">&quot;Y values (with noise)&quot;</span>)<br>plt.legend()<br>plt.show()<br>plt.close()<br></code></pre></td></tr></table></figure><h2 id="Getting-into-the-functions"><a href="#Getting-into-the-functions" class="headerlink" title="Getting into the functions"></a>Getting into the functions</h2><p>In [ ]:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">draw_scatter</span>(<span class="hljs-params">X=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>], y=[<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,-<span class="hljs-number">10</span>,<span class="hljs-number">50</span>], fontsize=<span class="hljs-number">12</span>, filepath=<span class="hljs-string">&quot;figure/my images.png&quot;</span>,</span><br><span class="hljs-params">                title=<span class="hljs-string">&quot;My title&quot;</span>, lable=<span class="hljs-string">&quot;my label&quot;</span>, x_lable=<span class="hljs-string">&quot;Xlable&quot;</span>, y_lable=<span class="hljs-string">&quot;Ylabel&quot;</span>, </span><br><span class="hljs-params">                </span>):<br>    <span class="hljs-comment"># import modules</span><br><br>    <span class="hljs-comment"># Modifying the backend of matplotlib</span><br>    <span class="hljs-keyword">import</span> matplotlib <span class="hljs-keyword">as</span> mlp<br>    mlp.use(<span class="hljs-string">&quot;Agg&quot;</span>)<br><br>    <span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br>    <span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>    <span class="hljs-keyword">from</span> matplotlib.font_manager <span class="hljs-keyword">import</span> FontProperties<br><br>    plt.rcParams[<span class="hljs-string">&#x27;font.family&#x27;</span>] = <span class="hljs-string">&#x27;Serif&#x27;</span><br>    plt.rcParams[<span class="hljs-string">&#x27;font.size&#x27;</span>] = fontsize<br>    font_geogria = FontProperties(fname=<span class="hljs-string">&quot;/home/xiyuanyang/.local/share/fonts/georgia.ttf&quot;</span>)<br>    font_sonti = FontProperties(fname=<span class="hljs-string">&quot;/home/xiyuanyang/.local/share/fonts/songti.ttc&quot;</span>)<br><br>    <span class="hljs-comment"># Plotting</span><br>    plt.figure(figsize=(<span class="hljs-number">10</span>, <span class="hljs-number">6</span>))<br>    plt.scatter(x=X, y=y, color=<span class="hljs-string">&#x27;red&#x27;</span>, label=lable, alpha=<span class="hljs-number">0.3</span>, s=<span class="hljs-number">5</span>)<br>    plt.title(title, fontproperties = font_geogria, fontsize = <span class="hljs-number">18</span>)<br>    plt.xlabel(x_lable)<br>    plt.ylabel(y_lable)<br>    plt.legend()<br><br>    <span class="hljs-comment"># ! Attention, suggest you to use the absolute path.</span><br>    plt.savefig(filepath)<br>    plt.close()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Code</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Tutorial</tag>
      
      <tag>Visualization</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Algorithm-BinaryTree</title>
    <link href="/posts/Algorithm-BinaryTree/"/>
    <url>/posts/Algorithm-BinaryTree/</url>
    
    <content type="html"><![CDATA[<style>  html, body, .markdown-body {    font-family: Georgia, sans, serif;  }</style><h1 id="Binary-Tree-for-MIT-6-006"><a href="#Binary-Tree-for-MIT-6-006" class="headerlink" title="Binary Tree for MIT 6.006"></a>Binary Tree for MIT 6.006</h1><h2 id="Maybe-you-just-need-a-binary-tree…"><a href="#Maybe-you-just-need-a-binary-tree…" class="headerlink" title="Maybe you just need a binary tree…"></a>Maybe you just need a binary tree…</h2><pre><code class="mermaid" >graph TD;    A[5]    B[3]    C[8]    D[2]    E[4]    F[7]    G[9]    A --> B    A --> C    B --> D    B --> E    C --> F    C --> G        </code></pre><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>Assume we have discussed <strong>Sequence Data Structure</strong> and <strong>Set Data Structure</strong>. Different data structures have different advantages as well as disadvantages.(Linked List and Array, etc) We hope to design a data structure with lower time complexity!</p><p>What’s the sacirfices? Maybe the <strong>container and space</strong>.</p><p><img src="https://s1.imagehub.cc/images/2025/03/13/4f0fb70e1a0c00421731e9deba50d90b.png" alt="Time complexity"></p><p>We just ignore the basic definition of binary tree! You can go through this blog: <a href="https://xiyuanyang-code.github.io/posts/DataStructure-Tree-Binary-Tree/">Binary Tree</a>.</p><p>Thus a node in binary tree needs to store three pointers: <strong>parent node, left-child node and right-child node</strong>.</p><h2 id="Definitions-and-Terminology"><a href="#Definitions-and-Terminology" class="headerlink" title="Definitions and Terminology"></a>Definitions and Terminology</h2><ul><li>Subtree<ul><li>We can give the recursive definition of binary tree.</li><li>subtree of $x$ is $x$ and its <strong>descendants</strong>. (x to be the root)</li></ul></li><li>root node, leafs</li><li>depth<ul><li>Every node has <strong>unique path</strong> from the current node to the root node.</li></ul></li><li>height<ul><li>the maximum depth of nodes in x’s subtree.</li><li><strong>the longest road to get to the leaf nodes</strong>.</li></ul></li></ul><p><strong>We first ensure all operations shown above is O(h)</strong>, where h is the height of the root node. We will then try to ensure that $O(h)$ is equinumerous to $O(logn)$ by AVL Tree.</p><h2 id="Traversal-Order-of-Nodes"><a href="#Traversal-Order-of-Nodes" class="headerlink" title="Traversal Order of Nodes"></a>Traversal Order of Nodes</h2><p>The basic sequence of traversal order: <strong>left-root-right</strong>.</p><p>Algorithm:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">iterate(node):<br>iterate(node.left)<br>node<br>iterate(node.right)<br></code></pre></td></tr></table></figure><p><strong>The traversal order provides a way to deal with a sequential list of data</strong> by binary tree.</p><h2 id="Operations"><a href="#Operations" class="headerlink" title="Operations"></a>Operations</h2><h3 id="Traversal-Operations"><a href="#Traversal-Operations" class="headerlink" title="Traversal Operations"></a>Traversal Operations</h3><h4 id="subtree-first-node"><a href="#subtree-first-node" class="headerlink" title="subtree_first(node)"></a><code>subtree_first(node)</code></h4><p>Given a subtree (of its node), which comes first in traversal order?</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">while</span>(node.left != <span class="hljs-literal">nullptr</span>)&#123;<br>node = node.left;<br>&#125;<br><span class="hljs-keyword">return</span> node;<br></code></pre></td></tr></table></figure><ul><li>Go left as much as possible!</li><li>When the current node is <strong>leaf node</strong> or simply has no left node, just <strong>undo</strong> to the previous layer.<ul><li>The process itself is like a <strong>recursion</strong>! (Just follow the recursive definition of a tree)</li></ul></li></ul><p>Of course, you can define <code>subtree_last(node)</code>.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">while</span>(node.right != <span class="hljs-literal">nullptr</span>)&#123;<br>node = node.right;<br>&#125;<br><span class="hljs-keyword">return</span> node;<br></code></pre></td></tr></table></figure><h4 id="successor-node"><a href="#successor-node" class="headerlink" title="successor(node)"></a><code>successor(node)</code></h4><p>Return the next node after the given node in tree’s traversal order.</p><p>Firstly, check whether the right node of this node is empty. If no, then <strong>go to its right node and traverse the new subtree formed by its right node</strong>, which means return the node of <code>subtree_first(node.right)</code>.</p><p>If yes, we need to ensure whether its parent node has been traversed. If this node is the left child of its parent node, then just go to the parent node followed by traversal orders. However, if it is the right child of its parent node, we just need to go upper to the parent node of its parent node, <strong>until the current node is the left child of its parent node</strong>!</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span>(node.right == <span class="hljs-literal">nullptr</span>)&#123;<br><span class="hljs-comment">//the right child is empty</span><br><span class="hljs-keyword">while</span>(node.parent != <span class="hljs-literal">nullptr</span> &amp;&amp; node != node.parent.left)&#123;<br>node = node.parent;<br>&#125;<br>    <span class="hljs-keyword">return</span> node.parent;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">subtree_first</span>(node.right);<br>&#125;<br></code></pre></td></tr></table></figure><p>These operations above just takes $O(h)$, where h is the height of the tree. You just need to check at most one single node in the same layer.</p><p>We can also define the <code>predecessor()</code> function to get the previous node similarly.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span>(node.left != <span class="hljs-literal">nullptr</span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">subtree_last</span>(node.left);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-keyword">while</span>(node.parent != <span class="hljs-literal">nullptr</span> &amp;&amp; node.parent.right != node)&#123;<br>        node = node.parent;<br>    &#125;<br>    <span class="hljs-keyword">return</span> node.parent;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Insert-and-delete"><a href="#Insert-and-delete" class="headerlink" title="Insert and delete"></a>Insert and delete</h3><h4 id="subtree-insert-after-node-new"><a href="#subtree-insert-after-node-new" class="headerlink" title="subtree_insert_after(node, new)"></a><code>subtree_insert_after(node, new)</code></h4><p>Insert the new node <code>new</code> through the traversal order, enabling it to be right before <code>node</code> in the tree.</p><ul><li>If there is no <strong>right child</strong>: put <code>new</code> there!<ul><li>You just need to “create” a right child of the <code>node</code> node.</li></ul></li><li>If there is a right child:<ul><li>Then we want the <code>new</code> node to be in the position <strong>before</strong> <code>node.right</code>. Thus, it needs to be <code>node.right</code>‘s left child!</li><li>We should return <code>subtree_first(node.right)</code>.</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span>(node.right == <span class="hljs-literal">nullptr</span>)&#123;<br>node.right = <span class="hljs-keyword">new</span>;<br><span class="hljs-keyword">new</span>.parent = node;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-keyword">new</span>.parent = <span class="hljs-built_in">subtree_first</span>(node.right);<br><span class="hljs-built_in">subtree_first</span>(node.right).left = <span class="hljs-keyword">new</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="subtree-delete-node"><a href="#subtree-delete-node" class="headerlink" title="subtree_delete(node)"></a><code>subtree_delete(node)</code></h4><p>Delete the node without changing other node’s traversal order.</p><p>In order to make the tree no to be “<strong>crashed</strong>“, we first need to get the previous node of the <code>node</code> to be deleted. We can use the <code>predecessor()</code> function which is symmetric to <code>successor()</code> function. </p><p>As is shown obviously, <strong>deleting a leaf node</strong> is very simple, thus we want to <strong>exchange</strong> the node into the leaf node without breaking the traversal order.</p><p>To be more specific, we can understand <code>node</code> as an “invisible” element in the traversal order, which can freely swap positions with other elements without changing the traversal order of the other elements. Ultimately, we hope to move <code>node</code> to the position of a leaf node.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span>(node.right == <span class="hljs-literal">nullptr</span> &amp;&amp; node.left == <span class="hljs-literal">nullptr</span>)&#123;<br><span class="hljs-comment">//is the leaf node</span><br><span class="hljs-keyword">if</span>(node == node.parent.left)&#123;<br>node.parent.left = <span class="hljs-literal">nullptr</span>;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>        node.parent.right = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-keyword">if</span>(node.right != <span class="hljs-literal">nullptr</span>)&#123;<br>        <span class="hljs-comment">//then we can go deeper to get to the leaf node!</span><br>        <span class="hljs-keyword">while</span>(!(node.right == <span class="hljs-literal">nullptr</span> &amp;&amp; node.left == <span class="hljs-literal">nullptr</span>))&#123;<br>            <span class="hljs-built_in">swap</span>(node, <span class="hljs-built_in">predecessor</span>(node));<br>            <span class="hljs-comment">//just swap the content </span><br>        &#125;<br>        <span class="hljs-built_in">delete</span>(node)<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-comment">//the node only have right child</span><br>        <span class="hljs-comment">//swap items with the successor of &lt;X&gt; and recurse</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>In a word, you just need to go down deeper and deeper, until you reach the <strong>leaf node</strong>. Then delete it!</p><h2 id="Applications"><a href="#Applications" class="headerlink" title="Applications"></a>Applications</h2><ul><li><strong>Sequence</strong>: traversal order &#x3D; sequence order.</li><li><strong>Set</strong>: traversal order &#x3D; increasing item key.<ul><li>Binary search tree.</li></ul></li></ul><p>For example, if you want to find an element in the tree, it’s just <strong>like the binary search</strong>! (If is bigger than the target, than go right. Else, go left)</p><p>For we let the Binary search tree to be sorted strictly by value: <code>node.left.value</code> &lt; <code>node.value</code> &lt; <code>node.right.value</code>. This property of Binary Search Tree (BST) is the key of implementing the time complexity of $O(h)$!</p><blockquote><p>We can also implement <code>find_next()</code> and <code>find_pre()</code>.</p></blockquote><p>We have implemented that the time complexity of Binary tree is  $O(h)$. Now, think of the question, what is the relation between tree’s height <code>h</code> and the number of nodes <code>n</code>?</p><ul><li>Case 1: This tree is a full binary tree, which means all nodes are saturated (except for the leaf nodes on the bottom layer). In this case, $n$ is strictly $2^h-1$.</li><li>Case 2: <strong>A singly linked list</strong> is a degenerate binary tree, where the height $h$ of the tree equals the number of nodes $n$.</li></ul><p>Thus, we have</p><p>$$2^h-1 \ge n \ge h$$</p><pre><code class="mermaid" >graph TD;    A[1]    B[2]    C[3]    D[4]    E[5]    F[6]    G[7]    A --> B    A --> C    B --> D    B --> E    C --> F    C --> G</code></pre><pre><code class="mermaid" >graph TD;    A[1]    B[2]    C[3]    D[4]    E[5]    A --> B    A --> null1[null]    B --> C    B --> null2[null]    C --> D    C --> null3[null]    D --> E    D --> null4[null]    E --> null5[null]    E --> null6[null]</code></pre><h2 id="subtree-at-node-i"><a href="#subtree-at-node-i" class="headerlink" title="subtree_at(node, i)"></a><code>subtree_at(node, i)</code></h2><p><code>subtree_at(node, i)</code> requires a node and the index i (0-based), asking to find the ith node in the subtree of <code>node</code>.</p><p>We first assume we have already known the <code>size(node)</code> function which can return the number of nodes in the <code>node</code>‘s subtree. Then we can implement this algorithm.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> nL = <span class="hljs-built_in">size</span>(node.left);<br><span class="hljs-comment">//this is the index of node in the subtree</span><br><span class="hljs-keyword">if</span>(i &lt; nL)&#123;<br>    <span class="hljs-comment">//find the node recursively!</span><br>    <span class="hljs-comment">//for it&#x27;s in the left tree, thus the index of the subtree of node and the index in the subtree of node.right is equal.</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">subtree_at</span>(node.left,i);<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i == nL)&#123;<br>    <span class="hljs-keyword">return</span> node;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-comment">//i &gt; nL</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">subtree_at</span>(node.right, i-nL<span class="hljs-number">-1</span>);<br>    <span class="hljs-comment">//i - nL -1 is the new index in the subtree of node.right. </span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Subtree-augmentation"><a href="#Subtree-augmentation" class="headerlink" title="Subtree augmentation"></a>Subtree augmentation</h3><ul><li>each node can store $O(1)$ extra fields&#x2F;properties.</li><li><code>node.size = node.left.size + node.right.size + 1</code></li><li><strong>Subtree property (node)</strong> can be computed from properties of node’s children (and node) in $O(1)$ time.</li></ul><p>However, if you don’t have any information, computing the size of a subtree achieves $O(n)$ time complexity. (You just need to go through all nodes recursively!) So we <strong>need to sacrefice the space</strong>: for every node, we have a private member called <code>node.size</code>. Then we should update this variable no matter what operations are.</p><p><strong>For insertion and deletion</strong>, we ultimately add a leaf node in the tree. We need to modify all nodes that are ancestors of the added node. It;s also $O(h)$ time complexity.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">while</span>(node != <span class="hljs-literal">nullptr</span>)&#123;<br>node.size ++;<br>    node = node.parent;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Subtree-properties"><a href="#Subtree-properties" class="headerlink" title="Subtree properties"></a>Subtree properties</h3><ul><li>sum, product, min, max of some features of every node in subtree.</li><li><strong>index</strong> in the traversal order is not the properties that need to be maintained because modifications may change all node’s indexes.</li></ul><h1 id="Part2-AVL-Tree"><a href="#Part2-AVL-Tree" class="headerlink" title="Part2: AVL Tree"></a>Part2: AVL Tree</h1><p>We now need to <strong>bound $h$ to $log(n)$</strong>!</p><p><strong>Definitions</strong>: Balanced Binary Tree is a tree that enjoys $h&#x3D;log(n)$.</p><p>A more strict definition: We define the <code>skew</code> of the node:</p><p>$$\left | height(node.left)-height(node.right) \right |\le 1 $$</p><h2 id="Rotation"><a href="#Rotation" class="headerlink" title="Rotation"></a>Rotation</h2><p>We want to modify the tree in a way that doesn’t <strong>modify it in traversal order</strong>. That is rotation, including <strong>right rotation and left rotation</strong>.</p><p><img src="https://s1.imagehub.cc/images/2025/03/13/843efdc5dd2b9de11c4b4cbe5d5b83a0.png" alt="rotate"></p><p>During the process shown above, we can get to manipulate the tree from an unbalanced tree into a <strong>balanced</strong> tree.</p><h3 id="Balanced-Tree"><a href="#Balanced-Tree" class="headerlink" title="Balanced Tree"></a>Balanced Tree</h3><p><strong>All balanced Trees have a logarithmic time complexity.</strong></p><p>We consider the worst balanced tree, which all nodes of the left subtree has the height of h-2, while all nodes of the right subtree has the height of h-1.(The total height, including the root node, is h).</p><p>Then we suppose $N_{h}$ is <strong>the number of nodes in this tree</strong> (height of the tree is h), Then we can solve this case using a recursive equation:</p><p>$$N_{h} &#x3D; N_{h-1} + N_{h -2} + 1$$</p><p>Then is the boring math… We can just skip that part and we can prove that <strong>All balanced Trees have a logarithmic time complexity.</strong></p><h3 id="Height-and-the-unbalanced…"><a href="#Height-and-the-unbalanced…" class="headerlink" title="Height and the unbalanced…"></a>Height and the unbalanced…</h3><p>Consider the lowest <strong>unbalanced node</strong> $x$. We want to build a balanced tree where all nodes enjoys the property of $\left | height(node.left)-height(node.right) \right |\le 1 $ or we can say $ height(node.left)-height(node.right) \in { 1,0,-1 }$.</p><p>Now we know the node $x$ doesn’t enjoy the property above. Moreover, due to it is the lowest unbalanced node, the <strong>out of range</strong> situation will only be $-2$ or $2$.</p><p>Hence, we have properties below: $$height(node.left)-height(node.right) \in {2 , -2  }$$</p><p>Without the loss of generality, we just assume that $height(node.left)-height(node.right) &#x3D; 2$! </p><pre><code class="mermaid" >graph TD    A((A)) --> B((B))    A --> C((C))    B --> D((D))    B --> E((E))    D --> F((F))    D --> G((G))</code></pre><p>Then we suppose the left child of node $x$ is $y$. Then we have three subtrees, where they are: <strong>the right subtree</strong> of node $x$ and the left and the right subtree of node $y$. If we assume $x.right.height &#x3D; k-1$, then $x.left.height &#x3D; k+1$ and $x.height &#x3D; max(x.left.height, x.right.height) + 1 &#x3D; k+2 $. And for the subtree of $x.left$, there are three possibilities:</p><ul><li>$x.left.left.height &#x3D;x.left.right.height + 1 &#x3D; k +1$: Then we can just rotate the node $y$ into the balanced tree!</li><li>$x.left.left.height &#x3D;x.left.right.height  &#x3D; k +1$: The situation is just the same!</li><li>$x.left.left.height + 1 &#x3D;x.left.right.height &#x3D; k +1$</li></ul><p>For the first two questions, you can see the demo shown below:</p><p><img src="https://s1.imagehub.cc/images/2025/03/22/ce857b9d3497c8092f71e2d5a1ef990c.png" alt="Rotation"></p><p><strong>For case 3</strong>, it’s a little bit harder! We can just see this picture shown previously:</p><p><img src="https://s1.imagehub.cc/images/2025/03/13/843efdc5dd2b9de11c4b4cbe5d5b83a0.png" alt="rotate"></p><p>In this case, we will operate <strong>two operations</strong> totally. Firstly, we will right rotate the node $39$ (Just like the operations in the other two cases). Secondly, we will left rotate the node $47$, and it will become a balances tree!</p><h3 id="If-you-want-to-memorize-this"><a href="#If-you-want-to-memorize-this" class="headerlink" title="If you want to memorize this:"></a>If you want to memorize this:</h3><p>Video Clip: <a href="https://www.bilibili.com/video/BV11N4y1x7od/">AVL balanced Tree</a></p><p><img src="https://s1.imagehub.cc/images/2025/03/23/4c704b275bd511867ed2934d22a7134f.png" alt="Memorization"></p><h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>In the first section, we talk about the basis of <strong>Binary Tree</strong>, regarding several operations like <strong>delete and insert a node</strong> and <strong>the traversal order of the binary tree</strong>. Why we need to do this, because the special storage of binary tree ensures all operations is within the time limit of $O(h)$, and the <strong>sequence of traversal</strong> ensures the relations of <strong>a sequential list</strong> and a binary tree. (For the set structure, we have BST)</p><p>In the second part, we need to ensure $O(h) \equiv O(logn)$.If we don’t do anything, there are some bad situations (like the <strong>singly linked list</strong>) where $O(h)&#x3D;O(n)$. To avoid this situation, we need to <strong>rotate the binary tree to a balanced tree</strong> to make the $O(h) \equiv O(logn)$ is true without <strong>changing the traversal order of the binary tree</strong>.</p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tutorial</tag>
      
      <tag>Tree</tag>
      
      <tag>Finished</tag>
      
      <tag>Data Structure</tag>
      
      <tag>C/C++</tag>
      
      <tag>Binary Tree</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Deep_Learning_Memo</title>
    <link href="/posts/Deep-Learning-Memo/"/>
    <url>/posts/Deep-Learning-Memo/</url>
    
    <content type="html"><![CDATA[<style>  html, body, .markdown-body {    font-family: Georgia, sans, serif;  }</style><h1 id="Deep-Learning-Memo"><a href="#Deep-Learning-Memo" class="headerlink" title="Deep Learning Memo"></a>Deep Learning Memo</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>When traning a neural network, there is lot’s of details that require attention, like how to set the learning rate, how to plot the fig, how to manage your project, etc. These details have no relations with the fundamental basis or the first principle of machine learning, they are just a sort of <strong>words of experience</strong>.</p><p>For green hands, there exists a huge gap between simply comprehending and copying other peoples neural networks from coding one’s own neural network. It’s a tough but effective process. Thus, I want to <strong>record my road of practicing deep learning</strong> by updating my Blog. This passage won’t discuss the basic principle and only involve my own experiences and insights during my practical process.</p><p>If you want to update this blog with your own experiences, just contact with the author.</p><h2 id="20250310-Using-matplotlib-in-Linux"><a href="#20250310-Using-matplotlib-in-Linux" class="headerlink" title="20250310 Using matplotlib in Linux"></a>20250310 Using matplotlib in Linux</h2><p>When using <code>matplotlib</code> in my WSL subsystem, I encountered errors as follows:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">qt.qpa.plugin: Could not load the Qt platform plugin <span class="hljs-string">&quot;xcb&quot;</span> <span class="hljs-keyword">in</span> <span class="hljs-string">&quot;&quot;</span> even though it was found.<br>This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem.<br><br>Available platform plugins are: eglfs, minimal, minimalegl, offscreen, vnc, webgl, xcb.<br><br>[1]    5870 IOT instruction (core dumped)  python try_plotting.py<br></code></pre></td></tr></table></figure><p>It seems that Linux cannot load the Qt platform plugin, which as a result failed to load the images.</p><h3 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions"></a>Solutions</h3><p>We cannot let Linux to directly show the plotted figure in the terminal for its lack of GUI interface. But we can realize it by changing Matplotlib’s backend: </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib <span class="hljs-keyword">as</span> mpl<br>mpl.use(<span class="hljs-string">&#x27;Agg&#x27;</span>)<br><span class="hljs-comment">#...</span><br><span class="hljs-comment">#...</span><br><span class="hljs-keyword">import</span> matplotlib.plt <span class="hljs-keyword">as</span> plt<br><span class="hljs-comment"># forbid scientific notation</span><br>np.set_printoptions(suppress=<span class="hljs-literal">True</span>)<br><br><br><span class="hljs-comment"># Then showing the figure by saving the figures.</span><br><br>plt.savefig(<span class="hljs-string">&quot;save/img.png&quot;</span>)<br><br></code></pre></td></tr></table></figure><p>Of course, you can use juypter notebook instead. Remember! Use <code>plt.close()</code> if you want to save more than one image.</p><h2 id="20250310-Arranging-my-file-structure"><a href="#20250310-Arranging-my-file-structure" class="headerlink" title="20250310 Arranging my file-structure"></a>20250310 Arranging my file-structure</h2><p>The contents below is generated by deepseek-v3.</p><h3 id="Simplified-Project-Structure"><a href="#Simplified-Project-Structure" class="headerlink" title="Simplified Project Structure"></a>Simplified Project Structure</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">your_project/<br>│<br>├── data/                    # Raw and processed data<br>│   ├── raw/                 <br>│   └── processed/           <br>│<br>├── models/                  # Trained models<br>│   ├── checkpoints/         # Model checkpoints<br>│   └── final/               # Final models<br>│<br>├── outputs/                 # Training outputs<br>│   ├── logs/                # Logs (e.g., TensorBoard)<br>│   ├── images/              # Generated images<br>│   └── plots/               # Plots<br>│<br>├── scripts/                 # Scripts<br>│   ├── train.py             # Training script<br>│   └── utils.py             # Utility functions<br>│<br>└── README.md                # Project description<br></code></pre></td></tr></table></figure><h3 id="Code-to-Auto-Create-Directories"><a href="#Code-to-Auto-Create-Directories" class="headerlink" title="Code to Auto-Create Directories"></a>Code to Auto-Create Directories</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> datetime<br><br><span class="hljs-comment"># Base directory</span><br>base_dir = <span class="hljs-string">&quot;your_project&quot;</span><br><br><span class="hljs-comment"># Subdirectories</span><br>dirs = &#123;<br>    <span class="hljs-string">&quot;data&quot;</span>: [<span class="hljs-string">&quot;raw&quot;</span>, <span class="hljs-string">&quot;processed&quot;</span>],<br>    <span class="hljs-string">&quot;models&quot;</span>: [<span class="hljs-string">&quot;checkpoints&quot;</span>, <span class="hljs-string">&quot;final&quot;</span>],<br>    <span class="hljs-string">&quot;outputs&quot;</span>: [<span class="hljs-string">&quot;logs&quot;</span>, <span class="hljs-string">&quot;images&quot;</span>, <span class="hljs-string">&quot;plots&quot;</span>],<br>    <span class="hljs-string">&quot;scripts&quot;</span>: []<br>&#125;<br><br><span class="hljs-comment"># Create directories</span><br><span class="hljs-keyword">for</span> parent_dir, sub_dirs <span class="hljs-keyword">in</span> dirs.items():<br>    parent_path = os.path.join(base_dir, parent_dir)<br>    os.makedirs(parent_path, exist_ok=<span class="hljs-literal">True</span>)<br>    <span class="hljs-keyword">for</span> sub_dir <span class="hljs-keyword">in</span> sub_dirs:<br>        sub_path = os.path.join(parent_path, sub_dir)<br>        os.makedirs(sub_path, exist_ok=<span class="hljs-literal">True</span>)<br><br><span class="hljs-comment"># Timestamped output directory</span><br>timestamp = datetime.now().strftime(<span class="hljs-string">&quot;%Y%m%d_%H%M%S&quot;</span>)<br>output_dir = os.path.join(base_dir, <span class="hljs-string">&quot;outputs&quot;</span>, timestamp)<br>os.makedirs(output_dir, exist_ok=<span class="hljs-literal">True</span>)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Directories created. Output directory: <span class="hljs-subst">&#123;output_dir&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="Usage-in-Training-Script"><a href="#Usage-in-Training-Script" class="headerlink" title="Usage in Training Script"></a>Usage in Training Script</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br><span class="hljs-comment"># Example output directory</span><br>output_dir = <span class="hljs-string">&quot;your_project/outputs/20231025_123456&quot;</span><br><br><span class="hljs-comment"># Save model checkpoint</span><br>model_checkpoint_path = os.path.join(output_dir, <span class="hljs-string">&quot;model_checkpoint.pth&quot;</span>)<br><span class="hljs-comment"># torch.save(model.state_dict(), model_checkpoint_path)  # PyTorch example</span><br><br><span class="hljs-comment"># Save training log</span><br>log_file_path = os.path.join(output_dir, <span class="hljs-string">&quot;training_log.txt&quot;</span>)<br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(log_file_path, <span class="hljs-string">&quot;w&quot;</span>) <span class="hljs-keyword">as</span> f:<br>    f.write(<span class="hljs-string">&quot;Epoch 1, Loss: 0.123\n&quot;</span>)<br><br><span class="hljs-comment"># Save generated image</span><br>image_path = os.path.join(output_dir, <span class="hljs-string">&quot;training_plot.png&quot;</span>)<br>plt.plot([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>])<br>plt.savefig(image_path)<br>plt.close()<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Training outputs saved to: <span class="hljs-subst">&#123;output_dir&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="Additional-Tips"><a href="#Additional-Tips" class="headerlink" title="Additional Tips"></a>Additional Tips</h3><ol><li><p><strong>Use a Config File</strong>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># config.py</span><br>BASE_DIR = <span class="hljs-string">&quot;your_project&quot;</span><br>DATA_DIR = os.path.join(BASE_DIR, <span class="hljs-string">&quot;data&quot;</span>)<br>MODELS_DIR = os.path.join(BASE_DIR, <span class="hljs-string">&quot;models&quot;</span>)<br>OUTPUTS_DIR = os.path.join(BASE_DIR, <span class="hljs-string">&quot;outputs&quot;</span>)<br></code></pre></td></tr></table></figure></li><li><p><strong>Use Logging</strong>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> logging<br>logging.basicConfig(filename=os.path.join(output_dir, <span class="hljs-string">&quot;training.log&quot;</span>), level=logging.INFO)<br>logging.info(<span class="hljs-string">&quot;Epoch 1, Loss: 0.123&quot;</span>)<br></code></pre></td></tr></table></figure></li><li><p><strong>Version Control</strong>:<br>Add to <code>.gitignore</code>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">your_project/data/<br>your_project/models/<br>your_project/outputs/<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>Artificial Intelligence</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Artificial Intelligence</tag>
      
      <tag>Deep Learning</tag>
      
      <tag>Convolutional Neural Networks</tag>
      
      <tag>AlexNet</tag>
      
      <tag>Image Clssification</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Taking-Notes</title>
    <link href="/posts/Taking-Notes/"/>
    <url>/posts/Taking-Notes/</url>
    
    <content type="html"><![CDATA[<style>  html, body, .markdown-body {    font-family: Georgia, sans, serif;  }</style><h1 id="Everything-you-need-to-know-about-Note-taking"><a href="#Everything-you-need-to-know-about-Note-taking" class="headerlink" title="Everything you need to know about Note-taking"></a>Everything you need to know about Note-taking</h1><p>To deliver my explanations more clearly, I will write this blog in Chinese, then translate it into English.</p><h1 id="Chinese-Version-About-Note-Taking"><a href="#Chinese-Version-About-Note-Taking" class="headerlink" title="Chinese Version: About Note Taking"></a>Chinese Version: About Note Taking</h1><p>在笔者数年的求学生涯中，<strong>记笔记</strong>总是被老师和家长宣传为<strong>认真学习</strong>的标杆之一。中学时期的笔者始终坚信这句话，每个学科的笔记本记了一本又一本，也在高考中取得了不错的成绩。但是，进入大学之后，笔者曾经对<strong>自己引以为傲的学习方法</strong>产生了怀疑，甚至一度将<strong>记笔记</strong>列为<strong>假努力，假学习</strong>的范畴。毕竟，我们很少看到在较为专业的学术讲坛中，资深的学者们人手抱着活页笔记本埋头记笔记。那<strong>记笔记</strong>究竟是一种怎样的学习方法，笔者百思不得其解。</p><p>在这篇博客中，笔者将会结合自己的经历，<strong>从记笔记的第一性原理出发</strong>，使记笔记的效益达到最大化。</p><h2 id="Definition？"><a href="#Definition？" class="headerlink" title="Definition？"></a>Definition？</h2><p>很奇怪，我们好像很少讨论记笔记的<strong>定义</strong>，但这似乎是非常重要的一件事情，因为记笔记的形式可以有多种多样，为了简化我们的讨论，我给出<strong>记笔记的如下定义</strong>：</p><div class="note note-primary">            <p>记笔记是指在学习过程中，将<strong>视觉、听觉等感官信息以书面形式记录下来</strong>的行为。</p>          </div><p>我们在定义中约束了记笔记的如下特征：</p><ul><li>我们讨论的记笔记都是<strong>针对学习新知识</strong>，对于其他的领域（例如备忘录，自由创作）等在本文不涉及。</li><li>记笔记需要接受<strong>感官信息</strong>，这样的感官信息是不唯一的，主要包括：<ul><li>视觉信息</li><li>听觉信息</li><li>思考</li><li>（其余暂时不考虑）</li></ul></li><li>记笔记需要以<strong>书面形式</strong>记录，在这里我们不讨论到底是使用活页本还是使用无纸化学习，因为这涉及生产力问题，与记笔记的第一性原理并无关联。</li></ul><h2 id="Why-notes"><a href="#Why-notes" class="headerlink" title="Why notes?"></a>Why notes?</h2><p>接下来，我们正式开始今天的讨论。</p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://www.youtube.com/watch?v=cRQqH18wJgw">Source of the Blog cover</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Efficient Tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tutorial</tag>
      
      <tag>Methodologies</tag>
      
      <tag>Taking Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Pre-Training-Is-Dead?</title>
    <link href="/posts/Pre-training-Is-Dead/"/>
    <url>/posts/Pre-training-Is-Dead/</url>
    
    <content type="html"><![CDATA[<h1 id="Neurips-Speeches-Pretraining-is-Dead"><a href="#Neurips-Speeches-Pretraining-is-Dead" class="headerlink" title="Neurips Speeches: Pretraining is Dead?"></a>Neurips Speeches: Pretraining is Dead?</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>I originally intended to write this blog in December, but Ilya’s views faced a lot of opposition at that time. However, in just three months, <strong>the emergence of Deepseek and the explosive growth of the AI agent sector</strong> seem to validate the correctness of this speech. In this blog, I will analyze, from the current perspective, the <strong>shift in the development path of AI starting from scaling laws</strong>, and interpret Ilya’s predictions for future development prospects.</p><p>The transcripts are copied from here<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="[speech's scripts](https://github.com/shun-liang/readable-talks-transcriptions/blob/main/neurips_2024/Vincent%20Weisser%20-%20.%40ilyasut%20full%20talk%20at%20neurips%202024%20pre-training%20as%20we%20know%20it%20will%20end%20and%20what%20comes%20next%20is%20superintelligence%20agentic%2C%20reasons%2C%20understands%20and%20is%20self%20aware.md)">[2]</span></a></sup>, and you can go through YouTube for the original video<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="[the original videos](https://www.youtube.com/watch?v=1yvBqasHLZs&t=10s)">[1]</span></a></sup>.</p><h2 id="Table-of-contents"><a href="#Table-of-contents" class="headerlink" title="Table of contents"></a>Table of contents</h2>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-b2241494" role="button" aria-expanded="false" aria-controls="collapse-b2241494">        <div class="fold-arrow">▶</div>TBD      </div>      <div class="fold-collapse collapse" id="collapse-b2241494">        <div class="fold-content">          <ul><li>0:00:00 <a href="#neurips-then-and-now">NeurIPS Then and Now</a></li><li>0:00:30 <a href="#a-ten-year-retrospective">A Ten Year Retrospective</a></li><li>0:01:22 <a href="#the-scaling-hypothesis-neural-network-history">The Scaling Hypothesis: Neural Network History</a></li><li>0:05:58 <a href="#connectionism-the-foundation-of-deep-learning">Connectionism: The Foundation of Deep Learning</a></li><li>0:09:51 <a href="#scaling-in-biology-body-size-and-brain-mass">Scaling in Biology: Body Size and Brain Mass</a></li><li>0:16:45 <a href="#beyond-neurons-new-frontiers-in-cognition">Beyond Neurons: New Frontiers in Cognition</a></li><li>0:16:59 <a href="#biological-inspiration-in-ai-limited-but-successful">Biological Inspiration in AI: Limited but Successful</a></li><li>0:18:12 <a href="#ai-reasoning-hallucinations-and-rights">AI Reasoning, Hallucinations, and Rights</a></li><li>0:22:13 <a href="#multi-hop-reasoning-and-distribution-generalization">Multi-hop reasoning and distribution generalization</a></li></ul>        </div>      </div>    </div><h2 id="A-Ten-Year-Retrospective"><a href="#A-Ten-Year-Retrospective" class="headerlink" title="A Ten Year Retrospective"></a>A Ten Year Retrospective</h2><p style="font-family: 'Times New Roman', serif; font-size: 20px; font-style: italic">And now we've got my experienced, hopefully visor. But here I'd like to talk a little bit about the work itself and maybe a ten year retrospective on it. Because a lot of the things in this work were correct, but some not so much. And we can review them and we can see what happened and how it gently flowed to where we are today.</p><h3 id="The-Scaling-Hypothesis-Neural-Network-History"><a href="#The-Scaling-Hypothesis-Neural-Network-History" class="headerlink" title="The Scaling Hypothesis: Neural Network History"></a>The Scaling Hypothesis: Neural Network History</h3><p style="font-family: 'Times New Roman', serif; font-size: 20px; font-style: italic">So let's begin by talking about what we did. And the way we'll do it is by showing slides from the same talk 10 years ago. But the summary of what we did is the following three bullet points.</p><ul><li><strong>Autoregressive model trained on text</strong>.</li><li><strong>Large neural networks</strong>.</li><li><strong>Large dataset</strong>.</li></ul><p style="font-family: 'Times New Roman', serif; font-size: 20px; font-style: italic">And what we said here is that if you have a large neural network with 10 layers, then it can do anything that a human being can do in a fraction of a second.     </p><p style="font-family: 'Times New Roman', serif; font-size: 20px; font-style: italic"> Well, if you believe the deep learning dogma, so to say, that artificial neurons and biological neurons are similar, or at least not too different. And you believe that real neurons are slow, then anything that we can do quickly. By we, I mean human beings. I even mean just one human in the entire world. If there is one human in the entire world that can do some task in a fraction of a second, then a 10 layer neural network can do it too. Right? It follows. You just take their connections and you embed them inside your neural net, the artificial one. </p><p style="font-family: 'Times New Roman', serif; font-size: 20px; font-style: italic">If you could go beyond in your layers somehow, then you could do more. But back then, we could only do 10 layers, which is why we emphasized whatever human beings can do in a fraction of a second. </p><p style="font-family: 'Times New Roman', serif; font-size: 20px; font-style: italic">A different slide from the talk. You might be able to recognize that something auto-regressive is going on here. The slide says that if you have an auto-regressive model and it predicts the next token well enough, then it will in fact grab and capture and grasp the correct distribution over sequences that come next. And this was a relatively new thing. It wasn't literally the first ever auto-regressive neural network, but I would argue it was the first auto-regressive neural network where we really believed that if you train it really well, then you will get whatever you want. </p><p><img src="https://s1.imagehub.cc/images/2025/03/10/23f27504cf03f87506abbe68dae8a379.png" alt="Autoregressive Model"></p><p style="font-family: 'Times New Roman', serif; font-size: 20px; font-style: italic">Now I'm going to show you some ancient history that many of you may have never seen before. It's called the LSTM. To those unfamiliar, an LSTM is the thing that poor deep learning researchers did before Transformers. And it's basically a ResNet, but rotated 90 degrees.</p><p><img src="https://s1.imagehub.cc/images/2025/03/10/9b484a8616b8c6ff89034f50417662f8.png" alt="The LSTM model"></p><p style="font-family: 'Times New Roman', serif; font-size: 20px; font-style: italic">Another cool feature from that old talk that I want to highlight is that we used parallelization. But not just any parallelization. We used pipelining, as witnessed by this one layer per GPU. Was it wise to pipeline? As we now know, pipelining is not wise. But we were not as wise back then. So we used that and we got a 3.5x speedup using eight GPUs.</p><p style="font-family: 'Times New Roman', serif; font-size: 20px; font-style: italic">And the conclusion slide in some sense, the conclusion slide from the talk from back then is the most important slide because it spelled out what could arguably be the beginning of the scaling hypothesis, right? That if you have a very big data set and you train a very big neural network, then success is guaranteed. </p><p><strong>Maybe this is the prototype of Scaling Law</strong>! Without considering the limitation of data and computing resources (at least we have Moore’s Law), the model’s accuracy can be guaranteed by increasing the number of parameters and the training cost. In other world, the more parameters the model have, the more powerful the model it is, if given enough training resources.</p><p>This answer is cruel, but somehow effectiveness.</p><h2 id="The-age-of-Pre-Training"><a href="#The-age-of-Pre-Training" class="headerlink" title="The age of Pre-Training"></a>The age of Pre-Training</h2><p><img src="https://s1.imagehub.cc/images/2025/03/10/4965aee1f8450caee29f72db0e993283.png" alt="The age of pre-training"></p><p style="font-family: 'Times New Roman', serif; font-size: 20px; font-style: italic">But what this led to the age of pre-training. And the age of pre-training is what we might say the GPT-2 model, the GPT-3 model, the scaling laws. And I want to specifically call out my former collaborators, Alec Radford, also Jared Kaplan, Dario Amode, for really making this work. And this is what's been the driver of all of progress, all the progress that we see today. Extra-large neural networks. Extra-ordinarily large neural networks trained on huge data sets. </p><p style="font-family: 'Times New Roman', serif; font-size: 20px; font-style: italic">But pre-training as we know it will <b>unquestionably end</b>. Pre-training will end. Why will it end? Because while compute is growing through better hardware, better algorithms, and larger clusters, all those things keep increasing your compute. All these things keep increasing your compute. The data is not growing because we have but one internet. We have but one internet. You could even say, you could even go as far as to say that data is the fossil fuel of AI. It was like created somehow, and now we use it, and we've achieved peak data, and there will be no more. <h2 id="What-comes-next"><a href="#What-comes-next" class="headerlink" title="What comes next?"></a>What comes next?</h2><p style="font-family: 'Times New Roman', serif; font-size: 20px; font-style: italic"> So, here I'll take a bit of liberty to speculate about what comes next. Actually, I don't need to speculate because many people are speculating too. And I'll mention their speculations. You may have heard the phrase <b>agents</b>. It's common. And I'm sure that eventually something will happen. But people feel like something agents is the future. More concretely, but also a little bit vaguely, <b>synthetic data</b>. But what does synthetic data mean? Figuring this out is a big challenge. And I'm sure that different people have all kinds of interesting progress there. And an <b>inference time compute</b>, or maybe what's been most recently, most vividly seen in O1, the O1 model. These are all examples of things, of people trying to figure out what to do after pretraining. And those are all very good things to do.<ul><li><strong>Agents</strong></li><li><strong>Synthetic Data</strong></li><li><strong>Inference time compute</strong></li></ul><h3 id="Scaling-in-Biology-Body-Size-and-Brain-Mass"><a href="#Scaling-in-Biology-Body-Size-and-Brain-Mass" class="headerlink" title="Scaling in Biology: Body Size and Brain Mass"></a>Scaling in Biology: Body Size and Brain Mass</h3><p><img src="https://i-blog.csdnimg.cn/direct/1e4533a2f3a142d59da834d0473cb688.png" alt="Example from nature"></p><p style="font-family: 'Times New Roman', serif; font-size: 20px; font-style: italic">I want to mention one other example from biology, which I think is really cool.  What that means is that there is a precedent. There is an example of biology figuring out <b>some kind of different scaling</b>. Something clearly is different. So, I think that is cool.<h3 id="In-the-long-term…"><a href="#In-the-long-term…" class="headerlink" title="In the long term…"></a>In the long term…</h3><h4 id="Super-Intelligence"><a href="#Super-Intelligence" class="headerlink" title="Super Intelligence"></a>Super Intelligence</h4><ul><li>Agentic</li></ul><p style="font-family: 'Times New Roman', serif; font-size: 20px; font-style: italic">Those systems are actually going to be agentic in real ways. Whereas right now, the systems are not agents in any meaningful sense. Just very, that might be too strong. They are very, very slightly agentic. Just beginning.<ul><li>Reasons</li></ul><p style="font-family: 'Times New Roman', serif; font-size: 20px; font-style: italic">It will actually reason. And by the way, I want to mention something about reasoning. Is that a system that reasons, the more it reasons, the more unpredictable it becomes. The more it reasons, the more unpredictable it becomes. All the deep learning that we've been used to is very predictable. Because if you've been working on replicating human intuition essentially. It's like the gut feel. If you come back to the 0.1 second reaction time. What kind of processing we do in our brains? Well, it's our intuition. So we've endowed our AIs with some of that intuition. <b>But reasoning, and you're seeing some early signs of that. Reasoning is unpredictable. And one reason to see that is because the chess AIs, the really good ones, are unpredictable to the best human chess players</b>. <p style="font-family: 'Times New Roman', serif; font-size: 20px; font-style: italic">So we will have to be dealing with AI systems that are incredibly unpredictable. They will understand things from limited data. They will not get confused. All the things which are really big limitations. <div class="note note-info">            <p><strong>In the Q&amp;A part</strong>: About reasoning and hallucinations</p><p>You mentioned reasoning as being one of the core aspects of maybe the modeling in the future. And maybe a differentiator. What we saw in some of the poster sessions is that hallucinations in today’s models, the way we’re analyzing… I mean, maybe you correct me. You’re the expert on this. But the way we’re analyzing whether a model is hallucinating today without… Because we know of the dangers of models not being able to reason, that we’re using a statistical analysis. Let’s say some amount of standard deviations or whatever away from the mean. In the future, wouldn’t it… Do you think that a model given reasoning will be able to correct itself, sort of autocorrect itself? And that will be a core feature of future models so that there won’t be as many hallucinations because the model will recognize when… Maybe that’s too esoteric of a question. But the model will be able to reason and understand when a hallucination is occurring. Does the question make sense?</p><p style="font-family: 'Times New Roman', serif; font-size: 20px; font-style: italic"><b>Yes, the answer is yes! </b>          </div><p style="font-family: 'Times New Roman', serif; font-size: 20px; font-style: italic"><b>I'm not saying how, by the way. And I'm not saying when. I'm saying that it will. </b><ul><li>Self-awareness</li></ul><p style="font-family: 'Times New Roman', serif; font-size: 20px; font-style: italic">And when all those things will happen together with self-awareness. Because why not? Self-awareness is useful. You, ourselves, are parts of our own world models. When all those things come together. We will have systems of radically different qualities and properties that exist today. And of course, they will have incredible and amazing capabilities. But the kind of issues that come up with systems like this. And I'll just leave it as an exercise to imagine. It's very different from what we are used to. <h2 id="Q-A-Part"><a href="#Q-A-Part" class="headerlink" title="Q&amp;A Part"></a>Q&amp;A Part</h2><p><strong>Q</strong>:  Now, in 2024, are there other biological structures that are part of human cognition that you think are worth exploring in a similar way or that you’re interested in anyway?</p><p style="font-family: 'Times New Roman', serif; font-size: 20px; font-style: italic">So, the way I'd answer this question is that if you are or someone is a person who has a specific insight about, hey, we are all being extremely silly because clearly the brain does something and we are not. And that's something that can be done and that's something that can be done and they should pursue it. I personally don't. Well, <b>it depends on the level of abstraction you're looking at</b>. Maybe I'll answer it this way. Like there's been a lot of desire to make <b>biologically inspired AI</b>. And you could argue on some level that biologically inspired AI is incredibly successful, which is all of deep learning is biologically inspired AI. But on the other hand, <b>the biological inspiration was very, very, very modest</b>. It's like, let's use neurons. This is the full extent of the biological inspiration. Let's use neurons. And more detailed biological inspiration has been very hard to come by. But I wouldn't rule it out. I think if someone has a special insight, they might be able to see something and that would be useful.<p><strong>Q</strong>: I wanted to ask, do you think LLMs generalize multi-hop reasoning out of distribution?</p><p style="font-family: 'Times New Roman', serif; font-size: 20px; font-style: italic">So, okay. The question assumes that the answer is yes or no. But the question should not be answered yes or no. Because what does it mean, out of distribution generalization? What does it mean? What does it mean in distribution? And what does it mean out of distribution? Because it's a test of time talk, I'll say, that long, long ago, before people were using deep learning, they were using things like string matching, n-grams. For machine translation, people were using statistical phrase tables. Can you imagine? They had tens of thousands of code of complexity, which was, I mean, it was truly unfathomable. And back then, generalization meant, is it literally not in the same word phrasing as in the data set? Now, we may say, well, sure, my model achieves this high score on, I don't know, math competitions. But maybe the math, maybe some discussion in some forum on the internet was about the same ideas, and therefore it's memorized. Well, okay, you could say maybe it's in distribution, maybe it's memorization. But I also think that our standards for what counts as generalization have increased really quite substantially, dramatically, unimaginably, if you keep track. And so I think the answer is, to some degree, probably not as well as human beings. I think it is true that human beings generalize much better. But at the same time, they definitely generalize out of distribution to some degree.<h2 id="Other-Lectures-about-Pre-training-and-Scaling-Law"><a href="#Other-Lectures-about-Pre-training-and-Scaling-Law" class="headerlink" title="Other Lectures about Pre-training and Scaling Law"></a>Other Lectures about Pre-training and Scaling Law</h2><h3 id="Jason-Wei-Scaling-Paradigms-for-Large-Language-Models"><a href="#Jason-Wei-Scaling-Paradigms-for-Large-Language-Models" class="headerlink" title="Jason Wei: Scaling Paradigms for Large Language Models"></a>Jason Wei: Scaling Paradigms for Large Language Models</h3><p>The original video on Youtube is <a href="https://www.youtube.com/watch?v=yhpjpNXJDco">here</a>.<sup id="fnref:5" class="footnote-ref"><a href="#fn:5" rel="footnote"><span class="hint--top hint--rounded" aria-label="[Jason Wei: Scaling Paradigms for Large Language Models](https://www.youtube.com/watch?v=yhpjpNXJDco)">[5]</span></a></sup></p><p>The scaling paradigms for <strong>next-word predictions</strong> works so well, but is it all we need to achieve <strong>AGI</strong>? Maybe not, Jason Wei gives his reasons in the text below:</p><p>Some words may be super hard for next-token predictions to implement.</p><p><img src="https://s1.imagehub.cc/images/2025/03/17/ce50369c2b6655334d2a218439e9b9c4.png" alt="The disadvantage of next-token prediction"></p><p>In pure-next-token prediction, the model sees language as a <strong>pure probablility of language distribution</strong>, it means the model uses similar computing resources to solve hard tasks and easier ones.</p><p><strong>The approach</strong>: Chain of Thought Prompting.</p><p><strong>The limitation of CoT</strong>: We want the model’s chain of thought to be my inner monologue or like a stream of thought.</p><p>All in all, only the “dumb” scaling law is not correct in the long run! We need to find something for effective, rather than naive. Maybe is <strong>LLM reasoning</strong>.</p><h3 id="Shital-Shah’s-comment-on-scaling-law…"><a href="#Shital-Shah’s-comment-on-scaling-law…" class="headerlink" title="Shital Shah’s comment on scaling law…"></a>Shital Shah’s comment on scaling law…</h3><p><img src="https://s1.imagehub.cc/images/2025/03/25/1bbc71c38c1050629c8a009b2ea4a765.png" alt="Scaling Law"></p><p>The whole transcripts</p><blockquote><p>With current synthetic data techniques, one issue is that they don’t add a lot of new entropy to the original pre-training data. Pre-training data is synthesized from spending centuries of human-FLOPs. <strong>Prompt-based synthetic generation can only produce data in the neighborhood of existing data.</strong> This creates an entropy bottleneck: there is simply not enough entropy per token to gain as you move down the tail of organic data or rely on prompt-based synthetic data.</p></blockquote><blockquote><p>A possible solution is to <strong>spend more compute time during testing to generate synthetic data with higher entropy content</strong>. The entropy per token in a given dataset seems to be related to the FLOPs spent on generating that data. Human data was generated from a vast amount of compute spent by humans over millennia. Our pre-training data is the equivalent of fossil fuel, and that data is running out.</p></blockquote><blockquote><p>While human-FLOPs are in limited supply, <strong>GPU-FLOPs through techniques like ttc can allow us to generate synthetic data with high entropy</strong>, offering a way to overcome this bottleneck. However, the bad news is that we will need more compute than predicted by scaling laws. So, can’t we just rely solely on task-targeted compute?</p></blockquote><blockquote><p>Merely scaling inference compute won’t be sufficient. A weak model can spend an inordinate amount of inference compute and still fail to solve a hard problem. <strong>There seems to be an intricate, intertwined dance between training and inference compute, with each improving the other. Imagine a cycle of training a model, generating high-entropy synthetic data by scaling inference compute, and then using that data to continue training. This is the self-improving recipe.</strong></p></blockquote><blockquote><p>Humans operate in a similar way: we consume previously generated data and use it to create new data for the next generation. One critical element in this process is <strong>embodiment</strong>, which <strong>enables the transfer of entropy from our environment</strong>. Spend thousands of years of human-FLOPs in this way, and you get the pre-training data that we currently use!</p></blockquote><h3 id="Neurips-2024-speech-delivered-by-Kaiming-He"><a href="#Neurips-2024-speech-delivered-by-Kaiming-He" class="headerlink" title="Neurips 2024 speech delivered by Kaiming He"></a>Neurips 2024 speech delivered by Kaiming He</h3><p>ML Research, via the Len</p><ul><li>Research is SGD in a chaotic landscape</li><li>Look for ‘surprise’</li><li>Future is the Real Test set</li><li>Scalability</li></ul><p>The files stores in <a href="https://people.csail.mit.edu/kaiming/neurips2024workshop/neurips2024_newinml_kaiming.pdf">here</a>.</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://www.youtube.com/watch?v=1yvBqasHLZs&t=10s">the original videos</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://github.com/shun-liang/readable-talks-transcriptions/blob/main/neurips_2024/Vincent%20Weisser%20-%20.%40ilyasut%20full%20talk%20at%20neurips%202024%20pre-training%20as%20we%20know%20it%20will%20end%20and%20what%20comes%20next%20is%20superintelligence%20agentic%2C%20reasons%2C%20understands%20and%20is%20self%20aware.md">speech’s scripts</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://www.reddit.com/r/singularity/comments/1hdrjvq/ilyas_full_talk_at_neurips_2024_pretraining_as_we/">https://www.reddit.com/r/singularity/comments/1hdrjvq/ilyas_full_talk_at_neurips_2024_pretraining_as_we/</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span><a href="https://luluyan.medium.com/notes-on-ilyas-talk-at-neurips-2024-will-the-causal-compass-be-guiding-ai-s-future-with-reason-e387fa6d8dc9">Remarks by luluyan</a><a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:5" class="footnote-text"><span><a href="https://www.youtube.com/watch?v=yhpjpNXJDco">Jason Wei: Scaling Paradigms for Large Language Models</a><a href="#fnref:5" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:6" class="footnote-text"><span><blockquote>Scaling laws assume that the quality of tokens remains mostly the same as you scale. However, in real-world large-scale datasets, this is not true. When there is an upper bound on quality training tokens, there is an upper bound on scaling. But what about synthetic data?</blockquote><a href="#fnref:6" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:6" class="footnote-text"><span><a href="https://x.com/sytelus/status/1857102074070352290">https://x.com/sytelus/status/1857102074070352290</a><a href="#fnref:6" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Artificial Intelligence</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Artificial Intelligence</tag>
      
      <tag>Deep Learning</tag>
      
      <tag>Finished</tag>
      
      <tag>Pretraining</tag>
      
      <tag>Large Language Models</tag>
      
      <tag>Celebrity speeches</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS294-3-Autogen</title>
    <link href="/posts/CS294-3-Autogen/"/>
    <url>/posts/CS294-3-Autogen/</url>
    
    <content type="html"><![CDATA[<style>  html, body, .markdown-body {    font-family: Georgia, sans, serif;  }</style><h1 id="CS294-194-196-Autogen"><a href="#CS294-194-196-Autogen" class="headerlink" title="CS294&#x2F;194-196 Autogen"></a>CS294&#x2F;194-196 Autogen</h1><p>Finally back… So sorry for the updating absence these days.</p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>In nowadays GPT models, which is known as <strong>Generative Large Language Models</strong>, is extremely powerful in <strong>generating new tokens</strong>, including generating texts, images, or even videos. We see the hope of <strong>AGI</strong> (Artificial General Intelligence) coming in the next few years. However, for real-world scenario, there is still plenty of room for improvement in <strong>enhancing the breadth and depth of problem-solving</strong> for large language models.</p><ul><li><strong>For depth</strong>: LLM’s reasoning and reinforcement learning may be the final way out! (We won’t discuss this topic now, you can skip to my another blog focusing on LLM reasoning instead)</li><li><strong>For breadth</strong>: Well, let’s dive deeper into this problem.</li></ul><p>Assume you want to develop a small program for your study (a program for arranging daily plans, etc). You can you <strong>GPT-4o</strong> or <strong>Deepseek</strong> by using prompt of “Please help me develop a python program to arrange my daily routines and tasks automatically.”</p><p>Then models may reply a response like this:</p><p><img src="https://s1.imagehub.cc/images/2025/03/07/b3b864199610be7ceaf0158631223db9.png" alt="gpt"></p><blockquote><p>I use <strong>Next-chat</strong> applications by filling my <code>gpt-api-key</code>.</p></blockquote><p>It’s great, but <strong>when the task is becoming more complex</strong>, it’s likely for models to make mistakes. For example, if you ask only one AI model to write a brand new <strong>operating system</strong>, it won’t get a satisfied response.</p><p><img src="https://s1.imagehub.cc/images/2025/03/07/85e76179162461fb85698975d7750dca.png" alt="When you help AI to build Large-scale projects..."></p><p><strong>So what’s next</strong>? Enhancing the single performance won’t get too much progress compared to the increasing cost of computing resources. Thus, <strong>multi-agent</strong> is here to implement and solve large-scale developing projects!</p><p>Today, we gonna introduce <code>Autogen</code><sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://github.com/microsoft/autogen">[1]</span></a></sup>, a framework for creating multi-agent AI applications that can act autonomously or work alongside humans. This framework is developed by <strong>Microsoft</strong>.</p><h2 id="Multi-Agent-Orchestration"><a href="#Multi-Agent-Orchestration" class="headerlink" title="Multi-Agent Orchestration"></a>Multi-Agent Orchestration</h2><ul><li>Static &#x2F; Dynamic</li><li>Context Sharing &#x2F; isolation</li><li>Cooperation &#x2F; competition</li><li>Centralized &#x2F; decentralized</li><li>Intervention &#x2F; automation</li></ul><h2 id="Agent-Design-Patterns"><a href="#Agent-Design-Patterns" class="headerlink" title="Agent Design Patterns"></a>Agent Design Patterns</h2><ul><li>Conversations</li><li>Prompting &amp; Reasoning<ul><li>React</li><li>Chain of thought</li></ul></li><li>Tool use</li><li>Planning</li><li>Integrating multiple models, modalities and memories</li></ul><h2 id="2-Core-Operations"><a href="#2-Core-Operations" class="headerlink" title="2 Core Operations"></a>2 Core Operations</h2><ul><li><strong>Define Agents</strong>: Conversable &amp; Customizable</li><li><strong>Get them to talk</strong>: Conversation Programming</li></ul><h1 id="LlamaIndex"><a href="#LlamaIndex" class="headerlink" title="LlamaIndex"></a>LlamaIndex</h1><h2 id="A-better-Knowledge-Assistant"><a href="#A-better-Knowledge-Assistant" class="headerlink" title="A better Knowledge Assistant"></a>A better Knowledge Assistant</h2><p>Basic Rag use the traditional <strong>Embeddings</strong> methods to split the text into chunks and search the text with the similarity… It is too naive sometimes, leading to the hallucination and moreover, large language models only needs to summarize the given text which is a quite simple task for them.</p><p>So we need a better RAG!</p><ul><li><strong>High-Quality Multi-Modal RAG</strong></li><li>Complex Output Generation.(Generating a report, etc.)</li><li>Agentic Reasoning over complex inputs</li><li>Towards a scalable, full-stack development.</li></ul><p>Traditional Embedding methods only handle with text messages.</p><h3 id="Setting-up-a-Multi-Modal-RAG"><a href="#Setting-up-a-Multi-Modal-RAG" class="headerlink" title="Setting up a Multi Modal RAG"></a>Setting up a Multi Modal RAG</h3><p>Visual Data…</p><p>We need a LLM-PDF-parser to make the parsing and chunking period, which could decrease the <strong>hallucination</strong> when LLMs are faced with visual data.</p><p><img src="https://s1.imagehub.cc/images/2025/04/06/34a89d11e713bb31c1f1facdc9d48342.png" alt="Document Parser"></p><h3 id="Agentic-Reasoning-over-complex-inputs"><a href="#Agentic-Reasoning-over-complex-inputs" class="headerlink" title="Agentic Reasoning over complex inputs"></a>Agentic Reasoning over complex inputs</h3><p>Like the ReAct model</p><ul><li>Tool Use</li><li>Planning</li><li>Memory</li><li>Reflection</li></ul><h4 id="Unconstrained-Constrained-Flows"><a href="#Unconstrained-Constrained-Flows" class="headerlink" title="Unconstrained &amp; Constrained Flows"></a>Unconstrained &amp; Constrained Flows</h4><ul><li><p>Constrained Flows</p></li><li><p><img src="https://s1.imagehub.cc/images/2025/04/06/c3d3cff5953222f1b9f16ce683176dde.png" alt="Constrained FLows"></p><ul><li>We design a <strong>router</strong> based on prompts to let LLM design which tools to use, and then let the LLM reflect on the performance, finally getting the output.</li><li>It is more reliable, but less expressive, because the router will only allocate different tasks to relatively fixed-tool use.</li></ul></li><li><p>Unconstrained Flows</p></li><li><p><img src="https://s1.imagehub.cc/images/2025/04/06/e45c84af30feadaf226fa761aba64512.png" alt="Unconstrained Flows"></p><ul><li><strong>Agent Orchestrator</strong> could decide which tools to use automatically and combine different tools together.</li><li>In this case, you no longer use simple if-else allocation logic, but instead give the agent greater autonomy. This can lead to a heavy reliance on the agent’s capabilities and may result in consequences such as <strong>infinite loops</strong>. (That is why it is <strong>less reliable</strong>)</li></ul></li></ul><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://github.com/microsoft/autogen">https://github.com/microsoft/autogen</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Artificial Intelligence</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Artificial Intelligence</tag>
      
      <tag>Deep Learning</tag>
      
      <tag>Finished</tag>
      
      <tag>Autogen</tag>
      
      <tag>Agent</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python-Numpy-Cheatsheet</title>
    <link href="/posts/Python-numpy-cheatsheet/"/>
    <url>/posts/Python-numpy-cheatsheet/</url>
    
    <content type="html"><![CDATA[<style>  html, body, .markdown-body {    font-family: Georgia, sans, serif;  }</style><h1 id="Numpy-CheatSheet"><a href="#Numpy-CheatSheet" class="headerlink" title="Numpy CheatSheet"></a>Numpy CheatSheet</h1><p>See the repo on my github: <a href="https://github.com/xiyuanyang-code/numpy_tutorial">https://github.com/xiyuanyang-code/numpy_tutorial</a>.</p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><blockquote><p>This section is copied from <code>README.md</code> part in my github repo.</p></blockquote><h3 id="Learning-Numpy-within-30-minutes"><a href="#Learning-Numpy-within-30-minutes" class="headerlink" title="Learning Numpy within 30 minutes!"></a>Learning Numpy within 30 minutes!</h3><p>😊Quickly get started with basic NumPy operations in 30 minutes!</p><p>See <a href="https://xiyuanyang-code.github.io/posts/Python-numpy-cheatsheet/">https://xiyuanyang-code.github.io/posts/Python-numpy-cheatsheet/</a> for more details.</p><h4 id="Introduction-1"><a href="#Introduction-1" class="headerlink" title="Introduction"></a>Introduction</h4><p>NumPy is the fundamental package for scientific computing in Python. It is a Python library that provides a multidimensional array object, various derived objects (such as masked arrays and matrices), and an assortment of routines for fast operations on arrays, including mathematical, logical, shape manipulation, sorting, selecting, I&#x2F;O, discrete Fourier transforms, basic linear algebra, basic statistical operations, random simulation and much more. <sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://numpy.org/doc/stable/">[1]</span></a></sup></p><p>This repo provides with the basic numpy tutorial with <code>.ipynb</code> file, aiming to teach greenhands to quickly get started with basic NumPy operations using Jupyter Notebook interaction in 30 minutes.</p><h4 id="Installation"><a href="#Installation" class="headerlink" title="Installation"></a>Installation</h4><p>This command is for importing the numpy module in your python scripts:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip install numpy==1.26.4<br></code></pre></td></tr></table></figure><p>You can also use the <code>requirements.txt</code> file in this repo.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip install -r requirements.txt<br></code></pre></td></tr></table></figure><p>After the installation, run the first code cell in <code>numpy_tutorial.ipynb</code> to check if the output is correct. (<code>1.26.4</code>)</p><h4 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h4><p>The tutorial includes several parts:</p><ul><li>Creating arrays and matrix</li><li>Checking parameters of Arrays</li><li>Accessing and modifying elements<ul><li>Slices</li><li>Modifications</li></ul></li><li>Repetition, Copying and Reshaping<ul><li>Repeat</li><li>Copy</li><li>Reshape</li></ul></li><li>Linear Algebra and other mathematical operations<ul><li>Basic Mathematical operations</li><li>Linear Algebra</li></ul></li><li>Statics<ul><li>Boolean Mask</li></ul></li><li>Advanced Usage<ul><li>Loading data from files</li></ul></li></ul><p>Go to the juypter notebook for more details!</p><h4 id="In-the-future…"><a href="#In-the-future…" class="headerlink" title="In the future…"></a>In the future…</h4><p>We will finish the <code>/demo</code> directory in the future, which will provides you with practical applications of numpy.</p><h4 id="References"><a href="#References" class="headerlink" title="References"></a>References</h4><h2 id="Basic-Usage"><a href="#Basic-Usage" class="headerlink" title="Basic Usage"></a>Basic Usage</h2><blockquote><p>This section is copied from <code>numpt_tutorial.ipynb</code> section in my github repo.</p></blockquote><h1 id="Numpy-tutorial"><a href="#Numpy-tutorial" class="headerlink" title="Numpy tutorial"></a>Numpy tutorial</h1><h2 id="Preliminaries"><a href="#Preliminaries" class="headerlink" title="Preliminaries"></a>Preliminaries</h2><p>This command is for importing the numpy module in your python scripts:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip install numpy<br></code></pre></td></tr></table></figure><p>You can use functions in numpy via <code>np.XX</code> (e.g. <code>np.array</code>)</p><p>You can replace it with:</p><ul><li>import numpy as (anything word you like)</li><li>from numpy import numpy (danger! This may cause conflicts in different functions. I don’t recommend for this way of importing numpy)</li></ul><p>In [1]:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># make sure you have installed numpy via:</span><br><span class="hljs-comment"># pip install numpy</span><br><br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br></code></pre></td></tr></table></figure><h2 id="Creating-arrays-and-matrix"><a href="#Creating-arrays-and-matrix" class="headerlink" title="Creating arrays and matrix"></a>Creating arrays and matrix</h2><p>You can create <strong>arrays</strong> in <code>numpy</code> of different dimensions, which is one of the most frequently used commands in numpy.</p><ul><li><p>Creating arrays manually</p><p>  You can create arrays manually by <strong>writing all elements into the arrays</strong>.</p></li></ul><p>In [ ]:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Creating arrays manually</span><br><br><span class="hljs-comment"># One dimension (like a vector storing int value)</span><br>array_1d = np.array([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>])<br><br><span class="hljs-comment"># Two dimensions (4*4)</span><br>array_2d = np.array([[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>],[<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">11</span>,<span class="hljs-number">12</span>],[<span class="hljs-number">13</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">16</span>]])<br><br><span class="hljs-comment"># Three dimensions (more complex)</span><br>array_3d = np.array([[[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]],[[<span class="hljs-number">5</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">7</span>,<span class="hljs-number">8</span>]]])<br><br><span class="hljs-comment"># Visualize</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Showing arrays of one-dimension: \n&quot;</span>,array_1d)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Showing arrays of two-dimensions: \n&quot;</span>,array_2d)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Showing arrays of three-dimensions: \n&quot;</span>,array_3d)<br></code></pre></td></tr></table></figure><ul><li><p>Creating several <strong>templates</strong></p><p>  It’s time-consuming to write all elements in your python scripts if the size or the dimensions of arrays becomes very large. (More bigger the dimension is, there are more square backets!)</p><p>  Thus, you can use the templates in <code>numpy</code> to initilize an array automatically.</p></li></ul><p>In [ ]:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Creating several templates</span><br><br><span class="hljs-comment"># If all elements of the matrix is of the same initial value:</span><br><br><span class="hljs-comment"># For zero-matrix</span><br>zero_int_matrix = np.zeros((<span class="hljs-number">5</span>,<span class="hljs-number">5</span>), dtype = <span class="hljs-string">&#x27;int64&#x27;</span>)<br>zero_double_matrix = np.zeros((<span class="hljs-number">4</span>,<span class="hljs-number">5</span>), dtype = <span class="hljs-string">&#x27;float64&#x27;</span>)<br>zero_int_bigger_matrix = np.zeros((<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>))<br><br><span class="hljs-built_in">print</span>(zero_int_matrix)<br><span class="hljs-built_in">print</span>(zero_double_matrix)<br><span class="hljs-built_in">print</span>(zero_int_bigger_matrix)<br><br><br><span class="hljs-comment"># For matrix filled with ones</span><br>ones_matrix = np.ones((<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>), dtype=<span class="hljs-string">&#x27;int32&#x27;</span>)<br><span class="hljs-built_in">print</span>(ones_matrix)<br><br><span class="hljs-comment"># Identity Matrix</span><br>indentity_matrix = np.identity(<span class="hljs-number">6</span>)<br><span class="hljs-built_in">print</span>(indentity_matrix)<br></code></pre></td></tr></table></figure><p>In [ ]:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Filled with a specific number</span><br>tobefilled = <span class="hljs-number">64</span><br><br><span class="hljs-comment"># Using full to fill an array with a given size (like 3*4)</span><br>filled_array = np.full((<span class="hljs-number">3</span>,<span class="hljs-number">4</span>), fill_value= tobefilled, dtype = <span class="hljs-string">&#x27;int64&#x27;</span>)<br><span class="hljs-built_in">print</span>(filled_array)<br><br><span class="hljs-comment"># Using full_like to return a full array with the same shape and type as a given array.</span><br>filled_like_1 = np.full_like(filled_array, fill_value=tobefilled, dtype=<span class="hljs-string">&#x27;float64&#x27;</span>)<br>filled_like_2 = np.full_like(filled_array, fill_value= <span class="hljs-number">1</span>)<br><br><span class="hljs-built_in">print</span>(filled_like_1)<br><span class="hljs-built_in">print</span>(filled_like_2)<br></code></pre></td></tr></table></figure><p>Moreover, you can generate arrays <strong>randomly</strong> using the <code>random</code> module in numpy.</p><ul><li><code>np.random.rand</code> function is used to generate an array of a given size with a a uniform distribution over [0, 1).</li><li><code>randint</code> function is used to return random integers from a boundary of [a,b).</li></ul><p>In [ ]:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Generating random arrays</span><br><br><span class="hljs-comment"># Create an array of the given shape and populate it with random samples from a uniform distribution over [0, 1).</span><br>random_decimals = np.<span class="hljs-built_in">round</span>(np.random.rand(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>), <span class="hljs-number">2</span>)<br><span class="hljs-built_in">print</span>(random_decimals)<br><br><span class="hljs-comment"># Return random integers from low (inclusive) to high (exclusive).</span><br>random_integers = np.random.randint(-<span class="hljs-number">4</span>, <span class="hljs-number">8</span>, size=(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>))<br><span class="hljs-built_in">print</span>(random_integers)<br></code></pre></td></tr></table></figure><h2 id="Checking-parameters-of-Arrays"><a href="#Checking-parameters-of-Arrays" class="headerlink" title="Checking parameters of Arrays"></a>Checking parameters of Arrays</h2><p>You can checking several basic information of an array using <code>print()</code> function.</p><ul><li>print the array: It will show all elements of the array.</li><li><code>dtype</code>: The data type of the array.</li><li><code>ndim</code>: The dimensions of the array.</li><li><code>shape</code>: The size of the array.</li><li><code>itemsize</code>: The size of the single element in the array.</li><li><code>nbytes</code>: The total size of the array.</li></ul><p>In [ ]:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Checking parameters of Arrays</span><br><br>checked_array = np.<span class="hljs-built_in">round</span>(np.random.rand(<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>))<br><br><span class="hljs-built_in">print</span>(checked_array)<br><span class="hljs-built_in">print</span>(checked_array.dtype)<br><span class="hljs-built_in">print</span>(checked_array.ndim)<br><span class="hljs-built_in">print</span>(checked_array.shape)<br><span class="hljs-built_in">print</span>(checked_array.itemsize)<br><span class="hljs-built_in">print</span>(checked_array.nbytes)<br></code></pre></td></tr></table></figure><p>Wow! You have sucessfully created various arrays! In the following chapter, you will learn how to <strong>operate arrays and make some calculations</strong>.</p><h2 id="Accessing-and-modifying-elements"><a href="#Accessing-and-modifying-elements" class="headerlink" title="Accessing and modifying elements"></a>Accessing and modifying elements</h2><h3 id="Slices"><a href="#Slices" class="headerlink" title="Slices"></a>Slices</h3><p>We can get the slices of the array and access specific elements by using <code>[]</code> operator. The scripts below shows the fundamental usage of it.</p><p>In [ ]:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python">get_element = np.<span class="hljs-built_in">round</span>(np.random.rand(<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>),<span class="hljs-number">3</span>)<br><br><span class="hljs-comment"># See the whole array and its size.</span><br><span class="hljs-comment"># print(get_element)</span><br><span class="hljs-built_in">print</span>(get_element.ndim, get_element.shape)<br><br><span class="hljs-comment"># Slices</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n&quot;</span>)<br>sliced_array_1 = get_element[<span class="hljs-number">0</span>]<br><span class="hljs-built_in">print</span>(sliced_array_1)<br><span class="hljs-built_in">print</span>(sliced_array_1.ndim, sliced_array_1.shape)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n&quot;</span>)<br>sliced_array_1 = get_element[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]<br><span class="hljs-built_in">print</span>(sliced_array_1)<br><span class="hljs-built_in">print</span>(sliced_array_1.ndim, sliced_array_1.shape)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n&quot;</span>)<br>sliced_array_1 = get_element[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]<br><span class="hljs-built_in">print</span>(sliced_array_1)<br><span class="hljs-built_in">print</span>(sliced_array_1.ndim, sliced_array_1.shape)<br></code></pre></td></tr></table></figure><p>From the example shown above, we know that <code>[]</code> can get an array’s slices and decrease array’s dimensions. It’s just like <strong>peeling an onion</strong>!</p><p>Regarding the <strong>different dimensions</strong> of an array, you can determine different dimensions by counting square brackets.</p><p>Moreover, you can use <code>:</code> to make the slices more powerful.</p><p>In [ ]:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># The demonstration of using : in slices</span><br><br><span class="hljs-built_in">print</span>(get_element[<span class="hljs-number">0</span>])<br><span class="hljs-built_in">print</span>(get_element[<span class="hljs-number">0</span>,:])<br><span class="hljs-built_in">print</span>(get_element[<span class="hljs-number">0</span>,<span class="hljs-number">2</span>:,<span class="hljs-number">3</span>:])<br><span class="hljs-built_in">print</span>(get_element[<span class="hljs-number">0</span>,:<span class="hljs-number">3</span>])<br><br><span class="hljs-comment"># Advanced usage: slicing with step size</span><br><span class="hljs-comment"># -1 means the end</span><br><span class="hljs-built_in">print</span>(get_element[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>:-<span class="hljs-number">1</span>:<span class="hljs-number">2</span>])<br></code></pre></td></tr></table></figure><p>The colon <code>:</code> operator is used for slicing, which enables you to select a range of elements.</p><p>For example, array[start:end] retrieves elements from the index start to end-1. If you use : alone, like array[:], it returns the entire array. You can also specify a step, such as array[start​:end:step], which selects elements at regular intervals.</p><p>Additionally, when working with multi-dimensional arrays, you can use a comma to separate indices for each dimension, like array[row_index, column_index]. The colon can be applied to each dimension, allowing for complex selections, such as array[:, 1:3], which selects all rows but only columns 1 and 2.</p><p>For me, I prefer to memorize <code>:</code> as a <strong>greedy symbol</strong>, which means get all the index from the current position to the end (or the beginning).</p><p>For example, <code>get_element[0,2:,3:]</code> means for the second dimension, we just want from the 2 (included) till the end. The third dimension is the same. If <code>:</code> is before the number like <code>get_element[0,:3]</code>, this means for second dimension, we want (from the begining) to the index 3 (excluded).</p><h3 id="Modifications"><a href="#Modifications" class="headerlink" title="Modifications"></a>Modifications</h3><p>You can also modify values (or even slices) of the array by giving the right index.</p><p>Make sure <strong>the size of the array doesn’t mismatch!</strong></p><p>In [ ]:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Modification</span><br>get_element[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>] = <span class="hljs-number">100</span><br><br>np.set_printoptions(suppress=<span class="hljs-literal">True</span>)<br><span class="hljs-built_in">print</span>(get_element)<br><br>get_element[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,:] = [<span class="hljs-number">20</span>, <span class="hljs-number">20</span>, <span class="hljs-number">20</span>, <span class="hljs-number">20</span>]<br><span class="hljs-built_in">print</span>(get_element)<br></code></pre></td></tr></table></figure><p>In [ ]:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># However, this may cause an error</span><br>get_element[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,:] = [<span class="hljs-number">10</span>, <span class="hljs-number">10</span>]<br><span class="hljs-built_in">print</span>(get_element)<br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">Error message:</span><br><span class="hljs-string">ValueError: could not broadcast input array from shape (2,) into shape (4,)</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="Repetition-Copying-and-Reshaping"><a href="#Repetition-Copying-and-Reshaping" class="headerlink" title="Repetition, Copying and Reshaping"></a>Repetition, Copying and Reshaping</h2><p>You can <strong>repeat</strong>, <strong>reshape</strong> and <strong>copy</strong> arrays!</p><h3 id="Repeat"><a href="#Repeat" class="headerlink" title="Repeat"></a>Repeat</h3><p>In [ ]:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python">base_array = np.<span class="hljs-built_in">round</span>(np.random.rand(<span class="hljs-number">5</span>,<span class="hljs-number">5</span>),<span class="hljs-number">2</span>)<br><span class="hljs-built_in">print</span>(base_array)<br><span class="hljs-built_in">print</span>(base_array.shape)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n&quot;</span>)<br><br><span class="hljs-comment"># Repeat rows</span><br>array_repeated = np.repeat(base_array, <span class="hljs-number">2</span>, axis=<span class="hljs-number">0</span>)<br><span class="hljs-built_in">print</span>(array_repeated)<br><span class="hljs-built_in">print</span>(array_repeated.shape)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n&quot;</span>)<br><br><span class="hljs-comment"># Repeat colomns</span><br>array_repeated = np.repeat(base_array, <span class="hljs-number">2</span>,axis=<span class="hljs-number">1</span>)<br><span class="hljs-built_in">print</span>(array_repeated)<br><span class="hljs-built_in">print</span>(array_repeated.shape)<br></code></pre></td></tr></table></figure><h3 id="Copy"><a href="#Copy" class="headerlink" title="Copy"></a>Copy</h3><p>In [ ]:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Copying arrays</span><br>array_c = np.array([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])<br>array_d = array_c.copy()  <span class="hljs-comment"># Create a copy</span><br>array_e = array_c          <span class="hljs-comment"># Reference to original</span><br><br>array_d[<span class="hljs-number">0</span>] = <span class="hljs-number">100</span><br>array_e[<span class="hljs-number">0</span>] = <span class="hljs-number">200</span><br><span class="hljs-built_in">print</span>(array_c)  <span class="hljs-comment"># Original array remains unchanged</span><br><span class="hljs-built_in">print</span>(array_d)  <span class="hljs-comment"># Modified copy</span><br><span class="hljs-built_in">print</span>(array_e)  <span class="hljs-comment"># Reference to original</span><br></code></pre></td></tr></table></figure><p><strong>Attention!</strong> If you use <code>copy()</code> function, then the copied array have no correlations with the original array from now on. However, if you simply use the <strong>assignment operator</strong>, then it just creates a <strong>references</strong> of the original array. Modifying one’s value will affect the other’s!</p><h3 id="Reshape"><a href="#Reshape" class="headerlink" title="Reshape"></a>Reshape</h3><p>You can reshape the size of an array by using the <code>reshape</code> commands in numpy. For example, you can compress a 25x25 image into a 625-dimensional column vector. But <strong>make sure the reshaped size have same numbers of elements compared with previous ones</strong>.</p><p><strong>Stacking</strong> is a command which is likely to <code>repeat</code>, but it can operate on different arrays with same row-length (using hstack) or colomn-length (using vstack).</p><p>In [ ]:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Reshaping arrays</span><br>before = np.array([[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>], [<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>]])<br>after = before.reshape((<span class="hljs-number">4</span>, <span class="hljs-number">2</span>))<br><span class="hljs-built_in">print</span>(after)<br><br><span class="hljs-comment"># Vertical stacking</span><br>v1 = np.array([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>])<br>v2 = np.array([<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>])<br>stacked_vertical = np.vstack([v1, v2, v1, v2])<br><span class="hljs-built_in">print</span>(stacked_vertical)<br><br><span class="hljs-comment"># Horizontal stacking</span><br>h1 = np.ones((<span class="hljs-number">2</span>, <span class="hljs-number">4</span>))<br>h2 = np.zeros((<span class="hljs-number">2</span>, <span class="hljs-number">2</span>))<br>stacked_horizontal = np.hstack((h1, h2))<br><span class="hljs-built_in">print</span>(stacked_horizontal)<br></code></pre></td></tr></table></figure><h2 id="Linear-Algebra-and-other-mathematical-operations"><a href="#Linear-Algebra-and-other-mathematical-operations" class="headerlink" title="Linear Algebra and other mathematical operations"></a>Linear Algebra and other mathematical operations</h2><p>Here is <strong>Linear Algebra</strong>! You can implement various computations regarding matrix and arrays in numpy.</p><h3 id="Basic-Mathematical-operations"><a href="#Basic-Mathematical-operations" class="headerlink" title="Basic Mathematical operations"></a>Basic Mathematical operations</h3><p>In [ ]:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python">array_f = np.array([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>])<br><span class="hljs-built_in">print</span>(array_f + <span class="hljs-number">2</span>)  <span class="hljs-comment"># Addition</span><br><span class="hljs-built_in">print</span>(array_f - <span class="hljs-number">2</span>)  <span class="hljs-comment"># Subtraction</span><br><span class="hljs-built_in">print</span>(array_f * <span class="hljs-number">2</span>)  <span class="hljs-comment"># Multiplication</span><br><span class="hljs-built_in">print</span>(array_f / <span class="hljs-number">2</span>)  <span class="hljs-comment"># Division</span><br><br><span class="hljs-comment"># Element-wise operations with another array</span><br>array_g = np.array([<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>])<br><span class="hljs-built_in">print</span>(array_f + array_g)  <span class="hljs-comment"># Element-wise addition</span><br><br><span class="hljs-comment"># Power and trigonometric functions</span><br><span class="hljs-built_in">print</span>(array_f ** <span class="hljs-number">2</span>)  <span class="hljs-comment"># Squaring</span><br><span class="hljs-built_in">print</span>(np.cos(array_f))  <span class="hljs-comment"># Cosine function</span><br></code></pre></td></tr></table></figure><h3 id="Linear-Algebra"><a href="#Linear-Algebra" class="headerlink" title="Linear Algebra"></a>Linear Algebra</h3><p>You can go through the <a href="https://numpy.org/doc/2.2/reference/routines.linalg.html">linalg website</a> for more caiculations. The python scripts demonstrat several basic operations of it.</p><p>In [ ]:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-comment"># Create random matrices</span><br>A = np.random.rand(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>)<br>B = np.random.rand(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>)<br><br><span class="hljs-comment"># Matrix Addition</span><br>addition_result = np.add(A, B)<br><br><span class="hljs-comment"># Matrix Subtraction</span><br>subtraction_result = np.subtract(A, B)<br><br><span class="hljs-comment"># Matrix Multiplication</span><br>multiplication_result = np.matmul(A, B)<br><span class="hljs-comment"># You can also use A @ B!</span><br><br><span class="hljs-comment"># Matrix pow</span><br>matrix_exp = np.linalg.matrix_power(A, <span class="hljs-number">3</span>)<br><br><span class="hljs-comment"># Matrix Transpose</span><br>transpose_result = np.transpose(A)<br><br><span class="hljs-comment"># Matrix Inverse</span><br>inverse_result = np.linalg.inv(A)<br><br><span class="hljs-comment"># Matrix Determinant, rank and trace</span><br>determinant_result = np.linalg.det(A)<br>rank_result = np.linalg.matrix_rank(A)<br>trace_result = np.trace(A)<br><br><span class="hljs-comment"># Eigenvalues and Eigenvectors</span><br>eigenvalues, eigenvectors = np.linalg.eig(A)<br><br><span class="hljs-comment"># Solve Linear System (Ax = b)</span><br>b = np.random.rand(<span class="hljs-number">3</span>)<br>solution = np.linalg.solve(A, b)<br><br><span class="hljs-comment"># SVD</span><br>U, S, V = np.linalg.svd(A)<br><br><span class="hljs-comment"># Print results</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Matrix A:\n&quot;</span>, A)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Matrix B:\n&quot;</span>, B)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Addition Result:\n&quot;</span>, addition_result)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Subtraction Result:\n&quot;</span>, subtraction_result)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Multiplication Result:\n&quot;</span>, multiplication_result)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Transpose of A:\n&quot;</span>, transpose_result)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Inverse of A:\n&quot;</span>, inverse_result)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Determinant of A:\n&quot;</span>, determinant_result)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Eigenvalues of A:\n&quot;</span>, eigenvalues)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Eigenvectors of A:\n&quot;</span>, eigenvectors)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Solution of Ax = b:\n&quot;</span>, solution)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;SVD\n&quot;</span>, U, S, V)<br></code></pre></td></tr></table></figure><h2 id="Statics"><a href="#Statics" class="headerlink" title="Statics"></a>Statics</h2><p>In [ ]:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">stats_array = np.array([[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]])<br><span class="hljs-built_in">print</span>(np.<span class="hljs-built_in">min</span>(stats_array))  <span class="hljs-comment"># Minimum value</span><br><span class="hljs-built_in">print</span>(np.<span class="hljs-built_in">max</span>(stats_array, axis=<span class="hljs-number">1</span>))  <span class="hljs-comment"># Maximum value along rows</span><br><span class="hljs-built_in">print</span>(np.<span class="hljs-built_in">sum</span>(stats_array, axis=<span class="hljs-number">0</span>))  <span class="hljs-comment"># Sum along columns</span><br></code></pre></td></tr></table></figure><h3 id="Boolean-Mask"><a href="#Boolean-Mask" class="headerlink" title="Boolean Mask"></a>Boolean Mask</h3><p>In [ ]:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Boolean masking example</span><br>boolean_mask = ~((stats_array &gt; <span class="hljs-number">2</span>) &amp; (stats_array &lt; <span class="hljs-number">5</span>))<br><span class="hljs-built_in">print</span>(boolean_mask)<br></code></pre></td></tr></table></figure><h2 id="Advanced-Usage"><a href="#Advanced-Usage" class="headerlink" title="Advanced Usage"></a>Advanced Usage</h2><h3 id="Loading-data-from-files"><a href="#Loading-data-from-files" class="headerlink" title="Loading data from files"></a>Loading data from files</h3><p>You can use <code>genfromtxt()</code> function to automatically write the arrays from txt file into numpy. Moreover, you can use <code>savetxt()</code> function to save your arrays into other files!</p><p>In [ ]:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Loading data from a CSV file</span><br>filedata = np.genfromtxt(<span class="hljs-string">&#x27;data.txt&#x27;</span>, delimiter=<span class="hljs-string">&#x27; &#x27;</span>)<br>filedata = filedata.astype(<span class="hljs-string">&#x27;int32&#x27;</span>)<br><span class="hljs-built_in">print</span>(filedata)<br></code></pre></td></tr></table></figure><p>In [ ]:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Writing the array to a text file</span><br>output_file = <span class="hljs-string">&#x27;output_data.txt&#x27;</span><br>np.savetxt(output_file, filedata, delimiter=<span class="hljs-string">&#x27; &#x27;</span>, fmt=<span class="hljs-string">&#x27;%d&#x27;</span>)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Data has been written to <span class="hljs-subst">&#123;output_file&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>This memo provides a concise overview of NumPy’s capabilities, including array creation, manipulation, mathematical operations, and more. For further details, refer to the official <a href="https://numpy.org/doc/stable/">NumPy documentation</a>.</p><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://numpy.org/doc/stable/">https://numpy.org/doc/stable/</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Project</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Finished</tag>
      
      <tag>Python</tag>
      
      <tag>Tutorial</tag>
      
      <tag>Numpy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Algorithm-Chunking</title>
    <link href="/posts/Algorithm-Chunking/"/>
    <url>/posts/Algorithm-Chunking/</url>
    
    <content type="html"><![CDATA[<style>  html, body, .markdown-body {    font-family: Georgia, sans, serif;  }</style><h1 id="Algorithms-Chunking"><a href="#Algorithms-Chunking" class="headerlink" title="Algorithms: Chunking"></a>Algorithms: Chunking</h1><p><strong>分块算法</strong></p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>现在考虑如下问题：</p><ul><li>对于一个规模较大的数组</li><li>现在需要频繁地发送<strong>区间请求</strong>，例如：<ul><li>查询一个区间的数组元素之和</li><li>对一个区间的数组进行批量运算（例如同时+-*&#x2F;一个数）</li><li>其他更加复杂的运算</li></ul></li></ul><p>暴力解法是非常容易实现的，但是时间复杂度过高，原因是<strong>进行了很多重复性的运算</strong>。我们需要追求更加高效的算法。在本文中，我们将介绍最基本的**分块算法(Chunking Algorithms)**，为这一类问题提供小于线性时间复杂度的算法。</p><h2 id="Example1-Adding-numbers"><a href="#Example1-Adding-numbers" class="headerlink" title="Example1: Adding numbers"></a>Example1: Adding numbers</h2><p>题目: 现在给定一个数组<code>arr</code>，给出以下指令：</p><ul><li><code>A l r n</code>：表示对区间[l,r]的所有元素的值都加上n。</li><li><code>Q i</code>：表示<strong>查询</strong>操作，指查询特定索引(0-based)上的数组值。</li></ul><p>对于比较暴力的做法，是对每一次<strong>Add</strong>的操作时，使用for循环遍历更新对应数组的值，最后直接查询输出。复杂度O(mn)，m为操作次数，n为数组长度。</p><p>为什么<strong>分块</strong>能够优化这个问题？因为我们观察到<strong>相邻元素在操作时的行为在很大概率上是相同的</strong>，因此暴力的遍历会浪费很多时间。举一个具体的例子：对应<code>arr[30]</code>和<code>arr[31]</code>，只要我规定的区间<strong>同时包含了这两个元素</strong>，那行为就是完全相同。换句话说，我们可以<strong>把相邻的元素打包在一起</strong>，对于相同的操作<strong>统一处理</strong>，这样就能极大的减少时间复杂度！</p><p>这就是<strong>分块</strong>，将一整个区间分成几小块，再对所分的块进行批量处理。（<strong>优化的暴力</strong>）</p><p>首先，我们给出<strong>分块</strong>的基本架构：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> total_length = <span class="hljs-number">0</span>;<br>    std::cin &gt;&gt; total_length;<br>    <span class="hljs-type">int</span>* arr = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[total_length];<br><br>    <span class="hljs-comment">//chunking!</span><br>    <span class="hljs-type">int</span> block_size = (<span class="hljs-type">int</span>)std::<span class="hljs-built_in">sqrt</span>(total_length);<br>    <span class="hljs-type">int</span> block_count = std::<span class="hljs-built_in">ceil</span>((<span class="hljs-type">double</span>)total_length / block_size);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们将一整个<code>total_length</code>的长度<strong>取根号</strong>作为分块的长度（由基本不等式可以证明此时时间复杂度最低）。</p><p>接下来，我们需要解决的问题是：<strong>如何处理区间的add操作</strong>？这便是<strong>分块思想以空间换时间</strong>的思想，通过引入<code>tag</code>数组，来实现数组的批量加法。具体而言就是：</p><ul><li>创建一个新数组<code>add-tag</code>，长度为<code>block_count</code>。用来记录<strong>这一个分块中批量处理的加和值</strong>。</li><li>在查询的时候，元素的实际值 &#x3D; 数组中元素记录的值 + <code>add_tag</code>中元素所在块对应的值。</li></ul><blockquote><p><code>add-tag</code>是<strong>分块</strong>的核心，原先需要遍历一整个块的元素实现相同的<strong>重复操作</strong>，但现在只需<strong>额外维护一个数组就可以实现</strong>！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tutorial</tag>
      
      <tag>C/C++</tag>
      
      <tag>Chunking</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Bash_commands</title>
    <link href="/posts/Bash-commands/"/>
    <url>/posts/Bash-commands/</url>
    
    <content type="html"><![CDATA[<style>  html, body, .markdown-body {    font-family: Georgia, sans, serif;  }</style><h1 id="Bash-Commands-Memo"><a href="#Bash-Commands-Memo" class="headerlink" title="Bash Commands Memo"></a>Bash Commands Memo</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><h3 id="KISS-principle"><a href="#KISS-principle" class="headerlink" title="KISS principle"></a>KISS principle</h3><p>When using Linux, one problem that may easily be ignored by greenhands is: <strong>Why Linux</strong>. For programmers, Linux has great advantages over Windows OS for its light, free and open-source characteristics. If you <strong>use Linux the same way you use Windows</strong>, you won’t be able to harness the spirit and greatest strengths of Linux.</p><p>Therefore, for every Linux beginner, it is very important to <strong>familiarize themselves with Linux&#x2F;Unix philosophy and practice it in their usage</strong>! I recommend this Blog<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://www.ruanyifeng.com/blog/2009/06/unix_philosophy.html">[1]</span></a></sup> (author: Yifeng Ruan) which clearly explains the philosophy of Unix.</p><p>In this Blog, it says:</p><div class="note note-primary">            <p>The Wikipedia page lists several versions of the Unix philosophy, with different people offering their own summaries. Doug McIlroy, the inventor of the pipe command, summarized it in three principles, while Eric S. Raymond, in his book <em>The Art of Unix Programming</em>, expanded it to a total of <strong>17 principles</strong> (in both the English and Chinese editions).</p><p>However, I noticed that everyone agrees on one fundamental principle of the Unix philosophy: the “<strong>Principle of Simplicity</strong>“—solving problems in the simplest way possible. This is also known as the famous <strong>KISS principle</strong> (<strong>Keep It Simple, Stupid</strong>), which means “keep things simple and straightforward.”</p><p><img src="https://lh3.ggpht.com/_6p3hNkUNWrQ/SjpEiMoM3TI/AAAAAAAABdE/9lkeDQLzXUY/s800/bg2009061801.gif" alt="From Yifeng Ruan&#39;s Blog"></p>          </div><p>Specifically, what is the <strong>Principle of Simplicity</strong>? From my perspective, the Principle of Simplicity means <strong>refining every operation to its utmost simplicity</strong>, <strong>focusing solely on</strong> accomplishing a single, independent small task, and then efficiently combining these tasks to achieve more complex objectives.</p><p>For example, using <strong>pipes</strong><code>|</code> to connect commands enables us to use several small commands and connect them together so as to finish customed and complex tasks. (If you don’t know what pipe is, you can go through <strong>Missing semester for Lec1 first</strong>.) In contrast, <strong>commands in powershell</strong> don’t seem to follow the Principle of Simplicity in some circumstances.</p><ul><li><strong>IF</strong> you want to list all the processes named “Notepad” and stop them:</li></ul><p>In Bash:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ps aux | grep [n]otepad | awk <span class="hljs-string">&#x27;&#123;print $2&#125;&#x27;</span> | xargs <span class="hljs-built_in">kill</span><br></code></pre></td></tr></table></figure><p>In PowerShell:</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">Get-Process</span> | <span class="hljs-built_in">Where-Object</span> &#123;<span class="hljs-variable">$_</span>.Name <span class="hljs-operator">-eq</span> <span class="hljs-string">&quot;notepad&quot;</span>&#125; | <span class="hljs-built_in">Stop-Process</span><br></code></pre></td></tr></table></figure><ul><li><strong>IF</strong> you want to count total lines in all <code>.log</code> files recursively:</li></ul><p>In Bash:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">find . -name <span class="hljs-string">&quot;*.log&quot;</span> -<span class="hljs-built_in">exec</span> <span class="hljs-built_in">cat</span> &#123;&#125; + | <span class="hljs-built_in">wc</span> -l  <br></code></pre></td></tr></table></figure><p>In PowerShell:</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">Get-ChildItem</span> <span class="hljs-literal">-Recurse</span> <span class="hljs-literal">-Filter</span> *.log | <span class="hljs-built_in">ForEach-Object</span> &#123; <span class="hljs-built_in">Get-Content</span> <span class="hljs-variable">$_</span> &#125; | <span class="hljs-built_in">Measure-Object</span> <span class="hljs-literal">-Line</span> | <span class="hljs-built_in">Select-Object</span> <span class="hljs-literal">-ExpandProperty</span> Lines  <br></code></pre></td></tr></table></figure><ul><li><strong>IF</strong> you want to list all files in a directory with size and last modified time:</li></ul><p>In Bash:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ls</span> -l --time-style=+<span class="hljs-string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>  <br></code></pre></td></tr></table></figure><p>In PowerShell:</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">Get-ChildItem</span> | <span class="hljs-built_in">Select-Object</span> Name, Length, LastWriteTime | <span class="hljs-built_in">Format-Table</span> <span class="hljs-literal">-AutoSize</span><br></code></pre></td></tr></table></figure><blockquote><p>PowerShell is <strong>object-oriented</strong>, meaning it treats command outputs as objects with properties and methods, allowing for <strong>more complex</strong> and manipulations directly within the shell, though it may require more verbose code to access and manipulate these properties. In contrast, Bash is text-based, handling command outputs as plain text streams, which are then processed using text utilities like <code>awk</code> and <code>sed</code> for parsing and transformation. While Bash’s text-based approach can be simpler for straightforward tasks, PowerShell’s object-oriented nature provides richer functionality and easier handling of structured data, albeit with potentially increased complexity in scripting.</p></blockquote><h3 id="How-to-learn-Bash-commands"><a href="#How-to-learn-Bash-commands" class="headerlink" title="How to learn Bash commands"></a>How to learn Bash commands</h3><p>Thus, it’s of great importance to follow <strong>KISS</strong> rules while learning thousands of Bash commands. <strong>All commands are used for efficiency and all commands must remain simple and “stupid” independently.</strong></p><p>In the following articles, I will continuously update my journey of learning Bash commands and share concise study notes for your reference. Several basic commands and commands that have few options like <code>ls</code> and <code>logout</code> won’t be listed into the updating plan. This Blog only focuses on those commands that are simple but powerful.</p><h3 id="Recommended-Tools"><a href="#Recommended-Tools" class="headerlink" title="Recommended Tools"></a>Recommended Tools</h3><p>I strongly recommend <strong>tldr</strong><sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://github.com/tldr-pages/tldr">[2]</span></a></sup> for learning Bash commands in a simple way instead of searching for horribly long <code>man</code> files tutorial.</p><p>You can go to the <a href="https://tldr.sh/">https://tldr.sh/</a> for searching. You can also install tldr locally in your Linux systems but it will be a little bit slow.</p><p><strong>Remember, keep it simple, stupid</strong>.</p><h1 id="Commands"><a href="#Commands" class="headerlink" title="Commands"></a>Commands</h1><h2 id="Table-of-contents"><a href="#Table-of-contents" class="headerlink" title="Table of contents"></a>Table of contents</h2><p><strong>Text processing</strong>:</p><table><thead><tr><th><strong>grep</strong></th><th>search for specific patterns within files or input text</th></tr></thead><tbody><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr></tbody></table><h2 id="grep-command"><a href="#grep-command" class="headerlink" title="grep command"></a><code>grep</code> command</h2><p><code>grep</code> is a powerful command-line tool in Unix&#x2F;Linux used to search for specific patterns within files or input text. </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">grep [options] pattern [file]<br></code></pre></td></tr></table></figure><ul><li><strong><code>pattern</code></strong>: The text or <strong>regular expression</strong> to search for.</li><li><strong><code>file</code></strong>: The file(s) to search within. If omitted, <code>grep</code> reads from standard input.</li></ul><p>For example, you can using the <code>grep</code> command by using pipes.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /etc/ssh/sshd_config | grep Port<br></code></pre></td></tr></table></figure><p>This command will first output the file contents of <code>sshd_config</code> while the content itself won’t be printed directly into the screen. It will be transmitted as the input of the grep command.</p><h3 id="Common-Options"><a href="#Common-Options" class="headerlink" title="Common Options"></a><strong>Common Options</strong></h3><ul><li><code>-i</code>: Ignore case (case-insensitive search).</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">grep -i <span class="hljs-string">&quot;hello&quot;</span> file.txt<br></code></pre></td></tr></table></figure><ul><li><code>-v</code>: Invert match (show lines that do <strong>not</strong> match the pattern).</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">grep -v <span class="hljs-string">&quot;error&quot;</span> file.txt<br></code></pre></td></tr></table></figure><ul><li><code>-r</code> or <code>-R</code>: Recursively search directories.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">grep -r <span class="hljs-string">&quot;pattern&quot;</span> /path/to/dir<br></code></pre></td></tr></table></figure><ul><li><code>-n</code>: Show line numbers of matching lines.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">grep -n <span class="hljs-string">&quot;pattern&quot;</span> file.txt<br></code></pre></td></tr></table></figure><ul><li><code>-c</code>: Count the number of matching lines.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">grep -c <span class="hljs-string">&quot;pattern&quot;</span> file.txt<br></code></pre></td></tr></table></figure><ul><li><code>-l</code>: List filenames containing the pattern.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">grep -l <span class="hljs-string">&quot;pattern&quot;</span> *.txt<br></code></pre></td></tr></table></figure><ul><li><code>-w</code>: Match whole words only.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">grep -w <span class="hljs-string">&quot;word&quot;</span> file.txt<br></code></pre></td></tr></table></figure><ul><li><code>-A</code>, <code>-B</code>, <code>-C</code>: Show lines after, before, or around the match.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">grep -A 2 <span class="hljs-string">&quot;pattern&quot;</span> file.txt  <span class="hljs-comment"># Show 2 lines after the match</span><br>grep -B 2 <span class="hljs-string">&quot;pattern&quot;</span> file.txt  <span class="hljs-comment"># Show 2 lines before the match</span><br>grep -C 2 <span class="hljs-string">&quot;pattern&quot;</span> file.txt  <span class="hljs-comment"># Show 2 lines before and after the match</span><br></code></pre></td></tr></table></figure><p>For example, I have a directory (current) and exists files as below:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs bash">.<br>├── grep_test.txt<br>└── sub_dirc<br>    ├── modified_1.txt<br>    └── modified_2.txt<br><br>2 directories, 3 files<br><br>❯ <span class="hljs-built_in">cat</span> grep_test.txt<br>Hello my name is Jack.<br>I am 18 year<span class="hljs-string">&#x27;s old.</span><br><span class="hljs-string">Do you like me?</span><br><span class="hljs-string">I want to make friends with you.</span><br><span class="hljs-string">Remember my name, my name is JACK!</span><br><span class="hljs-string">HAahah</span><br><span class="hljs-string">do you know my favourite motto?</span><br><span class="hljs-string">Knowledge isn&#x27;</span>t free, you have to pay attention.<br><br>❯ <span class="hljs-built_in">cat</span> ./sub_dirc/modified_1.txt<br>Hello my name is Henry.<br>I am 17 year<span class="hljs-string">&#x27;s old.</span><br><span class="hljs-string">Do you like me?</span><br><span class="hljs-string">I want to make friends with you.</span><br><span class="hljs-string">Remember my name, my name is Henry!</span><br><span class="hljs-string">HAahah</span><br><span class="hljs-string">do you know my favourite motto?</span><br><span class="hljs-string">Nothing is possible</span><br><span class="hljs-string"></span><br><span class="hljs-string">❯ cat ./sub_dirc/modified_2.txt</span><br><span class="hljs-string">Hello my name is Kate.</span><br><span class="hljs-string">I am 20 year&#x27;</span>s old.<br>Do you like us?<br>I want to make friends with you.<br>Remember my name, my name is KatE!<br>HAahah<br><span class="hljs-keyword">do</span> you know my favourite motto?<br>Open <span class="hljs-built_in">source</span> is the best thing <span class="hljs-keyword">in</span> the world!<br></code></pre></td></tr></table></figure><p>Now I can use several commands as below to efficiently search specific information that I want!</p><p>I can use <code>-r</code> to search for the whole current directory.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">grep -r <span class="hljs-string">&quot;Hello&quot;</span> ./<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">./sub_dirc/modified_1.txt:Hello my name is Henry.<br>./sub_dirc/modified_2.txt:Hello my name is Kate.<br>./grep_test.txt:Hello my name is Jack.<br></code></pre></td></tr></table></figure></br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">grep -nri <span class="hljs-string">&quot;Jack&quot;</span> ./<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">./grep_test.txt:1:Hello my name is Jack.<br>./grep_test.txt:5:Remember my name, my name is JACK!<br></code></pre></td></tr></table></figure></br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">grep -nrc <span class="hljs-string">&quot;Hello&quot;</span> ./<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">./sub_dirc/modified_1.txt:1<br>./sub_dirc/modified_2.txt:1<br>./grep_test.txt:1<br></code></pre></td></tr></table></figure></br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">grep -nrv <span class="hljs-string">&quot;Hello&quot;</span> ./<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs bash">./sub_dirc/modified_1.txt:2:I am 17 year<span class="hljs-string">&#x27;s old.</span><br><span class="hljs-string">./sub_dirc/modified_1.txt:3:Do you like me?</span><br><span class="hljs-string">./sub_dirc/modified_1.txt:4:I want to make friends with you.</span><br><span class="hljs-string">./sub_dirc/modified_1.txt:5:Remember my name, my name is Henry!</span><br><span class="hljs-string">./sub_dirc/modified_1.txt:6:HAahah</span><br><span class="hljs-string">./sub_dirc/modified_1.txt:7:do you know my favourite motto?</span><br><span class="hljs-string">./sub_dirc/modified_1.txt:8:Nothing is possible</span><br><span class="hljs-string">./sub_dirc/modified_1.txt:9:</span><br><span class="hljs-string">./sub_dirc/modified_2.txt:2:I am 20 year&#x27;</span>s old.<br>./sub_dirc/modified_2.txt:3:Do you like us?<br>./sub_dirc/modified_2.txt:4:I want to make friends with you.<br>./sub_dirc/modified_2.txt:5:Remember my name, my name is KatE!<br>./sub_dirc/modified_2.txt:6:HAahah<br>./sub_dirc/modified_2.txt:7:<span class="hljs-keyword">do</span> you know my favourite motto?<br>./sub_dirc/modified_2.txt:8:Open <span class="hljs-built_in">source</span> is the best thing <span class="hljs-keyword">in</span> the world!<br>./sub_dirc/modified_2.txt:9:<br>./grep_test.txt:2:I am 18 year<span class="hljs-string">&#x27;s old.</span><br><span class="hljs-string">./grep_test.txt:3:Do you like me?</span><br><span class="hljs-string">./grep_test.txt:4:I want to make friends with you.</span><br><span class="hljs-string">./grep_test.txt:5:Remember my name, my name is JACK!</span><br><span class="hljs-string">./grep_test.txt:6:HAahah</span><br><span class="hljs-string">./grep_test.txt:7:do you know my favourite motto?</span><br><span class="hljs-string">./grep_test.txt:8:Knowledge isn&#x27;</span>t free, you have to pay attention.<br>./grep_test.txt:9:<br></code></pre></td></tr></table></figure></br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">grep -ri -A 1 <span class="hljs-string">&quot;motto&quot;</span> ./<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">./sub_dirc/modified_1.txt:<span class="hljs-keyword">do</span> you know my favourite motto?<br>./sub_dirc/modified_1.txt-Nothing is possible<br>--<br>./sub_dirc/modified_2.txt:<span class="hljs-keyword">do</span> you know my favourite motto?<br>./sub_dirc/modified_2.txt-Open <span class="hljs-built_in">source</span> is the best thing <span class="hljs-keyword">in</span> the world!<br>--<br>./grep_test.txt:<span class="hljs-keyword">do</span> you know my favourite motto?<br>./grep_test.txt-Knowledge isn<span class="hljs-string">&#x27;t free, you have to pay attention.</span><br></code></pre></td></tr></table></figure><p>You can make the command line more complex to get more specific data!</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">grep -ri -A 1 <span class="hljs-string">&quot;motto&quot;</span> ./ | grep -v <span class="hljs-string">&quot;motto&quot;</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">./sub_dirc/modified_1.txt-Nothing is possible<br>--<br>./sub_dirc/modified_2.txt-Open <span class="hljs-built_in">source</span> is the best thing <span class="hljs-keyword">in</span> the world!<br>--<br>./grep_test.txt-Knowledge isn<span class="hljs-string">&#x27;t free, you have to pay attention.</span><br></code></pre></td></tr></table></figure><p>More specific:</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">grep</span> -rih -A <span class="hljs-number">1</span> <span class="hljs-string">&quot;motto&quot;</span> ./ | <span class="hljs-keyword">grep</span> -v <span class="hljs-string">&quot;motto&quot;</span> | <span class="hljs-keyword">grep</span> -v <span class="hljs-string">&quot;^--$&quot;</span><br></code></pre></td></tr></table></figure><p>Using the <code>-h</code> options to forbid grep showing filenames while searching the directory recursively. Adding more pipes and using <strong>Regex</strong> can enable developers to make more specific pattern matching problems more freely.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Bash">Nothing is possible<br>Open <span class="hljs-built_in">source</span> is the best thing <span class="hljs-keyword">in</span> the world!<br>Knowledge isn<span class="hljs-string">&#x27;t free, you have to pay attention.</span><br></code></pre></td></tr></table></figure><p>By using this command, you can <strong>get all the mottos for all person’s files</strong>, which will significantly enhance one’s working efficiency. For more options, you can typing <code>man grep</code> for advanced usage.</p><h2 id="awk-command"><a href="#awk-command" class="headerlink" title="awk command"></a><code>awk</code> command</h2><p>AWK is a powerful <strong>text-processing language designed for pattern scanning and processing</strong>. AWK is particularly useful for manipulating structured data, such as log files, CSV files, or any text files with consistent formatting. It operates on a <strong>line-by-line basis</strong>.</p><blockquote><p>AWK is named after its creators—Alfred Aho, Peter Weinberger, and Brian Kernighan. </p></blockquote><p>AWK is a powerful command. It can also be seen as a programming language! An AWK program consists of a series of <strong>patterns</strong> and <strong>actions</strong>. The general syntax is:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pattern &#123; action &#125;<br></code></pre></td></tr></table></figure><ul><li><strong>Pattern</strong>: Specifies <strong>when</strong> the action should be executed (e.g., matching a specific line or condition).</li><li><strong>Action</strong>: Defines what to do when the pattern matches (e.g., print a field, perform a calculation).</li></ul><p>If no pattern is provided, the action is applied to every line. If no action is provided, the default action is to <strong>print the entire line</strong>.  By default, AWK <strong>splits each line into fields based on whitespace (spaces or tabs)</strong>. Fields are accessed using <code>$1</code>, <code>$2</code>, <code>$3</code>, etc., where <code>$1</code> is the first field, <code>$2</code> is the second, and so on. The entire line is stored in <code>$0</code>.</p><h3 id="Common-Options-1"><a href="#Common-Options-1" class="headerlink" title="Common Options"></a>Common Options</h3><ul><li><p>Printing Specific Fields</p></li><li><p>Filtering Lines Based on a Condition</p></li><li><p>Using Built-in Variables</p></li><li><p>Changing the Field Separator</p></li><li><p>Using BEGIN and END Blocks</p></li><li><p>Using Regular Expression</p></li><li><p>Conditional Statements</p></li><li><p>Associative Arrays</p></li><li><p>String Manipulation</p></li><li><p>Custom Functions</p></li><li><p>Output Redirection</p></li></ul><p>Assuming I have a file like below:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">ID      Name          Gender  Age  Class     Chinese  Math  English  Physics  Chemistry<br>2023001 John_Doe      Male    18   Class_1   85       92    88       90       87<br>2023002 Alice_Smith   Female  17   Class_2   78       85    80       82       79<br>2023003 Bob_Johnson   Male    19   Class_1   92       88    95       89       94<br>2023004 Emma_Wilson   Female  18   Class_3   65       72    68       70       62<br>2023005 Mike_Brown    Male    17   Class_2   80       76    85       78       82<br>2023006 Lily_Davis    Female  19   Class_3   88       90    92       87       91<br>2023007 Tom_Miller    Male    18   Class_1   73       68    75       70       65<br></code></pre></td></tr></table></figure><ul><li><strong>Printing Specific Fields</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">awk <span class="hljs-string">&#x27;&#123; print $1, $3 &#125;&#x27;</span> file.txt<br></code></pre></td></tr></table></figure><hr><ul><li><strong>Filtering Lines Based on a Condition</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">awk <span class="hljs-string">&#x27;$3 &gt; 25 &#123; print $0 &#125;&#x27;</span> file.txt<br></code></pre></td></tr></table></figure><p>The basic logic for AWK is <strong>if-else</strong> statement, it first scans the text and used the judgements for <code>if $3 &gt; 25, then print $0</code></p><ul><li>Using Built-in Variables</li></ul><p>AWK provides several built-in variables:</p><ul><li><code>NR</code>: Current line number.</li><li><code>NF</code>: Number of fields in the current line.</li><li><code>FS</code>: Field separator (default is whitespace).</li><li><code>OFS</code>: Output field separator (default is space).</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">awk <span class="hljs-string">&#x27;&#123; print NR, $NF &#125;&#x27;</span> file.txt<br></code></pre></td></tr></table></figure><hr><ul><li><strong>Changing the Field Separator</strong></li></ul><p>Use the <code>FS</code> variable to specify a custom field separator, such as a comma for CSV files.</p><p><strong>Example</strong>: Print the second field from a CSV file.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">awk -F, <span class="hljs-string">&#x27;&#123; print $2 &#125;&#x27;</span> data.csv<br></code></pre></td></tr></table></figure><p><strong>Input (<code>data.csv</code>)</strong>:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">John</span>,Doe,<span class="hljs-number">30</span>,Engineer<br><span class="hljs-attribute">Jane</span>,Smith,<span class="hljs-number">25</span>,Designer<br></code></pre></td></tr></table></figure><p><strong>Output</strong>:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">Doe</span><br><span class="hljs-attribute">Smith</span><br></code></pre></td></tr></table></figure><hr><ul><li><strong>Using BEGIN and END Blocks</strong></li></ul><p>The <code>BEGIN</code> block is executed before processing any input, and the <code>END</code> block is executed after all input is processed. You can use it as a programming language for complex tasks!</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">awk <span class="hljs-string">&#x27;</span><br><span class="hljs-string">BEGIN &#123; sum = 0 &#125;</span><br><span class="hljs-string">&#123; sum += $3 &#125;</span><br><span class="hljs-string">END &#123; print &quot;Total lines:&quot;, NR, &quot;Sum of third field:&quot;, sum &#125;</span><br><span class="hljs-string">&#x27;</span> file.txt<br></code></pre></td></tr></table></figure><p><strong>Output</strong>:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Total</span> lines: <span class="hljs-number">2</span> Sum of third field: <span class="hljs-number">55</span><br></code></pre></td></tr></table></figure><hr><ul><li>Regular Expressions: AWK supports regular expressions for pattern matching. Use <code>~</code> to match and <code>!~</code> to negate a match.</li></ul><p><strong>Example</strong>: Print lines where the second field contains “Smith”.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">awk <span class="hljs-string">&#x27;$2 ~ /Smith/ &#123; print $0 &#125;&#x27;</span> file.txt<br></code></pre></td></tr></table></figure><hr><ul><li><strong>Conditional Statements</strong></li></ul><p>AWK supports <code>if-else</code> statements for more complex logic.</p><p><strong>Example</strong>: Classify ages as “Young” or “Old”.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">awk <span class="hljs-string">&#x27;&#123;</span><br><span class="hljs-string">    if ($3 &lt; 30)</span><br><span class="hljs-string">        print $1, &quot;is Young&quot;</span><br><span class="hljs-string">    else</span><br><span class="hljs-string">        print $1, &quot;is Old&quot;</span><br><span class="hljs-string">&#125;&#x27;</span> file.txt<br></code></pre></td></tr></table></figure><hr><ul><li><strong>Associative Arrays</strong></li></ul><p>AWK supports <strong>associative arrays (like dictionaries)</strong> for storing and retrieving data.</p><p><strong>Example</strong>: Count the frequency of each unique value in the third field.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">awk <span class="hljs-string">&#x27;&#123; count[$3]++ &#125;</span><br><span class="hljs-string">END &#123;</span><br><span class="hljs-string">    for (age in count)</span><br><span class="hljs-string">        print age, &quot;:&quot;, count[age]</span><br><span class="hljs-string">&#125;&#x27;</span> file.txt<br></code></pre></td></tr></table></figure><hr><ul><li><strong>String Manipulation</strong></li></ul><p>AWK provides functions for string manipulation, such as <code>length</code>, <code>substr</code>, and <code>toupper</code>. Like the <code>&lt;string&gt;</code> toolbox in cpp!</p><p><strong>Example</strong>: Print the length of the first field.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">awk <span class="hljs-string">&#x27;&#123; print length($1) &#125;&#x27;</span> file.txt<br></code></pre></td></tr></table></figure><hr><ul><li><strong>Custom Functions</strong></li></ul><p>You can define custom functions in AWK for reusable logic.</p><p><strong>Example</strong>: Define a function to calculate the square of a number.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">awk <span class="hljs-string">&#x27;</span><br><span class="hljs-string">function square(x) &#123;</span><br><span class="hljs-string">    return x * x</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">&#123; print square($3) &#125;</span><br><span class="hljs-string">&#x27;</span> file.txt<br></code></pre></td></tr></table></figure><hr><ul><li><strong>Output Redirection</strong></li></ul><p>AWK allows you to redirect output to files.</p><p><strong>Example</strong>: Write the first field to a new file.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">awk <span class="hljs-string">&#x27;&#123; print $1 &gt; &quot;output.txt&quot; &#125;&#x27;</span> file.txt<br></code></pre></td></tr></table></figure><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://www.ruanyifeng.com/blog/2009/06/unix_philosophy.html">https://www.ruanyifeng.com/blog/2009/06/unix_philosophy.html</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://github.com/tldr-pages/tldr">https://github.com/tldr-pages/tldr</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Efficient Tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tutorial</tag>
      
      <tag>Bash</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Bash_exercises</title>
    <link href="/posts/Bash-exercises/"/>
    <url>/posts/Bash-exercises/</url>
    
    <content type="html"><![CDATA[<style>  html, body, .markdown-body {    font-family: Georgia, sans, serif;  }</style><h1 id="Bash-Exercises"><a href="#Bash-Exercises" class="headerlink" title="Bash Exercises"></a>Bash Exercises</h1><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>In this blog, I will record my learning process of <strong>Bash scripts</strong>. I won’t specifically spend a large amount of time learning Bash, for <strong>the fundamental usage of efficient tools is for improving efficiency, rather than anything else</strong>. Trapped into learning tools itself for too long is dangerous and meaningless.</p><p><strong>My practice plan</strong>:</p><ul><li><strong>Try to familiarize command line in daily usage.</strong></li><li><strong>Follow Unix&#x2F;Linux Philosophy</strong></li><li><strong>From comprehending others’ scripts or dotfiles to creating my own Bash scripts to implement automatic tasks</strong></li></ul><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/3/35/Tux.svg/150px-Tux.svg.png" alt="Tux the penguin"></p><h2 id="2025-2-16"><a href="#2025-2-16" class="headerlink" title="2025&#x2F;2&#x2F;16"></a>2025&#x2F;2&#x2F;16</h2><p><code>unzip_all.sh</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><br>DIR=<span class="hljs-string">&quot;<span class="hljs-variable">$PWD</span>&quot;</span><br><span class="hljs-keyword">for</span> zipfile <span class="hljs-keyword">in</span> <span class="hljs-string">&quot;<span class="hljs-variable">$DIR</span>&quot;</span>/*.zip;<span class="hljs-keyword">do</span><br>    <span class="hljs-keyword">if</span> [ -f <span class="hljs-string">&quot;<span class="hljs-variable">$zipfile</span>&quot;</span> ]; <span class="hljs-keyword">then</span><br>    <span class="hljs-comment"># check whether it is a regular file.</span><br>        unzip <span class="hljs-string">&quot;<span class="hljs-variable">$zipfile</span>&quot;</span> -d <span class="hljs-string">&quot;<span class="hljs-variable">$DIR</span>&quot;</span><br>        <span class="hljs-comment">#unzip the file.</span><br>        <br>    <span class="hljs-keyword">fi</span><br><span class="hljs-keyword">done</span><br><br></code></pre></td></tr></table></figure><p><strong>Function</strong>: unzip all files for the current directory.</p><h2 id="2025-3-11"><a href="#2025-3-11" class="headerlink" title="2025&#x2F;3&#x2F;11"></a>2025&#x2F;3&#x2F;11</h2><p>update my <code>.customed_functions.sh</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/zsh</span><br><span class="hljs-comment"># All customed Functions</span><br><span class="hljs-comment"># Several core principles: KISS! Don&#x27;t make it too complex.</span><br><br><span class="hljs-comment"># This functions sets different colours for terminal.</span><br><span class="hljs-function"><span class="hljs-title">print_colored</span></span>() &#123;<br>    <span class="hljs-built_in">local</span> color=<span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span><br>    <span class="hljs-built_in">local</span> text=<span class="hljs-string">&quot;<span class="hljs-variable">$2</span>&quot;</span><br>    <br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;<span class="hljs-variable">$color</span>&quot;</span> <span class="hljs-keyword">in</span><br>        red)    <span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;\033[31m<span class="hljs-variable">$text</span>\033[0m&quot;</span> ;;  <span class="hljs-comment"># 红色</span><br>        green)  <span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;\033[32m<span class="hljs-variable">$text</span>\033[0m&quot;</span> ;;  <span class="hljs-comment"># 绿色</span><br>        yellow) <span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;\033[33m<span class="hljs-variable">$text</span>\033[0m&quot;</span> ;;  <span class="hljs-comment"># 黄色</span><br>        blue)   <span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;\033[34m<span class="hljs-variable">$text</span>\033[0m&quot;</span> ;;  <span class="hljs-comment"># 蓝色</span><br>        purple) <span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;\033[35m<span class="hljs-variable">$text</span>\033[0m&quot;</span> ;;  <span class="hljs-comment"># 紫色</span><br>        cyan)   <span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;\033[36m<span class="hljs-variable">$text</span>\033[0m&quot;</span> ;;  <span class="hljs-comment"># 青色</span><br>        white)  <span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;\033[37m<span class="hljs-variable">$text</span>\033[0m&quot;</span> ;;  <span class="hljs-comment"># 白色</span><br>        *)      <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$text</span>&quot;</span> ;;                   <span class="hljs-comment"># 默认</span><br>    <span class="hljs-keyword">esac</span><br>&#125;<br><br><br><span class="hljs-comment"># Tool Functions </span><br><span class="hljs-comment"># This function is for finding all functions in the sh files.</span><br><span class="hljs-function"><span class="hljs-title">LISTFUNCTIONS</span></span>()&#123;<br>    <span class="hljs-keyword">if</span> [[ ! -f <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span> ]]; <span class="hljs-keyword">then</span><br>        <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Error! File &#x27;<span class="hljs-variable">$1</span>&#x27; doesn&#x27;t exist.&quot;</span><br>        <span class="hljs-built_in">return</span> 1<br>    <span class="hljs-keyword">fi</span><br><br>    grep -E <span class="hljs-string">&#x27;^\s*function\s+\w+|\s*\w+\s*\(\)\s*&#123;&#x27;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span> | sed <span class="hljs-string">&#x27;s/^\s*function\s\+//; s/\s*(.*//; s/\s*&#123;//&#x27;</span><br>    print_colored red <span class="hljs-string">&quot;________________________________________________________________________&quot;</span><br><br>    awk <span class="hljs-string">&#x27;</span><br><span class="hljs-string">    /^#/ &#123; comment = $0 &#125;</span><br><span class="hljs-string">    </span><br><span class="hljs-string">    /^\s*function\s+\w+|\s*\w+\s*\(\)\s*&#123;/ &#123;</span><br><span class="hljs-string">        if ($0 ~ /^\s*function\s+/) &#123;</span><br><span class="hljs-string">            func_name = $0; sub(/^\s*function\s+/, &quot;&quot;, func_name); sub(/\s*(\(\)\s*&#123;).*/, &quot;&quot;, func_name);</span><br><span class="hljs-string">        &#125; else &#123;</span><br><span class="hljs-string">            func_name = $0; sub(/\s*(\(\)\s*&#123;).*/, &quot;&quot;, func_name);</span><br><span class="hljs-string">        &#125;</span><br><span class="hljs-string">        print func_name, comment</span><br><span class="hljs-string">        comment = &quot;&quot;</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">    &#x27;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span><br><br><br>    print_colored red <span class="hljs-string">&quot;________________________________________________________________________&quot;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;All files of bash scripts.&quot;</span><br>    <span class="hljs-built_in">ls</span> ~/.bash_scripts<br>&#125;<br><br><br><span class="hljs-comment"># Hello world</span><br><span class="hljs-comment"># This function is for greetings and test for customized functions.</span><br><span class="hljs-function"><span class="hljs-title">HELLO</span></span>()&#123;<br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Hello! You are in <span class="hljs-variable">$PWD</span> now.&quot;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Make Progress every day.&quot;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Remember keep simple and stupid in Linux and don&#x27;t forget the zen of Python!&quot;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Have a great time!&quot;</span><br>&#125;<br><br><br><br><span class="hljs-comment"># GENERAL</span><br><span class="hljs-comment"># This function lists all customed functions.</span><br><span class="hljs-function"><span class="hljs-title">MY</span></span>()&#123;<br>    HELLO<br>    print_colored red <span class="hljs-string">&quot;________________________________________________________________________&quot;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Several Customed Functions are listed in this functions&quot;</span><br>    LISTFUNCTIONS ~/.bash_scripts/customed_functions.sh<br>&#125;<br><br><span class="hljs-comment"># Tmux memo</span><br><span class="hljs-comment"># This funcion shows the basic usage of several tmux commands.</span><br><span class="hljs-function"><span class="hljs-title">TMUXH</span></span>()&#123;<br>    print_colored red <span class="hljs-string">&quot;TMUX MEMO&quot;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;\033[36mtmux new -s &lt;session-name&gt;\033[0m for create a new tmux session.&quot;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;\033[36mtmux attach -t &lt;session-name&gt;\033[0m for attach a new tmux session.&quot;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;\033[36mtmux kill-session -t &lt;session-name&gt;\033[0m for kill a session.&quot;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;\033[36mtmux tmux switch -t &lt;session-name&gt;\033[0m for switching different sessions.&quot;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;\033[36mtmux rename-session -t 0 &lt;new-name&gt;\033[0m for renaming the sessions.&quot;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;\033[36mtmux split-window\033[0m for spliting windows, -h for left and right.&quot;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;\033[36tmux select-pane\033[0m for moving cursor, -UDLR&quot;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;\033[36mtmux swap-pane -U\033[0m for swapping the current pane up.&quot;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;\033[36mtmux swap-pane -D\033[0m for swapping the current pane down.&quot;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;\033[36mCtrl+b %\033[0m for splitting the window vertically.&quot;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;\033[36mCtrl+b \&quot;\033[0m for splitting the window horizontally.&quot;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;\033[36mCtrl+b &lt;arrow key&gt;\033[0m for switching to another pane.&quot;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;\033[36mCtrl+b ;\033[0m for switching to the last pane.&quot;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;\033[36mCtrl+b o\033[0m for switching to the next pane.&quot;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;\033[36mCtrl+b &#123;\033[0m for swapping the current pane with the previous one.&quot;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;\033[36mCtrl+b &#125;\033[0m for swapping the current pane with the next one.&quot;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;\033[36mCtrl+b Ctrl+o\033[0m for moving all panes forward.&quot;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;\033[36mCtrl+b Alt+o\033[0m for moving all panes backward.&quot;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;\033[36mCtrl+b x\033[0m for closing the current pane.&quot;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;\033[36mCtrl+b !\033[0m for splitting the current pane into a new window.&quot;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;\033[36mCtrl+b z\033[0m for toggling the current pane to fullscreen.&quot;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;\033[36mCtrl+b Ctrl+&lt;arrow key&gt;\033[0m for resizing panes.&quot;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;\033[36mCtrl+b q\033[0m for displaying pane numbers.&quot;</span><br><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;\033[36mtmux new-window\033[0m for creating a new window.&quot;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;\033[36mtmux new-window -n &lt;window-name&gt;\033[0m for creating a new window with a specific name.&quot;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;\033[36mtmux select-window -t &lt;window-number&gt;\033[0m for switching to a specific window by number.&quot;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;\033[36mtmux select-window -t &lt;window-name&gt;\033[0m for switching to a specific window by name.&quot;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;\033[36mtmux rename-window &lt;new-name&gt;\033[0m for renaming the current window.&quot;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;\033[36mCtrl+b c\033[0m for creating a new window.&quot;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;\033[36mCtrl+b p\033[0m for switching to the previous window.&quot;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;\033[36mCtrl+b n\033[0m for switching to the next window.&quot;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;\033[36mCtrl+b &lt;number&gt;\033[0m for switching to a specific window by its number.&quot;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;\033[36mCtrl+b w\033[0m for selecting a window from a list.&quot;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;\033[36mCtrl+b ,\033[0m for renaming the current window.&quot;</span><br><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;\033[36mtmux list-keys\033[0m for listing all key bindings.&quot;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;\033[36mtmux list-commands\033[0m for listing all tmux commands and their parameters.&quot;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;\033[36mtmux info\033[0m for listing information about current tmux sessions.&quot;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;\033[36mtmux source-file ~/.tmux.conf\033[0m for reloading the current tmux configuration.&quot;</span><br><br>&#125;<br><br><span class="hljs-comment"># Alias Memo</span><br><span class="hljs-comment"># This Function is for getting all the alias in the file ~/.zshrc</span><br><span class="hljs-function"><span class="hljs-title">ALIAS_GET</span></span>()&#123;<br>    <span class="hljs-built_in">cat</span> ~/.zshrc | grep <span class="hljs-string">&#x27;alias .*=&#x27;</span> | grep -v <span class="hljs-string">&quot;mate&quot;</span><br>&#125;<br><br><span class="hljs-comment"># colourful demontrations</span><br><span class="hljs-comment"># This Function displays all colours in terminal (Using RGB).</span><br><span class="hljs-function"><span class="hljs-title">ALL_COLOURS</span></span>()&#123;<br><span class="hljs-keyword">for</span> R <span class="hljs-keyword">in</span> $(<span class="hljs-built_in">seq</span> 0 20 255); <span class="hljs-keyword">do</span><br>    <span class="hljs-keyword">for</span> G <span class="hljs-keyword">in</span> $(<span class="hljs-built_in">seq</span> 0 20 255); <span class="hljs-keyword">do</span><br>        <span class="hljs-keyword">for</span> B <span class="hljs-keyword">in</span> $(<span class="hljs-built_in">seq</span> 0 20 255); <span class="hljs-keyword">do</span><br>            <span class="hljs-built_in">printf</span> <span class="hljs-string">&quot;\e[38;2;<span class="hljs-variable">$&#123;R&#125;</span>;<span class="hljs-variable">$&#123;G&#125;</span>;<span class="hljs-variable">$&#123;B&#125;</span>m█\e[0m&quot;</span>;<br>        <span class="hljs-keyword">done</span><br>    <span class="hljs-keyword">done</span><br><span class="hljs-keyword">done</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="2025-3-11-1"><a href="#2025-3-11-1" class="headerlink" title="2025&#x2F;3&#x2F;11"></a>2025&#x2F;3&#x2F;11</h2><p>update my <code>dlcpp.sh</code> function:</p><ul><li>This function is <strong>only used for deleting the complied binary files when I am coding with my cpp project and the homework of Data Structure</strong>. This may be dangerous if you use it casually in other directories.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-function"><span class="hljs-title">CLEAR_ALL_BINF</span></span>()&#123;<br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Attention! This function is for C++ training only&quot;</span><br><br><span class="hljs-comment"># 查找根目录下的所有二进制文件</span><br>binary_files=$(find . -<span class="hljs-built_in">type</span> f ! -name <span class="hljs-string">&quot;*.cpp&quot;</span> ! -name <span class="hljs-string">&quot;*.*&quot;</span> 2&gt;/dev/null)<br><br><span class="hljs-comment"># 检查是否找到任何文件</span><br><span class="hljs-keyword">if</span> [ -z <span class="hljs-string">&quot;<span class="hljs-variable">$binary_files</span>&quot;</span> ]; <span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;No files detected&quot;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Press Enter to quit.&quot;</span><br>    <span class="hljs-built_in">read</span> whether_to_quit<br>    <span class="hljs-keyword">if</span> [[ -z <span class="hljs-string">&quot;<span class="hljs-variable">$whether_to_quit</span>&quot;</span> ]]; <span class="hljs-keyword">then</span><br>        <span class="hljs-built_in">return</span>  0<br>    <span class="hljs-keyword">fi</span><br><span class="hljs-keyword">fi</span><br><br><span class="hljs-comment"># 列出要删除的文件</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;All files needs to be deleted&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$binary_files</span>&quot;</span><br><br><span class="hljs-comment"># 提示用户确认</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Are you sure to delete these files? (Danger sometimes!) [yes/anything else]&quot;</span><br><span class="hljs-comment"># 读取用户输入</span><br><span class="hljs-built_in">read</span> confirmation<br><br><span class="hljs-comment"># 根据用户输入进行处理</span><br><span class="hljs-keyword">if</span> [[ <span class="hljs-string">&quot;<span class="hljs-variable">$confirmation</span>&quot;</span> == <span class="hljs-string">&quot;yes&quot;</span> ]]; <span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Deleting&quot;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$binary_files</span>&quot;</span> | xargs <span class="hljs-built_in">rm</span> -f<br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Done&quot;</span><br><span class="hljs-keyword">else</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;No files deleted&quot;</span><br><span class="hljs-keyword">fi</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Efficient Tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tutorial</tag>
      
      <tag>Bash</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS294-1-LLM-Reasoning</title>
    <link href="/posts/CS294-1-LLM-Reasoning/"/>
    <url>/posts/CS294-1-LLM-Reasoning/</url>
    
    <content type="html"><![CDATA[<style>  html, body, .markdown-body {    font-family: Georgia, sans, serif;  }</style><h1 id="CS294-194-196-Large-Language-Model-Agents"><a href="#CS294-194-196-Large-Language-Model-Agents" class="headerlink" title="CS294&#x2F;194-196 Large Language Model Agents"></a>CS294&#x2F;194-196 Large Language Model Agents</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>In this course, you will learn several basic concepts of LLM reasoning and build <strong>agents</strong> based on LLMs. This course map are shown as follows:</p><p><img src="https://s1.imagehub.cc/images/2025/02/23/66a458463c0f0aec8832db6c4ae5cddd.png" alt="Large Language Model Agents MOOC"><br><img src="https://s1.imagehub.cc/images/2025/02/23/e089ee6ff2c1746bb9e648a1f34632f0.png" alt="Topics covered in this course"></p><h1 id="Lec1-LLM-reasoning"><a href="#Lec1-LLM-reasoning" class="headerlink" title="Lec1: LLM reasoning"></a>Lec1: LLM reasoning</h1><h2 id="Intermediate-Steps-works"><a href="#Intermediate-Steps-works" class="headerlink" title="Intermediate Steps works"></a>Intermediate Steps works</h2><p><img src="https://s1.imagehub.cc/images/2025/02/12/bbbd6f99a96f0c55aa908517e85d0272.png" alt="LLM reasoning"></p><p><strong>Reasoning</strong>: Humans can learn from <strong>a few or even no examples</strong> during the process because <strong>humans can reason</strong>! <strong>Traditional ML methods</strong> fails: <strong>Auto-encoder</strong>, require vast amount of labeled data.</p><p>Training LLMs needs a new way (<strong>few-shot or zero-shot prompting</strong>).</p><p>So how to make LLMs implement this? <strong>Let’s think step by step</strong>! Paper1<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://aclanthology.org/P17-1015.pdf">[1]</span></a></sup> shown below in ACL 2017 first shows the effectiveness of introducing <strong>intermediate steps</strong> when designing model’s architecture. Following the work by Ling et al 2017, Cobbe et al 2021 in OpenAI built a much larger math word problem dataset (<strong>GSM8K</strong>) with natural language rationales, and used it to finetune GPT3.</p><p>How to implement <strong>intermediate steps</strong>? <strong>It’s the Chain-of-Thought</strong>! This is the foundation of modern mainstream reasoning models.</p><p><a href="https://www.imagehub.cc/image/Screenshot-2025-02-23-192125.C723yh"><img src="https://s1.imagehub.cc/images/2025/02/23/9ea0a1dc06b516dc107daa1351c848ee.png" alt="Chain of Thought Prompting"></a></p><p>Regardless of training, fine-tuning, or prompting, when provided with <strong>examples that include intermediate steps</strong>, LLMs will respond with intermediate steps.</p><p>How to understand this? In my opinion, traditional machine learning methods, in simple terms, means finding patterns of labeled data points in a high-dimensional data space. This is essentially a process of <strong>finding patterns</strong>. Sometimes LLMs don’t provide the answer you want is for the reason of catching the wrong patterns. Providing intermediate steps enables LLMs to catch the right pattern more easily with the guidance.</p><p><strong>This doesn’t end!</strong> We can make LLMs more powerful by training LLM’s reasoning abilities. In the book “How to Solve It”, the writer introduces <strong>decomposing and recombining</strong> are important operations of the mind. You decompose the whole into its parts and recombine the parts in a more or less whole.</p><p>We can simulate this process in LLMs, by enabling LLMs to <strong>think step by step</strong> on its own! In other words, LLMs can autonomously generate and decompose the whole problem and solve each sub-questions step by step.</p><p>In <a href="https://github.com/brendenlake/SCAN">SCAN</a> (Compositional Generalization) and <a href="https://github.com/google-research/google-research/blob/master/cfq/README.md">CFQ</a> (Text-to-code) tasks, this method uses just 0.1% demonstration examples and achieves perfect generalization. Moreover, we can make LLMs perform well <strong>without using demonstration examples</strong>, which is known as <strong>zero-shot prompting</strong>.</p><h2 id="Analogical-Reasoning"><a href="#Analogical-Reasoning" class="headerlink" title="Analogical Reasoning"></a>Analogical Reasoning</h2><p><strong>Analogical reasoning</strong> is an important think pattern that human solve new problem. When humans encounter new and difficult tasks, people tend to <strong>relate this problem to previously seen problems</strong> to get several ideas. That is <strong>experience</strong>. We also want LLMs to learn this ability.</p><blockquote><p>“A mathematician is a person who can find analogies between theorems; a better mathematician is one who can see analogies between proofs and the best mathematician can notice analogies between theories. One can imagine that the ultimate mathematician is one who can see analogies between analogies.”</p><p> —-Stefan Banach</p></blockquote><p><strong>Whatever the method is</strong>, we ultimately want LLMs to learn and comprehend the problem itself, rather than just wandering set on the basis of the limited data.</p><h2 id="LLM-reasoning-without-prompting"><a href="#LLM-reasoning-without-prompting" class="headerlink" title="LLM reasoning without prompting"></a>LLM reasoning without prompting</h2><p>In previous research, zero-shot prompting perform worse than few-shot prompting. We can achieve LLM reasoning without prompting! Pre-trained LLMs, without further finetuning, has been ready for step-by-step reasoning, but we need a non-greedy decoding strategy to <strong>elicit</strong> it. </p><p>When a <strong>step-by-step reasoning path is present</strong>, LLMs have much higher confidence in <strong>decoding the final answer</strong> than direct-answer decoding.</p><p>In the graph shown as follows, <strong>CoT decoding</strong> performs better than <strong>greedy decoding</strong>.</p><p><img src="https://s1.imagehub.cc/images/2025/02/28/577f66e4738a260c87d88e80e85011e1.png" alt="greedy decoding and CoT-decoding"></p><h2 id="Self-consistency"><a href="#Self-consistency" class="headerlink" title="Self-consistency"></a>Self-consistency</h2><h2 id="Limitations"><a href="#Limitations" class="headerlink" title="Limitations"></a>Limitations</h2><h2 id="Papers"><a href="#Papers" class="headerlink" title="Papers"></a>Papers</h2><p>This section is for several papers this course has recommended, some of which are demonstrated on the PowerPoint.  By diving deeper into these lectures and slides again, you can absolutely gain a deeper meaning of LLM reasoning!</p><h3 id="Paper1-Derive-the-Final-Answer-through-Intermediate-Steps"><a href="#Paper1-Derive-the-Final-Answer-through-Intermediate-Steps" class="headerlink" title="Paper1_Derive the Final Answer through Intermediate Steps"></a>Paper1_Derive the Final Answer through Intermediate Steps</h3><p>This paper<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://aclanthology.org/P17-1015.pdf">[1]</span></a></sup> focuses on solving algebraic word problems by generating answer rationales. A new dataset with 100,000 samples of questions, answers, and rationales is created. The model proposed is a sequence-to-sequence model that generates a program’s instructions to produce the rationale and then the answer. It defines 22 operations and models each instruction based on the text program specification and history. Inducing programs is achieved by leveraging the progression in rationales and filtering possible instructions. Staged back-propagation is used to handle the memory challenge caused by long rationales. Experiments show that compared with baseline models like the attention-based sequence-to-sequence model with copy mechanisms, this model performs better in terms of perplexity, BLEU score, and accuracy. It demonstrates the effectiveness of using rationales to guide program induction in solving math problems and provides a new approach and dataset for future research in this area. </p><p>The model seems to have <strong>the reasoning ability</strong>, but actually its basic structure is still <strong>LSTM</strong> model (a version of <strong>RNN</strong>). Decompose the problem into smaller subproblems, ultimately transforming it into a series of instruction sets, making it difficult to solve more challenging mathematical problems. Moreover, <strong>transformer</strong> structure hasn’t been invented yet. But it proves the potential of <strong>generating intermediate steps</strong> while getting the final answer to decrease perplexity and enhance error rate.</p><div style="text-align: center;">    <img src="https://s1.imagehub.cc/images/2025/02/12/a54fa6519a140208b75e94f2e9a8a030.png" alt="Paper Notes" style="zoom:50%;" /></div><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><blockquote><p>The cite format is informal, the references below just list the url link of all papers.</p></blockquote><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://aclanthology.org/P17-1015.pdf">https://aclanthology.org/P17-1015.pdf</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Artificial Intelligence</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Artificial Intelligence</tag>
      
      <tag>Deep Learning</tag>
      
      <tag>Agent</tag>
      
      <tag>LLM reasoning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Missing-Semester-Notes</title>
    <link href="/posts/Missing-Semester-Notes/"/>
    <url>/posts/Missing-Semester-Notes/</url>
    
    <content type="html"><![CDATA[<style>  html, body, .markdown-body {    font-family: Georgia, sans, serif;  }</style><h1 id="Lecture-Notes-Missing-Semester-for-your-CS-education"><a href="#Lecture-Notes-Missing-Semester-for-your-CS-education" class="headerlink" title="Lecture Notes: Missing Semester for your CS education"></a>Lecture Notes: Missing Semester for your CS education</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p><img src="https://s1.imagehub.cc/images/2025/02/12/2fba209f139c83bb6212f0f589baac2a.png" alt="Missing Semester of Your CS education"></p><p><strong>Welcome to the course: The Missing Semester of Your CS Education!</strong></p><p>When I first learned about this course at the beginning of my freshman year, I had no concept of command lines, development, and other related topics. Additionally, since the course was taught entirely in English, I tried attending a few lectures but eventually gave up, and my absorption rate was also low. During this winter break, after a semester of experience in my freshman year, I installed <strong>the WSL subsystem and mastered the most basic Bash knowledge</strong>. When I revisited this course, I felt a sudden clarity. Now, the command line has become a tool I frequently use, greatly improving my learning and development efficiency. Therefore, I will organize my <strong>Missing Semester notes</strong> in this blog, hoping to inspire and help future learners.</p><p>Before starting the learning exploration, I strongly recommend you to <strong>ensure all these questions and contents below are carefully read</strong>, which will help you gain a better learning experience.</p><h3 id="Where-to-find-the-course"><a href="#Where-to-find-the-course" class="headerlink" title="Where to find the course?"></a>Where to find the course?</h3><p><strong>On YouTube:</strong> <a href="https://www.youtube.com/@MissingSemester">https://www.youtube.com/@MissingSemester</a></p><p>The course also has its own websites for clear lecture notes!</p><ul><li><a href="https://missing.csail.mit.edu/">https://missing.csail.mit.edu/</a></li><li><a href="https://github.com/missing-semester/missing-semester">https://github.com/missing-semester/missing-semester</a></li></ul><p>For domestic users, you can browse <a href="https://www.bilibili.com/">Bilibili</a> for reposting of the original course and Chinese subtitle translation.</p><ul><li><a href="https://www.bilibili.com/video/BV1x7411H7wa/?vd_source=6955add1d28c52cd48096d58e09ce798">Repost on Bilibili</a></li></ul><h3 id="What’s-this-course-about"><a href="#What’s-this-course-about" class="headerlink" title="What’s this course about?"></a>What’s this course about?</h3><p>Let’s take a look at how the course instructor evaluates the positioning of this course.</p><blockquote><p><strong>Missing semester Lec1 Beginning- The overall introduction of this course</strong></p><p>This class stems from an observation that Anish, Jose, and I have made while attending various classes at MIT. The observation is that, as computer scientists, we all know that computers are great at performing repetitive tasks and automating things. However, we often fail to realize that there are many tools that can make our own development processes better. We can be much more efficient in how we use our computers because <strong>we can use the computer as a tool for ourselves</strong>, not just for building websites or software. This class is an attempt to address this issue. It is an attempt to show you some of the tools that you can use to great effect in your day-to-day work, in your research, and in your studies. It’s going to be a class where we want to teach you <strong>both how to make the most of the tools that you already know and, hopefully, introduce you to some tools that you don’t know yet</strong>. We also want to show you how to combine these tools to produce more powerful results than you might think possible with what you know today.</p><p><strong>Chinese Translation</strong>:</p><p>这门课程源于Anish、Jose和我在MIT参加各种课程时的一个观察。我们发现，作为计算机科学家，我们都知道计算机非常擅长执行重复性任务和自动化工作。然而，我们常常没有意识到，有许多工具可以让我们的开发过程变得更好。我们可以更高效地使用计算机，因为我们可以将计算机作为我们自己的工具，而不仅仅是用来构建网站或软件。这门课程旨在解决这个问题。它试图向你展示一些可以在日常工作、研究和学习中高效使用的工具。这门课程的目标是教你如何充分利用你已经知道的工具，同时也希望向你介绍一些你以前不知道的工具，并展示如何将这些工具结合起来，产生比你今天所知道的更强大的结果。</p></blockquote><p>So this lecture is for <strong>Tool-using</strong> during your CS education. Several Tools can be seen in the subtitle of each courses.</p><h3 id="Am-I-ready-to-take-the-course"><a href="#Am-I-ready-to-take-the-course" class="headerlink" title="Am I ready to take the course?"></a>Am I ready to take the course?</h3><p><strong>However</strong>, I am unwilling to announce the fact that: This course is not suitable for <strong>Totally-Green-Hand</strong>.🙂‍↕️🙂‍↕️🙂‍↕️ Here are two following reasons I have summarized:</p><ul><li>The course progresses <strong>very quickly</strong>. If you have no prior knowledge of these concepts, there’s a high chance you won’t keep up with the pace! Although you can pause while learning on video platforms, <strong>previewing the basic knowledge before taking the course can provide a better learning experience</strong>.</li><li>In learning tools, <strong>practice is a very important component</strong>. This course mainly focuses on lectures and lacks opportunities for hands-on practice.</li></ul><p>Thus, I strongly recommend you to do such things before entering the courses:</p><ul><li><p><strong>Make sure you have installed command-line environment before the course begins!</strong> (Most important)</p><ul><li><strong>MacOS</strong> or <strong>Linux</strong> is preferred.</li><li><strong>WSL</strong> for <strong>Windows</strong></li></ul><blockquote><p><strong>While learning the course content, practice hands-on operations simultaneously!</strong> </p></blockquote><blockquote><p>Still updating~</p></blockquote></li></ul><h2 id="Lec1-2-Shell-Tools-and-Scripting"><a href="#Lec1-2-Shell-Tools-and-Scripting" class="headerlink" title="Lec1-2: Shell Tools and Scripting"></a>Lec1-2: Shell Tools and Scripting</h2><h3 id="in-Bash"><a href="#in-Bash" class="headerlink" title="$ in Bash"></a><code>$</code> in Bash</h3><p>In Bash, <code>$</code> has special meanings:</p><ol><li><strong>Variable Reference</strong>: Access variable values (<code>$var</code>).</li><li><strong>Special Variables</strong>: <ul><li><code>$0</code>: Script name.</li><li><code>$1</code>-<code>$9</code>: Script arguments.</li><li><code>$?</code>: Exit status of the last command.</li><li><code>$$</code>: Current script’s PID.</li></ul></li><li><strong>Command Substitution</strong>: Capture command output (<code>$(command)</code>).</li><li><strong>Arithmetic Operations</strong>: Perform math (<code>$((expression))</code>).</li><li><strong>Environment Variables</strong>: Access (<code>$HOME</code>, <code>$PATH</code>).</li></ol><p>Here <code>$1</code> is the first argument to the script&#x2F;function. Unlike other scripting languages, bash uses a variety of special variables to refer to arguments, error codes, and other relevant variables. Below is a list of some of them. A more comprehensive list can be found <a href="https://tldp.org/LDP/abs/html/special-chars.html">here</a>.</p><ul><li><code>$0</code> - Name of the script</li><li><code>$1</code> to <code>$9</code> - Arguments to the script. <code>$1</code> is the first argument and so on.</li><li><code>$@</code> - All the arguments</li><li><code>$#</code> - Number of arguments</li><li><code>$?</code> - Return code of the previous command<ul><li>If the previous command execute successfully, the arguments will probably return <code>0</code>.</li><li>If it fails, it will return none-0 value.</li></ul></li><li><code>$$</code> - <strong>Process identification number (PID)</strong> for the current script</li><li><code>!!</code> - <strong>Entire last command, including arguments</strong>. A common pattern is to execute a command only for it to fail due to missing permissions; you can quickly re-execute the command with sudo by doing <code>sudo !!</code></li><li><code>$_</code> - Last argument from the last command. If you are in an interactive shell, you can also quickly get this value by typing <code>Esc</code> followed by <code>.</code> or <code>Alt+.</code></li></ul><h3 id="find-command"><a href="#find-command" class="headerlink" title="find command"></a><code>find</code> command</h3><p><code>find</code> is a very powerful command-line tool used to search for files and directories in a directory tree. It supports a large number of parameters and options, allowing searches based on file name, type, size, time, permissions, and many other conditions. Below are some commonly used <code>find</code> parameters and options, categorized by functionality:</p><h4 id="1-Basic-Search"><a href="#1-Basic-Search" class="headerlink" title="1. Basic Search"></a>1. <strong>Basic Search</strong></h4><ul><li><strong><code>.</code></strong>: Start searching from the current directory.</li><li><strong><code>/path/to/dir</code></strong>: Start searching from the specified directory.</li></ul><h4 id="2-Search-by-File-Name"><a href="#2-Search-by-File-Name" class="headerlink" title="2. Search by File Name"></a>2. <strong>Search by File Name</strong></h4><ul><li><strong><code>-name &quot;pattern&quot;</code></strong>: Match file names (case-sensitive).<ul><li>Example: <code>find . -name &quot;*.txt&quot;</code> finds all <code>.txt</code> files.</li></ul></li><li><strong><code>-iname &quot;pattern&quot;</code></strong>: Match file names (case-insensitive).<ul><li>Example: <code>find . -iname &quot;readme*&quot;</code> finds all <code>README</code>, <code>readme</code>, etc. files.</li></ul></li><li><strong><code>-regex &quot;pattern&quot;</code></strong>: Match file names using regular expressions.<ul><li>Example: <code>find . -regex &quot;.*\.txt$&quot;</code> finds all files ending with <code>.txt</code>.</li></ul></li></ul><h4 id="3-Search-by-File-Type"><a href="#3-Search-by-File-Type" class="headerlink" title="3. Search by File Type"></a>3. <strong>Search by File Type</strong></h4><ul><li><strong><code>-type f</code></strong>: Find regular files.</li><li><strong><code>-type d</code></strong>: Find directories.</li><li><strong><code>-type l</code></strong>: Find symbolic links.</li><li><strong><code>-type s</code></strong>: Find socket files.</li><li><strong><code>-type p</code></strong>: Find named pipes (FIFO).</li><li><strong><code>-type c</code></strong>: Find character device files.</li><li><strong><code>-type b</code></strong>: Find block device files.</li></ul><h4 id="4-Search-by-File-Size"><a href="#4-Search-by-File-Size" class="headerlink" title="4. Search by File Size"></a>4. <strong>Search by File Size</strong></h4><ul><li><strong><code>-size +n</code></strong>: Find files larger than <code>n</code>.</li><li><strong><code>-size -n</code></strong>: Find files smaller than <code>n</code>.</li><li><strong><code>-size n</code></strong>: Find files exactly <code>n</code> in size.<ul><li>Units can be:<ul><li><code>c</code>: Bytes (default).</li><li><code>k</code>: Kilobytes.</li><li><code>M</code>: Megabytes.</li><li><code>G</code>: Gigabytes.</li></ul></li><li>Example: <code>find . -size +100M</code> finds files larger than 100MB.</li></ul></li></ul><h4 id="5-Search-by-Time"><a href="#5-Search-by-Time" class="headerlink" title="5. Search by Time"></a>5. <strong>Search by Time</strong></h4><ul><li><strong><code>-mtime n</code></strong>: Find files modified <code>n</code> days ago.<ul><li><code>-mtime +n</code>: Files modified more than <code>n</code> days ago.</li><li><code>-mtime -n</code>: Files modified within the last <code>n</code> days.</li></ul></li><li><strong><code>-atime n</code></strong>: Find files accessed <code>n</code> days ago.</li><li><strong><code>-ctime n</code></strong>: Find files whose status (e.g., permissions or ownership) changed <code>n</code> days ago.</li><li><strong><code>-mmin n</code></strong>: Find files modified <code>n</code> minutes ago.<ul><li><code>-mmin +n</code>: Files modified more than <code>n</code> minutes ago.</li><li><code>-mmin -n</code>: Files modified within the last <code>n</code> minutes.</li></ul></li><li><strong><code>-amin n</code></strong>: Find files accessed <code>n</code> minutes ago.</li><li><strong><code>-cmin n</code></strong>: Find files whose status changed <code>n</code> minutes ago.</li></ul><h4 id="6-Search-by-Permissions"><a href="#6-Search-by-Permissions" class="headerlink" title="6. Search by Permissions"></a>6. <strong>Search by Permissions</strong></h4><ul><li><strong><code>-perm mode</code></strong>: Find files with permissions exactly matching <code>mode</code>.<ul><li>Example: <code>find . -perm 644</code> finds files with permissions <code>644</code>.</li></ul></li><li><strong><code>-perm -mode</code></strong>: Find files with permissions including <code>mode</code>.<ul><li>Example: <code>find . -perm -u=r</code> finds files readable by the user.</li></ul></li><li><strong><code>-perm /mode</code></strong>: Find files with any of the <code>mode</code> bits set.</li></ul><h4 id="7-Search-by-User-and-Group"><a href="#7-Search-by-User-and-Group" class="headerlink" title="7. Search by User and Group"></a>7. <strong>Search by User and Group</strong></h4><ul><li><strong><code>-user username</code></strong>: Find files owned by the specified user.</li><li><strong><code>-group groupname</code></strong>: Find files owned by the specified group.</li><li><strong><code>-uid uid</code></strong>: Find files owned by the specified user ID.</li><li><strong><code>-gid gid</code></strong>: Find files owned by the specified group ID.</li></ul><h4 id="8-Logical-Operations"><a href="#8-Logical-Operations" class="headerlink" title="8. Logical Operations"></a>8. <strong>Logical Operations</strong></h4><ul><li><strong><code>-and</code> or <code>-a</code></strong>: Logical AND (default).</li><li><strong><code>-or</code> or <code>-o</code></strong>: Logical OR.</li><li><strong><code>-not</code> or <code>!</code></strong>: Logical NOT.</li><li><strong><code>()</code></strong>: Group conditions.<ul><li>Example: <code>find . \( -name &quot;*.txt&quot; -o -name &quot;*.md&quot; \)</code> finds <code>.txt</code> or <code>.md</code> files.</li></ul></li></ul><h4 id="9-Execute-Actions"><a href="#9-Execute-Actions" class="headerlink" title="9. Execute Actions"></a>9. <strong>Execute Actions</strong></h4><ul><li><strong><code>-exec command &#123;&#125; \;</code></strong>: Execute a command on the found files.<ul><li>Example: <code>find . -name &quot;*.log&quot; -exec rm &#123;&#125; \;</code> deletes all <code>.log</code> files.</li></ul></li><li><strong><code>-exec command &#123;&#125; +</code></strong>: Pass multiple files to the command at once.<ul><li>Example: <code>find . -name &quot;*.txt&quot; -exec cp &#123;&#125; /backup/ +</code> copies all <code>.txt</code> files to <code>/backup</code>.</li></ul></li><li><strong><code>-ok command &#123;&#125; \;</code></strong>: Similar to <code>-exec</code>, but prompts for confirmation before executing the command.</li><li><strong><code>-delete</code></strong>: Delete the found files.</li><li><strong><code>-print</code></strong>: Print the path of the found files (default behavior).</li><li><strong><code>-ls</code></strong>: Display the found files in <code>ls -dils</code> format.</li></ul><h4 id="10-Other-Common-Options"><a href="#10-Other-Common-Options" class="headerlink" title="10. Other Common Options"></a>10. <strong>Other Common Options</strong></h4><ul><li><strong><code>-maxdepth n</code></strong>: Limit the maximum directory depth for the search.<ul><li>Example: <code>find . -maxdepth 2 -name &quot;*.txt&quot;</code> searches for <code>.txt</code> files only in the current directory and its immediate subdirectories.</li></ul></li><li><strong><code>-mindepth n</code></strong>: Limit the minimum directory depth for the search.</li><li><strong><code>-empty</code></strong>: Find empty files or directories.</li><li><strong><code>-readable</code></strong>: Find readable files.</li><li><strong><code>-writable</code></strong>: Find writable files.</li><li><strong><code>-executable</code></strong>: Find executable files.</li></ul><h4 id="11-Comprehensive-Examples"><a href="#11-Comprehensive-Examples" class="headerlink" title="11. Comprehensive Examples"></a>11. <strong>Comprehensive Examples</strong></h4><p>Find and delete all <code>.log</code> files in the current directory:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">find . -name <span class="hljs-string">&quot;*.log&quot;</span> -delete<br></code></pre></td></tr></table></figure><p>Find files larger than 100MB in <code>/var/log</code> and display detailed information:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">find /var/log -size +100M -<span class="hljs-built_in">ls</span><br></code></pre></td></tr></table></figure><p>Find <code>.txt</code> files modified within the last 7 days in the current directory and copy them to <code>/backup</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">find . -name <span class="hljs-string">&quot;*.txt&quot;</span> -mtime -7 -<span class="hljs-built_in">exec</span> <span class="hljs-built_in">cp</span> &#123;&#125; /backup/ \;<br></code></pre></td></tr></table></figure><p>Find and delete all empty directories in the current directory:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">find . -<span class="hljs-built_in">type</span> d -empty -delete<br></code></pre></td></tr></table></figure><p>Find files with permissions <code>644</code> in the current directory and change their permissions to <code>755</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">find . -<span class="hljs-built_in">type</span> f -perm 644 -<span class="hljs-built_in">exec</span> <span class="hljs-built_in">chmod</span> 755 &#123;&#125; \;<br></code></pre></td></tr></table></figure><h3 id="grep-command"><a href="#grep-command" class="headerlink" title="grep command"></a><code>grep</code> command</h3><p><code>grep</code> is a powerful command-line tool in Unix&#x2F;Linux used to search for specific patterns within files or input text. </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">grep [options] pattern [file]<br></code></pre></td></tr></table></figure><ul><li><strong><code>pattern</code></strong>: The text or <strong>regular expression</strong> to search for.</li><li><strong><code>file</code></strong>: The file(s) to search within. If omitted, <code>grep</code> reads from standard input.</li></ul><p>For example, you can using the <code>grep</code> command by using pipes.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /etc/ssh/sshd_config | grep Port<br></code></pre></td></tr></table></figure><p>This command will first output the file contents of <code>sshd_config</code> while the content itself won’t be printed directly into the screen. It will be transmitted as the input of the grep command.</p><h4 id="Common-Options"><a href="#Common-Options" class="headerlink" title="Common Options"></a><strong>Common Options</strong></h4><ul><li><code>-i</code>: Ignore case (case-insensitive search).</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">grep -i <span class="hljs-string">&quot;hello&quot;</span> file.txt<br></code></pre></td></tr></table></figure><ul><li><code>-v</code>: Invert match (show lines that do <strong>not</strong> match the pattern).</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">grep -v <span class="hljs-string">&quot;error&quot;</span> file.txt<br></code></pre></td></tr></table></figure><ul><li><code>-r</code> or <code>-R</code>: Recursively search directories.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">grep -r <span class="hljs-string">&quot;pattern&quot;</span> /path/to/dir<br></code></pre></td></tr></table></figure><ul><li><code>-n</code>: Show line numbers of matching lines.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">grep -n <span class="hljs-string">&quot;pattern&quot;</span> file.txt<br></code></pre></td></tr></table></figure><ul><li><code>-c</code>: Count the number of matching lines.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">grep -c <span class="hljs-string">&quot;pattern&quot;</span> file.txt<br></code></pre></td></tr></table></figure><ul><li><code>-l</code>: List filenames containing the pattern.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">grep -l <span class="hljs-string">&quot;pattern&quot;</span> *.txt<br></code></pre></td></tr></table></figure><ul><li><code>-w</code>: Match whole words only.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">grep -w <span class="hljs-string">&quot;word&quot;</span> file.txt<br></code></pre></td></tr></table></figure><ul><li><code>-A</code>, <code>-B</code>, <code>-C</code>: Show lines after, before, or around the match.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">grep -A 2 <span class="hljs-string">&quot;pattern&quot;</span> file.txt  <span class="hljs-comment"># Show 2 lines after the match</span><br>grep -B 2 <span class="hljs-string">&quot;pattern&quot;</span> file.txt  <span class="hljs-comment"># Show 2 lines before the match</span><br>grep -C 2 <span class="hljs-string">&quot;pattern&quot;</span> file.txt  <span class="hljs-comment"># Show 2 lines before and after the match</span><br></code></pre></td></tr></table></figure><p>For example, I have a directory (current) and exists files as below:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs bash">.<br>├── grep_test.txt<br>└── sub_dirc<br>    ├── modified_1.txt<br>    └── modified_2.txt<br><br>2 directories, 3 files<br><br>❯ <span class="hljs-built_in">cat</span> grep_test.txt<br>Hello my name is Jack.<br>I am 18 year<span class="hljs-string">&#x27;s old.</span><br><span class="hljs-string">Do you like me?</span><br><span class="hljs-string">I want to make friends with you.</span><br><span class="hljs-string">Remember my name, my name is JACK!</span><br><span class="hljs-string">HAahah</span><br><span class="hljs-string">do you know my favourite motto?</span><br><span class="hljs-string">Knowledge isn&#x27;</span>t free, you have to pay attention.<br><br>❯ <span class="hljs-built_in">cat</span> ./sub_dirc/modified_1.txt<br>Hello my name is Henry.<br>I am 17 year<span class="hljs-string">&#x27;s old.</span><br><span class="hljs-string">Do you like me?</span><br><span class="hljs-string">I want to make friends with you.</span><br><span class="hljs-string">Remember my name, my name is Henry!</span><br><span class="hljs-string">HAahah</span><br><span class="hljs-string">do you know my favourite motto?</span><br><span class="hljs-string">Nothing is possible</span><br><span class="hljs-string"></span><br><span class="hljs-string">❯ cat ./sub_dirc/modified_2.txt</span><br><span class="hljs-string">Hello my name is Kate.</span><br><span class="hljs-string">I am 20 year&#x27;</span>s old.<br>Do you like us?<br>I want to make friends with you.<br>Remember my name, my name is KatE!<br>HAahah<br><span class="hljs-keyword">do</span> you know my favourite motto?<br>Open <span class="hljs-built_in">source</span> is the best thing <span class="hljs-keyword">in</span> the world!<br></code></pre></td></tr></table></figure><p>Now I can use several commands as below to efficiently search specific information that I want!</p><p>I can use <code>-r</code> to search for the whole current directory.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">grep -r <span class="hljs-string">&quot;Hello&quot;</span> ./<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">./sub_dirc/modified_1.txt:Hello my name is Henry.<br>./sub_dirc/modified_2.txt:Hello my name is Kate.<br>./grep_test.txt:Hello my name is Jack.<br></code></pre></td></tr></table></figure></br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">grep -nri <span class="hljs-string">&quot;Jack&quot;</span> ./<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">./grep_test.txt:1:Hello my name is Jack.<br>./grep_test.txt:5:Remember my name, my name is JACK!<br></code></pre></td></tr></table></figure></br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">grep -nrc <span class="hljs-string">&quot;Hello&quot;</span> ./<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">./sub_dirc/modified_1.txt:1<br>./sub_dirc/modified_2.txt:1<br>./grep_test.txt:1<br></code></pre></td></tr></table></figure></br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">grep -nrv <span class="hljs-string">&quot;Hello&quot;</span> ./<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs bash">./sub_dirc/modified_1.txt:2:I am 17 year<span class="hljs-string">&#x27;s old.</span><br><span class="hljs-string">./sub_dirc/modified_1.txt:3:Do you like me?</span><br><span class="hljs-string">./sub_dirc/modified_1.txt:4:I want to make friends with you.</span><br><span class="hljs-string">./sub_dirc/modified_1.txt:5:Remember my name, my name is Henry!</span><br><span class="hljs-string">./sub_dirc/modified_1.txt:6:HAahah</span><br><span class="hljs-string">./sub_dirc/modified_1.txt:7:do you know my favourite motto?</span><br><span class="hljs-string">./sub_dirc/modified_1.txt:8:Nothing is possible</span><br><span class="hljs-string">./sub_dirc/modified_1.txt:9:</span><br><span class="hljs-string">./sub_dirc/modified_2.txt:2:I am 20 year&#x27;</span>s old.<br>./sub_dirc/modified_2.txt:3:Do you like us?<br>./sub_dirc/modified_2.txt:4:I want to make friends with you.<br>./sub_dirc/modified_2.txt:5:Remember my name, my name is KatE!<br>./sub_dirc/modified_2.txt:6:HAahah<br>./sub_dirc/modified_2.txt:7:<span class="hljs-keyword">do</span> you know my favourite motto?<br>./sub_dirc/modified_2.txt:8:Open <span class="hljs-built_in">source</span> is the best thing <span class="hljs-keyword">in</span> the world!<br>./sub_dirc/modified_2.txt:9:<br>./grep_test.txt:2:I am 18 year<span class="hljs-string">&#x27;s old.</span><br><span class="hljs-string">./grep_test.txt:3:Do you like me?</span><br><span class="hljs-string">./grep_test.txt:4:I want to make friends with you.</span><br><span class="hljs-string">./grep_test.txt:5:Remember my name, my name is JACK!</span><br><span class="hljs-string">./grep_test.txt:6:HAahah</span><br><span class="hljs-string">./grep_test.txt:7:do you know my favourite motto?</span><br><span class="hljs-string">./grep_test.txt:8:Knowledge isn&#x27;</span>t free, you have to pay attention.<br>./grep_test.txt:9:<br></code></pre></td></tr></table></figure></br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">grep -ri -A 1 <span class="hljs-string">&quot;motto&quot;</span> ./<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">./sub_dirc/modified_1.txt:<span class="hljs-keyword">do</span> you know my favourite motto?<br>./sub_dirc/modified_1.txt-Nothing is possible<br>--<br>./sub_dirc/modified_2.txt:<span class="hljs-keyword">do</span> you know my favourite motto?<br>./sub_dirc/modified_2.txt-Open <span class="hljs-built_in">source</span> is the best thing <span class="hljs-keyword">in</span> the world!<br>--<br>./grep_test.txt:<span class="hljs-keyword">do</span> you know my favourite motto?<br>./grep_test.txt-Knowledge isn<span class="hljs-string">&#x27;t free, you have to pay attention.</span><br></code></pre></td></tr></table></figure><p>You can make the command line more complex to get more specific data!</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">grep -ri -A 1 <span class="hljs-string">&quot;motto&quot;</span> ./ | grep -v <span class="hljs-string">&quot;motto&quot;</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">./sub_dirc/modified_1.txt-Nothing is possible<br>--<br>./sub_dirc/modified_2.txt-Open <span class="hljs-built_in">source</span> is the best thing <span class="hljs-keyword">in</span> the world!<br>--<br>./grep_test.txt-Knowledge isn<span class="hljs-string">&#x27;t free, you have to pay attention.</span><br></code></pre></td></tr></table></figure><p>More specific:</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">grep</span> -rih -A <span class="hljs-number">1</span> <span class="hljs-string">&quot;motto&quot;</span> ./ | <span class="hljs-keyword">grep</span> -v <span class="hljs-string">&quot;motto&quot;</span> | <span class="hljs-keyword">grep</span> -v <span class="hljs-string">&quot;^--$&quot;</span><br></code></pre></td></tr></table></figure><p>Using the <code>-h</code> options to forbid grep showing filenames while searching the directory recursively. Adding more pipes and using <strong>Regex</strong> can enable developers to make more specific pattern matching problems more freely.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Bash">Nothing is possible<br>Open <span class="hljs-built_in">source</span> is the best thing <span class="hljs-keyword">in</span> the world!<br>Knowledge isn<span class="hljs-string">&#x27;t free, you have to pay attention.</span><br></code></pre></td></tr></table></figure><p>By using this command, you can <strong>get all the mottos for all person’s files</strong>, which will significantly enhance one’s working efficiency. For more options, you can typing <code>man grep</code> for advanced usage.</p><h2 id="Lec3-Vim-editors"><a href="#Lec3-Vim-editors" class="headerlink" title="Lec3: Vim editors"></a>Lec3: Vim editors</h2><p>You can just go to <a href="https://xiyuanyang-code.github.io/posts/Vim-tutorial/">Vim tutorial</a> for help.</p><h2 id="Lec4-Data-Wrangling"><a href="#Lec4-Data-Wrangling" class="headerlink" title="Lec4: Data Wrangling"></a>Lec4: Data Wrangling</h2><h2 id="Lec5-Command-Line-Environment"><a href="#Lec5-Command-Line-Environment" class="headerlink" title="Lec5: Command Line Environment"></a>Lec5: Command Line Environment</h2><h2 id="Lec6-Git-Version-Control"><a href="#Lec6-Git-Version-Control" class="headerlink" title="Lec6: Git (Version Control)"></a>Lec6: Git (Version Control)</h2><h2 id="Lec7-Debugging-and-Profiling"><a href="#Lec7-Debugging-and-Profiling" class="headerlink" title="Lec7: Debugging and Profiling"></a>Lec7: Debugging and Profiling</h2><p><strong>Debugging</strong> is of great importance! Mastering debugging in the coding process will significantly enhance your coding speed and time you will cost when your codes get an error.</p><blockquote><p>“The most effective debugging tool is still careful thought, coupled with judiciously placed print statements” — Brian Kernighan, <em>Unix for Beginners</em>.</p></blockquote><p>This is the simplest way, somehow, an “effective” way to find your bugs in your code by using <strong>print</strong> functions to print all the significant variables and statements where you encountered your bug.</p><p><strong>It is simple, but sometimes naive</strong>. We need to learn some advance techniques for better performance and efficiency. <strong>So that is why we need to learn debugging!</strong></p><h3 id="Logging"><a href="#Logging" class="headerlink" title="Logging"></a>Logging</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> logging<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> random<br><span class="hljs-keyword">from</span> concurrent.futures <span class="hljs-keyword">import</span> ThreadPoolExecutor<br><br><span class="hljs-comment"># Configure logging</span><br>logging.basicConfig(<br>    level=logging.DEBUG,<br>    <span class="hljs-built_in">format</span>=<span class="hljs-string">&#x27;%(asctime)s - %(levelname)s - %(message)s&#x27;</span>,<br>    handlers=[<br>        logging.FileHandler(<span class="hljs-string">&quot;task_scheduler.log&quot;</span>),  <span class="hljs-comment"># Log to a file</span><br>        logging.StreamHandler()  <span class="hljs-comment"># Log to console</span><br>    ]<br>)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Task</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;Class representing a task.&quot;&quot;&quot;</span><br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, duration</span>):<br>        <span class="hljs-variable language_">self</span>.name = name<br>        <span class="hljs-variable language_">self</span>.duration = duration  <span class="hljs-comment"># Duration in seconds</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">execute</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;Simulate task execution.&quot;&quot;&quot;</span><br>        logging.info(<span class="hljs-string">f&quot;Starting task: <span class="hljs-subst">&#123;self.name&#125;</span>&quot;</span>)<br>        time.sleep(<span class="hljs-variable language_">self</span>.duration)<br>        logging.info(<span class="hljs-string">f&quot;Completed task: <span class="hljs-subst">&#123;self.name&#125;</span>&quot;</span>)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TaskScheduler</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;Class for scheduling and executing tasks.&quot;&quot;&quot;</span><br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.tasks = []<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">add_task</span>(<span class="hljs-params">self, task</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;Add a task to the scheduler.&quot;&quot;&quot;</span><br>        <span class="hljs-variable language_">self</span>.tasks.append(task)<br>        logging.debug(<span class="hljs-string">f&quot;Task added: <span class="hljs-subst">&#123;task.name&#125;</span> (Duration: <span class="hljs-subst">&#123;task.duration&#125;</span>s)&quot;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run_tasks</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;Run all scheduled tasks concurrently.&quot;&quot;&quot;</span><br>        logging.info(<span class="hljs-string">&quot;Starting task execution...&quot;</span>)<br>        <span class="hljs-keyword">with</span> ThreadPoolExecutor(max_workers=<span class="hljs-number">5</span>) <span class="hljs-keyword">as</span> executor:<br>            futures = &#123;executor.submit(task.execute()): task <span class="hljs-keyword">for</span> task <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>.tasks&#125;<br>            <span class="hljs-keyword">for</span> future <span class="hljs-keyword">in</span> futures:<br>                <span class="hljs-keyword">try</span>:<br>                    future.result()  <span class="hljs-comment"># Wait for the task to complete</span><br>                <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>                    logging.error(<span class="hljs-string">f&quot;Task failed: <span class="hljs-subst">&#123;futures[future].name&#125;</span> with error: <span class="hljs-subst">&#123;e&#125;</span>&quot;</span>)<br>        logging.info(<span class="hljs-string">&quot;All tasks completed.&quot;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    scheduler = TaskScheduler()<br><br>    <span class="hljs-comment"># Create and add tasks with random durations</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>        duration = random.randint(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>)  <span class="hljs-comment"># Random duration between 1 and 5 seconds</span><br>        task = Task(<span class="hljs-string">f&quot;Task-<span class="hljs-subst">&#123;i+<span class="hljs-number">1</span>&#125;</span>&quot;</span>, duration)<br>        scheduler.add_task(task)<br><br>    <span class="hljs-comment"># Run the scheduled tasks</span><br>    scheduler.run_tasks()<br><br></code></pre></td></tr></table></figure><p><strong>Logging</strong> is a great habit to make your debugging message neater! You can add several lines before the main functions to set the syntax of logging.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> logging<br><span class="hljs-comment"># Configure logging</span><br>logging.basicConfig(<br>    level=logging.DEBUG,<br>    <span class="hljs-built_in">format</span>=<span class="hljs-string">&#x27;%(asctime)s - %(levelname)s - %(message)s&#x27;</span>,<br>    handlers=[<br>        logging.FileHandler(<span class="hljs-string">&quot;task_scheduler.log&quot;</span>),  <span class="hljs-comment"># Log to a file</span><br>        logging.StreamHandler()  <span class="hljs-comment"># Log to console</span><br>    ]<br>)<br></code></pre></td></tr></table></figure><p>Then, you can output several log messages during your coding precess. Like this:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">logging.info(<span class="hljs-string">f&quot;Starting task: <span class="hljs-subst">&#123;self.name&#125;</span>&quot;</span>)<br>logging.debug(<span class="hljs-string">f&quot;Task added: <span class="hljs-subst">&#123;task.name&#125;</span> (Duration: <span class="hljs-subst">&#123;task.duration&#125;</span>s)&quot;</span>)<br>logging.error(<span class="hljs-string">f&quot;Task failed: <span class="hljs-subst">&#123;futures[future].name&#125;</span> with error: <span class="hljs-subst">&#123;e&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><div class="note note-primary">            <p>There are three types of <strong>logging messages</strong>.(Of course there are more!)</p><ul><li><strong>Debugging</strong>: This level is used for detailed information, typically of interest only when diagnosing problems. It provides insights into the internal state of the application and is useful for developers during the debugging process.<ul><li>e.g. Logging variable values, function entry and exit points, or detailed flow of execution.</li></ul></li><li><strong>INFO</strong>: This level is used to confirm that things are working as expected. It provides general information about the application’s progress and state without being overly verbose.<ul><li>e.g. Logging the start and completion of tasks, user actions, or significant milestones in the application.</li></ul></li><li><strong>ERROR</strong>: This level indicates a more serious problem that prevented the program from performing a function. It is used to log exceptions or errors that occur during execution.<ul><li>e.g. Logging when a task fails due to an exception or when a critical operation cannot be completed.</li></ul></li><li><strong>There does exist several other debugging messages</strong>! For instance, <strong>warning</strong>, <strong>critical</strong>, etc.</li></ul>          </div><blockquote><p>It’s ok if you don’t understand about threads in the codes shown above. You can just focus on the logging messages.</p></blockquote><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">2025</span>-<span class="hljs-number">02</span>-<span class="hljs-number">23</span> <span class="hljs-number">20</span>:<span class="hljs-number">45</span>:<span class="hljs-number">45</span>,<span class="hljs-number">873</span> - DEBUG - Task added: Task-<span class="hljs-number">1</span> (Duration: <span class="hljs-number">2</span>s)<br><span class="hljs-attribute">2025</span>-<span class="hljs-number">02</span>-<span class="hljs-number">23</span> <span class="hljs-number">20</span>:<span class="hljs-number">45</span>:<span class="hljs-number">45</span>,<span class="hljs-number">873</span> - DEBUG - Task added: Task-<span class="hljs-number">2</span> (Duration: <span class="hljs-number">2</span>s)<br><span class="hljs-attribute">2025</span>-<span class="hljs-number">02</span>-<span class="hljs-number">23</span> <span class="hljs-number">20</span>:<span class="hljs-number">45</span>:<span class="hljs-number">45</span>,<span class="hljs-number">873</span> - DEBUG - Task added: Task-<span class="hljs-number">3</span> (Duration: <span class="hljs-number">1</span>s)<br><span class="hljs-attribute">2025</span>-<span class="hljs-number">02</span>-<span class="hljs-number">23</span> <span class="hljs-number">20</span>:<span class="hljs-number">45</span>:<span class="hljs-number">45</span>,<span class="hljs-number">874</span> - DEBUG - Task added: Task-<span class="hljs-number">4</span> (Duration: <span class="hljs-number">2</span>s)<br><span class="hljs-attribute">2025</span>-<span class="hljs-number">02</span>-<span class="hljs-number">23</span> <span class="hljs-number">20</span>:<span class="hljs-number">45</span>:<span class="hljs-number">45</span>,<span class="hljs-number">874</span> - DEBUG - Task added: Task-<span class="hljs-number">5</span> (Duration: <span class="hljs-number">4</span>s)<br><span class="hljs-attribute">2025</span>-<span class="hljs-number">02</span>-<span class="hljs-number">23</span> <span class="hljs-number">20</span>:<span class="hljs-number">45</span>:<span class="hljs-number">45</span>,<span class="hljs-number">874</span> - DEBUG - Task added: Task-<span class="hljs-number">6</span> (Duration: <span class="hljs-number">1</span>s)<br><span class="hljs-attribute">2025</span>-<span class="hljs-number">02</span>-<span class="hljs-number">23</span> <span class="hljs-number">20</span>:<span class="hljs-number">45</span>:<span class="hljs-number">45</span>,<span class="hljs-number">874</span> - DEBUG - Task added: Task-<span class="hljs-number">7</span> (Duration: <span class="hljs-number">4</span>s)<br><span class="hljs-attribute">2025</span>-<span class="hljs-number">02</span>-<span class="hljs-number">23</span> <span class="hljs-number">20</span>:<span class="hljs-number">45</span>:<span class="hljs-number">45</span>,<span class="hljs-number">874</span> - DEBUG - Task added: Task-<span class="hljs-number">8</span> (Duration: <span class="hljs-number">2</span>s)<br><span class="hljs-attribute">2025</span>-<span class="hljs-number">02</span>-<span class="hljs-number">23</span> <span class="hljs-number">20</span>:<span class="hljs-number">45</span>:<span class="hljs-number">45</span>,<span class="hljs-number">874</span> - DEBUG - Task added: Task-<span class="hljs-number">9</span> (Duration: <span class="hljs-number">3</span>s)<br><span class="hljs-attribute">2025</span>-<span class="hljs-number">02</span>-<span class="hljs-number">23</span> <span class="hljs-number">20</span>:<span class="hljs-number">45</span>:<span class="hljs-number">45</span>,<span class="hljs-number">874</span> - DEBUG - Task added: Task-<span class="hljs-number">10</span> (Duration: <span class="hljs-number">5</span>s)<br><span class="hljs-attribute">2025</span>-<span class="hljs-number">02</span>-<span class="hljs-number">23</span> <span class="hljs-number">20</span>:<span class="hljs-number">45</span>:<span class="hljs-number">45</span>,<span class="hljs-number">875</span> - INFO - Starting task execution...<br><span class="hljs-attribute">2025</span>-<span class="hljs-number">02</span>-<span class="hljs-number">23</span> <span class="hljs-number">20</span>:<span class="hljs-number">45</span>:<span class="hljs-number">45</span>,<span class="hljs-number">875</span> - INFO - Starting task: Task-<span class="hljs-number">1</span><br><span class="hljs-attribute">2025</span>-<span class="hljs-number">02</span>-<span class="hljs-number">23</span> <span class="hljs-number">20</span>:<span class="hljs-number">45</span>:<span class="hljs-number">47</span>,<span class="hljs-number">875</span> - INFO - Completed task: Task-<span class="hljs-number">1</span><br><span class="hljs-attribute">2025</span>-<span class="hljs-number">02</span>-<span class="hljs-number">23</span> <span class="hljs-number">20</span>:<span class="hljs-number">45</span>:<span class="hljs-number">47</span>,<span class="hljs-number">876</span> - INFO - Starting task: Task-<span class="hljs-number">2</span><br><span class="hljs-attribute">2025</span>-<span class="hljs-number">02</span>-<span class="hljs-number">23</span> <span class="hljs-number">20</span>:<span class="hljs-number">45</span>:<span class="hljs-number">49</span>,<span class="hljs-number">876</span> - INFO - Completed task: Task-<span class="hljs-number">2</span><br><span class="hljs-attribute">2025</span>-<span class="hljs-number">02</span>-<span class="hljs-number">23</span> <span class="hljs-number">20</span>:<span class="hljs-number">45</span>:<span class="hljs-number">49</span>,<span class="hljs-number">877</span> - INFO - Starting task: Task-<span class="hljs-number">3</span><br><span class="hljs-attribute">2025</span>-<span class="hljs-number">02</span>-<span class="hljs-number">23</span> <span class="hljs-number">20</span>:<span class="hljs-number">45</span>:<span class="hljs-number">50</span>,<span class="hljs-number">877</span> - INFO - Completed task: Task-<span class="hljs-number">3</span><br><span class="hljs-attribute">2025</span>-<span class="hljs-number">02</span>-<span class="hljs-number">23</span> <span class="hljs-number">20</span>:<span class="hljs-number">45</span>:<span class="hljs-number">50</span>,<span class="hljs-number">878</span> - INFO - Starting task: Task-<span class="hljs-number">4</span><br><span class="hljs-attribute">2025</span>-<span class="hljs-number">02</span>-<span class="hljs-number">23</span> <span class="hljs-number">20</span>:<span class="hljs-number">45</span>:<span class="hljs-number">52</span>,<span class="hljs-number">878</span> - INFO - Completed task: Task-<span class="hljs-number">4</span><br><span class="hljs-attribute">2025</span>-<span class="hljs-number">02</span>-<span class="hljs-number">23</span> <span class="hljs-number">20</span>:<span class="hljs-number">45</span>:<span class="hljs-number">52</span>,<span class="hljs-number">879</span> - INFO - Starting task: Task-<span class="hljs-number">5</span><br><span class="hljs-attribute">2025</span>-<span class="hljs-number">02</span>-<span class="hljs-number">23</span> <span class="hljs-number">20</span>:<span class="hljs-number">45</span>:<span class="hljs-number">56</span>,<span class="hljs-number">879</span> - INFO - Completed task: Task-<span class="hljs-number">5</span><br><span class="hljs-attribute">2025</span>-<span class="hljs-number">02</span>-<span class="hljs-number">23</span> <span class="hljs-number">20</span>:<span class="hljs-number">45</span>:<span class="hljs-number">56</span>,<span class="hljs-number">879</span> - INFO - Starting task: Task-<span class="hljs-number">6</span><br><span class="hljs-attribute">2025</span>-<span class="hljs-number">02</span>-<span class="hljs-number">23</span> <span class="hljs-number">20</span>:<span class="hljs-number">45</span>:<span class="hljs-number">57</span>,<span class="hljs-number">880</span> - INFO - Completed task: Task-<span class="hljs-number">6</span><br><span class="hljs-attribute">2025</span>-<span class="hljs-number">02</span>-<span class="hljs-number">23</span> <span class="hljs-number">20</span>:<span class="hljs-number">45</span>:<span class="hljs-number">57</span>,<span class="hljs-number">880</span> - INFO - Starting task: Task-<span class="hljs-number">7</span><br><span class="hljs-attribute">2025</span>-<span class="hljs-number">02</span>-<span class="hljs-number">23</span> <span class="hljs-number">20</span>:<span class="hljs-number">46</span>:<span class="hljs-number">02</span>,<span class="hljs-number">508</span> - INFO - Completed task: Task-<span class="hljs-number">7</span><br><span class="hljs-attribute">2025</span>-<span class="hljs-number">02</span>-<span class="hljs-number">23</span> <span class="hljs-number">20</span>:<span class="hljs-number">46</span>:<span class="hljs-number">02</span>,<span class="hljs-number">509</span> - INFO - Starting task: Task-<span class="hljs-number">8</span><br><span class="hljs-attribute">2025</span>-<span class="hljs-number">02</span>-<span class="hljs-number">23</span> <span class="hljs-number">20</span>:<span class="hljs-number">46</span>:<span class="hljs-number">04</span>,<span class="hljs-number">509</span> - INFO - Completed task: Task-<span class="hljs-number">8</span><br><span class="hljs-attribute">2025</span>-<span class="hljs-number">02</span>-<span class="hljs-number">23</span> <span class="hljs-number">20</span>:<span class="hljs-number">46</span>:<span class="hljs-number">04</span>,<span class="hljs-number">509</span> - INFO - Starting task: Task-<span class="hljs-number">9</span><br><span class="hljs-attribute">2025</span>-<span class="hljs-number">02</span>-<span class="hljs-number">23</span> <span class="hljs-number">20</span>:<span class="hljs-number">46</span>:<span class="hljs-number">07</span>,<span class="hljs-number">510</span> - INFO - Completed task: Task-<span class="hljs-number">9</span><br><span class="hljs-attribute">2025</span>-<span class="hljs-number">02</span>-<span class="hljs-number">23</span> <span class="hljs-number">20</span>:<span class="hljs-number">46</span>:<span class="hljs-number">07</span>,<span class="hljs-number">510</span> - INFO - Starting task: Task-<span class="hljs-number">10</span><br><span class="hljs-attribute">2025</span>-<span class="hljs-number">02</span>-<span class="hljs-number">23</span> <span class="hljs-number">20</span>:<span class="hljs-number">46</span>:<span class="hljs-number">12</span>,<span class="hljs-number">511</span> - INFO - Completed task: Task-<span class="hljs-number">10</span><br><span class="hljs-attribute">2025</span>-<span class="hljs-number">02</span>-<span class="hljs-number">23</span> <span class="hljs-number">20</span>:<span class="hljs-number">46</span>:<span class="hljs-number">12</span>,<span class="hljs-number">512</span> - ERROR - Task failed: Task-<span class="hljs-number">1</span> with error: &#x27;NoneType&#x27; object is not callable<br><span class="hljs-attribute">2025</span>-<span class="hljs-number">02</span>-<span class="hljs-number">23</span> <span class="hljs-number">20</span>:<span class="hljs-number">46</span>:<span class="hljs-number">12</span>,<span class="hljs-number">512</span> - ERROR - Task failed: Task-<span class="hljs-number">2</span> with error: &#x27;NoneType&#x27; object is not callable<br><span class="hljs-attribute">2025</span>-<span class="hljs-number">02</span>-<span class="hljs-number">23</span> <span class="hljs-number">20</span>:<span class="hljs-number">46</span>:<span class="hljs-number">12</span>,<span class="hljs-number">512</span> - ERROR - Task failed: Task-<span class="hljs-number">3</span> with error: &#x27;NoneType&#x27; object is not callable<br><span class="hljs-attribute">2025</span>-<span class="hljs-number">02</span>-<span class="hljs-number">23</span> <span class="hljs-number">20</span>:<span class="hljs-number">46</span>:<span class="hljs-number">12</span>,<span class="hljs-number">512</span> - ERROR - Task failed: Task-<span class="hljs-number">4</span> with error: &#x27;NoneType&#x27; object is not callable<br><span class="hljs-attribute">2025</span>-<span class="hljs-number">02</span>-<span class="hljs-number">23</span> <span class="hljs-number">20</span>:<span class="hljs-number">46</span>:<span class="hljs-number">12</span>,<span class="hljs-number">512</span> - ERROR - Task failed: Task-<span class="hljs-number">5</span> with error: &#x27;NoneType&#x27; object is not callable<br><span class="hljs-attribute">2025</span>-<span class="hljs-number">02</span>-<span class="hljs-number">23</span> <span class="hljs-number">20</span>:<span class="hljs-number">46</span>:<span class="hljs-number">12</span>,<span class="hljs-number">512</span> - ERROR - Task failed: Task-<span class="hljs-number">6</span> with error: &#x27;NoneType&#x27; object is not callable<br><span class="hljs-attribute">2025</span>-<span class="hljs-number">02</span>-<span class="hljs-number">23</span> <span class="hljs-number">20</span>:<span class="hljs-number">46</span>:<span class="hljs-number">12</span>,<span class="hljs-number">512</span> - ERROR - Task failed: Task-<span class="hljs-number">7</span> with error: &#x27;NoneType&#x27; object is not callable<br><span class="hljs-attribute">2025</span>-<span class="hljs-number">02</span>-<span class="hljs-number">23</span> <span class="hljs-number">20</span>:<span class="hljs-number">46</span>:<span class="hljs-number">12</span>,<span class="hljs-number">513</span> - ERROR - Task failed: Task-<span class="hljs-number">8</span> with error: &#x27;NoneType&#x27; object is not callable<br><span class="hljs-attribute">2025</span>-<span class="hljs-number">02</span>-<span class="hljs-number">23</span> <span class="hljs-number">20</span>:<span class="hljs-number">46</span>:<span class="hljs-number">12</span>,<span class="hljs-number">513</span> - ERROR - Task failed: Task-<span class="hljs-number">9</span> with error: &#x27;NoneType&#x27; object is not callable<br><span class="hljs-attribute">2025</span>-<span class="hljs-number">02</span>-<span class="hljs-number">23</span> <span class="hljs-number">20</span>:<span class="hljs-number">46</span>:<span class="hljs-number">12</span>,<span class="hljs-number">513</span> - ERROR - Task failed: Task-<span class="hljs-number">10</span> with error: &#x27;NoneType&#x27; object is not callable<br><span class="hljs-attribute">2025</span>-<span class="hljs-number">02</span>-<span class="hljs-number">23</span> <span class="hljs-number">20</span>:<span class="hljs-number">46</span>:<span class="hljs-number">12</span>,<span class="hljs-number">513</span> - INFO - <span class="hljs-literal">All</span> tasks completed.<br><br></code></pre></td></tr></table></figure><p>If you only want to output several <strong>error</strong> messages, you can just make more settings like this:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Configure logging</span><br>logging.basicConfig(<br>    level=logging.DEBUG,  <span class="hljs-comment"># Set the logging level for the root logger</span><br>    <span class="hljs-built_in">format</span>=<span class="hljs-string">&#x27;%(asctime)s - %(levelname)s - %(message)s&#x27;</span>,<br>    handlers=[<br>        logging.FileHandler(<span class="hljs-string">&quot;task_scheduler.log&quot;</span>),  <span class="hljs-comment"># Log to a file</span><br>    ]<br>)<br><br><span class="hljs-comment"># Create a StreamHandler for console output</span><br>console_handler = logging.StreamHandler()<br>console_handler.setLevel(logging.ERROR)  <span class="hljs-comment"># Set the level for the console handler</span><br>formatter = logging.Formatter(<span class="hljs-string">&#x27;%(asctime)s - %(levelname)s - %(message)s&#x27;</span>)  <span class="hljs-comment"># Set the format for the console handler</span><br>console_handler.setFormatter(formatter)  <span class="hljs-comment"># Assign the formatter to the console handler</span><br><br><span class="hljs-comment"># Add the console handler to the root logger</span><br>logging.getLogger().addHandler(console_handler)<br></code></pre></td></tr></table></figure><p>Of course, you can modify the logging message with different colors. You can modify the output colors of the terminal by using <code>echo</code> command with different parameters.</p><p>For example, I have implemented this function in my <code>~/.zshrc</code> files.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># This functions sets different colours for terminal.</span><br><span class="hljs-function"><span class="hljs-title">print_colored</span></span>() &#123;<br>    <span class="hljs-built_in">local</span> color=<span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span><br>    <span class="hljs-built_in">local</span> text=<span class="hljs-string">&quot;<span class="hljs-variable">$2</span>&quot;</span><br>    <br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;<span class="hljs-variable">$color</span>&quot;</span> <span class="hljs-keyword">in</span><br>        red)    <span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;\033[31m<span class="hljs-variable">$text</span>\033[0m&quot;</span> ;;  <span class="hljs-comment"># 红色</span><br>        green)  <span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;\033[32m<span class="hljs-variable">$text</span>\033[0m&quot;</span> ;;  <span class="hljs-comment"># 绿色</span><br>        yellow) <span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;\033[33m<span class="hljs-variable">$text</span>\033[0m&quot;</span> ;;  <span class="hljs-comment"># 黄色</span><br>        blue)   <span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;\033[34m<span class="hljs-variable">$text</span>\033[0m&quot;</span> ;;  <span class="hljs-comment"># 蓝色</span><br>        purple) <span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;\033[35m<span class="hljs-variable">$text</span>\033[0m&quot;</span> ;;  <span class="hljs-comment"># 紫色</span><br>        cyan)   <span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;\033[36m<span class="hljs-variable">$text</span>\033[0m&quot;</span> ;;  <span class="hljs-comment"># 青色</span><br>        white)  <span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;\033[37m<span class="hljs-variable">$text</span>\033[0m&quot;</span> ;;  <span class="hljs-comment"># 白色</span><br>        *)      <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$text</span>&quot;</span> ;;                   <span class="hljs-comment"># 默认</span><br>    <span class="hljs-keyword">esac</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>You can copy this function into your dotfiles!</p><p><img src="https://s1.imagehub.cc/images/2025/02/28/87a238e1a1a0d42310acd011cc82ed7e.png" alt="Customizing colours in terminal"></p><h3 id="Debugger"><a href="#Debugger" class="headerlink" title="Debugger"></a>Debugger</h3><p>Just simply output several logging messages isn’t enough! For example, you can not <strong>detect memory leak</strong> with printing all variables and messages. Thus, we need more <strong>specific tools to debugging</strong>！</p><p>Many programming languages come with some form of debugger. In Python this is the Python Debugger <a href="https://docs.python.org/3/library/pdb.html"><code>pdb</code></a>.</p><p>Here is a brief description of some of the commands <code>pdb</code> supports:</p><ul><li><strong>l</strong>(ist) - Displays 11 lines around the current line or continue the previous listing.</li><li><strong>s</strong>(tep) - Execute the current line, stop at the first possible occasion.</li><li><strong>n</strong>(ext) - Continue execution until the next line in the current function is reached or it returns.</li><li><strong>b</strong>(reak) - Set a breakpoint (depending on the argument provided).</li><li><strong>p</strong>(rint) - Evaluate the expression in the current context and print its value. There’s also <strong>pp</strong> to display using <a href="https://docs.python.org/3/library/pprint.html"><code>pprint</code></a> instead.</li><li><strong>r</strong>(eturn) - Continue execution until the current function returns.</li><li><strong>q</strong>(uit) - Quit the debugger.</li></ul><h2 id="Lec8-Metaprogramming"><a href="#Lec8-Metaprogramming" class="headerlink" title="Lec8: Metaprogramming"></a>Lec8: Metaprogramming</h2><h2 id="Lec9-Security-and-Cryptography"><a href="#Lec9-Security-and-Cryptography" class="headerlink" title="Lec9: Security and Cryptography"></a>Lec9: Security and Cryptography</h2><h2 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h2><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2>]]></content>
    
    
    <categories>
      
      <category>Efficient Tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tutorial</tag>
      
      <tag>Bash</tag>
      
      <tag>Missing Semester</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>My-WorkFlow</title>
    <link href="/posts/My-WorkFlow/"/>
    <url>/posts/My-WorkFlow/</url>
    
    <content type="html"><![CDATA[<style>  html, body, .markdown-body {    font-family: Georgia, sans, serif;  }</style><p><img src="https://s1.imagehub.cc/images/2025/02/07/329668c81128e08f84c1d1ea140bc31b.jpg" alt="Welcome to Xiyuan Yang&#39;s Blog!"></p><h1 id="My-WorkFlow"><a href="#My-WorkFlow" class="headerlink" title="My WorkFlow"></a>My WorkFlow</h1><h2 id="About-this-Blog"><a href="#About-this-Blog" class="headerlink" title="About this Blog"></a>About this Blog</h2><p>As a student of Computer Science and Artificial Intelligence, <strong>efficiency</strong> is of great importance! In this Blog below, I will recommend several efficient tools I have experienced and used during my exploration. This Blog will be updated permanently, not only for a long-time sharing project, but also for a systematic review of my personal workflow.  </p><p>My working environment:</p><ul><li>Microsoft Windows 11, x64-based PC<ul><li>Intel(R) Core(TM) Ultra 5 125H (14 cores)</li><li>Intel(R) Arc(TM) Graphics</li></ul></li><li>For WSL:<ul><li>WSL2: Ubuntu 22.04.1 LTS,Jammy</li></ul></li></ul><blockquote><p>I plan to buy a <strong>MacBook</strong> when I grow older, but who knows?</p></blockquote><h2 id="Core-Principles"><a href="#Core-Principles" class="headerlink" title="Core Principles"></a>Core Principles</h2><p><strong>How to improve efficiency?</strong> Here are several core principles I have concluded during my learning exploration:</p><ul><li><strong>Improving efficiency is the ultimate goal</strong>.</li><li><strong>Avoid Repetitive Labors</strong>.</li><li><strong>There is no best, only the most suitable</strong>.</li></ul><p>We will dive into these principles deeply later.</p><blockquote><p><strong>However</strong>, it’s worth mentioning the difference between <strong>learning</strong> and <strong>working</strong>. Learning is a process where input and absorption take up the main part, while working is mainly for output and producing fruitful contents.</p><p>For both working and learning, <strong>efficiency</strong> is of great importance, but the core principles may differ from each other based on its different goals and methods. For example, repetitive work may be helpful in learning methods in some circumstances.</p><p>This is another topic! We can discuss it further in the future. We may just <strong>focusing on several core principles above</strong> in today’s Blog.</p></blockquote><h2 id="Coding"><a href="#Coding" class="headerlink" title="Coding"></a>Coding</h2><p><strong>Integrated Development Environment (IDE)</strong> is of great importance for every programmer.</p><h3 id="Visual-Studio-Code"><a href="#Visual-Studio-Code" class="headerlink" title="Visual Studio Code"></a>Visual Studio Code</h3><img src="https://media2.dev.to/dynamic/image/width=1000,height=420,fit=cover,gravity=auto,format=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2F0sbafazseadoy4jupixj.png" alt="Vscode" style="zoom: 50%;" /><p><a href="https://code.visualstudio.com/">https://code.visualstudio.com/</a></p><p>Visual Studio Code (VS Code) is a free, open-source code editor supporting multiple programming languages. It offers powerful features like <strong>IntelliSense, debugging, Git integration, and extensions</strong>. Cross-platform for Windows, macOS, and Linux, it boasts a clean interface and high performance, making it a top choice for developers.</p><h3 id="Cursor"><a href="#Cursor" class="headerlink" title="Cursor"></a>Cursor</h3><p><a href="https://www.cursor.com/">https://www.cursor.com/</a></p><p>Cursor is an AI-powered code editor designed for modern developers. It integrates <strong>AI assistance for code completion, refactoring, and debugging, enhancing productivity.</strong> Built on VS Code’s foundation, it supports multiple languages and frameworks. Its sleek interface, real-time collaboration, and AI-driven insights make it a cutting-edge tool for efficient coding.</p><blockquote><p>For Learning, I often use Vscode only to practice my programming skills. For work, I will use <strong>Cursor and Vscode</strong> both. AI assistance is of great convenience, but it will interrupt my train of thought while coding.</p></blockquote><h2 id="Command-Line"><a href="#Command-Line" class="headerlink" title="Command Line"></a>Command Line</h2><p><strong>I strongly recommend everyone to use command line skillfully in our daily lives</strong>.</p><h3 id="Windows-Terminal"><a href="#Windows-Terminal" class="headerlink" title="Windows Terminal"></a>Windows Terminal</h3><p>I have build a similar terminal environment based on this <a href="https://xxyqwq.github.io/2024/01/27/build-windows-terminal/">Blog</a>.<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://xxyqwq.github.io/2024/01/27/build-windows-terminal/">[1]</span></a></sup></p><p><strong>Tools used</strong>: <strong>oh-my-posh</strong> + <strong>powerlevel10k</strong></p><p>To make <strong>powershell</strong> more likely to <strong>Bash-like language</strong>, I set some alias and customed functions as below, you can modify your config files by using commands below:</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">code <span class="hljs-variable">$PROFILE</span><br></code></pre></td></tr></table></figure><p>It will open default editor (for me, it’s cursor) and you can modify and custom settings freely!</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-comment"># my custom settings for powershell</span><br><span class="hljs-built_in">oh</span><span class="hljs-literal">-my-posh</span> init pwsh <span class="hljs-literal">--config</span> <span class="hljs-string">&quot;C:\Users\29349\powerlevel10k_lean.omp.json&quot;</span> | <span class="hljs-built_in">Invoke-Expression</span><br><span class="hljs-built_in">Import-Module</span> posh<span class="hljs-literal">-git</span><br><span class="hljs-built_in">Import-Module</span> PSReadLine<br><span class="hljs-built_in">Set-PSReadLineOption</span> <span class="hljs-literal">-PredictionSource</span> <span class="hljs-built_in">History</span><br><span class="hljs-built_in">Set-PSReadLineKeyHandler</span> <span class="hljs-literal">-Chord</span> <span class="hljs-string">&quot;Ctrl+RightArrow&quot;</span> <span class="hljs-literal">-Function</span> ForwardWord<br><br><br><br><span class="hljs-built_in">Remove-Item</span> <span class="hljs-literal">-Path</span> Alias:<span class="hljs-built_in">ls</span> <span class="hljs-literal">-Force</span><br><span class="hljs-built_in">Remove-Item</span> <span class="hljs-literal">-Path</span> Alias:<span class="hljs-built_in">cd</span> <span class="hljs-literal">-Force</span><br><span class="hljs-built_in">Remove-Item</span> <span class="hljs-literal">-Path</span> Alias:<span class="hljs-built_in">pwd</span> <span class="hljs-literal">-Force</span><br><span class="hljs-built_in">Remove-Item</span> <span class="hljs-literal">-Path</span> Alias:<span class="hljs-built_in">rm</span> <span class="hljs-literal">-Force</span><br><span class="hljs-built_in">Remove-Item</span> <span class="hljs-literal">-Path</span> Alias:<span class="hljs-built_in">cp</span> <span class="hljs-literal">-Force</span><br><span class="hljs-built_in">Remove-Item</span> <span class="hljs-literal">-Path</span> Alias:<span class="hljs-built_in">mv</span> <span class="hljs-literal">-Force</span><br><span class="hljs-built_in">Remove-Item</span> <span class="hljs-literal">-Path</span> Alias:<span class="hljs-built_in">cat</span> <span class="hljs-literal">-Force</span><br><span class="hljs-built_in">Remove-Item</span> <span class="hljs-literal">-Path</span> Alias:<span class="hljs-built_in">ps</span> <span class="hljs-literal">-Force</span><br><span class="hljs-built_in">Remove-Item</span> <span class="hljs-literal">-Path</span> Alias:<span class="hljs-built_in">kill</span> <span class="hljs-literal">-Force</span><br><span class="hljs-built_in">Remove-Item</span> <span class="hljs-literal">-Path</span> Alias:<span class="hljs-built_in">clear</span> <span class="hljs-literal">-Force</span><br><span class="hljs-built_in">Remove-Item</span> <span class="hljs-literal">-Path</span> Alias:<span class="hljs-built_in">man</span> <span class="hljs-literal">-Force</span><br><br><br><span class="hljs-comment"># 覆盖内置别名（强制覆盖）</span><br><span class="hljs-built_in">Set-Alias</span> <span class="hljs-literal">-Name</span> <span class="hljs-built_in">ls</span> <span class="hljs-literal">-Value</span> <span class="hljs-built_in">Get-ChildItem</span> <span class="hljs-literal">-Force</span><br><span class="hljs-built_in">Set-Alias</span> <span class="hljs-literal">-Name</span> <span class="hljs-built_in">cd</span> <span class="hljs-literal">-Value</span> <span class="hljs-built_in">Set-Location</span> <span class="hljs-literal">-Force</span><br><span class="hljs-built_in">Set-Alias</span> <span class="hljs-literal">-Name</span> <span class="hljs-built_in">pwd</span> <span class="hljs-literal">-Value</span> <span class="hljs-built_in">Get-Location</span> <span class="hljs-literal">-Force</span><br><span class="hljs-built_in">Set-Alias</span> <span class="hljs-literal">-Name</span> <span class="hljs-built_in">rm</span> <span class="hljs-literal">-Value</span> <span class="hljs-built_in">Remove-Item</span> <span class="hljs-literal">-Force</span><br><span class="hljs-built_in">Set-Alias</span> <span class="hljs-literal">-Name</span> <span class="hljs-built_in">cp</span> <span class="hljs-literal">-Value</span> <span class="hljs-built_in">Copy-Item</span> <span class="hljs-literal">-Force</span><br><span class="hljs-built_in">Set-Alias</span> <span class="hljs-literal">-Name</span> <span class="hljs-built_in">mv</span> <span class="hljs-literal">-Value</span> <span class="hljs-built_in">Move-Item</span> <span class="hljs-literal">-Force</span><br><span class="hljs-built_in">Set-Alias</span> <span class="hljs-literal">-Name</span> <span class="hljs-built_in">cat</span> <span class="hljs-literal">-Value</span> <span class="hljs-built_in">Get-Content</span> <span class="hljs-literal">-Force</span><br><span class="hljs-built_in">Set-Alias</span> <span class="hljs-literal">-Name</span> <span class="hljs-built_in">ps</span> <span class="hljs-literal">-Value</span> <span class="hljs-built_in">Get-Process</span> <span class="hljs-literal">-Force</span><br><span class="hljs-built_in">Set-Alias</span> <span class="hljs-literal">-Name</span> <span class="hljs-built_in">kill</span> <span class="hljs-literal">-Value</span> <span class="hljs-built_in">Stop-Process</span> <span class="hljs-literal">-Force</span><br><span class="hljs-built_in">Set-Alias</span> <span class="hljs-literal">-Name</span> <span class="hljs-built_in">clear</span> <span class="hljs-literal">-Value</span> <span class="hljs-built_in">Clear-Host</span> <span class="hljs-literal">-Force</span><br><span class="hljs-built_in">Set-Alias</span> <span class="hljs-literal">-Name</span> <span class="hljs-built_in">man</span> <span class="hljs-literal">-Value</span> <span class="hljs-built_in">Get-Help</span> <span class="hljs-literal">-Force</span><br><span class="hljs-built_in">Set-Alias</span> <span class="hljs-literal">-Name</span> which <span class="hljs-literal">-Value</span> <span class="hljs-built_in">Get-Command</span> <span class="hljs-literal">-Force</span><br><br><span class="hljs-comment"># 定义函数代替别名（用于需要参数的命令）</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mkdir</span></span> &#123;<br>    <span class="hljs-keyword">param</span>(<br>        [<span class="hljs-built_in">string</span>]<span class="hljs-variable">$Path</span><br>    )<br>    <span class="hljs-built_in">New-Item</span> <span class="hljs-literal">-ItemType</span> Directory <span class="hljs-literal">-Path</span> <span class="hljs-variable">$Path</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">find</span></span> &#123;<br>    <span class="hljs-keyword">param</span>(<br>        [<span class="hljs-built_in">string</span>]<span class="hljs-variable">$Path</span><br>    )<br>    <span class="hljs-built_in">Get-ChildItem</span> <span class="hljs-literal">-Recurse</span> <span class="hljs-literal">-Path</span> <span class="hljs-variable">$Path</span><br>&#125;<br><br><span class="hljs-comment"># 定义函数以支持参数传递</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ls</span></span> &#123;<br>    <span class="hljs-keyword">param</span>(<br>        [<span class="hljs-built_in">string</span>]<span class="hljs-variable">$Options</span><br>    )<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable">$Options</span> <span class="hljs-operator">-eq</span> <span class="hljs-string">&quot;-l&quot;</span>) &#123;<br>        <span class="hljs-built_in">Get-ChildItem</span> | <span class="hljs-built_in">Format-Table</span> <span class="hljs-literal">-AutoSize</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">Get-ChildItem</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">grep</span></span> &#123;<br>    <span class="hljs-keyword">param</span>(<br>        [<span class="hljs-built_in">string</span>]<span class="hljs-variable">$Pattern</span>,<br>        [<span class="hljs-built_in">string</span>]<span class="hljs-variable">$Path</span><br>    )<br>    <span class="hljs-built_in">Select-String</span> <span class="hljs-literal">-Pattern</span> <span class="hljs-variable">$Pattern</span> <span class="hljs-literal">-Path</span> <span class="hljs-variable">$Path</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">touch</span></span> &#123;<br>    <span class="hljs-keyword">param</span>(<br>        [<span class="hljs-built_in">string</span>]<span class="hljs-variable">$Path</span><br>    )<br>    <span class="hljs-keyword">if</span> (<span class="hljs-operator">-Not</span> (<span class="hljs-built_in">Test-Path</span> <span class="hljs-variable">$Path</span>)) &#123;<br>        <span class="hljs-built_in">New-Item</span> <span class="hljs-literal">-ItemType</span> File <span class="hljs-literal">-Path</span> <span class="hljs-variable">$Path</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        (<span class="hljs-built_in">Get-Item</span> <span class="hljs-variable">$Path</span>).LastWriteTime = <span class="hljs-built_in">Get-Date</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment"># 其他常用函数</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ll</span></span> &#123;<br>    <span class="hljs-built_in">Get-ChildItem</span> | <span class="hljs-built_in">Format-Table</span> <span class="hljs-literal">-AutoSize</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">la</span></span> &#123;<br>    <span class="hljs-built_in">Get-ChildItem</span> <span class="hljs-literal">-Force</span> | <span class="hljs-built_in">Format-Table</span> <span class="hljs-literal">-AutoSize</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> ..</span> &#123;<br>    <span class="hljs-built_in">Set-Location</span> ..<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> ...</span> &#123;<br>    <span class="hljs-built_in">Set-Location</span> ..\..<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> ~</span> &#123;<br>    <span class="hljs-built_in">Set-Location</span> ~<br>&#125;<br><br><span class="hljs-comment"># 重新加载配置文件</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reload</span></span> &#123;<br>    . <span class="hljs-variable">$PROFILE</span><br>&#125;<br><br><br></code></pre></td></tr></table></figure><h3 id="Linux-Terminal"><a href="#Linux-Terminal" class="headerlink" title="Linux Terminal"></a>Linux Terminal</h3><p><strong>My version</strong>: <strong>Ubuntu 22.04</strong></p><p>I use <strong>Oh-my-zsh</strong> and <strong>Powerlevel-10k</strong> for my custom settings<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://xxyqwq.github.io/2023/07/31/build-linux-terminal/">[2]</span></a></sup>. The famous course in MIT: <a href="https://missing.csail.mit.edu/">Missing semester of my CS education</a> includes a lecture<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://missing.csail.mit.edu/2020/command-line/">[3]</span></a></sup> teaching you to customize your dotfiles to make your shell more shell more powerful.</p><p><a href="https://ohmyz.sh/">https://ohmyz.sh/</a></p><p><a href="https://github.com/romkatv/powerlevel10k">https://github.com/romkatv/powerlevel10k</a></p><p>You can search github for <strong>dotfiles</strong> where you can peek others’ custom settings and migrate to your own settings. It’s also a great way to learn Bash commands and improve proficiency step by step while practicing.</p><blockquote><p>It’s common for green hands to make mistakes! Don’t be afraid, try to spend more time and conquer it! </p></blockquote><p>My dotfiles for zsh settings are as below.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim ~/.zshrc<br><span class="hljs-comment"># entering vim and make your custom settings</span><br><span class="hljs-built_in">source</span> ~/.zshrc  <span class="hljs-comment">#run the files or you can just reopen the terminal</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Files for zshrc</span><br><span class="hljs-comment"># Enable Powerlevel10k instant prompt. Should stay close to the top of ~/.zshrc.</span><br><span class="hljs-comment"># Initialization code that may require console input (password prompts, [y/n]</span><br><span class="hljs-comment"># confirmations, etc.) must go above this block; everything else may go below.</span><br><span class="hljs-keyword">if</span> [[ -r <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;XDG_CACHE_HOME:-<span class="hljs-variable">$HOME</span>/.cache&#125;</span>/p10k-instant-prompt-<span class="hljs-variable">$&#123;(%):-%n&#125;</span>.zsh&quot;</span> ]]; <span class="hljs-keyword">then</span><br>  <span class="hljs-built_in">source</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;XDG_CACHE_HOME:-<span class="hljs-variable">$HOME</span>/.cache&#125;</span>/p10k-instant-prompt-<span class="hljs-variable">$&#123;(%):-%n&#125;</span>.zsh&quot;</span><br><span class="hljs-keyword">fi</span><br><br><span class="hljs-comment"># If you come from bash you might have to change your $PATH.</span><br><span class="hljs-comment"># export PATH=$HOME/bin:$HOME/.local/bin:/usr/local/bin:$PATH</span><br><br><span class="hljs-comment"># Path to your oh-my-zsh installation.</span><br><span class="hljs-built_in">export</span> ZSH=<span class="hljs-string">&quot;<span class="hljs-variable">$HOME</span>/.oh-my-zsh&quot;</span><br><br><span class="hljs-comment"># Set name of the theme to load --- if set to &quot;random&quot;, it will</span><br><span class="hljs-comment"># load a random theme each time oh-my-zsh is loaded, in which case,</span><br><span class="hljs-comment"># to know which specific one was loaded, run: echo $RANDOM_THEME</span><br><span class="hljs-comment"># See https://github.com/ohmyzsh/ohmyzsh/wiki/Themes</span><br>ZSH_THEME=<span class="hljs-string">&quot;powerlevel10k/powerlevel10k&quot;</span><br><br><span class="hljs-comment"># Set list of themes to pick from when loading at random</span><br><span class="hljs-comment"># Setting this variable when ZSH_THEME=random will cause zsh to load</span><br><span class="hljs-comment"># a theme from this variable instead of looking in $ZSH/themes/</span><br><span class="hljs-comment"># If set to an empty array, this variable will have no effect.</span><br><span class="hljs-comment"># ZSH_THEME_RANDOM_CANDIDATES=( &quot;robbyrussell&quot; &quot;agnoster&quot; )</span><br><br><span class="hljs-comment"># Uncomment the following line to use case-sensitive completion.</span><br><span class="hljs-comment">#plugins=(zsh-syntax-highlighting)# CASE_SENSITIVE=&quot;true&quot;</span><br><br><span class="hljs-comment"># Uncomment the following line to use hyphen-insensitive completion.</span><br><span class="hljs-comment"># Case-sensitive completion must be off. _ and - will be interchangeable.</span><br><span class="hljs-comment"># HYPHEN_INSENSITIVE=&quot;true&quot;</span><br><br><span class="hljs-comment"># Uncomment one of the following lines to change the auto-update behavior</span><br><span class="hljs-comment"># zstyle &#x27;:omz:update&#x27; mode disabled  # disable automatic updates</span><br><span class="hljs-comment"># zstyle &#x27;:omz:update&#x27; mode auto      # update automatically without asking</span><br><span class="hljs-comment"># zstyle &#x27;:omz:update&#x27; mode reminder  # just remind me to update when it&#x27;s time</span><br><br><span class="hljs-comment"># Uncomment the following line to change how often to auto-update (in days).</span><br><span class="hljs-comment"># zstyle &#x27;:omz:update&#x27; frequency 13</span><br><br><span class="hljs-comment"># Uncomment the following line if pasting URLs and other text is messed up.</span><br><span class="hljs-comment"># DISABLE_MAGIC_FUNCTIONS=&quot;true&quot;</span><br><br><span class="hljs-comment"># Uncomment the following line to disable colors in ls.</span><br><span class="hljs-comment"># DISABLE_LS_COLORS=&quot;true&quot;</span><br><br><span class="hljs-comment"># Uncomment the following line to disable auto-setting terminal title.</span><br><span class="hljs-comment"># DISABLE_AUTO_TITLE=&quot;true&quot;</span><br><br><span class="hljs-comment"># Uncomment the following line to enable command auto-correction.</span><br><span class="hljs-comment"># ENABLE_CORRECTION=&quot;true&quot;</span><br><br><span class="hljs-comment"># Uncomment the following line to display red dots whilst waiting for completion.</span><br><span class="hljs-comment"># You can also set it to another string to have that shown instead of the default red dots.</span><br><span class="hljs-comment"># e.g. COMPLETION_WAITING_DOTS=&quot;%F&#123;yellow&#125;waiting...%f&quot;</span><br><span class="hljs-comment"># Caution: this setting can cause issues with multiline prompts in zsh &lt; 5.7.1 (see #5765)</span><br><span class="hljs-comment"># COMPLETION_WAITING_DOTS=&quot;true&quot;</span><br><br><span class="hljs-comment"># Uncomment the following line if you want to disable marking untracked files</span><br><span class="hljs-comment"># under VCS as dirty. This makes repository status check for large repositories</span><br><span class="hljs-comment"># much, much faster.</span><br><span class="hljs-comment"># DISABLE_UNTRACKED_FILES_DIRTY=&quot;true&quot;</span><br><br><span class="hljs-comment"># Uncomment the following line if you want to change the command execution time</span><br><span class="hljs-comment"># stamp shown in the history command output.</span><br><span class="hljs-comment"># You can set one of the optional three formats:</span><br><span class="hljs-comment"># &quot;mm/dd/yyyy&quot;|&quot;dd.mm.yyyy&quot;|&quot;yyyy-mm-dd&quot;</span><br><span class="hljs-comment"># or set a custom format using the strftime function format specifications,</span><br><span class="hljs-comment"># see &#x27;man strftime&#x27; for details.</span><br><span class="hljs-comment"># HIST_STAMPS=&quot;mm/dd/yyyy&quot;</span><br><br><span class="hljs-comment"># Would you like to use another custom folder than $ZSH/custom?</span><br><span class="hljs-comment"># ZSH_CUSTOM=/path/to/new-custom-folder</span><br><br><span class="hljs-comment"># Which plugins would you like to load?</span><br><span class="hljs-comment"># Standard plugins can be found in $ZSH/plugins/</span><br><span class="hljs-comment"># Custom plugins may be added to $ZSH_CUSTOM/plugins/</span><br><span class="hljs-comment"># Example format: plugins=(rails git textmate ruby lighthouse)</span><br><span class="hljs-comment"># Add wisely, as too many plugins slow down shell startup.</span><br>plugins=(git zsh-syntax-highlighting)<br><br><span class="hljs-built_in">source</span> <span class="hljs-variable">$ZSH</span>/oh-my-zsh.sh<br><br><span class="hljs-comment"># User configuration</span><br><br><span class="hljs-comment"># export MANPATH=&quot;/usr/local/man:$MANPATH&quot;</span><br><br><span class="hljs-comment"># You may need to manually set your language environment</span><br><span class="hljs-comment"># export LANG=en_US.UTF-8</span><br><br><span class="hljs-comment"># Preferred editor for local and remote sessions</span><br><span class="hljs-comment"># if [[ -n $SSH_CONNECTION ]]; then</span><br><span class="hljs-comment">#   export EDITOR=&#x27;vim&#x27;</span><br><span class="hljs-comment"># else</span><br><span class="hljs-comment">#   export EDITOR=&#x27;mvim&#x27;</span><br><span class="hljs-comment"># fi</span><br><br><span class="hljs-comment"># Compilation flags</span><br><span class="hljs-comment"># export ARCHFLAGS=&quot;-arch x86_64&quot;</span><br><br><span class="hljs-comment"># Set personal aliases, overriding those provided by oh-my-zsh libs,</span><br><span class="hljs-comment"># plugins, and themes. Aliases can be placed here, though oh-my-zsh</span><br><span class="hljs-comment"># users are encouraged to define aliases within the ZSH_CUSTOM folder.</span><br><span class="hljs-comment"># For a full list of active aliases, run `alias`.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Example aliases</span><br><span class="hljs-comment"># alias zshconfig=&quot;mate ~/.zshrc&quot;</span><br><span class="hljs-comment"># alias ohmyzsh=&quot;mate ~/.oh-my-zsh&quot;</span><br><span class="hljs-comment"># &gt;&gt;&gt; conda initialize &gt;&gt;&gt;</span><br><span class="hljs-comment"># !! Contents within this block are managed by &#x27;conda init&#x27; !!</span><br>__conda_setup=<span class="hljs-string">&quot;<span class="hljs-subst">$(&#x27;/home/xiyuanyang/anaconda3/bin/conda&#x27; &#x27;shell.bash&#x27; &#x27;hook&#x27; 2&gt; /dev/null)</span>&quot;</span><br><span class="hljs-keyword">if</span> [ $? -eq 0 ]; <span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">eval</span> <span class="hljs-string">&quot;<span class="hljs-variable">$__conda_setup</span>&quot;</span><br><span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">if</span> [ -f <span class="hljs-string">&quot;/home/xiyuanyang/anaconda3/etc/profile.d/conda.sh&quot;</span> ]; <span class="hljs-keyword">then</span><br>        . <span class="hljs-string">&quot;/home/xiyuanyang/anaconda3/etc/profile.d/conda.sh&quot;</span><br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-built_in">export</span> PATH=<span class="hljs-string">&quot;/home/xiyuanyang/anaconda3/bin:<span class="hljs-variable">$PATH</span>&quot;</span><br>    <span class="hljs-keyword">fi</span><br><span class="hljs-keyword">fi</span><br><span class="hljs-built_in">unset</span> __conda_setup<br><span class="hljs-comment"># &lt;&lt;&lt; conda initialize &lt;&lt;&lt;</span><br><br><span class="hljs-comment"># To customize prompt, run `p10k configure` or edit ~/.p10k.zsh.</span><br>[[ ! -f ~/.p10k.zsh ]] || <span class="hljs-built_in">source</span> ~/.p10k.zsh<br><br><span class="hljs-built_in">export</span> PATH=<span class="hljs-string">&quot;<span class="hljs-variable">$HOME</span>/.cargo/bin:<span class="hljs-variable">$PATH</span>&quot;</span><br><br><span class="hljs-built_in">eval</span> $(thefuck --<span class="hljs-built_in">alias</span>)<br><span class="hljs-comment"># You can use whatever you want as an alias, like for Mondays:</span><br><span class="hljs-built_in">eval</span> $(thefuck --<span class="hljs-built_in">alias</span> FUCK)<br><br><br><br><br><span class="hljs-built_in">export</span> PATH=<span class="hljs-string">&quot;<span class="hljs-variable">$HOME</span>/.cargo/bin:<span class="hljs-variable">$PATH</span>&quot;</span><br><br><br><span class="hljs-built_in">source</span> ~/.zsh/zsh-autosuggestions/zsh-autosuggestions.zsh<br><br><span class="hljs-comment"># setting for alias here</span><br><span class="hljs-built_in">alias</span> cls=<span class="hljs-string">&#x27;clear&#x27;</span><br><span class="hljs-built_in">alias</span> ll=<span class="hljs-string">&#x27;la -lah&#x27;</span><br><span class="hljs-built_in">alias</span> v=<span class="hljs-string">&#x27;vim&#x27;</span><br><span class="hljs-built_in">alias</span> gc=<span class="hljs-string">&#x27;git commit&#x27;</span><br><span class="hljs-built_in">alias</span> gs=<span class="hljs-string">&#x27;git status&#x27;</span><br><span class="hljs-built_in">alias</span> <span class="hljs-built_in">mv</span>=<span class="hljs-string">&#x27;mv -i&#x27;</span><br><span class="hljs-built_in">alias</span> <span class="hljs-built_in">df</span>=<span class="hljs-string">&#x27;df -h&#x27;</span><br><span class="hljs-built_in">alias</span> ..=<span class="hljs-string">&#x27;cd ..&#x27;</span><br><br><br><span class="hljs-comment"># 设置默认字符串颜色为淡蓝色</span><br>ZSH_HIGHLIGHT_STYLES[default]=<span class="hljs-string">&#x27;fg=#87CEEB&#x27;</span><br><br><span class="hljs-comment"># 设置管道颜色为淡粉色</span><br>ZSH_HIGHLIGHT_STYLES[pipe]=<span class="hljs-string">&#x27;fg=#FFB6C1&#x27;</span><br><br><span class="hljs-comment"># 设置命令颜色为淡紫色</span><br>ZSH_HIGHLIGHT_STYLES[<span class="hljs-built_in">command</span>]=<span class="hljs-string">&#x27;fg=#DDA0DD&#x27;</span><br><br><span class="hljs-comment"># 设置别名颜色为淡橙色</span><br>ZSH_HIGHLIGHT_STYLES[<span class="hljs-built_in">alias</span>]=<span class="hljs-string">&#x27;fg=#FFDAB9&#x27;</span><br><br><span class="hljs-comment"># 设置路径颜色为淡黄色</span><br>ZSH_HIGHLIGHT_STYLES[path]=<span class="hljs-string">&#x27;fg=#FFFACD&#x27;</span><br><br><span class="hljs-comment"># 设置错误颜色为淡红色</span><br>ZSH_HIGHLIGHT_STYLES[error]=<span class="hljs-string">&#x27;fg=#FFCCCB&#x27;</span><br><br><span class="hljs-comment"># 设置内置命令颜色为淡紫色</span><br>ZSH_HIGHLIGHT_STYLES[<span class="hljs-built_in">builtin</span>]=<span class="hljs-string">&#x27;fg=#DDA0DD&#x27;</span><br><br></code></pre></td></tr></table></figure><blockquote><p>For usage of Vim, readers can skip to my Blog for basic vim-tutorial.<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://xiyuanyang-code.github.io/posts/Vim-tutorial/">[4]</span></a></sup></p><p><a href="https://xiyuanyang-code.github.io/posts/Vim-tutorial/">https://xiyuanyang-code.github.io/posts/Vim-tutorial/</a></p></blockquote><h4 id="Several-Packages-in-Ubuntu"><a href="#Several-Packages-in-Ubuntu" class="headerlink" title="Several Packages in Ubuntu"></a>Several Packages in Ubuntu</h4><p>The block below shows all the packages I have installed manually. You can also use the list below to check your installation.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">touch</span> target_filenames.txt<br>apt-mark showmanual &gt; target_filenames.txt<br><span class="hljs-built_in">cat</span> target_filenames.txt <span class="hljs-comment">#all files that have been installed in Ubuntu,including system files.</span><br><span class="hljs-built_in">touch</span> all_packages.txt<br>dpkg --list &gt; all_packages.txt<br><span class="hljs-built_in">cat</span> all_packages.txt<br><span class="hljs-built_in">touch</span> final_answers.txt<br>grep -Ff target_filenames.txt all_packages.txt &gt; final_answers.txt<br><span class="hljs-built_in">cat</span> final_answers.txt<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><code class="hljs bash">| Status=Not/Inst/Conf-files/Unpacked/halF-conf/Half-inst/trig-aWait/Trig-pend<br>ii  alsa-topology-conf            1.2.5.1-2                               all          ALSA topology configuration files<br>ii  alsa-ucm-conf                 1.2.6.3-1ubuntu1.12                     all          ALSA Use Case Manager configuration files<br>ii  base-files                    12ubuntu4.2                             amd64        Debian base system miscellaneous files<br>ii  base-passwd                   3.5.52build1                            amd64        Debian base system master password and group files<br>ii  bash                          5.1-6ubuntu1.1                          amd64        GNU Bourne Again SHell<br>ii  bash-completion               1:2.11-5ubuntu1                         all          programmable completion <span class="hljs-keyword">for</span> the bash shell<br>ii  bc                            1.07.1-3build1                          amd64        GNU bc arbitrary precision calculator language<br>ii  binutils-common:amd64         2.38-4ubuntu2.6                         amd64        Common files <span class="hljs-keyword">for</span> the GNU assembler, linker and binary utilities<br>ii  bsdutils                      1:2.37.2-4ubuntu3.4                     amd64        basic utilities from 4.4BSD-Lite<br>ii  build-essential               12.9ubuntu3                             amd64        Informational list of build-essential packages<br>ii  bzip2                         1.0.8-5build1                           amd64        high-quality block-sorting file compressor - utilities<br>ii  cargo                         1.75.0+dfsg0ubuntu1~bpo0-0ubuntu0.22.04 amd64        Rust package manager<br>ii  cmake                         3.22.1-1ubuntu1.22.04.2                 amd64        cross-platform, open-source make system<br>ii  cmake-data                    3.22.1-1ubuntu1.22.04.2                 all          CMake data files (modules, templates and documentation)<br>ii  command-not-found             22.04.0                                 all          Suggest installation of packages <span class="hljs-keyword">in</span> interactive bash sessions<br>ii  cpio                          2.13+dfsg-7ubuntu0.1                    amd64        GNU cpio -- a program to manage archives of files<br>ii  curl                          7.81.0-1ubuntu1.20                      amd64        <span class="hljs-built_in">command</span> line tool <span class="hljs-keyword">for</span> transferring data with URL syntax<br>ii  dash                          0.5.11+git20210903+057cd650a4ed-3build1 amd64        POSIX-compliant shell<br>ii  debconf                       1.5.79ubuntu1                           all          Debian configuration management system<br>ii  debconf-i18n                  1.5.79ubuntu1                           all          full internationalization support <span class="hljs-keyword">for</span> debconf<br>ii  deborphan                     1.7.35                                  amd64        program that can find unused packages, e.g. libraries<br>ii  diffutils                     1:3.8-0ubuntu2                          amd64        File comparison utilities<br>ii  distro-info-data              0.52ubuntu0.7                           all          information about the distributions<span class="hljs-string">&#x27; releases (data files)</span><br><span class="hljs-string">ii  dosfstools                    4.2-1build3                             amd64        utilities for making and checking MS-DOS FAT filesystems</span><br><span class="hljs-string">ii  e2fsprogs                     1.46.5-2ubuntu1.1                       amd64        ext2/ext3/ext4 file system utilities</span><br><span class="hljs-string">ii  fd-find                       8.3.1-1ubuntu0.1                        amd64        Simple, fast and user-friendly alternative to find</span><br><span class="hljs-string">ii  file                          1:5.41-3ubuntu0.1                       amd64        Recognize the type of data in a file using &quot;magic&quot; numbers</span><br><span class="hljs-string">ii  findutils                     4.8.0-1ubuntu3                          amd64        utilities for finding files--find, xargs</span><br><span class="hljs-string">ii  gdb                           12.1-0ubuntu1~22.04.2                   amd64        GNU Debugger</span><br><span class="hljs-string">ii  git                           1:2.34.1-1ubuntu1.12                    amd64        fast, scalable, distributed revision control system</span><br><span class="hljs-string">ii  git-man                       1:2.34.1-1ubuntu1.12                    all          fast, scalable, distributed revision control system (manual pages)</span><br><span class="hljs-string">ii  gnupg-l10n                    2.2.27-3ubuntu2.1                       all          GNU privacy guard - localization files</span><br><span class="hljs-string">ii  grep                          3.7-1build1                             amd64        GNU grep, egrep and fgrep</span><br><span class="hljs-string">ii  gzip                          1.10-4ubuntu4.1                         amd64        GNU compression utilities</span><br><span class="hljs-string">ii  hostname                      3.23ubuntu2                             amd64        utility to set/show the host name or domain name</span><br><span class="hljs-string">ii  htop                          3.0.5-7build2                           amd64        interactive processes viewer</span><br><span class="hljs-string">ii  init                          1.62                                    amd64        metapackage ensuring an init system is installed</span><br><span class="hljs-string">ii  init-system-helpers           1.62                                    all          helper tools for all init systems</span><br><span class="hljs-string">ii  libalgorithm-diff-perl        1.201-1                                 all          module to find differences between files</span><br><span class="hljs-string">ii  libalgorithm-diff-xs-perl     0.04-6build3                            amd64        module to find differences between files (XS accelerated)</span><br><span class="hljs-string">ii  libasound2-data               1.2.6.1-1ubuntu1                        all          Configuration files and profiles for ALSA drivers</span><br><span class="hljs-string">ii  libatk1.0-data                2.36.0-3build1                          all          Common files for the ATK accessibility toolkit</span><br><span class="hljs-string">ii  libaudit-common               1:3.0.7-1build1                         all          Dynamic library for security auditing - common files</span><br><span class="hljs-string">ii  libavahi-common-data:amd64    0.8-5ubuntu5.2                          amd64        Avahi common data files</span><br><span class="hljs-string">ii  libbz2-1.0:amd64              1.0.8-5build1                           amd64        high-quality block-sorting file compressor library - runtime</span><br><span class="hljs-string">ii  libc-ares2:amd64              1.18.1-1ubuntu0.22.04.3                 amd64        asynchronous name resolver</span><br><span class="hljs-string">ii  libc-bin                      2.35-0ubuntu3.9                         amd64        GNU C Library: Binaries</span><br><span class="hljs-string">ii  libc-dev-bin                  2.35-0ubuntu3.9                         amd64        GNU C Library: Development binaries</span><br><span class="hljs-string">ii  libc-devtools                 2.35-0ubuntu3.9                         amd64        GNU C Library: Development tools</span><br><span class="hljs-string">ii  libc6:amd64                   2.35-0ubuntu3.9                         amd64        GNU C Library: Shared libraries</span><br><span class="hljs-string">ii  libc6-dbg:amd64               2.35-0ubuntu3.9                         amd64        GNU C Library: detached debugging symbols</span><br><span class="hljs-string">ii  libc6-dev:amd64               2.35-0ubuntu3.9                         amd64        GNU C Library: Development Libraries and Header Files</span><br><span class="hljs-string">ii  libc6-i386                    2.35-0ubuntu3.9                         amd64        GNU C Library: 32-bit shared libraries for AMD64</span><br><span class="hljs-string">ii  libcairo-gobject2:amd64       1.16.0-5ubuntu2                         amd64        Cairo 2D vector graphics library (GObject library)</span><br><span class="hljs-string">ii  libcairo2:amd64               1.16.0-5ubuntu2                         amd64        Cairo 2D vector graphics library</span><br><span class="hljs-string">ii  libcanberra0:amd64            0.30-10ubuntu1.22.04.1                  amd64        simple abstract interface for playing event sounds</span><br><span class="hljs-string">ii  libcap-ng0:amd64              0.7.9-2.2build3                         amd64        An alternate POSIX capabilities library</span><br><span class="hljs-string">ii  libcap2:amd64                 1:2.44-1ubuntu0.22.04.1                 amd64        POSIX 1003.1e capabilities (library)</span><br><span class="hljs-string">ii  libcap2-bin                   1:2.44-1ubuntu0.22.04.1                 amd64        POSIX 1003.1e capabilities (utilities)</span><br><span class="hljs-string">ii  libcbor0.8:amd64              0.8.0-2ubuntu1                          amd64        library for parsing and generating CBOR (RFC 7049)</span><br><span class="hljs-string">ii  libcc1-0:amd64                12.3.0-1ubuntu1~22.04                   amd64        GCC cc1 plugin for GDB</span><br><span class="hljs-string">ii  libcolord2:amd64              1.4.6-1                                 amd64        system service to manage device colour profiles -- runtime</span><br><span class="hljs-string">ii  libcom-err2:amd64             1.46.5-2ubuntu1.1                       amd64        common error description library</span><br><span class="hljs-string">ii  libcrypt-dev:amd64            1:4.4.27-1                              amd64        libcrypt development files</span><br><span class="hljs-string">ii  libcrypt1:amd64               1:4.4.27-1                              amd64        libcrypt shared library</span><br><span class="hljs-string">ii  libcryptsetup12:amd64         2:2.4.3-1ubuntu1.1                      amd64        disk encryption support - shared library</span><br><span class="hljs-string">ii  libctf-nobfd0:amd64           2.38-4ubuntu2.6                         amd64        Compact C Type Format library (runtime, no BFD dependency)</span><br><span class="hljs-string">ii  libctf0:amd64                 2.38-4ubuntu2.6                         amd64        Compact C Type Format library (runtime, BFD dependency)</span><br><span class="hljs-string">ii  libcups2:amd64                2.4.1op1-1ubuntu4.11                    amd64        Common UNIX Printing System(tm) - Core library</span><br><span class="hljs-string">ii  libcurl3-gnutls:amd64         7.81.0-1ubuntu1.20                      amd64        easy-to-use client-side URL transfer library (GnuTLS flavour)</span><br><span class="hljs-string">ii  libcurl4:amd64                7.81.0-1ubuntu1.20                      amd64        easy-to-use client-side URL transfer library (OpenSSL flavour)</span><br><span class="hljs-string">ii  libdebconfclient0:amd64       0.261ubuntu1                            amd64        Debian Configuration Management System (C-implementation library)</span><br><span class="hljs-string">ii  libdebuginfod1:amd64          0.186-1build1                           amd64        library to interact with debuginfod (development files)</span><br><span class="hljs-string">ii  libdrm-common                 2.4.110-1ubuntu1                        all          Userspace interface to kernel DRM services -- common files</span><br><span class="hljs-string">ii  libelf1:amd64                 0.186-1build1                           amd64        library to read and write ELF files</span><br><span class="hljs-string">ii  libext2fs2:amd64              1.46.5-2ubuntu1.1                       amd64        ext2/ext3/ext4 file system libraries</span><br><span class="hljs-string">ii  libfile-fcntllock-perl        0.22-3build7                            amd64        Perl module for file locking with fcntl(2)</span><br><span class="hljs-string">ii  libfreetype6:amd64            2.11.1+dfsg-1ubuntu0.2                  amd64        FreeType 2 font engine, shared library files</span><br><span class="hljs-string">ii  libgcc-11-dev:amd64           11.4.0-1ubuntu1~22.04                   amd64        GCC support library (development files)</span><br><span class="hljs-string">ii  libgdbm-compat4:amd64         1.23-1                                  amd64        GNU dbm database routines (legacy support runtime version) </span><br><span class="hljs-string">ii  libgdbm6:amd64                1.23-1                                  amd64        GNU dbm database routines (runtime version) </span><br><span class="hljs-string">ii  libgdk-pixbuf2.0-common       2.42.8+dfsg-1ubuntu0.3                  all          GDK Pixbuf library - data files</span><br><span class="hljs-string">ii  libglib2.0-data               2.72.4-0ubuntu2.4                       all          Common files for GLib library</span><br><span class="hljs-string">ii  libgtk-3-common               3.24.33-1ubuntu2.2                      all          common files for the GTK graphical user interface library</span><br><span class="hljs-string">ii  libldap-common                2.5.16+dfsg-0ubuntu0.22.04.2            all          OpenLDAP common files for libraries</span><br><span class="hljs-string">ii  liblocale-gettext-perl        1.07-4build3                            amd64        module using libc functions for internationalization in Perl</span><br><span class="hljs-string">ii  libmagic-mgc                  1:5.41-3ubuntu0.1                       amd64        File type determination library using &quot;magic&quot; numbers (compiled magic file)</span><br><span class="hljs-string">ii  libmagic1:amd64               1:5.41-3ubuntu0.1                       amd64        Recognize the type of data in a file using &quot;magic&quot; numbers - library</span><br><span class="hljs-string">ii  libnsl-dev:amd64              1.3.0-2build2                           amd64        libnsl development files</span><br><span class="hljs-string">ii  libpcre2-8-0:amd64            10.39-3ubuntu0.1                        amd64        New Perl Compatible Regular Expression Library- 8 bit runtime files</span><br><span class="hljs-string">ii  libpcre3:amd64                2:8.39-13ubuntu0.22.04.1                amd64        Old Perl 5 Compatible Regular Expression Library - runtime files</span><br><span class="hljs-string">ii  libplymouth5:amd64            0.9.5+git20211018-1ubuntu3              amd64        graphical boot animation and logger - shared libraries</span><br><span class="hljs-string">ii  libpython3-dev:amd64          3.10.6-1~22.04.1                        amd64        header files and a static library for Python (default)</span><br><span class="hljs-string">ii  libpython3.10-dev:amd64       3.10.12-1~22.04.8                       amd64        Header files and a static library for Python (v3.10)</span><br><span class="hljs-string">ii  librsvg2-2:amd64              2.52.5+dfsg-3ubuntu0.2                  amd64        SAX-based renderer library for SVG files (runtime)</span><br><span class="hljs-string">ii  librsvg2-common:amd64         2.52.5+dfsg-3ubuntu0.2                  amd64        SAX-based renderer library for SVG files (extra runtime)</span><br><span class="hljs-string">ii  librtmp1:amd64                2.4+20151223.gitfa8646d.1-2build4       amd64        toolkit for RTMP streams (shared library)</span><br><span class="hljs-string">ii  libsemanage-common            3.3-1build2                             all          Common files for SELinux policy management libraries</span><br><span class="hljs-string">ii  libsource-highlight-common    3.1.9-4.1build2                         all          architecture-independent files for source highlighting library</span><br><span class="hljs-string">ii  libstd-rust-dev:amd64         1.75.0+dfsg0ubuntu1~bpo0-0ubuntu0.22.04 amd64        Rust standard libraries - development files</span><br><span class="hljs-string">ii  libstdc++-11-dev:amd64        11.4.0-1ubuntu1~22.04                   amd64        GNU Standard C++ Library v3 (development files)</span><br><span class="hljs-string">ii  libtcl8.6:amd64               8.6.12+dfsg-1build1                     amd64        Tcl (the Tool Command Language) v8.6 - run-time library files</span><br><span class="hljs-string">ii  libthai-data                  0.1.29-1build1                          all          Data files for Thai language support library</span><br><span class="hljs-string">ii  libtirpc-common               1.3.2-2ubuntu0.1                        all          transport-independent RPC library - common files</span><br><span class="hljs-string">ii  libtirpc-dev:amd64            1.3.2-2ubuntu0.1                        amd64        transport-independent RPC library - development files</span><br><span class="hljs-string">ii  libvorbisfile3:amd64          1.3.7-1build2                           amd64        high-level API for Vorbis General Audio Compression Codec</span><br><span class="hljs-string">ii  libwebp7:amd64                1.2.2-2ubuntu0.22.04.2                  amd64        Lossy compression of digital photographic images</span><br><span class="hljs-string">ii  libxkbcommon0:amd64           1.4.0-1                                 amd64        library interface to the XKB compiler - shared library</span><br><span class="hljs-string">ii  linux-libc-dev:amd64          5.15.0-131.141                          amd64        Linux Kernel Headers for development</span><br><span class="hljs-string">ii  login                         1:4.8.1-2ubuntu2.2                      amd64        system login tools</span><br><span class="hljs-string">ii  logsave                       1.46.5-2ubuntu1.1                       amd64        save the output of a command in a log file</span><br><span class="hljs-string">ii  lsb-base                      11.1.0ubuntu4                           all          Linux Standard Base init script functionality</span><br><span class="hljs-string">ii  lshw                          02.19.git.2021.06.19.996aaad9c7-2build1 amd64        information about hardware configuration</span><br><span class="hljs-string">ii  lsof                          4.93.2+dfsg-1.1build2                   amd64        utility to list open files</span><br><span class="hljs-string">ii  make                          4.3-4.1build1                           amd64        utility for directing compilation</span><br><span class="hljs-string">ii  media-types                   7.0.0                                   all          List of standard media types and their usual file extension</span><br><span class="hljs-string">ii  motd-news-config              12ubuntu4.2                             all          Configuration for motd-news shipped in base-files</span><br><span class="hljs-string">ii  mount                         2.37.2-4ubuntu3.4                       amd64        tools for mounting and manipulating filesystems</span><br><span class="hljs-string">ii  ncurses-base                  6.3-2ubuntu0.1                          all          basic terminal type definitions</span><br><span class="hljs-string">ii  ncurses-bin                   6.3-2ubuntu0.1                          amd64        terminal-related programs and man pages</span><br><span class="hljs-string">ii  ncurses-term                  6.3-2ubuntu0.1                          all          additional terminal type definitions</span><br><span class="hljs-string">ii  net-tools                     1.60+git20181103.0eebece-1ubuntu5       amd64        NET-3 networking toolkit</span><br><span class="hljs-string">ii  nodejs                        12.22.9~dfsg-1ubuntu3.6                 amd64        evented I/O for V8 javascript - runtime executable</span><br><span class="hljs-string">ii  nodejs-doc                    12.22.9~dfsg-1ubuntu3.6                 all          API documentation for Node.js, the javascript platform</span><br><span class="hljs-string">ii  openssh-server                1:8.9p1-3ubuntu0.10                     amd64        secure shell (SSH) server, for secure access from remote machines</span><br><span class="hljs-string">ii  pastebinit                    1.5.1-1ubuntu1                          all          command-line pastebin client</span><br><span class="hljs-string">ii  patch                         2.7.6-7build2                           amd64        Apply a diff file to an original</span><br><span class="hljs-string">ii  plymouth                      0.9.5+git20211018-1ubuntu3              amd64        boot animation, logger and I/O multiplexer</span><br><span class="hljs-string">ii  plymouth-theme-ubuntu-text    0.9.5+git20211018-1ubuntu3              amd64        boot animation, logger and I/O multiplexer - ubuntu text theme</span><br><span class="hljs-string">ii  procps                        2:3.3.17-6ubuntu2.1                     amd64        /proc file system utilities</span><br><span class="hljs-string">ii  psmisc                        23.4-2build3                            amd64        utilities that use the proc file system</span><br><span class="hljs-string">ii  python3-dev                   3.10.6-1~22.04.1                        amd64        header files and a static library for Python (default)</span><br><span class="hljs-string">ii  python3-gdbm:amd64            3.10.8-1~22.04                          amd64        GNU dbm database support for Python 3.x</span><br><span class="hljs-string">ii  python3-pip                   22.0.2+dfsg-1ubuntu0.5                  all          Python package installer</span><br><span class="hljs-string">ii  python3-setuptools            59.6.0-1.2ubuntu0.22.04.2               all          Python3 Distutils Enhancements</span><br><span class="hljs-string">ii  python3-wadllib               1.3.6-1                                 all          Python 3 library for navigating WADL files</span><br><span class="hljs-string">ii  python3-zipp                  1.0.0-3ubuntu0.1                        all          pathlib-compatible Zipfile object wrapper - Python 3.x</span><br><span class="hljs-string">ii  python3.10-dev                3.10.12-1~22.04.8                       amd64        Header files and a static library for Python (v3.10)</span><br><span class="hljs-string">ii  rake                          13.0.6-2                                all          ruby make-like utility</span><br><span class="hljs-string">ii  readline-common               8.1.2-1                                 all          GNU readline and history libraries, common files</span><br><span class="hljs-string">ii  ripgrep                       13.0.0-2ubuntu0.1                       amd64        Recursively searches directories for a regex pattern</span><br><span class="hljs-string">ii  rpcsvc-proto                  1.4.2-0ubuntu6                          amd64        RPC protocol compiler and definitions</span><br><span class="hljs-string">ii  rsync                         3.2.7-0ubuntu0.22.04.4                  amd64        fast, versatile, remote (and local) file-copying tool</span><br><span class="hljs-string">ii  shellcheck                    0.8.0-2                                 amd64        lint tool for shell scripts</span><br><span class="hljs-string">ii  squashfs-tools                1:4.5-3build1                           amd64        Tool to create and append to squashfs filesystems</span><br><span class="hljs-string">ii  sysvinit-utils                3.01-1ubuntu1                           amd64        System-V-like utilities</span><br><span class="hljs-string">ii  thefuck                       3.29-0.3                                all          spelling corrector of console commands</span><br><span class="hljs-string">ii  tmux                          3.2a-4ubuntu0.2                         amd64        terminal multiplexer</span><br><span class="hljs-string">ii  tree                          2.0.2-1                                 amd64        displays an indented directory tree, in color</span><br><span class="hljs-string">ii  ubuntu-minimal                1.481                                   amd64        Minimal core of Ubuntu</span><br><span class="hljs-string">ii  ubuntu-standard               1.481                                   amd64        The Ubuntu standard system</span><br><span class="hljs-string">ii  ubuntu-wsl                    1.481                                   amd64        Ubuntu on Windows tools - Windows Subsystem for Linux integration</span><br><span class="hljs-string">ii  ucf                           3.0043                                  all          Update Configuration File(s): preserve user changes to config files</span><br><span class="hljs-string">ii  unzip                         6.0-26ubuntu3.2                         amd64        De-archiver for .zip files</span><br><span class="hljs-string">ii  valgrind                      1:3.18.1-1ubuntu2                       amd64        instrumentation framework for building dynamic analysis tools</span><br><span class="hljs-string">ii  vim-common                    2:8.2.3995-1ubuntu2.23                  all          Vi IMproved - Common files</span><br><span class="hljs-string">ii  vim-gtk                       2:8.2.3995-1ubuntu2.23                  all          Vi IMproved - enhanced vi editor (dummy package)</span><br><span class="hljs-string">ii  vim-gtk3                      2:8.2.3995-1ubuntu2.23                  amd64        Vi IMproved - enhanced vi editor - with GTK3 GUI</span><br><span class="hljs-string">ii  vim-gui-common                2:8.2.3995-1ubuntu2.23                  all          Vi IMproved - Common GUI files</span><br><span class="hljs-string">ii  vim-runtime                   2:8.2.3995-1ubuntu2.23                  all          Vi IMproved - Runtime files</span><br><span class="hljs-string">ii  wget                          1.21.2-2ubuntu1.1                       amd64        retrieves files from the web</span><br><span class="hljs-string">ii  xxd                           2:8.2.3995-1ubuntu2.23                  amd64        tool to make (or reverse) a hex dump</span><br><span class="hljs-string">ii  zip                           3.0-12build2                            amd64        Archiver for .zip files</span><br><span class="hljs-string">ii  zsh                           5.8.1-1                                 amd64        shell with lots of features</span><br><span class="hljs-string">ii  zsh-common                    5.8.1-1                                 all          architecture independent files for Zsh</span><br><span class="hljs-string"></span><br></code></pre></td></tr></table></figure><h4 id="Other-powerful-open-source-software"><a href="#Other-powerful-open-source-software" class="headerlink" title="Other powerful open-source software"></a>Other powerful open-source software</h4><p>Github is a nice place to attain poweful and open-source developer tools! I will recommend two tools that I have used frequently.</p><h5 id="thefuck"><a href="#thefuck" class="headerlink" title="thefuck"></a>thefuck</h5><p>Thefuck<sup id="fnref:6" class="footnote-ref"><a href="#fn:6" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://github.com/nvbn/thefuck">[6]</span></a></sup> is a powerful tool that can automatically correct your command-line mistakes. Everytime you type something wrong (like <code>sudo apt insyall update</code>), using the <code>fuck</code> command will help you find your bug instead of typing it or modifying it in a time-consuming process. You can set some interesting alias such as <code>FuckingNvidia</code> to make the command more powerful! (Just a joke.) </p><p>Sometimes thefuck is a bit too slow… I will use <code>zsh-syntax-highlighting</code> instead to alert me to command input errors. My customed settings for zsh-syntax-highlighting have been written into my <code>~/.zshrc</code> dotfiles. You can skip to the <a href="#Linux-Terminal">previous part</a>.</p><h5 id="Yazi"><a href="#Yazi" class="headerlink" title="Yazi"></a>Yazi</h5><p>Yazi<sup id="fnref:5" class="footnote-ref"><a href="#fn:5" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://github.com/sxyazi/yazi">[5]</span></a></sup> (means “duck”) is a terminal file manager written in Rust, based on non-blocking async I&#x2F;O. It aims to provide an efficient, user-friendly, and customizable file management experience.</p><p>It’s quite useful for its vim-liked operations. I often use it to browse and search my files quickly and navigate through multiple files.</p><p>You can go through their websites to obtain a deeper insight!</p><p><a href="https://github.com/sxyazi/yazi">https://github.com/sxyazi/yazi</a> </p><h2 id="Information-Collection"><a href="#Information-Collection" class="headerlink" title="Information Collection"></a>Information Collection</h2><p><strong>Several forums regarding AI</strong></p><table><thead><tr><th><a href="https://waytoagi.feishu.cn/wiki/QPe5w5g7UisbEkkow8XcDmOpn8e">Way to AGI</a></th><th>通往 AGI 之路 - Feishu Docs</th><th>The Feishu documentation for the development and usage of AI</th></tr></thead><tbody><tr><td><a href="https://a16z.com/ai-canon/">AI canon</a></td><td>AI canon from a16z</td><td>A curated list of resources we’ve relied on to get smarter about modern AI</td></tr><tr><td><a href="https://openai.com/research/">Open AI Research</a></td><td>OpenAI Research</td><td>The Research and releasing blog for OpenAI</td></tr><tr><td><a href="https://research.google/blog/">Google Research</a></td><td>Google Research</td><td>The Research and releasing blog for Google</td></tr><tr><td><a href="https://deepmind.google/discover/blog/">Deepmind</a></td><td>Google Deepmind</td><td>The Research and releasing blog for Google Deepmind</td></tr><tr><td><a href="https://ai.meta.com/blog/">Meta</a></td><td>Meta</td><td>AI at Meta Blog</td></tr><tr><td><a href="https://blogs.nvidia.com/blog/category/deep-learning/">Nvidia</a></td><td>Nvidia</td><td>The Research and releasing blog for Nvidia</td></tr><tr><td><a href="https://blogs.microsoft.com/">Microsoft</a></td><td>Microsoft</td><td>The Research and releasing blog for Microsoft</td></tr><tr><td><a href="https://huggingface.co/papers">Hugging Face Daily Papers</a></td><td>Hugging Face</td><td>Hugging Face Daily Papers</td></tr><tr><td><a href="https://stratechery.com/category/articles/">Stratechery</a></td><td>Articles – Stratechery by Ben Thompson</td><td>Articles – Stratechery by Ben Thompson</td></tr></tbody></table><h2 id="Office-Software"><a href="#Office-Software" class="headerlink" title="Office Software"></a>Office Software</h2><h3 id="Markdown-files"><a href="#Markdown-files" class="headerlink" title="Markdown files"></a>Markdown files</h3><p>For me, <strong>markdown</strong> is really an efficient tool! Not only for its convenience compared with <strong>Microsoft Word or WPS</strong>, but also for its simple but powerful syntax. Markdown has unparalleled advantages over other formats in note-taking, text generation, and more.</p><p>For Chinese users, you can select this website as your Markdown tutorial: <a href="https://markdown.com.cn/">https://markdown.com.cn/</a> . <a href="https://commonmark.org/">CommonMark</a> is also a great website for teaching markdown syntax.</p><p>In the text below, I will recommend <strong>4</strong> different tools to write markdown. These tools are applicable in different scenarios. </p><h4 id="Typora-Most-Recommended"><a href="#Typora-Most-Recommended" class="headerlink" title="Typora (Most Recommended)"></a>Typora (Most Recommended)</h4><p>The website of Typora</p><ul><li>Lightly and neat.</li><li>You can choose your theme in the open-source market, or you can just use your own <strong>css</strong> files!</li><li>The most frequently used markdown editor!</li></ul><h4 id="MarkText-Free-and-open-source"><a href="#MarkText-Free-and-open-source" class="headerlink" title="MarkText (Free and open-source)"></a>MarkText (Free and open-source)</h4><p>Advantages over Typora: </p><ul><li><strong>Free and Open-source</strong></li><li>customized settings: hot-keys, etc.</li></ul><p>Several disadvantages:</p><ul><li>Personally, I don’t like its <strong>UI</strong> design…</li><li>Sometimes less fluent than Typora.</li></ul><h4 id="SiYuan-Note-For-Note-Management"><a href="#SiYuan-Note-For-Note-Management" class="headerlink" title="SiYuan Note (For Note Management)"></a>SiYuan Note (For Note Management)</h4><p>Typora don’t focus on <strong>File management</strong>, you can only navigate files in the same root folder.</p><p><strong>Siyuan Note</strong> is a free and open-source markdown editor, which have great advantages over <strong>Note Management</strong>! You can go through <a href="https://github.com/siyuan-note/siyuan">this website</a> for more details.</p><h4 id="Vscode-For-Coding-and-Manuals"><a href="#Vscode-For-Coding-and-Manuals" class="headerlink" title="Vscode (For Coding and Manuals)"></a>Vscode (For Coding and Manuals)</h4><p>eh… Actually I don’t like writing markdown in vscode (except for writing it in Jupyter Lab). However, several vscode plugins support the visualization of markdown files and you can make some slight modifications of your docs (like <code>README.md</code>). </p><h3 id="PDF-viewers"><a href="#PDF-viewers" class="headerlink" title="PDF viewers"></a>PDF viewers</h3><p><a href="https://www.sumatrapdfreader.org/free-pdf-reader">Sumatra PDF viewer</a> is the PDF viewers that is most frequently used by myself. <a href="https://www.sumatrapdfreader.org/">SumatraPDF</a> is a free <a href="https://www.sumatrapdfreader.org/docs/Supported-document-formats">PDF, EPUB, MOBI, CHM, XPS, DjVu, CBZ and CBR</a> reader for Windows. It’s small, fast, customizable and full of features.</p><p><strong>I love open-source!</strong> </p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://typora.io/">Typora</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:1" class="footnote-text"><span><a href="https://xxyqwq.github.io/2024/01/27/build-windows-terminal/">https://xxyqwq.github.io/2024/01/27/build-windows-terminal/</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://xxyqwq.github.io/2023/07/31/build-linux-terminal/">https://xxyqwq.github.io/2023/07/31/build-linux-terminal/</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://missing.csail.mit.edu/2020/command-line/">https://missing.csail.mit.edu/2020/command-line/</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span><a href="https://xiyuanyang-code.github.io/posts/Vim-tutorial/">https://xiyuanyang-code.github.io/posts/Vim-tutorial/</a><a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:5" class="footnote-text"><span><a href="https://github.com/sxyazi/yazi">https://github.com/sxyazi/yazi</a><a href="#fnref:5" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:6" class="footnote-text"><span><a href="https://github.com/nvbn/thefuck">https://github.com/nvbn/thefuck</a><a href="#fnref:6" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:7" class="footnote-text"><span><a href="https://commonmark.org/">https://commonmark.org/</a><a href="#fnref:7" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:8" class="footnote-text"><span><a href="https://typora.io/">https://typora.io/</a><a href="#fnref:8" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    
    <tags>
      
      <tag>Announcement</tag>
      
      <tag>Finished</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>My-Posts</title>
    <link href="/posts/My-Posts/"/>
    <url>/posts/My-Posts/</url>
    
    <content type="html"><![CDATA[<style>  html, body, .markdown-body {    font-family: Georgia, sans, serif;  }</style><p><img src="https://s1.imagehub.cc/images/2025/02/07/329668c81128e08f84c1d1ea140bc31b.jpg" alt="Welcome to Xiyuan Yang&#39;s Blog!"></p><p>This article systematically summarizes the previously published articles by categorizing them into topics.</p><p>This passage will be updated permanently, adding new posts every two weeks.</p><div class="note note-primary">            <p><strong>Last Update Time: 2025&#x2F;03&#x2F;25</strong></p>          </div><h1 id="About-the-author"><a href="#About-the-author" class="headerlink" title="About the author"></a>About the author</h1><p><a href="https://xiyuanyang-code.github.io/about/">About - Xiyuan Yang’s Blog</a> You can Jump to this link for more information.</p><h1 id="All-posts"><a href="#All-posts" class="headerlink" title="All posts!"></a>All posts!</h1><p>The posts can be divided into several <a href="https://xiyuanyang-code.github.io/categories/">categories</a> below:</p><ul><li><p>Code Basis: <strong>Basic Syntax of several programming language</strong></p><ul><li>Category Link: <a href="https://xiyuanyang-code.github.io/categories/Code/">Categories - Code - Xiyuan Yang’s Blog</a></li></ul></li><li><p>Algorithms: <strong>Advanced Learning of Algorithms and Data Structures</strong></p><ul><li>Category Link: <a href="https://xiyuanyang-code.github.io/categories/Algorithm/">Categories - Algorithm - Xiyuan Yang’s Blog</a></li></ul></li><li><p>Efficient Tools: <strong>Tool usage for Computer Science and AI</strong></p><ul><li>Category Link: <a href="https://xiyuanyang-code.github.io/categories/Efficient-Tools/">Categories - Efficient Tools - Xiyuan Yang’s Blog</a></li></ul></li><li><p>Project: <strong>Demonstration and Introduction of My Github Project</strong></p><ul><li>Category Link: <a href="https://xiyuanyang-code.github.io/categories/Project/">Categories - Project - Xiyuan Yang’s Blog</a></li></ul></li><li><p>Artificial Intelligence: <strong>Research Paper Reading</strong></p><ul><li>Category Link: <a href="https://xiyuanyang-code.github.io/categories/Artificial-Intelligence/">Categories - Artificial Intelligence - Xiyuan Yang’s Blog</a></li></ul></li></ul><br><p>Moreover, all posts ca be divided into three categories based on the <strong>completion progress</strong>.</p><ul><li><p><strong>Finished</strong>😃: Posts that have been finished writing and will not be modified in a short term unless some mistakes are caught.</p></li><li><p><strong>Updating</strong>🫡: Mostly blogs with announcements, which will be updated in real time.</p></li><li><p><strong>Not yet Finished</strong>🤡: Posts that have not yet been finished.</p></li></ul><h2 id="Total-demonstration"><a href="#Total-demonstration" class="headerlink" title="Total demonstration"></a>Total demonstration</h2><blockquote><p>Updated: 2025.4.12</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs bash">❌AI-Paper-2024<br>❌AI-indepth-reading-AlexNet<br>❌AIBasis-Neural-Networks<br>❌AINN-GAN<br>✅Above-All<br>✅Algorithm-BFS-DFS<br>✅Algorithm-BinaryTree<br>❌Algorithm-Chunking<br>✅Algorithm-Introduction<br>✅Algorithm-MCTS<br>✅Algorithm-Memo<br>✅Algorithm-Sorting<br>❌AutoGen-automatic-essay-modification<br>✅Bash-commands<br>✅Bash-exercises<br>✅Blog-Update-Fetching-Script<br>✅C-plus-plus-Primer-Plus-tutorial<br>✅CMake-tutorial-episode2<br>✅CMake-tutorial1<br>✅CS294-1-LLM-Reasoning<br>✅CS294-3-Autogen<br>✅Class-Inheritance<br>✅Code-Reuse-in-OOP<br>✅DataStructure-AVL-Tree<br>✅DataStructure-Fenwick-Tree<br>✅DataStructure-LCA<br>✅DataStructure-LinearList<br>✅DataStructure-Queue<br>❌DataStructure-RBT-Tree<br>✅DataStructure-Set<br>✅DataStructure-Sparse-Table<br>✅DataStructure-Stack<br>✅DataStructure-Stack-Queue-Advanced<br>✅DataStructure-String<br>✅DataStructure-Tree<br>✅DataStructure-Tree-Binary-Heap<br>✅DataStructure-Tree-Binary-Search-Tree<br>✅DataStructure-Tree-Binary-Tree<br>❌DataStructure-Trie<br>✅DataStructure-Tutorial<br>✅Deep-Learning-Memo<br>✅Dynamic-Memory-and-Classes<br>✅Exception-Handling-in-C-plus-plus<br>✅Input-and-Output-in-C-plus-plus<br>✅Introduction-to-OOP<br>✅Jotting-References-and-Encapsulation-in-OOP<br>✅LaTeX-tutorial<br>✅Leetcode-Mistake-collection<br>✅Leetcode-Mistake-collection-1-10<br>✅Leetcode-Mistake-collection-11-20<br>✅Leetcode-Mistake-collection-21-30<br>✅Leetcode-Mistake-collection-31-40<br>✅Life-musings<br>✅Linked-List-Implementation-Based-on-Structs<br>✅Linux-Bash-Introduction<br>✅MYGITHUB-Lightweight-speech-recognition-conversion-model<br>✅Math-Multivariable-Calculus<br>✅Missing-Semester-Notes<br>✅My-Posts<br>✅My-WorkFlow<br>✅Pointers-Arrays-and-Functions<br>✅Pre-training-Is-Dead<br>✅Python-Update-Learning<br>✅Python-advanced-File-Management<br>✅Python-cheatsheet<br>✅Python-numpy-cheatsheet<br>✅Python-tutorial<br>✅Python-visualization<br>✅RAG-Blog-Content-Retrieval<br>✅RAG-tutorial<br>✅RL-speeches<br>✅Regular-Expression<br>❌Taking-Notes<br>❌Tools-Tutorial<br>✅Torch-memo<br>✅Vim-tutorial<br></code></pre></td></tr></table></figure><h2 id="Code-Basis"><a href="#Code-Basis" class="headerlink" title="Code Basis"></a>Code Basis</h2><ul><li><strong>Python Grammar Tutorial</strong></li><li><strong>C++ Primer Plus Tutorial</strong></li></ul><h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><ul><li><strong>Data Structure</strong></li><li><strong>Algorithms from MIT 6.006</strong></li><li><strong>Leetcode Mistake Collection</strong></li></ul><h2 id="Project"><a href="#Project" class="headerlink" title="Project"></a>Project</h2><ul><li><strong>My Github Projects</strong></li></ul><h2 id="Efficient-Tools"><a href="#Efficient-Tools" class="headerlink" title="Efficient Tools"></a>Efficient Tools</h2><ul><li><strong>Bash&#x2F;Linux</strong></li><li><strong>Methodologies</strong></li><li><strong>Other developer’s Tools</strong> <ul><li>Missing semester Notes</li></ul></li></ul><h2 id="Artificial-Intelligence"><a href="#Artificial-Intelligence" class="headerlink" title="Artificial Intelligence"></a>Artificial Intelligence</h2><ul><li><p><strong>CS294: LLM Agents</strong></p></li><li><p><strong>Celebrity Speeches</strong></p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Announcement</tag>
      
      <tag>Updating</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DataStructure-Tree-Binary-Tree</title>
    <link href="/posts/DataStructure-Tree-Binary-Tree/"/>
    <url>/posts/DataStructure-Tree-Binary-Tree/</url>
    
    <content type="html"><![CDATA[<style>  html, body, .markdown-body {    font-family: Georgia, sans, serif;  }</style><h1 id="Data-Structure-Binary-Tree"><a href="#Data-Structure-Binary-Tree" class="headerlink" title="Data Structure: Binary Tree"></a>Data Structure: Binary Tree</h1><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><h2 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h2><p>树的定义有两种形式：<strong>递归形式</strong> 和 <strong>延伸形式</strong>。同理，我们对<strong>二叉树</strong>也可以有两种定义的解释：</p><ul><li><p><strong>延伸形式</strong>：每一个节点至多延伸出两个子节点。（可以无节点，一个节点或者两个节点）</p></li><li><p><strong>递归形式</strong>：或者为空，或者由<strong>一个根节点和两颗互不相交的子树构成</strong>，而左右子树都是<strong>二叉树</strong>。</p></li></ul><blockquote><p>可以把“二叉树为空”理解为递归调用中的函数终止条件。</p></blockquote><p>根据上面的定义，我们可以归纳二叉树的<strong>五种基本形态</strong>：</p><table><thead><tr><th>空二叉树</th><th>只有根的二叉树</th><th>只有非空左子树</th><th>只有非空右子树</th><th>左右子树均非空</th></tr></thead></table><p><img src="https://s1.imagehub.cc/images/2025/02/07/b3ab2a0443e525aee7eb1fbdca255773.png" alt="five categories"></p><div class="note note-warning">            <p><strong>注意！</strong> 二叉树是<strong>有序树</strong>，其左右子树存在差异，必须严格区分。</p><p>换句话说，下面的两棵树不可以看做是同一颗二叉树！</p>          </div><pre><code class="mermaid" >graph TDA[node] --> B[value_1]A --> C[value_2]D[node] --> E[value_2]D --> F[value_1]</code></pre><p>二叉树是一种特殊的树，但在二叉树内部，又有很多<strong>特殊的二叉树</strong>：</p><table><thead><tr><th>名词</th><th>描述</th></tr></thead><tbody><tr><td><strong>满二叉树</strong></td><td>每个节点都有 0 或 2 个子节点，且<strong>所有叶节点都在同一层</strong>。</td></tr><tr><td><strong>完全二叉树</strong></td><td>除最后一层外，其他层都是满的，且最后一层的节点尽量<strong>靠左排列</strong>。<br>也就是说，满二叉树一定是完全二叉树，把完全二叉树的叶节点全部补齐就可以变成满二叉树。</td></tr><tr><td><strong>平衡二叉树</strong></td><td>任意节点的左右子树高度差不超过 1，常见实现如 AVL 树、红黑树。</td></tr><tr><td><strong>二叉搜索树 (BST)</strong></td><td>左子树所有节点的值小于根节点，右子树所有节点的值大于根节点，且左右子树也分别是二叉搜索树。</td></tr><tr><td><strong>AVL 树</strong></td><td>一种自平衡二叉搜索树，通过旋转操作保持平衡，确保左右子树高度差不超过 1。</td></tr><tr><td><strong>红黑树</strong></td><td>一种自平衡二叉搜索树，通过颜色标记和旋转操作保持平衡，确保最长路径不超过最短路径的两倍。</td></tr><tr><td><strong>线索二叉树</strong></td><td>通过利用空指针指向节点的前驱或后继，优化遍历效率。</td></tr><tr><td><strong>堆 (Heap)</strong></td><td>一种完全二叉树，分为最大堆（父节点值大于子节点）和最小堆（父节点值小于子节点）。</td></tr><tr><td><strong>B 树</strong></td><td>一种多路平衡搜索树，常用于数据库和文件系统，节点可以有多个子节点。</td></tr><tr><td><strong>B+ 树</strong></td><td>B 树的变种，所有数据存储在叶节点，内部节点仅存储索引，适合范围查询。</td></tr><tr><td><strong>哈夫曼树</strong></td><td>一种带权路径长度最短的二叉树，用于数据压缩（如哈夫曼编码）。</td></tr><tr><td><strong>二叉字典树 (Trie)</strong></td><td>一种多叉树，用于高效存储和检索字符串，每个节点代表一个字符。</td></tr></tbody></table><h2 id="Mathematical-Properties"><a href="#Mathematical-Properties" class="headerlink" title="Mathematical Properties"></a>Mathematical Properties</h2><p><img src="https://s1.imagehub.cc/images/2025/02/07/69c05a5935d390a5750f7806da87c2d6.png" alt="BinaryTree HandNotes"></p><h2 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h2><p>根据上一篇博客的内容，对于一般的树结构可以有如下的操作：</p><ul><li><p><code>create()</code> : create a new tree.</p></li><li><p><code>clear()</code> : clear all nodes in a tree.</p></li><li><p><code>isEmpty()</code> : judge whether a tree is clean.</p></li><li><p><code>root()</code> : find the value of the root node.</p></li><li><p><code>parent(x)</code> : find the parent value of node <code>x</code>.</p></li><li><p><code>child(x, i)</code> : find the <code>i</code>th child value of node <code>x</code>.</p></li><li><p><code>remove(x, i)</code> : remove the <code>i</code>th child subtree of node <code>x</code>.</p></li><li><p><code>travese()</code> : traverse all the nodes in the tree.</p></li></ul><p>在二叉树中，<strong>树的运算可以被进一步的细分</strong>：</p><ul><li><p><strong>找孩子节点</strong>可以被细分为<strong>找左子节点和右子节点</strong>。</p></li><li><p><strong>删除子树</strong>可以被细分为<strong>删除左子树和删除右子树</strong>。</p></li><li><p><strong>二叉树的遍历</strong>可以被细分为<strong>前序遍历，中序遍历，后序遍历和层次遍历</strong>。</p></li></ul><h3 id="Traversal-for-Binary-Tree"><a href="#Traversal-for-Binary-Tree" class="headerlink" title="Traversal for Binary Tree"></a>Traversal for Binary Tree</h3><p>下面重点解释一下第三点，对于如下的二叉树：</p><blockquote><p>由于mermaid流程图的原因，null表示空，没有节点（这样做是为了区分左节点和右节点）。</p></blockquote><pre><code class="mermaid" >graph TD    1((1)) --> 2((2))    1 --> 3((3))    2 --> 4((4))    2 --> 5((5))    3 --> 6((6))    3 --> 7((7))    4 --> 8((8))    4 --> 9((9))    5 --> 10((10))    5 --> 11((11))    6 --> 12((12))    6 --> 13((13))    7 --> 14((14))    7 --> 15((15))    8 --> 16((16))    9 --> 17((17))    10 --> 18((18))    11 --> 19((19))    12 --> 20((20))    8 --> 21((null))    9 --> 22((null))    10 --> 23((null))    11 --> 24((null))    12 --> 25((null))</code></pre><p>在标好号之后（见上文的手写笔记性质5，从上到下，从左到右），<strong>二叉树的遍历</strong>就是从1~n遍历一遍，不过由于<strong>节点之间的关系是层次关系比较复杂</strong>，因此可以有很多种不同的遍历方式。</p><h4 id="Level-Order-Traversal-BFS"><a href="#Level-Order-Traversal-BFS" class="headerlink" title="Level-Order Traversal (BFS)"></a>Level-Order Traversal (BFS)</h4><p>一种最显而易见的<strong>遍历方法</strong>就是根据序号的排列<strong>升序</strong>遍历，具体到树而言，可以做如下定义：</p><p><strong>在访问完<code>k</code>层的所有节点后，再按照从左到右的次序访问<code>k + 1</code>层的节点</strong>。我们把这种遍历的方式叫做<strong>层次遍历</strong>。</p><blockquote><p>Level order traversal follows breadth-first search to visit&#x2F;modify every node of the tree. As BFS suggests, the breadth of the tree <strong>takes priority first</strong> and then <strong>moves to depth</strong>. In simple words, we will visit <strong>all the nodes present at the same level</strong> one-by-one <strong>from left to right</strong>, and then it <strong>moves to the next level</strong> to visit all the nodes of that level.<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="[4 Types of Tree Traversal Algorithms | Built In](https://builtin.com/software-engineering-perspectives/tree-traversal#:~:text=The%20types%20of%20tree%20traversal,traversal%20and%20level%20order%20traversal.)">[1]</span></a></sup></p><p><strong>层次遍历</strong>本质上就是一种<strong>广度优先算法</strong>，何为广度？就是相同层数下的每一个节点都要遍历到，才会继续探索更深的层数。</p></blockquote><p>因此，对于上述的二叉树，遍历的顺序就是从1到20，升序遍历。</p><p>至于具体实现：可以使用<strong>队列</strong>来存储节点的in和out，<strong>队列的入队顺序正好就是层次遍历的顺序</strong>。对于队尾元素出队后再将<strong>两个子节点（如果有的话）</strong>进队，这样就保证了<strong>只有在同一层的所有节点全部遍历完之后</strong>才回去考虑下一节点。同时我们的入队满足先左后右的顺序，因此便能轻松实现二叉树的层次遍历。</p><h4 id="Traversal-Order-for-DFS"><a href="#Traversal-Order-for-DFS" class="headerlink" title="Traversal Order for DFS"></a>Traversal Order for DFS</h4><p>上面的遍历方法很直观，但有一个致命的缺陷：<strong>树结构的核心是层次关系，或者说是父子关系</strong>，但是层次便利相邻两个节点的关系是<strong>同级别的邻居关系</strong>，例如10-&gt;11，两个节点关系并不密切。因此，<strong>我们需要从树的递归定义出发，探索新的遍历方式</strong>。</p><p>新的遍历方式要求遍历相邻的两个节点应存在父子关系（对于大部分而言），因此，<strong>我们需要使用递归的方式</strong>，因为树的父子关系的生成就是依靠的递归定义。这与经典的搜索算法：<strong>深度优先搜索</strong>（DFS）不谋而合。</p><p>具体的递归方式如何实现？仿照树的递归定义，我们在每一个<strong>递归单元</strong>无非是要遍历完成这三个东西：<strong>左子树，根节点，右子树</strong>。这三者之间的遍历并没有具体的先后顺序要求（当然我们默认左子树先于右子树被遍历）。因此，DFS类的二叉树遍历还可以被细分为如下三种遍历方式：</p><ul><li><p><strong>Preorder Traversal</strong> : <code>root -&gt; left sub_tree -&gt; right sub_tree</code></p></li><li><p><strong>Inorder Traversal</strong> : <code>left sub_tree -&gt; root -&gt; right sub_tree</code></p></li><li><p><strong>Postorder Traversal</strong> : <code>left sub_tree -&gt; right sub_tree -&gt; root</code></p></li></ul><blockquote><p>分类的关键就是在于<strong>根节点</strong>在何时被遍历。</p></blockquote><h5 id="Preorder-Traversal"><a href="#Preorder-Traversal" class="headerlink" title="Preorder Traversal"></a>Preorder Traversal</h5><p>我们首先仿照树的定义，引出<strong>前序遍历，或者叫先根遍历</strong>（Preorder Traversal）的定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//Pseudocode for Preorder Traversal</span><br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">isEmpty</span>())&#123;<br>    <span class="hljs-comment">//End for recursion: The sub_tree remaining is empty</span><br>    no operations here<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    traverse the root node<br>    <span class="hljs-built_in">Preorder_traverse</span>(left_subtree)<br>    <span class="hljs-built_in">Preorder_traverse</span>(right_subtree)<br>&#125;<br></code></pre></td></tr></table></figure><p>也就是说，对于每一棵树，拆分成<strong>前序遍历左子树——访问根节点——前序遍历右子树</strong>的顺序，直到达到递归终止条件：<strong>树为空</strong>。</p><p>这里的底层原理其实就是二叉树的递归定义：</p><blockquote><p>二叉树递归的定义方式：<strong>一个树或者为空，或者由一个根节点及两颗互不相交的子树构成。而子树也是二叉树</strong>。</p></blockquote><p>对于上面的树，先根遍历的顺序是：1,2,4,8,16,9,17,5,10,18,11,19,3,6,12,20,13,7,14,15.</p><blockquote><p><strong>The essence of Inorder Traversal</strong> is <strong>DFS</strong> !</p><p>The atomic operations in a recursive function are the same as inorder traversal but in a different order. Here, we visit the current node first and then go to the left subtree. After covering every node of the left subtree, we will move toward the right subtree and visit in a similar fashion.</p></blockquote><h5 id="Inorder-Traversal"><a href="#Inorder-Traversal" class="headerlink" title="Inorder Traversal"></a>Inorder Traversal</h5><p>中序遍历（中根遍历）：<strong>根节点夹在左右子树之间被遍历</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//Pseudocode for Inorder Traversal</span><br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">isEmpty</span>())&#123;<br>    <span class="hljs-comment">//End for recursion: The sub_tree remaining is empty</span><br>    no operations here<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-built_in">Inorder_traverse</span>(left_subtree)<br>    traverse the root node<br>    <span class="hljs-built_in">Inorder_traverse</span>(right_subtree)<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>值得一提的是，这是一种<strong>最常见的DFS搜索模型</strong>，严格按照从左至右的顺序进行。</p></blockquote><p>对于上面的树，遍历顺序为：16,8,4,17,9,2,18,10,5,19,11,1,20,12,6,13,3,14,7,15.</p><h5 id="Postorder-Traversal"><a href="#Postorder-Traversal" class="headerlink" title="Postorder Traversal"></a>Postorder Traversal</h5><p>后序遍历（后根遍历）：<strong>根节点在最后遍历</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//Pseudocode for Postorder Traversal</span><br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">isEmpty</span>())&#123;<br>    <span class="hljs-comment">//End for recursion: The sub_tree remaining is empty</span><br>    no operations here<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-built_in">Postorder_traverse</span>(left_subtree)<br>    <span class="hljs-built_in">Postorder_traverse</span>(right_subtree)<br>    traverse the root node<br>&#125;<br></code></pre></td></tr></table></figure><p>遍历顺序：16,8,17,9,4,18,10,19,11,5,2,20,12,13,6,14,15,7,3,1</p><h5 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h5><pre><code class="mermaid" >graph TD 1((1)) --> 2((2)) 1 --> 3((3)) 2 --> 4((4)) 2 --> 5((5)) 3 --> 6((6)) 3 --> 7((7)) 4 --> 8((8)) 4 --> 9((9)) 5 --> 10((10)) 5 --> 11((11)) 6 --> 12((12)) 6 --> 13((13)) 7 --> 14((14)) 7 --> 15((15)) 8 --> 16((16)) 9 --> 17((17)) 10 --> 18((18)) 11 --> 19((19)) 12 --> 20((20))    8 --> 21((null))    9 --> 22((null))    10 --> 23((null))    11 --> 24((null))    12 --> 25((null))</code></pre><p>层次遍历：升序遍历</p><p>先根遍历：1,2,4,8,16,9,17,5,10,18,11,19,3,6,12,20,13,7,14,15.</p><p>中根遍历：16,8,4,17,9,2,18,10,5,19,11,1,20,12,6,13,3,14,7,15.</p><p>后跟遍历：16,8,17,9,4,18,10,19,11,5,2,20,12,13,6,14,15,7,3,1</p><div class="note note-info">            <p><strong>一个很有意思的小问题：在已知这三种遍历顺序的哪几种的情况下</strong>，可以唯一确定一颗二叉树？</p><blockquote><p>在这里不考虑层次遍历，因为层次遍历无法提示我们层数的信息。</p></blockquote><p>先给出结论：</p><table><thead><tr><th>已知信息</th><th>结果</th></tr></thead><tbody><tr><td><strong>已知前序和中序的遍历顺序</strong></td><td>✅</td></tr><tr><td><strong>已知后序和中序的遍历顺序</strong></td><td>✅</td></tr><tr><td><strong>已知前序和后序的遍历顺序</strong></td><td>❌</td></tr></tbody></table><p>具体的解释比较难讲清楚：关键就在于<strong>确定根节点——左子树——右子树三者之间的关系</strong>，形象的来说，现在每个节点都像一颗珠子，我们需要根据<strong>已知遍历顺序把他们归纳成三堆：左子树，根节点和右子树</strong>。</p><p>再对左子树和右子树做相同的递归操作，最后可以画出树形结构。</p><p>那为什么最后一种不可以呢？<strong>因为二叉树严格区分左右子树</strong>，但是前序和后序遍历左右子树的挨着的，会出现无法区分的情况，例如：前序AB，后序BA，A为根节点，但无法确定B为左子树还是右子树。</p>          </div><h3 id="Abstract-Class"><a href="#Abstract-Class" class="headerlink" title="Abstract Class"></a>Abstract Class</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief Abstract class for Binary Tree</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @tparam T </span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BinaryTree</span>&#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">create</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> T <span class="hljs-title">root</span><span class="hljs-params">(T invalid_flag)</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> T <span class="hljs-title">parent</span><span class="hljs-params">(T current_node, T invalid_flag)</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> T <span class="hljs-title">lchild</span><span class="hljs-params">(T current_node, T invalid_flag)</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> T <span class="hljs-title">rchild</span><span class="hljs-params">(T current_node, T invalid_flag)</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">delLeft</span> <span class="hljs-params">(T current_node)</span> </span>= <span class="hljs-number">0</span>;<br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">delRight</span> <span class="hljs-params">(T current_node)</span> </span>= <span class="hljs-number">0</span>;<br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">PreOrder</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">InOrder</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">PostOrder</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">LevelOrder</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="Linked-Implementation"><a href="#Linked-Implementation" class="headerlink" title="Linked Implementation"></a>Linked Implementation</h3><p><strong>二叉树</strong>一般采用链接方式进行存储，因为顺序存储必须为可能存在插入点位的位置腾出空间，<strong>或者说需要先构建一个完全二叉树</strong>，再引入虚节点。但是这样的存储随着层数的上升会带来<strong>几何级数的空间浪费</strong>，因此，绝大部分二叉树采用链接实现。</p><p>链表的核心在于<strong>额外存储指针信息来实现遍历（跳转到其他节点）</strong>。具体来说有如下形式：</p><table><thead><tr><th>普通链表</th><th>二叉树链表</th></tr></thead><tbody><tr><td>单向链表：单向遍历，只需要储存一个指针的值。</td><td><strong>二叉链表</strong>：只储存两个孩子的地址</td></tr><tr><td>双向链表：可以双向遍历，需要储存前继节点和后继结点的值。</td><td><strong>三叉链表</strong>：还要储存父亲节点的地址</td></tr><tr><td>循环链表：从链尾回到链头（此处不讨论）</td><td></td></tr></tbody></table><p><img src="https://s1.imagehub.cc/images/2025/02/08/b9f88b36919b4c1bee78fbd32d7b6b4f.png" alt="Ternary Linked List"><br><img src="https://s1.imagehub.cc/images/2025/02/08/e36026a7fe5b69d36cfeb2652e711d86.png" alt="Binary Linked List"></p><p>我们把<strong>二叉链表</strong>成为<strong>标准存储结构</strong>，把<strong>三叉链表</strong>称为<strong>广义标准存储结构</strong>。</p><table><thead><tr><th>二叉链表</th><th><code>left</code></th><th><code>data</code></th><th><code>right</code></th><th></th></tr></thead><tbody><tr><td><strong>三叉链表</strong></td><td><strong><code>data</code></strong></td><td><strong><code>left</code></strong></td><td><strong><code>paret</code></strong></td><td><strong><code>right</code></strong></td></tr></tbody></table><p>为了方便，我们在下文只实现<strong>二叉树的二叉链表类</strong>。</p><p>二叉树的其余成员函数实现都相对比较简单。下面给出类的声明和一些重要函数的实现思路。</p><h4 id="Definition-1"><a href="#Definition-1" class="headerlink" title="Definition"></a>Definition</h4><h4 id="createTree"><a href="#createTree" class="headerlink" title="createTree()"></a><code>createTree()</code></h4><p>在这个函数中，我们需要创建<strong>一颗新的树</strong>。来看代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//创建树</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-type">void</span> binaryTree&lt;T&gt;::<span class="hljs-built_in">creatTree</span>(T flag) &#123;<br>    std::queue&lt;Node *&gt;que;<br>    Node *tmp;<br>    T x,l_data,r_data;<br>    <span class="hljs-comment">//创建树，输入flag表示空</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Enter the root node&quot;</span>;<br>    std::cin &gt;&gt; x;<br>    root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(x);<br>    que.<span class="hljs-built_in">push</span>(root);<br>    <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>()) &#123;<br>        tmp = que.<span class="hljs-built_in">top</span>();<br>        que.<span class="hljs-built_in">pop</span>();<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Enter&quot;</span> &lt;&lt; tmp-&gt;data &lt;&lt;<span class="hljs-string">&quot;two sons (&quot;</span> &lt;&lt; flag &lt;&lt; <span class="hljs-string">&quot;) represents the null node&quot;</span>;<br>        std::cin &gt;&gt; l_data &gt;&gt; r_data;<br>        <span class="hljs-keyword">if</span>(l_data != flag)&#123;<br>            que.<span class="hljs-built_in">push</span>(tmp -&gt; left = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(l_data));<br>        &#125;<br>        <span class="hljs-keyword">if</span>(r_data != flag)&#123;<br>            que.<span class="hljs-built_in">push</span>(tmp-&gt;right = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(r_data));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>基本实现思路：采用和<strong>层次遍历</strong>相同的实现思路。（使用队列）</p><div class="note note-primary">            <p><strong>二叉树</strong>的实现看似复杂，其实思想非常的简单。只需要在脑海中存在树的图像，并且灵活运用<strong>树的递归定义</strong>即可。</p>          </div><h4 id="二叉树遍历的非递归实现-栈实现"><a href="#二叉树遍历的非递归实现-栈实现" class="headerlink" title="二叉树遍历的非递归实现 栈实现"></a>二叉树遍历的非递归实现 栈实现</h4><div class="note note-primary">            <p>递归函数是程序设计中非常经典的一个算法环节，但是传统的函数递归调用是建立在<strong>栈内存</strong>上的，编译器自动为函数递归的层层调用创建<strong>栈帧空间</strong>，存在不小的时间和空间开销（例如函数指针）。因此，我们也可以使用栈自己模拟<strong>二叉树遍历的递归版本</strong>，有关栈模拟递归的讲解在本质上就是<strong>手搓状态机和栈帧空间</strong>，具体的教程可以看如下的材料：</p><ul><li><a href="https://xiyuanyang-code.github.io/posts/DataStructure-Stack-Queue-Advanced/">栈模拟递归</a></li><li><a href="https://www.bilibili.com/video/BV1HTAWeTEo3/?share_source=copy_web&vd_source=1722361acea5d9b6aee1f9fef0777c69&t=998">从状态机的角度看栈模拟递归的实现</a></li></ul>          </div><div class="note note-primary">            <p>1.执行代码块0</p><p>2.保存现场准备进入下一层</p><p>3.接受下层返回的数据</p><p>4.恢复现场</p><p>5.继续执行代码块1</p>          </div><h5 id="例题-二叉树的后根遍历的栈模拟递归实现"><a href="#例题-二叉树的后根遍历的栈模拟递归实现" class="headerlink" title="例题 二叉树的后根遍历的栈模拟递归实现"></a>例题 二叉树的后根遍历的栈模拟递归实现</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> SRC_HPP</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SRC_HPP</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">The recursive implementation:</span><br><span class="hljs-comment">traverse(x.left)</span><br><span class="hljs-comment">traverse(x.right)</span><br><span class="hljs-comment">traverse(x)</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">the default function</span><br><span class="hljs-comment">if(node.left == nullptr &amp;&amp; node.right == nullptr)&#123;</span><br><span class="hljs-comment">    traverse the node of x</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Info</span> &#123;<br>  <span class="hljs-comment">// Add whatever you want here</span><br>  <span class="hljs-type">int</span> current_size; <span class="hljs-comment">// now the traversa has gone to which section</span><br>  <span class="hljs-type">int</span> pc;<br>  <span class="hljs-comment">//pc = 1: The initial statement</span><br>  <span class="hljs-comment">//pc = 2: Has been traversed the left node</span><br>  <span class="hljs-comment">//pc = 3: has been traversed the right node</span><br>  <span class="hljs-type">const</span> Node*  root_node;<br>  <span class="hljs-type">int</span> *arr;<br>  <span class="hljs-type">int</span> total_treesize;<br>  <br><br><br><br><br>  <span class="hljs-built_in">Info</span>(<span class="hljs-type">int</span> current= <span class="hljs-number">0</span>, <span class="hljs-type">int</span> pc= <span class="hljs-number">1</span>, <span class="hljs-type">const</span> Node*  root= <span class="hljs-literal">nullptr</span>, <span class="hljs-type">int</span> *arr =<span class="hljs-literal">nullptr</span>, <span class="hljs-type">int</span> total_treesize = <span class="hljs-number">0</span>)<br>  :<span class="hljs-built_in">current_size</span>(current), <span class="hljs-built_in">pc</span>(pc),<span class="hljs-built_in">root_node</span>(root), <span class="hljs-built_in">arr</span>(arr),<span class="hljs-built_in">total_treesize</span>(total_treesize) &#123;<br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span></span><br>  &#125;<br><br>  ~<span class="hljs-built_in">Info</span>() &#123;<br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span></span><br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;  <span class="hljs-comment">// DO NOT edit this part</span><br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">int</span> _data;<br>  Node *_lson, *_rson;<br>  <span class="hljs-keyword">mutable</span> Info _info;  <span class="hljs-comment">// custom data</span><br><br>  <span class="hljs-function"><span class="hljs-keyword">friend</span> Node *<span class="hljs-title">genTree</span><span class="hljs-params">()</span></span>;<br><br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">Node</span>();<br><br>  <span class="hljs-built_in">Node</span>(<span class="hljs-type">int</span> data);<br><br>  ~<span class="hljs-built_in">Node</span>();<br><br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">data</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">const</span> Node *<span class="hljs-type">const</span> <span class="hljs-title">lson</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">const</span> Node *<span class="hljs-type">const</span> <span class="hljs-title">rson</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>  <span class="hljs-function">Info &amp;<span class="hljs-title">info</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversePostOrder</span><span class="hljs-params">(<span class="hljs-type">const</span> Node *<span class="hljs-type">const</span> root, <span class="hljs-type">int</span> *arr, <span class="hljs-type">int</span> tree_size)</span> </span>&#123;<br>  <span class="hljs-type">int</span> currentsize = <span class="hljs-number">0</span>;<br>  Info* st = <span class="hljs-keyword">new</span> Info[tree_size];<span class="hljs-comment">//the simulation of stack</span><br>  <span class="hljs-type">int</span> top = <span class="hljs-number">0</span>;<br>  st[top] = <span class="hljs-built_in">Info</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, root, arr, tree_size);<br><br>  <span class="hljs-keyword">while</span>(top &gt;= <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-keyword">auto</span>&amp; top_val = st[top];<br>    <span class="hljs-keyword">switch</span>(top_val.pc)&#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">if</span>(top_val.root_node-&gt;<span class="hljs-built_in">lson</span>() == <span class="hljs-literal">nullptr</span> &amp;&amp; top_val.root_node-&gt;<span class="hljs-built_in">rson</span>() == <span class="hljs-literal">nullptr</span>)&#123;<br>                <span class="hljs-comment">//fill in the root node!</span><br>                arr[currentsize] = top_val.root_node-&gt;<span class="hljs-built_in">data</span>();<br>                currentsize ++;<br>                <span class="hljs-keyword">if</span>(currentsize &gt; tree_size)&#123;<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>                top --;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(top_val.root_node-&gt;<span class="hljs-built_in">lson</span>() == <span class="hljs-literal">nullptr</span>)&#123;<br>                top_val.pc = <span class="hljs-number">3</span>;<br>                st[++top] = <span class="hljs-built_in">Info</span>(currentsize, <span class="hljs-number">1</span>, top_val.root_node-&gt;<span class="hljs-built_in">rson</span>(), arr, tree_size);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                top_val.pc = <span class="hljs-number">2</span>;<br>                st[++top] = <span class="hljs-built_in">Info</span>(currentsize, <span class="hljs-number">1</span>, top_val.root_node-&gt;<span class="hljs-built_in">lson</span>(), arr, tree_size);<br>            &#125;<span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">if</span>(top_val.root_node-&gt;<span class="hljs-built_in">rson</span>() == <span class="hljs-literal">nullptr</span>)&#123;<br>                arr[currentsize] = top_val.root_node-&gt;<span class="hljs-built_in">data</span>();<br>                currentsize ++;<br>                <span class="hljs-keyword">if</span>(currentsize &gt; tree_size)&#123;<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>                top --;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                top_val.pc = <span class="hljs-number">3</span>;<br>                st[++top] = <span class="hljs-built_in">Info</span>(currentsize, <span class="hljs-number">1</span>, top_val.root_node-&gt;<span class="hljs-built_in">rson</span>(), arr, tree_size);<br>            &#125;<span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>            arr[currentsize] = top_val.root_node-&gt;<span class="hljs-built_in">data</span>();<br>                currentsize ++;<br>                <span class="hljs-keyword">if</span>(currentsize &gt; tree_size)&#123;<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>                top --;<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><blockquote><p>解释：</p><ul><li>这里使用的是<strong>模拟栈</strong>，就是一个原始数组。</li><li>分析递归调用的核心：<ul><li>定义<code>pc == 1</code>为初始状态<ul><li>这个时候函数开始执行，首先应该执行if语句，判断是否为叶节点<ul><li>如果是，那么说明递归到达终点，将此时的栈帧弹出（他已经完成了自己的使命）</li><li>如果不是，就需要完成以下操作：<ul><li>先遍历左子树（达到下一层递归）</li><li>遍历右子树（达到下一层递归）</li><li>遍历自身根节点</li></ul></li></ul></li></ul></li><li>于是我们便很轻松定义出<code>pc == 2</code> 和 <code>pc == 3</code> 的状态，分别代表已经遍历完成左子树和右子树。</li></ul></li></ul></blockquote><h2 id="Applications"><a href="#Applications" class="headerlink" title="Applications"></a>Applications</h2><h3 id="计算表达式"><a href="#计算表达式" class="headerlink" title="计算表达式"></a>计算表达式</h3><p>在学习<strong>栈</strong>的时候，我们学习了<strong>前缀表达式</strong>和<strong>中缀表达式</strong>，根本思想是利用<strong>运算符</strong>的优先级，通过栈来控制弹出顺序，从而达到计算顺序和输入顺序之间的差异。</p><p>我们是否可以使用树来完成这一操作？貌似可操作性非常的大！请看下面的<strong>表达式树</strong>：</p><p><img src="https://s1.imagehub.cc/images/2025/03/26/c76d32ad239b58520dbc7601d78043f3.png" alt="Tree for expressions"></p><p>这样的书写方式相比于波兰表达式更加的直观。同样的，计算分成两步：</p><ul><li>将中缀表达式转化成<strong>表达式二叉树</strong>。</li><li>对二叉树进行<strong>后序遍历</strong>，得到计算结果。<ul><li>此处还是需要栈来实现运算，如果一个运算符的两个节点全部遍历完成，此时需要完成该运算符的二元运算。</li></ul></li></ul><p>接下来我们来重点研究如何从中缀转成二叉树。</p><p>为什么我们可以写成<strong>二叉树</strong>的形式？关键原因在于运算符（所有的二元运算符）可以看成是一个<code>function</code>，换句话说，一个表达式的基本结构就是<code>function(a,b)</code>，而$a$与$b$都是对应的数，其可以在内部递归调用更小的运算（存在优先级），而这与<strong>二叉树的递归定义</strong>不谋而合！</p><p>也就是说，树的构建过程就是树的生长过程，这里看 <a href="https://www.bilibili.com/video/BV1Gq4y1i7BX?spm_id_from=333.788.videopod.episodes&vd_source=6955add1d28c52cd48096d58e09ce798&p=22">这个视频</a> 比较直观。本质上和中缀转后缀的过程相同！</p><p><strong>总结</strong>：</p><ul><li>顺序扫描中缀表达式</li><li>扫描的运算数<ul><li>运算树为空：作为第一个运算数保存。</li><li>运算树非空：作为上一运算符的<strong>右儿子</strong>。</li></ul></li><li>如果扫描到 <code>+</code> 或 <code>-</code>：<ul><li>在树中，由于我们最后是做的后序遍历，越靠近根节点的运算符越晚运算（相当于根节点的栈帧在最底层，最后被返回），而加减在运算符中的优先级是最低的，并且满足从左至右的顺序。</li><li>因此，<strong>需要直接将整颗子树下移，同时将其作为新的根节点</strong>（右子树保持空）</li></ul></li><li>如果扫描到 <code>*</code> 或 <code>\</code>:<ul><li>与当前的根节点进行比较：<ul><li>如果根节点也是乘除，那么当前运算符上提为根节点，而原树下移为左子树</li><li>如果根节点是加减，则优先级高于他，故下移成为其右子树的根，原先的右子树变成这个节点的左子树。</li></ul></li></ul></li></ul><p>现在我们加上对<strong>括号</strong>的处理：<strong>括号内部本质上就是调用一个子表达式！</strong></p><ul><li>遇到括号，将括号内部的子表达式<strong>构建成一颗子树作为整个表达式的一个运算数</strong>。</li></ul><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><p>You can see my Github repo for <a href="https://github.com/xiyuanyang-code/Data_structure/blob/master/single_files/Specific_USage/calculator2.cpp">Data Structure</a>!</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">Implementatin of expression of Binary Tree</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">calc</span>&#123;<br>    <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Type</span>&#123;DATA, ADD, SUB, MULTI, DIV, OPAREN, CPAREN, EOL&#125;;<br><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span><br>    <span class="hljs-comment">//define the binary tree</span><br>    &#123;<br>        Type type;<br>        <span class="hljs-type">int</span> data;<br>        node *lchild, *rchild;<br>        <span class="hljs-built_in">node</span> (Type t, <span class="hljs-type">int</span> d = <span class="hljs-number">0</span>, node *lc = <span class="hljs-literal">nullptr</span>, node *rc = <span class="hljs-literal">nullptr</span>)&#123;<br>            type = t;<br>            data = d;<br>            lchild = lc;<br>            rchild = rc;<br>        &#125;<br>    &#125;;<br>    <br>    <span class="hljs-keyword">private</span>:<br>        node* root;<br>    <br>        <span class="hljs-comment">//several tool function</span><br>        <span class="hljs-function">node* <span class="hljs-title">create</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>*&amp; s)</span></span>&#123;<br>            node *p = <span class="hljs-literal">nullptr</span>;<br>            node *root = <span class="hljs-literal">nullptr</span>;<br>            Type returntype;<br>            <span class="hljs-type">int</span> value;<br><br>            <span class="hljs-comment">//creating the new tree</span><br>            <span class="hljs-keyword">while</span>(*s)&#123;<br>                returntype = <span class="hljs-built_in">gettoken</span>(s, value);<br>                <span class="hljs-keyword">switch</span> (returntype)<br>                &#123;<br>                    <span class="hljs-keyword">case</span> DATA:<br>                    <span class="hljs-keyword">case</span> OPAREN:<br>                        <span class="hljs-keyword">if</span> (returntype == DATA) &#123;<br>                            p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">node</span>(DATA, value);<br>                        &#125; <span class="hljs-keyword">else</span> &#123;<br>                            p = <span class="hljs-built_in">create</span>(s);<br>                            <span class="hljs-comment">//if is a OPAREN, then we need to create a new subtree recursively!</span><br>                        &#125;<br><br>                        <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">nullptr</span>) &#123;<br>                            <span class="hljs-keyword">if</span>(root -&gt; rchild == <span class="hljs-literal">nullptr</span>)&#123;<br>                                root -&gt; rchild = p;<br>                            &#125;<span class="hljs-keyword">else</span>&#123;<br>                                <span class="hljs-comment">//it must be * or /</span><br>                                root -&gt; rchild -&gt; rchild = p;<br>                            &#125;<br>                        &#125;<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">case</span> CPAREN:<br>                    <span class="hljs-keyword">case</span> EOL:<br>                        <span class="hljs-comment">// the creation ends</span><br>                        <span class="hljs-keyword">return</span> root;<br>                    <span class="hljs-keyword">case</span> ADD:<br>                    <span class="hljs-keyword">case</span> SUB:<br>                        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>)&#123;<br>                            root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">node</span>(returntype, <span class="hljs-number">0</span>, p);<br>                            <span class="hljs-comment">//attention, in this case, the data 0 is meaningless for non-data operators;</span><br>                        &#125; <span class="hljs-keyword">else</span> &#123;<br>                            root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">node</span>(returntype, <span class="hljs-number">0</span>, root);<br>                        &#125;<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">case</span> MULTI:<br>                    <span class="hljs-keyword">case</span> DIV:<br>                        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)&#123;<br>                            root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">node</span>(returntype, <span class="hljs-number">0</span>, p);<br>                        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root -&gt; type == MULTI || root -&gt; type == DIV) &#123;<br>                            root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">node</span>(returntype, <span class="hljs-number">0</span>, root);<br>                        &#125; <span class="hljs-keyword">else</span> &#123;<br>                            root -&gt; rchild = <span class="hljs-keyword">new</span> <span class="hljs-built_in">node</span>(returntype, <span class="hljs-number">0</span>, root -&gt; rchild);<br>                        &#125;<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-comment">//return the root node of the tree</span><br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br><br>        <span class="hljs-function">Type <span class="hljs-title">gettoken</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *&amp;s, <span class="hljs-type">int</span> &amp;data)</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-type">char</span> type;<br><br>            <span class="hljs-keyword">while</span> (*s == <span class="hljs-string">&#x27; &#x27;</span>) ++s;          <span class="hljs-comment">// Skip spaces in the infix expression</span><br><br>            <span class="hljs-keyword">if</span> (*s &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; *s &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) &#123;   <span class="hljs-comment">// Encountered a number</span><br>                data = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">while</span> (*s &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; *s &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) &#123;<br>                    data = data * <span class="hljs-number">10</span> + *s - <span class="hljs-string">&#x27;0&#x27;</span>;<br>                    ++s;<br>                &#125;<br>                <span class="hljs-keyword">return</span> DATA;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (*s == <span class="hljs-string">&#x27;\0&#x27;</span>) <span class="hljs-keyword">return</span> EOL;<br><br>            type = *s; ++s;<br>            <span class="hljs-keyword">switch</span> (type) &#123;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>: <span class="hljs-keyword">return</span> ADD;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span>: <span class="hljs-keyword">return</span> SUB;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span>: <span class="hljs-keyword">return</span> MULTI;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/&#x27;</span>: <span class="hljs-keyword">return</span> DIV;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;(&#x27;</span>: <span class="hljs-keyword">return</span> OPAREN;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;)&#x27;</span>: <span class="hljs-keyword">return</span> CPAREN;<br>                <span class="hljs-keyword">default</span>: <span class="hljs-keyword">return</span> EOL;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">result</span><span class="hljs-params">(calc::node *t)</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-type">int</span> num1, num2;<br>        <br>            <span class="hljs-keyword">if</span> (t-&gt;type == DATA) <span class="hljs-keyword">return</span> t-&gt;data;<br>            num1 = <span class="hljs-built_in">result</span>(t-&gt;lchild);  <span class="hljs-comment">// Calculate the left sub-expression</span><br>            num2 = <span class="hljs-built_in">result</span>(t-&gt;rchild);  <span class="hljs-comment">// Calculate the right sub-expression</span><br>            <span class="hljs-keyword">switch</span> (t -&gt; type) &#123;<br>                <span class="hljs-keyword">case</span> ADD: t-&gt;data = num1 + num2; <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> SUB: t-&gt;data = num1 - num2; <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> MULTI: t-&gt;data = num1 * num2; <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> DIV: t-&gt;data = num1 / num2; <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> t-&gt;data;<br>        &#125;<br><br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">calc</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s)&#123;<br>            root = <span class="hljs-built_in">create</span>(s);<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">result</span><span class="hljs-params">()</span></span>&#123;<br>            <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">result</span>(root);<br>        &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    std::string exp;<br>    std::cin &gt;&gt; exp;<br>    <span class="hljs-function">calc <span class="hljs-title">cl</span><span class="hljs-params">(exp.c_str())</span></span>;<br><br>    std::cout &lt;&lt; cl.<span class="hljs-built_in">result</span>() &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="哈夫曼树和哈夫曼编码"><a href="#哈夫曼树和哈夫曼编码" class="headerlink" title="哈夫曼树和哈夫曼编码"></a>哈夫曼树和哈夫曼编码</h3><h4 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h4><p>在文本处理中，我们经常涉及到<strong>字符编码</strong>的问题，例如<strong>ASCII</strong>编码是一种等长的编码，但是在一些情况下为了提高效率，我们往往采用<strong>不等长编码</strong>，使<strong>频率较高的字符具有较短的编码而频率较低的字符具有较长的编码</strong>。</p><p>因此，在此处介绍<strong>哈夫曼树</strong>和<strong>哈夫曼编码</strong>，来实现最优化的非等长编码问题。</p><h4 id="前缀编码"><a href="#前缀编码" class="headerlink" title="前缀编码"></a>前缀编码</h4><p>对于等长的编码形式，使用<strong>完全二叉树</strong>来构建01序列即可解决。例如如果使用等长编码的完全二叉树来构建ASCII，需要7个二进制位，也就是$height &#x3D; 7$的一颗完全二叉树（在这里是满二叉树）可以构建成功。</p><p>很显然，对于等长编码，<strong>非叶节点的存储空间被浪费了</strong>，我们需要做出优化从而修改成非等长编码，但是在此之前，我们需要确立<strong>编码的前提</strong>：</p><ul><li>对于前缀编码而言，<strong>字符只放在叶节点</strong>中，换句话说，任何一个编码的子集（根节点）不可以作为一个新的编码，否则在解码的过程中会出现冲突（对于前缀编码而言）。<ul><li>为什么不可以放在根节点中？如果根节点$A$是一个字符的前缀01编码，其衍生出的根节点是在A的01编码的基础之上<strong>再加一位</strong>，产生冲突。</li></ul></li><li>本质上确定<strong>前缀可以被唯一解码</strong>。</li></ul><h4 id="哈夫曼算法"><a href="#哈夫曼算法" class="headerlink" title="哈夫曼算法"></a>哈夫曼算法</h4><p>确定目标：在给定一组字符集$S$的元素及其使用频率的情况下，使计算出最优化的非等长前缀编码算法，使得<strong>期望编码空间的空间使用</strong>最小。</p><p><strong>思路</strong>：</p><ul><li><strong>权值大的更靠近树根</strong></li><li><strong>权值小的更远离树根</strong>（相对的，我们希望每一个字符的编码长度都尽可能的短）</li></ul><div class="note note-primary">            <p>给定一个带有权值的集合 $T &#x3D; { T_1,T_2, T_3,T_4,T_5…T_n}$，在初始状态下$A &#x3D; T$，之后执行<strong>n-1</strong>次循环：</p><ul><li>从A中选择<strong>权值最小和次小</strong>的节点</li><li>生成新的内部节点$b$，$T_1$，$T_2$是其左右儿子，权值为$\omega_1 + \omega_2$.</li><li>将新节点放入集合中。</li></ul>          </div><p><img src="https://s1.imagehub.cc/images/2025/03/27/c1ea6598712843be773f6bc075839fd7.png" alt="Huffman Tree"></p><h4 id="Implementation-1"><a href="#Implementation-1" class="headerlink" title="Implementation"></a>Implementation</h4><p>在二叉树的过程中，“<strong>儿子找爸爸</strong>”和“<strong>爸爸找儿子</strong>”的情况都会发生。我们可以使用<strong>二叉树的广义存储结构</strong>来实现，同时，对于静态的编码问题，节点的个数保持不变，因此我们可以使用<strong>数组</strong>来存储每一个节点的值。接下来，我们实现哈夫曼算法的实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iomanip&gt;</span> </span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">hfTree</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;<br>        T data;<br>        <span class="hljs-type">int</span> weight;<br>        <span class="hljs-type">int</span> parent, left, right;<br>    &#125;;<br><br>    Node* elem;<br>    <span class="hljs-type">int</span> length; <span class="hljs-comment">// Fixed size of the tree</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">hfcode</span> &#123;<br>        T data;<br>        std::string code;<br>    &#125;;<br><br>    <span class="hljs-built_in">hfTree</span>(<span class="hljs-type">const</span> T* x, <span class="hljs-type">const</span> <span class="hljs-type">int</span>* w, <span class="hljs-type">int</span> size) &#123;<br>        <span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXINT = <span class="hljs-number">32767</span>;<br>        <span class="hljs-type">int</span> min_1, min_2; <span class="hljs-comment">// The lowest and second lowest weights</span><br>        <span class="hljs-type">int</span> least, second_least;<br><br>        <span class="hljs-comment">// Initialize</span><br>        length = <span class="hljs-number">2</span> * size;<br>        elem = <span class="hljs-keyword">new</span> Node[length];<br><br>        <span class="hljs-comment">// Initial values for leaf nodes</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = size; i &lt; length; ++i) &#123;<br>            elem[i].weight = w[i - size];<br>            elem[i].data = x[i - size];<br>            elem[i].parent = elem[i].right = elem[i].left = <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// Merge nodes to build the Huffman tree</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = size - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; --i) &#123;<br>            min_1 = min_2 = MAXINT;<br>            least = second_least = <span class="hljs-number">0</span>;<br><br>            <span class="hljs-comment">// Find the two smallest nodes without parents</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; length; j++) &#123;<br>                <span class="hljs-keyword">if</span> (elem[j].parent == <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">if</span> (elem[j].weight &lt; min_1) &#123;<br>                        min_2 = min_1;<br>                        min_1 = elem[j].weight;<br>                        second_least = least;<br>                        least = j;<br>                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (elem[j].weight &lt; min_2) &#123;<br>                        min_2 = elem[j].weight;<br>                        second_least = j;<br>                    &#125;<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-comment">// Update the new internal node</span><br>            elem[i].weight = min_1 + min_2;<br>            elem[i].left = second_least;<br>            elem[i].right = least;<br>            elem[i].parent = <span class="hljs-number">0</span>;<br>            elem[least].parent = i;<br>            elem[second_least].parent = i;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// Generate Huffman codes</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getcode</span><span class="hljs-params">(hfcode result[])</span> </span>&#123;<br>        <span class="hljs-type">int</span> size = length / <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> cur, cur_parent;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = size; i &lt; length; ++i) &#123;<br>            result[i - size].data = elem[i].data;<br>            result[i - size].code = <span class="hljs-string">&quot;&quot;</span>;<br>            cur_parent = elem[i].parent;<br>            cur = i;<br><br>            <span class="hljs-keyword">while</span> (cur_parent != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">if</span> (elem[cur_parent].left == cur) &#123;<br>                    result[i - size].code = <span class="hljs-string">&quot;0&quot;</span> + result[i - size].code;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    result[i - size].code = <span class="hljs-string">&quot;1&quot;</span> + result[i - size].code;<br>                &#125;<br>                cur = cur_parent;<br>                cur_parent = elem[cur_parent].parent;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// Visualize the tree structure</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">viewTree</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Huffman Tree Structure:\n&quot;</span>;<br>        <span class="hljs-built_in">viewTreeHelper</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>); <span class="hljs-comment">// Start from root (index 1) with depth 0</span><br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// Recursive helper function to print the tree</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">viewTreeHelper</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> depth)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (index &gt;= length || elem[index].weight == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br><br>        <span class="hljs-comment">// Print indentation based on depth</span><br>        std::cout &lt;&lt; std::<span class="hljs-built_in">setw</span>(depth * <span class="hljs-number">4</span>) &lt;&lt; <span class="hljs-string">&quot;&quot;</span>;<br><br>        <span class="hljs-comment">// Print node information</span><br>        <span class="hljs-keyword">if</span> (index &gt;= length / <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-comment">// Leaf node</span><br>            std::cout &lt;&lt; <span class="hljs-string">&quot;Leaf: &quot;</span> &lt;&lt; elem[index].data &lt;&lt; <span class="hljs-string">&quot; (Weight: &quot;</span> &lt;&lt; elem[index].weight &lt;&lt; <span class="hljs-string">&quot;)\n&quot;</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// Internal node</span><br>            std::cout &lt;&lt; <span class="hljs-string">&quot;Node (Weight: &quot;</span> &lt;&lt; elem[index].weight &lt;&lt; <span class="hljs-string">&quot;)\n&quot;</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// Recursively print left and right children</span><br>        <span class="hljs-built_in">viewTreeHelper</span>(elem[index].left, depth + <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">viewTreeHelper</span>(elem[index].right, depth + <span class="hljs-number">1</span>);<br>    &#125;<br><br><span class="hljs-keyword">public</span>:<br>    ~<span class="hljs-built_in">hfTree</span>() &#123;<br>        <span class="hljs-keyword">delete</span>[] elem;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// Test data</span><br>    <span class="hljs-type">char</span> ch[] = &#123;<span class="hljs-string">&#x27;H&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>, <span class="hljs-string">&#x27;m&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>, <span class="hljs-string">&#x27;f&#x27;</span>, <span class="hljs-string">&#x27;k&#x27;</span>&#125;;<br>    <span class="hljs-type">int</span> w[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">66</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>&#125;;<br><br>    <span class="hljs-function">hfTree&lt;<span class="hljs-type">char</span>&gt; <span class="hljs-title">tree</span><span class="hljs-params">(ch, w, <span class="hljs-number">10</span>)</span></span>;<br>    hfTree&lt;<span class="hljs-type">char</span>&gt;::hfcode result[<span class="hljs-number">10</span>];<br><br>    <span class="hljs-comment">// Generate and print Huffman codes</span><br>    tree.<span class="hljs-built_in">getcode</span>(result);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Huffman Codes:\n&quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>        std::cout &lt;&lt; result[i].data &lt;&lt; <span class="hljs-string">&quot;: &quot;</span> &lt;&lt; result[i].code &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-comment">// Visualize the Huffman tree</span><br>    tree.<span class="hljs-built_in">viewTree</span>();<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://builtin.com/software-engineering-perspectives/tree-traversal#:~:text=The%20types%20of%20tree%20traversal,traversal%20and%20level%20order%20traversal.">4 Types of Tree Traversal Algorithms | Built In</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tutorial</tag>
      
      <tag>Tree</tag>
      
      <tag>Finished</tag>
      
      <tag>Data Structure</tag>
      
      <tag>C/C++</tag>
      
      <tag>Binary Tree</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DataStructure-Tree</title>
    <link href="/posts/DataStructure-Tree/"/>
    <url>/posts/DataStructure-Tree/</url>
    
    <content type="html"><![CDATA[<style>  html, body, .markdown-body {    font-family: Georgia, sans, serif;  }</style><h1 id="Data-Structure-Tree"><a href="#Data-Structure-Tree" class="headerlink" title="Data Structure: Tree"></a>Data Structure: Tree</h1><p>The title image is from here.<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="[Invert a Binary Tree](https://medium.com/@theodoreyoong/coding-short-inverting-a-binary-tree-in-python-f178e50e4dac)">[2]</span></a></sup></p><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>This article introduces the fundamental knowledge about tree data structures, including the key concept of hierarchy in trees, the strict standard definition of trees, and the declaration of abstract base classes. Additionally, the article discusses the role of trees and provides basic knowledge about binary trees.</p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>在上一章的学习中，我们聚焦于<strong>线性数据结构——线性表</strong>，其本质特征和定义是：<strong>数据元素之间按照线性关系进行排列</strong>。同时，我们对线性表做了一些约束，衍生出更加具体的数据结构：</p><ul><li><p>从内存管理的视角进行约束</p><ul><li><p><strong>链接实现</strong></p></li><li><p><strong>顺序实现</strong></p></li></ul></li><li><p>从元素的进出次序的视角进行约束</p><ul><li><p>栈（LIFO）</p></li><li><p>队列（FIFO）</p></li><li><p>双端队列</p></li></ul></li><li><p>对数据元素的类型进行约束</p><ul><li>字符串</li></ul></li></ul><p>我们是时候开启一段新的旅程了，线性表的威力固然强大，但是记住，<strong>数据结构的本质是抽象的建模过程</strong>，但是很多时候简单的线性结构并不能模拟这个复杂的世界。</p><p>例如，我的文件夹：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs bash">.<br>├── 1.md<br>├── 1.txt<br>├── 3.md<br>├── 4.md<br>├── 5.md<br>├── README.md<br>├── bar<br>├── example.sh<br>├── foo<br>├── project42<br>├── scripts.py<br>├── <span class="hljs-built_in">test</span><br>│   ├── a.py<br>│   ├── b.py<br>│   ├── c.py<br>│   ├── d.py<br>│   ├── e.py<br>│   ├── f.py<br>│   ├── folder1<br>│   │   └── README.md<br>│   ├── folder2<br>│   │   └── README.md<br>│   ├── folder3<br>│   │   └── README.md<br>│   ├── folder4<br>│   │   └── README.md<br>│   ├── folder5<br>│   │   └── README.md<br>│   ├── folder6<br>│   │   └── README.md<br>│   ├── folder7<br>│   │   └── README.md<br>│   ├── folder8<br>│   │   └── README.md<br>│   ├── folder9<br>│   │   └── README.md<br>│   ├── g.py<br>│   ├── h.py<br>│   ├── helloa.txt<br>│   ├── hellob.txt<br>│   ├── helloc.txt<br>│   ├── hellod.txt<br>│   ├── helloe.txt<br>│   ├── i.py<br>│   └── j.py<br>├── thefilefolder<br>│   ├── 1.md<br>│   ├── 1.py<br>│   ├── 2.md<br>│   ├── 2.py<br>│   ├── 3.md<br>│   ├── 3.py<br>│   ├── 4.md<br>│   └── 5.md<br>└── vimtest.txt<br><br>14 directories, 41 files<br></code></pre></td></tr></table></figure><p>同理，对于许多<strong>具有等级划分或者结构层次</strong>的数据结构，线性表似乎显的有点无能为力。因此我们引入一种全新的数据结构：<strong>树</strong>，来刻画这样一种抽象关系。</p><h2 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h2><blockquote><p>为了方便展示，博客中的所有树状结构全部使用<strong>Mermaid</strong>流程图的形式。</p></blockquote><p>我们首先展示一个简单的树形结构：</p><pre><code class="mermaid" >graph TDA[Me] --> B[Son_1]A --> C[Son_2]A --> D[Son_3]B --> E[Grandson1_1]B --> F[Grandson1_2]C --> H[Grandson2_1]C --> I[Grandson2_2]D --> K[Grandson3_1]D --> L[Grandson3_2]</code></pre><p>根据这个可视化的树，我们一句一句给出树的<strong>标准定义</strong>：</p><ul><li><p><strong>树</strong>是若干个节点的有限集合。</p><ul><li><p>这句话阐明了树的<strong>基本元素</strong>是节点。</p></li><li><p>这是否也在暗示我们<strong>对于树的实现：链接貌似优于顺序？</strong>（后面再讨论）</p></li></ul></li><li><p>它可以是空集，也可以是以下的结构：</p><ul><li><p>存在<strong>根节点</strong></p></li><li><p>其他的节点可分割为有限个互不相交的集合，这些集合本身也是一棵树。</p></li></ul></li></ul><p>第二句话十分的重要，因为它本质就是<strong>树后续递归操作的底层原理</strong>，或者说<strong>树的递归定义</strong>。</p><p>这句话有以下几种理解方式：</p><ul><li><p><strong>一棵树可以根据根节点不断的做分割，直到变成空集</strong>。（分割的视角）</p></li><li><p><strong>一棵树根据层级的不同可以不断的向下延伸直到底部</strong>。（延伸的视角）</p></li></ul><h3 id="Fundamental-terminology"><a href="#Fundamental-terminology" class="headerlink" title="Fundamental terminology"></a>Fundamental terminology</h3><table><thead><tr><th>术语</th><th>描述</th></tr></thead><tbody><tr><td>节点 (Node)</td><td>树中的基本元素，包含数据和指向其他节点的链接。</td></tr><tr><td>根节点 (Root)</td><td>树的顶层节点，<strong>没有父节点</strong>。<strong>根节点唯一！</strong></td></tr><tr><td>父节点 (Parent)</td><td>一个节点的直接上级节点。</td></tr><tr><td>子节点 (Child)</td><td>一个节点的直接下级节点。</td></tr><tr><td>叶子节点 (Leaf)</td><td>没有子节点的节点，也称为终端节点。</td></tr><tr><td>内部节点 (Internal)</td><td>至少有一个子节点的非根节点。</td></tr><tr><td>兄弟节点 (Sibling)</td><td>具有相同父节点的节点。</td></tr><tr><td>祖先节点 (Ancestor)</td><td>从根节点到该节点的路径上的所有节点。</td></tr><tr><td>后代节点 (Descendant)</td><td>从该节点到叶子节点的路径上的所有节点。</td></tr><tr><td>子树 (Subtree)</td><td>树中的任意节点及其所有后代节点构成的树。</td></tr><tr><td>深度 (Depth)</td><td>从根节点到该节点的路径长度。</td></tr><tr><td>高度 (Height)</td><td>从该节点到叶子节点的最长路径长度。树的高度是根节点的高度。</td></tr><tr><td>层次 (Level)</td><td>根节点为第1层，其子节点为第2层，以此类推。</td></tr><tr><td>度 (Degree)</td><td>节点的子节点数量。树的度是树中节点的最大度数。</td></tr><tr><td>路径 (Path)</td><td>从一个节点到另一个节点的节点序列。</td></tr><tr><td>森林 (Forest)</td><td>由若干棵互不相交的树组成的集合。</td></tr><tr><td>二叉树 (Binary Tree)</td><td>每个节点最多有两个子节点的树。</td></tr><tr><td>满二叉树 (Full Binary Tree)</td><td>每个节点都有0个或2个子节点的二叉树。</td></tr><tr><td>完全二叉树 (Complete Binary Tree)</td><td>除了最后一层，其他层都是满的，且最后一层节点尽量靠左的二叉树。</td></tr><tr><td>平衡二叉树 (Balanced Binary Tree)</td><td>左右子树高度差不超过1的二叉树。</td></tr><tr><td>二叉搜索树 (Binary Search Tree)</td><td>左子树节点值小于根节点，右子树节点值大于根节点的二叉树。</td></tr><tr><td>前序遍历 (Preorder Traversal)</td><td>先访问根节点，然后左子树，最后右子树。</td></tr><tr><td>中序遍历 (Inorder Traversal)</td><td>先访问左子树，然后根节点，最后右子树。</td></tr><tr><td>后序遍历 (Postorder Traversal)</td><td>先访问左子树，然后右子树，最后根节点。</td></tr><tr><td>层序遍历 (Level Order Traversal)</td><td>按层次从上到下、从左到右访问节点。</td></tr></tbody></table><h3 id="Fundamental-Computations"><a href="#Fundamental-Computations" class="headerlink" title="Fundamental Computations"></a>Fundamental Computations</h3><p><strong>树的基本逻辑关系是父子关系，或者说等级关系</strong>。以下是树的常见运算：</p><ul><li><p><code>create()</code> : create a new tree.</p></li><li><p><code>clear()</code> : clear all nodes in a tree.</p></li><li><p><code>isEmpty()</code> : judge whether a tree is clean.</p></li><li><p><code>root()</code> : find the value of the root node. </p></li><li><p><code>parent(x)</code> : find the parent value of node <code>x</code>.</p></li><li><p><code>child(x, i)</code> : find the <code>i</code>th child value of node <code>x</code>.</p></li><li><p><code>remove(x, i)</code> : remove the <code>i</code>th child subtree of node <code>x</code>.</p></li><li><p><code>travese()</code> : traverse all the nodes in the tree.</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//Abstract class </span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Tree</span>&#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">create</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> T <span class="hljs-title">root</span><span class="hljs-params">(T invalid_flag)</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> T <span class="hljs-title">parent</span><span class="hljs-params">(T current_node, T invalid_flag)</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> T <span class="hljs-title">child</span><span class="hljs-params">(T current_node, <span class="hljs-type">int</span> tree_index, T invalid_flag)</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">remove</span> <span class="hljs-params">(T current_node, <span class="hljs-type">int</span> tree_index)</span> </span>= <span class="hljs-number">0</span>;<br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">traverse</span> <span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br><br>&#125;;<br></code></pre></td></tr></table></figure><p>注意的是，函数声明中的<code>invalid_flag</code>是针对找不到根节点，找不到父节点或者找不到子节点而设计的。</p><h2 id="What’s-Next？"><a href="#What’s-Next？" class="headerlink" title="What’s Next？"></a>What’s Next？</h2><p>我们来想想具体如何实现树形结构，貌似有一点复杂，因为树的结构本身比较复杂，更不用提<strong>插入、删除、翻转节点这类更加复杂的操作了</strong>。因此，我们从最简单的情形出发：即<strong>一个节点至多延伸出两个子节点</strong>。</p><p>我们把这种树定义为<strong>二叉树</strong>，另一种递归的定义方式：<strong>一个树或者为空，或者由一个根节点及两颗互不相交的子树构成。而子树也是二叉树。</strong></p><p>例如上面的树很明显不是一个二叉树，因为Me有三个儿子。如果老三不存在，那就是一颗比较完美的二叉树（满二叉树）：</p><pre><code class="mermaid" >graph TDA[Me] --> B[Son_1]A --> C[Son_2]B --> E[Grandson1_1]B --> F[Grandson1_2]C --> H[Grandson2_1]C --> I[Grandson2_2]</code></pre><p>关于二叉树我们会在下一篇文章中详细讨论。</p><blockquote><p><strong>彩蛋</strong>：当你学习完二叉树的时候，记得回来看一看，一定会对树有着更深的认识和见解！</p></blockquote><h2 id="Tree-and-Forests"><a href="#Tree-and-Forests" class="headerlink" title="Tree and Forests"></a>Tree and Forests</h2><blockquote><p>请务必在学习完<strong>二叉树</strong>的基本知识之后再来学习本章。</p></blockquote><h3 id="广义树的存储实现"><a href="#广义树的存储实现" class="headerlink" title="广义树的存储实现"></a>广义树的存储实现</h3><p>在二叉树中，<strong>孩子的个数和种类</strong>是具有严格规定的，只有左儿子和右儿子并且需要严格区分。但是对于<strong>一般的树而言</strong>，孩子的数目是不固定的，节点可以有很多个子节点，也可以没有子节点。因此，此时采用二叉树的<strong>广义存储</strong>结构会显得非常赘余，因为节点的儿子数可以动态改变。因此，我们需要探寻一种新的<strong>可以存储广义树</strong>的节点存储方式。下面介绍<strong>孩子链表示法</strong>和<strong>孩子兄弟表示法</strong>，以及其对应的<strong>遍历顺序</strong>。</p><h4 id="孩子链表示法"><a href="#孩子链表示法" class="headerlink" title="孩子链表示法"></a>孩子链表示法</h4><p>我们从<strong>块状链表</strong>的思想优化广义树的存储实现。因此，可以把<strong>每个结点的所有孩子组织成一个链表</strong>，结点的设置可以优化为：</p><ul><li>储存数据的<code>data</code></li><li>指向孩子链的指针</li></ul><p>如果我们把树的所有节点全部放进一个数组中，这个就是<strong>广义树的静态存储</strong>。也可以组织成一个链表（那就是块状链表），那就是动态的孩子链表。此外，我们也可以在表头数组中额外添加一个存储父节点位置的字段，称为<strong>带双亲的孩子链表示法</strong>。</p><h4 id="孩子兄弟链表示法"><a href="#孩子兄弟链表示法" class="headerlink" title="孩子兄弟链表示法"></a>孩子兄弟链表示法</h4><p>在孩子链表示法中，我们在本质上只是使用<strong>数组存储每一个结点</strong>，但优化了有关<strong>孩子</strong>的存储。我们可以换一种思路，使用二叉树来表示广义树：</p><ul><li>左指针指向孩子链表</li><li>右指针指向兄弟链表</li></ul><p>这样的存储让<strong>树的结构更加的清晰</strong>，让不同层级（高度）的结点可以快速找到子节点。同时，其与二叉树的联结更加紧密，树本质上还是二叉树的形态。</p><p><img src="https://s1.imagehub.cc/images/2025/03/27/e27083f15c650ddc99e3aafbdcb4f686.png" alt="child and brothers"></p><h4 id="双亲表示法"><a href="#双亲表示法" class="headerlink" title="双亲表示法"></a>双亲表示法</h4><p>一个爸爸可以有很多儿子，但是<strong>一个儿子只能有一个爸爸！</strong>在双亲表示法中，我们只需要储存<strong>对应节点的父亲节点</strong>即可成功建树。使用双亲表示法能够快速上升到根节点，但是无法下降到叶子结点。</p><h3 id="森林"><a href="#森林" class="headerlink" title="森林"></a>森林</h3><p><strong>Definition</strong>：树的集合 &amp; 树的序列</p><blockquote><p>在哈夫曼算法中，对于集合中的数不断<strong>归并</strong>的过程也可以算作是森林的归并形式！</p></blockquote><p>因此，对于森林，我们考虑<strong>将森林转化成一整颗二叉树</strong>的过程：</p><ul><li>将每棵树转换成对应的二叉树，得到二叉树的集合。（使用孩子兄弟链的表示）</li><li>将$B_i$作为$B_{i-1}$作为根节点的右节点，使数不断延伸。</li></ul><blockquote><p>为什么需要这样做？这与<strong>孩子兄弟链</strong>表示法有关，在孩子兄弟链的生成过程中，<strong>根节点</strong>没有兄弟，因此<strong>根节点</strong>的右节点始终为空。我们可以使用这个位置的空缺来连接上新的二叉树，实现二叉树对森林高效存储。</p></blockquote><p>如果需要从二叉树反解码成森林，我们可以从根节点开始<strong>不断移动到右子节点</strong>并且不断拆分成每一棵子树。</p><h2 id="Applications"><a href="#Applications" class="headerlink" title="Applications"></a>Applications</h2><p>这篇文章<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="[Applications of tree data structure - GeeksforGeeks](https://www.geeksforgeeks.org/applications-of-tree-data-structure/)">[1]</span></a></sup>详细的介绍了树形结构的相关应用，总结一下就是：</p><p>树的主要用途和应用场景包括：</p><ol><li><strong>存储层次化数据</strong>：如文件系统、DOM模型、DNS系统等，这些数据天然具有层次结构。</li><li><strong>高效的搜索</strong>：二叉搜索树等树结构可以在对数时间内完成搜索，比线性数据结构更高效。</li><li><strong>排序</strong>：自平衡二叉搜索树等可以在插入数据时自动排序，方便查找最小、最大值等。</li><li><strong>动态数据管理</strong>：树结构可以动态增长和收缩，适合数据频繁变化的场景，如实时系统。</li><li><strong>高效的插入和删除</strong>：树结构提供了高效的插入和删除算法，适合需要频繁增删数据的应用。</li><li><strong>易于实现</strong>：相比图等复杂数据结构，树结构相对容易实现，广泛应用于编程项目中。</li></ol><p>其他应用场景包括：</p><ul><li><strong>存储层次化数据</strong>：如文件夹结构、组织架构、XML&#x2F;HTML数据等。</li><li><strong>二叉搜索树</strong>：用于快速搜索、插入、删除排序数据。</li><li><strong>堆</strong>：用于实现优先队列。</li><li><strong>B树和B+树</strong>：用于数据库索引。</li><li><strong>语法树</strong>：用于编译器设计中的代码扫描、解析和表达式求值。</li><li><strong>K-D树</strong>：用于组织K维空间中的点。</li><li><strong>Trie树</strong>：用于实现字典的前缀查找。</li><li><strong>后缀树</strong>：用于快速模式搜索。</li><li><strong>生成树和最短路径树</strong>：用于计算机网络中的路由器和网桥。</li><li><strong>决策树</strong>：用于人工智能中的决策算法。</li><li><strong>组织结构图</strong>：用于大型组织的层级结构。</li><li><strong>XML解析器</strong>：用于解析XML文档。</li><li><strong>机器学习算法</strong>：如决策树算法。</li><li><strong>数据库索引</strong>：用于高效的数据检索。</li><li><strong>DNS服务器</strong>：用于域名解析。</li><li><strong>计算机图形学</strong>：用于图像合成和视觉效果。</li><li><strong>表达式求值</strong>：用于计算算术表达式。</li><li><strong>游戏算法</strong>：如象棋游戏中的防守走法存储。</li><li><strong>Java虚拟机</strong>：用于管理和组织数据。</li></ul><p><strong>Tree is so important!</strong></p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://www.geeksforgeeks.org/applications-of-tree-data-structure/">Applications of tree data structure - GeeksforGeeks</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://medium.com/@theodoreyoong/coding-short-inverting-a-binary-tree-in-python-f178e50e4dac">Invert a Binary Tree</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tutorial</tag>
      
      <tag>Tree</tag>
      
      <tag>Finished</tag>
      
      <tag>Data Structure</tag>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Regular-Expression</title>
    <link href="/posts/Regular-Expression/"/>
    <url>/posts/Regular-Expression/</url>
    
    <content type="html"><![CDATA[<style>  html, body, .markdown-body {    font-family: Georgia, sans, serif;  }</style><h1 id="Regular-Expression-EN"><a href="#Regular-Expression-EN" class="headerlink" title="Regular Expression (EN)"></a>Regular Expression (EN)</h1><blockquote><p>The Blog is written in English, than Google translate into Chinese.</p></blockquote><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>What is Regular Expression? Lets have a look at Wikipedia’s definition:</p><blockquote><p>A <strong>regular expression</strong> (shortened as <strong><code>regex</code></strong> or <strong><code>regexp</code></strong>), sometimes referred to as <strong>rational expression</strong>, is a sequence of <a href="https://en.wikipedia.org/wiki/Character_(computing)">characters</a> that specifies a <a href="https://en.wikipedia.org/wiki/Pattern_matching">match pattern</a> in <a href="https://en.wikipedia.org/wiki/String_(computer_science)">text</a>. Usually such patterns are used by <a href="https://en.wikipedia.org/wiki/String-searching_algorithm">string-searching algorithms</a> for “find” or “find and replace” operations on <a href="https://en.wikipedia.org/wiki/String_(computer_science)">strings</a>, or for <a href="https://en.wikipedia.org/wiki/Data_validation">input validation</a>. Regular expression techniques are developed in <a href="https://en.wikipedia.org/wiki/Theoretical_computer_science">theoretical computer science</a> and <a href="https://en.wikipedia.org/wiki/Formal_language">formal language</a> theory.</p></blockquote><p>From the text above, we can conclude that:</p><ul><li>Regex is a <strong>sequence of characters</strong>, or we can say <strong>Regex is a special kind of string</strong>.</li><li>Regex is powerful in <strong>String searching algorithms</strong>.</li></ul><p>To explain this more clearly, let’s assume we have the following C++ program.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;random&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">SearchString</span><span class="hljs-params">(std::string text, std::string target)</span></span>&#123;<br>    <span class="hljs-comment">//There are some powerful algorithms here</span><br><br>    <span class="hljs-comment">//We just create a random number!</span><br>    std::random_device rd;  <br>    <span class="hljs-function">std::mt19937 <span class="hljs-title">gen</span><span class="hljs-params">(rd())</span></span>; <br>    std::uniform_int_distribution&lt;&gt; <span class="hljs-built_in">dis</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>); <br><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">dis</span>(gen);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    std::string text;<br>    std::string target;<br>    std::cout &lt;&lt; (<span class="hljs-built_in">SearchString</span>(text, target) ? <span class="hljs-string">&quot;Matched&quot;</span> : <span class="hljs-string">&quot;Mismatched&quot;</span>) &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>Assuming that we have a powerful algorithm (like <strong>KMP</strong> algorithm) that could judge whether there exists a target string in the whole text, which is shown in the <code>SearchSting</code> function. For example, <code>text</code> is <code>I love SJTU</code> while <code>target</code> is <code>SJTU</code>, then the program will output “Matched”!</p><p>But we want to make the function more powerful, like: I want to search whether there is a sentence that has the structure of <code>I love ...</code>, where <code>...</code> means any word consisting of four uppercase English letters. Or we can say we expect the consequences as below:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">target: I love `XXXX`(4 uppercase English Letters)<br>text1: I love SJTU                                    `Matched!`<br>text2: I love FUDAN                                    `Matched!(The funtion reads FUDA)`<br>text3: I love CUDA                                    `Matched`<br>text4: I love CuDA                                    `Mismatched`<br>text5: I love C0DA                                    `Mismatched`<br></code></pre></td></tr></table></figure><p>We definitely can implement the function by adding some code into <code>SearchString</code>, but it compromises universality. Over time, the algorithm has turned into a pile of if-else statements, resembling a mountain of messy code. In a word, the algorithm seems weak when facing <strong>more lenient string matching problems with more detailed requirements</strong>.</p><p>This problem does exist in the real world! For example, if you want to search all the files with suffix <code>.md</code>, how would you implement this using the command line?</p><h3 id="Regex-counts"><a href="#Regex-counts" class="headerlink" title="Regex counts!"></a>Regex counts!</h3><p>This is where the power of <strong>Regex</strong> shines. Regex offers advanced pattern matching capabilities, supporting complex patterns, quantifiers, character classes, and groups, which simple string matching lacks, enabling more flexible and powerful text search and manipulation. Moreover, regex plays as a powerful tool in programming language like <strong>Python</strong> and <strong>Javascripts</strong>. All the demos in the text will use <strong>Python</strong> as the demonstrating language.</p><p>For the questions above, we can use <strong>Regex</strong> to search files with certain suffixes using only one command line!</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">find . -<span class="hljs-built_in">type</span> f -regex <span class="hljs-string">&#x27;.*\.md$&#x27;</span><br></code></pre></td></tr></table></figure><p><img src="https://ooo.0x0.ooo/2025/02/01/OGtRCq.png" alt="Search Files with certain suffixes"></p><p>In today’s Blog, we will master the basic usage of <strong>Regex</strong> and implement some simple applications using Regex.</p><h2 id="Basic-Usage"><a href="#Basic-Usage" class="headerlink" title="Basic Usage"></a>Basic Usage</h2><h3 id="Learning-maps"><a href="#Learning-maps" class="headerlink" title="Learning maps"></a>Learning maps</h3><p>After knowing what Regex can do, next question we need to clarify is <strong>What Regex truly is</strong>.</p><ul><li>The fundamental principle: <strong>Regex is used for string matching problems.</strong></li><li>To say more specifically, for <strong>more complex</strong> string matching problems.</li></ul><p>What is <strong>complex</strong>? Assume that there is a picky person asking you to find all the strings with some peculiar and bizarre rules. It’s easy for you to understand the rules while hard for computers to do so. Therefore we can say: <strong>Regex is a series of laws to make computers understand “peculiar and bizarre rules” of complex string matching problems.</strong></p><blockquote><p>Like the question above, “find all file names with certain suffix ‘.md’” is a certain kind of <strong>peculiar and bizarre rules</strong>.</p></blockquote><p>There are countless peculiar and bizarre rules for string matching, and people intelligently <strong>create a system to unify</strong> recordings for these peculiar and bizarre rules.</p><table><thead><tr><th>Syntax</th><th>Explanations</th></tr></thead><tbody><tr><td><strong>Special Position Matching</strong></td><td>✅Characters that match the <strong>start</strong> and <strong>end</strong> of a string or a word.<br>✅<strong>Zero-Width Assertion</strong>: match customized certain positions.</td></tr><tr><td><strong>Special Character Matching</strong></td><td>✅Numbers, words, null characters.<br><strong>✅Escape characters for Metacharacter</strong>.<br>✅Wildcard</td></tr><tr><td><strong>Character Classes</strong></td><td>✅Match <strong>one character</strong> from a <strong>set of possible characters</strong>.</td></tr><tr><td><strong>Repetition</strong> and <strong>Capturing</strong></td><td>✅Quantifiers<br>✅Grouping<br>✅Capturing</td></tr></tbody></table><blockquote><p>So regex is just a hand-made syntax rule for string-matching problems! Don’t be afraid, and you can learn Regex gradually through your learning and working process. You don’t need to learn all the Regex syntax for it doesn’t make sense for most of the circumstances.</p></blockquote><h3 id="Metacharacters"><a href="#Metacharacters" class="headerlink" title="Metacharacters"></a>Metacharacters</h3><p>Metacharacters is characters that has <strong>different meanings</strong>, which is often used as the case and mark for special positions and characters. The table below shows several most frequently used metacharacters and we will discuss it during a concrete example. </p><table><thead><tr><th>Metacharacter</th><th>Description</th></tr></thead><tbody><tr><td><code>.</code></td><td>Matches any single character (except newline).</td></tr><tr><td><code>^</code></td><td>Matches the start of a string.</td></tr><tr><td><code>$</code></td><td>Matches the end of a string.</td></tr><tr><td><code>*</code></td><td>Matches 0 or more repetitions of the preceding element.</td></tr><tr><td><code>+</code></td><td>Matches 1 or more repetitions of the preceding element.</td></tr><tr><td><code>?</code></td><td>Matches 0 or 1 repetition of the preceding element (makes it optional).</td></tr><tr><td><code>\</code></td><td>Escapes a metacharacter (e.g., <code>\.</code> matches a literal dot).</td></tr><tr><td><code>[]</code></td><td>Matches any single character within the brackets (e.g., <code>[abc]</code>).</td></tr><tr><td><code>[^]</code></td><td>Matches any single character <strong>not</strong> within the brackets (e.g., <code>[^abc]</code>).</td></tr><tr><td><code>()</code></td><td>Groups patterns and captures the matched text.</td></tr><tr><td><code>&#123;&#125;</code></td><td>Specifies exact repetition (e.g., <code>a&#123;2,4&#125;</code> matches 2 to 4 <code>a</code>‘s).</td></tr><tr><td><code>\d</code></td><td>Matches any digit (equivalent to <code>[0-9]</code>).</td></tr><tr><td><code>\w</code></td><td>Matches any word character (letters, digits, underscore).</td></tr><tr><td><code>\s</code></td><td>Matches any whitespace character (space, tab, newline).</td></tr><tr><td><code>\b</code></td><td>Matches a word boundary.</td></tr><tr><td><code>\B</code></td><td>Matches a non-word boundary.</td></tr></tbody></table><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h3><p><strong>Learning Metacharacters</strong> is the most fundamental thing in learning Regex, as Regex’s power simply lies in searching different patterns and positions. In the Blog below, I will use a practical example to show readers how to use Regex in <strong>grep</strong> command to search for specific files and string patterns.</p><h4 id="Example-1-search-certain-file-name"><a href="#Example-1-search-certain-file-name" class="headerlink" title="Example 1: search certain file name"></a>Example 1: search certain file name</h4><p>This current directory is the place where I store all my Blog files in markdown format. If I type <code>ls</code> command, I will see all the files and folders in the current directories.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt; <span class="hljs-built_in">pwd</span><br>/mnt/d/Blog/source/_posts<br>&gt; <span class="hljs-built_in">ls</span><br>AI-indepth-reading-AlexNet<br>AI-indepth-reading-AlexNet.md<br>Above-All<br>Above-All.md<br>Algorithm-Introduction<br>Algorithm-Introduction.md<br>Bash-commands<br>Bash-commands.md<br>Bash-exercises<br>Bash-exercises.md<br>C-plus-plus-Primer-Plus-tutorial<br>C-plus-plus-Primer-Plus-tutorial.md<br>CMake-tutorial-episode2<br>CMake-tutorial-episode2.md<br>CMake-tutorial1<br>CMake-tutorial1.md<br>CS294-1-LLM-Reasoning<br>CS294-1-LLM-Reasoning.md<br>Class-Inheritance<br>Class-Inheritance.md<br>Code-Reuse-in-OOP<br>Code-Reuse-in-OOP.md<br>Data-Structure-Tutorial<br>Data-Structure-Tutorial.md<br>DataStructure-LinearList<br>DataStructure-LinearList.md<br>DataStructure-Queue<br>DataStructure-Queue.md<br>DataStructure-Stack<br>DataStructure-Stack.md<br>DataStructure-String<br>DataStructure-String.md<br>DataStructure-Tree<br>DataStructure-Tree-Binary-Tree<br>DataStructure-Tree-Binary-Tree.md<br>DataStructure-Tree.md<br>Dynamic-Memory-and-Classes<br>Dynamic-Memory-and-Classes.md<br>Exception-Handling-in-C-plus-plus<br>Exception-Handling-in-C-plus-plus.md<br>Input-and-Output-in-C-plus-plus<br>Input-and-Output-in-C-plus-plus.md<br>Introduction-to-OOP<br>Introduction-to-OOP.md<br>Jotting-References-and-Encapsulation-in-OOP<br>Jotting-References-and-Encapsulation-in-OOP.md<br>LaTeX-tutorial<br>LaTeX-tutorial.md<br>Leetcode-Mistake-collection<br>Leetcode-Mistake-collection-1-10<br>Leetcode-Mistake-collection-1-10.md<br>Leetcode-Mistake-collection-11-20<br>Leetcode-Mistake-collection-11-20.md<br>Leetcode-Mistake-collection-21-30<br>Leetcode-Mistake-collection-21-30.md<br>Leetcode-Mistake-collection-31-40<br>Leetcode-Mistake-collection-31-40.md<br>Leetcode-Mistake-collection.md<br>Life-musings<br>Life-musings.md<br>Linked-List-Implementation-Based-on-Structs<br>Linked-List-Implementation-Based-on-Structs.md<br>Linux-Bash-Introduction<br>Linux-Bash-Introduction.md<br>MYGITHUB-Lightweight-speech-recognition-conversion-model<br>MYGITHUB-Lightweight-speech-recognition-conversion-model.md<br>Missing-Semester-Notes<br>Missing-Semester-Notes.md<br>My-Posts<br>My-Posts.md<br>My-WorkFlow<br>My-WorkFlow.md<br>Pointers-Arrays-and-Functions<br>Pointers-Arrays-and-Functions.md<br>Python-Update-Learning<br>Python-Update-Learning.md<br>Python-advanced-File-Management<br>Python-advanced-File-Management.md<br>Python-cheatsheet<br>Python-cheatsheet.md<br>Python-tutorial<br>Python-tutorial.md<br>Regular-Expression<br>Regular-Expression.md<br>Tools-Tutorial<br>Tools-Tutorial.md<br>Vim-tutorial<br>Vim-tutorial.md<br>filenames.txt<br>hello-world.md<br></code></pre></td></tr></table></figure><p>If one day I want to search for all Blog files with <strong>Python</strong>, I can use the simple <code>grep</code> command like this:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ls</span> | grep -i <span class="hljs-string">&quot;python&quot;</span><br><span class="hljs-comment"># where -i means ignore whether it is the uppercase or the lowercase</span><br></code></pre></td></tr></table></figure><p>It will get result as below:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">Python-Update-Learning<br>Python-Update-Learning.md<br>Python-advanced-File-Management<br>Python-advanced-File-Management.md<br>Python-cheatsheet<br>Python-cheatsheet.md<br>Python-tutorial<br>Python-tutorial.md<br></code></pre></td></tr></table></figure><p>There are actually several sub-folders for storing blog images which I don;t want them to be displayed. Thus I can use Regex for searching <strong>speific suffixes</strong> as below:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">❯ <span class="hljs-built_in">ls</span> | grep -iE <span class="hljs-string">&quot;python.*\.md&quot;</span><br></code></pre></td></tr></table></figure><p><code>&quot;python.*\.md&quot;</code> : How to read Regex? just read it from left to right and <strong>take notice of every metacharacters for its special meaning</strong>! For example in this string, <code>python</code> contains no metacharacters and <code>.</code> is a <strong>very important metacharacters with the meaning of matching any single characters.</strong></p><p>And <code>*</code> is use for <strong>greedy research</strong>, which means matching 0 or more repetitions of the preceding element and make sure the matches as long as possible. So <code>.*</code> is a very powerful tool that matches all strings!</p><p><code>\</code> means <strong>escape characters</strong>, which is used for “escaping for the special functions for metacharacters”. If you want to match the metacharacters itself, you can use <code>\</code>! In this example, <code>\</code> is used for escaping <code>.</code>, which means to match the <code>.</code> itself.</p><p>So you now get to know how to search string with certain suffixes <code>.md</code>!</p><p>There are many other commands for more complex string-pattern matching, you can look up in the table above for searching accordingly!</p><h3 id="Advanced-Techniques"><a href="#Advanced-Techniques" class="headerlink" title="Advanced Techniques"></a>Advanced Techniques</h3><h4 id="Zero-Width-Assertion"><a href="#Zero-Width-Assertion" class="headerlink" title="Zero-Width Assertion"></a>Zero-Width Assertion</h4><p>Zero-width assertions are advanced features in regular expressions that allow you to <strong>match specific conditions at a position in the text without consuming characters</strong>. They are called “zero-width” because they do not contribute to the match result but instead assert whether a pattern exists (or does not exist) at a certain position.</p><h4 id="Types-of-Zero-Width-Assertions"><a href="#Types-of-Zero-Width-Assertions" class="headerlink" title="Types of Zero-Width Assertions:"></a>Types of Zero-Width Assertions:</h4><ol><li><strong>Positive Lookahead (<code>(?=...)</code>)</strong><br> Asserts that a pattern must follow the current position.<br> Example: <code>\d+(?= dollars)</code> matches numbers followed by “dollars” but does not include “dollars” in the match.</li><li><strong>Negative Lookahead (<code>(?!...)</code>)</strong><br> Asserts that a pattern must not follow the current position.<br> Example: <code>\d+(?! dollars)</code> matches numbers not followed by “dollars.”</li><li><strong>Positive Lookbehind (<code>(?&lt;=...)</code>)</strong><br> Asserts that a pattern must precede the current position.<br> Example: <code>(?&lt;=\$)\d+</code> matches numbers preceded by a dollar sign.</li><li><strong>Negative Lookbehind (<code>(?&lt;!...)</code>)</strong><br> Asserts that a pattern must not precede the current position.<br> Example: <code>(?&lt;!\$)\d+</code> matches numbers not preceded by a dollar sign.</li></ol><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>Just use regex in real practice! I will update this blog when I have some new comprehension for Regex~</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p><a href="https://regexr.com/">Regexr</a> : <strong>a powerful website for practicing Regex</strong>. </p><p><a href="https://www.regular-expressions.info/">https://www.regular-expressions.info/</a> : You can search for more advanced usage regarding Regex on this website.</p>]]></content>
    
    
    <categories>
      
      <category>Code</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tutorial</tag>
      
      <tag>string</tag>
      
      <tag>regular expression</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DataStructure-String</title>
    <link href="/posts/DataStructure-String/"/>
    <url>/posts/DataStructure-String/</url>
    
    <content type="html"><![CDATA[<style>  html, body, .markdown-body {    font-family: Georgia, sans, serif;  }</style><h1 id="Data-Structure-String"><a href="#Data-Structure-String" class="headerlink" title="Data Structure: String"></a>Data Structure: String</h1><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>This article reconstructs the underlying code of the <strong>string</strong> class from the perspective of data structures, including <strong>array-based sequential implementation</strong> and <strong>block list-based linked implementation</strong>. It also provides the usage of related functions in the string library. Subsequently, the article explains the classic string matching algorithm: the <strong>KMP</strong> algorithm and its applications, and finally introduces the concept of regular expressions.</p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>字符串在编程问题中很常见，在初学C++时，我们可以把字符串看成<strong>char类型的数组</strong>（C风格的字符串），同时C++引入了新的字符串类型：<strong>string</strong>。<code>string</code>类相比于传统的<code>char*</code>有着很多优势：</p><ul><li><p>根据<code>size</code>动态分配内存</p></li><li><p>不同手动回收堆上的内存</p></li><li><p>支持许多字符串操作</p></li></ul><p>在笔者的<a href="https://xiyuanyang-code.github.io/posts/Dynamic-Memory-and-Classes/">这篇博客</a>中，为了详细解释OOP中动态内存分配的使用，从一个<code>stringbad</code>类出发不断修改最终形成了一个还算健全的<code>string</code>类。本章作为<strong>线性数据结构</strong>的尾声，我们从<strong>数据结构</strong>的视角从底层重新审视<code>string</code>类并重写轮子。</p><h2 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h2><p>显而易见地，<code>string</code>类是一种线性数据结构，是<strong>线性表的一种特殊情况</strong>：</p><ul><li><p>线性表的每一个元素都是<strong>ASCII字符</strong>。</p></li><li><p>线性表有值等现实意义：例如”IloveSJTU”是一个字符串，是一个线性表，也可以说<strong>用双引号括起来的字符序列是字符串的值</strong>。</p></li></ul><blockquote><p>第二点有点钻牛角尖，读者只需了解：<strong>字符串是具有特殊的现实意义的</strong>，因此可以实现很多新的操作（例如运算符重载等等），而这些操作对于一般抽象的线性表而言很多是没有意义的。</p></blockquote><h2 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h2><p>接下来笔者给出线性表的常用操作：</p><ul><li><p>求字符个数 <code>length()</code></p></li><li><p>输出函数 <code>disp()</code></p></li><li><p><strong>经典增删查改四件套</strong></p><ul><li><p>插入函数 <code>insert(s1, start, s2)</code> ，在start处将s2插入进s1中</p></li><li><p>删除子串 <code>remove(s, start, len)</code></p></li><li><p>查找子串（<strong>这个问题很经典，我们会在KMP算法中实现</strong>）</p></li><li><p>修改：<strong>在这里我们实现字符串的赋值函数</strong> <code>copy(s1, s2)</code></p></li></ul></li><li><p>取子串 <code>substr(s, start, len)</code></p></li><li><p>字符串连接 <code>cat(s1, s2)</code></p></li><li><p>比较函数</p><ul><li><code>equal(s1, s2)</code>，<code>greater(s1, s2)</code>，<code>greaterEqual(s1, s2)</code>，<code>less(s1, s2)</code>，<code>lessEqual(s1, s2)</code></li></ul></li></ul><h3 id="Sequential-Implementation"><a href="#Sequential-Implementation" class="headerlink" title="Sequential Implementation"></a>Sequential Implementation</h3><p>下面我们来构思类的声明：</p><p>数据成员：一个char类型的指针（顺序存储字符），一个int值储存字符的大小。</p><blockquote><p>也可以将int值改写成一个<strong>返回int值的函数</strong>，但是这样做每一次求length都需要遍历字符串时间复杂度为O(n)，这里采用以空间换时间的做法。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">This is the implementation of hand-made string</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdexcept&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span> <span class="hljs-comment">//just for the min function</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><br><br><span class="hljs-comment">//Sequential implementation of string</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">seqString</span>&#123;<br>    <span class="hljs-keyword">friend</span> seqString <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> seqString&amp; s1, <span class="hljs-type">const</span> seqString&amp; s2);<br>    <span class="hljs-keyword">friend</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> seqString&amp; s1, <span class="hljs-type">const</span> seqString&amp; s2);<br>    <span class="hljs-keyword">friend</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-type">const</span> seqString&amp; s1, <span class="hljs-type">const</span> seqString&amp; s2);<br>    <span class="hljs-keyword">friend</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&gt;(<span class="hljs-type">const</span> seqString&amp; s1, <span class="hljs-type">const</span> seqString&amp; s2); <br>    <span class="hljs-keyword">friend</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&gt;=(<span class="hljs-type">const</span> seqString&amp; s1, <span class="hljs-type">const</span> seqString&amp; s2);<br>    <span class="hljs-keyword">friend</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> seqString&amp; s1, <span class="hljs-type">const</span> seqString&amp; s2);<br>    <span class="hljs-keyword">friend</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;=(<span class="hljs-type">const</span> seqString&amp; s1, <span class="hljs-type">const</span> seqString&amp; s2);<br>    <span class="hljs-keyword">friend</span> std::istream&amp; <span class="hljs-keyword">operator</span>&gt;&gt;(std::istream&amp; is,  seqString&amp; s);<br>    <span class="hljs-keyword">friend</span> std::ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="hljs-type">const</span> seqString&amp; s);<br><br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-type">char</span> *data;<br>        <span class="hljs-type">int</span> len = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">seqString</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* s=<span class="hljs-string">&quot;&quot;</span>);     <br>        <span class="hljs-built_in">seqString</span>(<span class="hljs-type">const</span> seqString&amp; other);   <br>        ~<span class="hljs-built_in">seqString</span>();<br>        seqString&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> seqString&amp; other);<br>        seqString&amp; <span class="hljs-keyword">operator</span>+=(<span class="hljs-type">const</span> seqString&amp; other);<br>        seqString&amp; <span class="hljs-keyword">operator</span>-=(<span class="hljs-type">const</span> seqString&amp; other);<br>        <span class="hljs-type">char</span> <span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> index) <span class="hljs-type">const</span>;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">const</span> seqString&amp; other, <span class="hljs-type">int</span> insertsize = <span class="hljs-number">-1</span>)</span></span>;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> deletelength, <span class="hljs-type">int</span> start =<span class="hljs-number">-1</span>)</span></span>;<br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">length</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>        <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>        <span class="hljs-function">seqString <span class="hljs-title">substr</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">int</span> leng)</span> <span class="hljs-type">const</span></span>;<br>&#125;;<br><br><span class="hljs-comment">//Defintion of Sequenial String</span><br><br><span class="hljs-comment">//default constructer</span><br>seqString::<span class="hljs-built_in">seqString</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>*s)&#123;<br>    <span class="hljs-comment">//first get the value of length;</span><br>    <span class="hljs-keyword">while</span>(s[len] != <span class="hljs-string">&#x27;\0&#x27;</span>)&#123;<br>        len++;<br>    &#125;<br>    data = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span> [len<span class="hljs-number">+1</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; s[i] != <span class="hljs-string">&#x27;\0&#x27;</span>; i++)&#123;<br>        data[i] = s[i];<br>    &#125;<br>    data[len] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>&#125;<br><br><span class="hljs-comment">//copy constructor</span><br>seqString::<span class="hljs-built_in">seqString</span>(<span class="hljs-type">const</span> seqString&amp; other)&#123;<br>    len = other.len;<br>    data = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span> [len<span class="hljs-number">+1</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= len; i++)&#123;<br>        data[i] = other.data[i];<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//destructor</span><br>seqString::~<span class="hljs-built_in">seqString</span>()&#123;<br>    <span class="hljs-keyword">delete</span>[] data;<br>&#125;<br><br><span class="hljs-comment">//overload of assignment operator</span><br>seqString&amp; seqString::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> seqString&amp; other)&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;other) <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    <span class="hljs-keyword">delete</span>[] data;<br>    len = other.len;<br>    data = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span> [len<span class="hljs-number">+1</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= len; i++)&#123;<br>        data[i] = other.data[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><br><span class="hljs-comment">//overload of &quot;+=&quot; operator</span><br>seqString&amp; seqString::<span class="hljs-keyword">operator</span>+=(<span class="hljs-type">const</span> seqString&amp; other)&#123;<br>    <span class="hljs-keyword">this</span> -&gt; <span class="hljs-built_in">insert</span>(len, other);<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><br><span class="hljs-comment">//overload of &quot;-=&quot; operator</span><br>seqString&amp; seqString::<span class="hljs-keyword">operator</span>-=(<span class="hljs-type">const</span> seqString&amp; other)&#123;<br>    seqString tmp = <span class="hljs-built_in">substr</span>(len - other.<span class="hljs-built_in">length</span>(), other.<span class="hljs-built_in">length</span>());<br>    <span class="hljs-keyword">if</span> (tmp == other)&#123;<br>        <span class="hljs-keyword">this</span> -&gt; <span class="hljs-built_in">remove</span>(len - other.<span class="hljs-built_in">length</span>(), other.<span class="hljs-built_in">length</span>());<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;Unmatched string&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//overload of index operator</span><br><span class="hljs-type">char</span> seqString::<span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> index) <span class="hljs-type">const</span>&#123;<br>    <span class="hljs-keyword">if</span>(index &lt; <span class="hljs-number">0</span> || index &gt;= len)&#123;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;Invalid index!&quot;</span>);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> data[index];<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//insert a string in the certain position</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">seqString::insert</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">const</span> seqString&amp; other, <span class="hljs-type">int</span> insertsize)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(insertsize == <span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-comment">//This means insert the whole size of other</span><br>        insertsize = other.<span class="hljs-built_in">length</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>( insertsize &lt; <span class="hljs-number">0</span> || insertsize &gt; other.<span class="hljs-built_in">length</span>())&#123;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;Invalid insert size!&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( start &lt; <span class="hljs-number">0</span> || start &gt; len)&#123;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;Invalid starting position!&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-type">char</span> *tmp = data;<br>        len += insertsize;<br>        data = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span> [len<span class="hljs-number">+1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; start; i++)&#123;<br>            data[i] = tmp[i];<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt; insertsize; i++)&#123;<br>            data[start + i] = other.data[i];<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = start; tmp[i] !=<span class="hljs-string">&#x27;\0&#x27;</span>; i++)&#123;<br>            data[i + insertsize] = tmp[i];<br>        &#125;<br>        data[len] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>        <span class="hljs-keyword">delete</span>[] tmp;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//remove a substring from a certain position</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">seqString::remove</span><span class="hljs-params">(<span class="hljs-type">int</span> deletelength,<span class="hljs-type">int</span> start )</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(start == <span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-comment">//then delete the last leng characters from the back</span><br>        start = len - deletelength;<br>        <span class="hljs-comment">//len represents the length of the whole string;</span><br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(start &lt; <span class="hljs-number">0</span> || start &gt;= len)&#123;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;Invalid starting position!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(start + deletelength &gt;= len)&#123;<br>        <span class="hljs-comment">//delete all the characters after the start index</span><br>        data [start] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>        len = start;<br>        <span class="hljs-type">char</span> * tmp = data;<br>        <span class="hljs-comment">//recycle the memory</span><br>        data = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span> [len<span class="hljs-number">+1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;= len; i++)&#123;<br>            data[i] = tmp[i];<br>        &#125;<br>        <span class="hljs-keyword">delete</span>[] tmp;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        len -= deletelength;<br>        <span class="hljs-type">char</span> *tmp = data;<br>        data = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span> [len<span class="hljs-number">+1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; start; i++)&#123;<br>            data[i] = tmp[i];<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = start + deletelength; tmp[i] != <span class="hljs-string">&#x27;\0&#x27;</span>; i++)&#123;<br>            data[i - deletelength] = tmp[i];<br>        &#125;<br>        data[len] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>        <span class="hljs-keyword">delete</span>[] tmp;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//get the length of the string</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">seqString::length</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>&#123;<br>    <span class="hljs-keyword">return</span> len;<br>&#125;<br><br><span class="hljs-comment">//judge whether the string is empty</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">seqString::isEmpty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>&#123;<br>    <span class="hljs-keyword">return</span> len == <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//get a substring from a certain position and a certain length</span><br><span class="hljs-function">seqString <span class="hljs-title">seqString::substr</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">int</span> sublength)</span> <span class="hljs-type">const</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(start &lt; <span class="hljs-number">0</span> || start &gt;= len)&#123;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;Invalid starting position!&quot;</span>);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">if</span>(sublength + start &gt;= len)&#123;<br>            sublength = len - start;<br>        &#125;<br><br>        seqString tmp; <span class="hljs-comment">//the target substring</span><br>        tmp.len = sublength;<br>        <span class="hljs-keyword">delete</span> tmp.data;<br>        tmp.data = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[tmp.len + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; sublength; i++)&#123;<br>            tmp.data[i] = data[start + i];<br>        &#125;<br>        tmp.data[tmp.len] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>        <span class="hljs-keyword">return</span> tmp;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//overload of plus operation</span><br>seqString <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> seqString&amp; s1, <span class="hljs-type">const</span> seqString&amp; s2)&#123;<br>    seqString tmp;<br>    tmp.len = s<span class="hljs-number">1.l</span>en + s<span class="hljs-number">2.l</span>en;<br>    <span class="hljs-keyword">delete</span>[] tmp.data;<br>    tmp.data = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[tmp.len + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s<span class="hljs-number">1.l</span>en; i++)&#123;<br>        tmp.data[i] = s<span class="hljs-number">1.</span>data[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s<span class="hljs-number">2.l</span>en; i++)&#123;<br>        tmp.data[i + s<span class="hljs-number">1.l</span>en] = s<span class="hljs-number">2.</span>data[i];<br>    &#125;<br>    tmp.data[tmp.len] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>    <span class="hljs-keyword">return</span> tmp;<br>&#125;<br><br><span class="hljs-comment">//several judgements</span><br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> seqString&amp; s1, <span class="hljs-type">const</span> seqString&amp; s2)&#123;<br>    <span class="hljs-keyword">if</span>(s<span class="hljs-number">1.l</span>en != s<span class="hljs-number">2.l</span>en) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; <span class="hljs-built_in">i</span>&lt; s<span class="hljs-number">1.l</span>en; i++)&#123;<br>        <span class="hljs-keyword">if</span>(s<span class="hljs-number">1.</span>data[i] != s<span class="hljs-number">2.</span>data[i]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-type">const</span> seqString&amp; s1, <span class="hljs-type">const</span> seqString&amp; s2)&#123;<br>    <span class="hljs-keyword">return</span> !(s1==s2);<br>&#125;<br><br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&gt;(<span class="hljs-type">const</span> seqString&amp; s1, <span class="hljs-type">const</span> seqString&amp; s2)&#123;<br>    <span class="hljs-type">int</span> minlength = std::<span class="hljs-built_in">min</span>(s<span class="hljs-number">1.l</span>en, s<span class="hljs-number">2.l</span>en);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; minlength; i++)&#123;<br>        <span class="hljs-keyword">if</span>(s1[i] != s2[i]) <span class="hljs-keyword">return</span> s1[i] &gt; s2[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> s<span class="hljs-number">1.l</span>en &gt; s<span class="hljs-number">2.l</span>en;<br>&#125;<br><br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&gt;=(<span class="hljs-type">const</span> seqString&amp; s1, <span class="hljs-type">const</span> seqString&amp; s2)&#123;<br>    <span class="hljs-keyword">return</span> s1 &gt; s2 || s1 == s2;<br>&#125;<br><br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> seqString&amp; s1, <span class="hljs-type">const</span> seqString&amp; s2)&#123;<br>    <span class="hljs-keyword">return</span> !(s1 &gt;= s2);<br>&#125;<br><br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;=(<span class="hljs-type">const</span> seqString&amp; s1, <span class="hljs-type">const</span> seqString&amp; s2)&#123;<br>    <span class="hljs-keyword">return</span> s1 &lt; s2 || s1 ==s2;<br>&#125;<br><br><span class="hljs-comment">//the overload function of &lt;&lt; and &gt;&gt; operator</span><br>std::istream&amp; <span class="hljs-keyword">operator</span>&gt;&gt;(std::istream&amp; is, seqString&amp; s) &#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> bufferSize = <span class="hljs-number">1024</span>;<br>    <span class="hljs-type">char</span> buffer[bufferSize];<br>    is &gt;&gt; buffer;<br><br>    <span class="hljs-type">int</span> inputLen = std::<span class="hljs-built_in">strlen</span>(buffer);<br><br>    <span class="hljs-keyword">if</span> (s.data) &#123;<br>        <span class="hljs-keyword">delete</span>[] s.data;<br>    &#125;<br><br>    s.data = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[inputLen + <span class="hljs-number">1</span>];<br>    std::<span class="hljs-built_in">strcpy</span>(s.data, buffer);<br>    s.len = inputLen;<br>    <span class="hljs-keyword">return</span> is;<br>&#125;<br><br>std::ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="hljs-type">const</span> seqString&amp; s)&#123;<br>    os &lt;&lt; s.data;<br>    <span class="hljs-keyword">return</span> os;<br>&#125;<br><br><br><span class="hljs-comment">//main function is used for debugging only</span><br><span class="hljs-comment">// Main function for debugging</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">seqString <span class="hljs-title">s1</span><span class="hljs-params">(<span class="hljs-string">&quot;Hello&quot;</span>)</span></span>;<br>    <span class="hljs-function">seqString <span class="hljs-title">s2</span><span class="hljs-params">(<span class="hljs-string">&quot;World&quot;</span>)</span></span>;<br><br>    <span class="hljs-comment">// Test operator+</span><br>    seqString s3 = s1 + s2;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;s1 + s2: &quot;</span> &lt;&lt; s3 &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// Test operator+=</span><br>    s1 += s2;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;s1 += s2: &quot;</span> &lt;&lt; s1 &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// Test operator-</span><br>    s1 -= s2;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;s1 -= s2: &quot;</span> &lt;&lt; s1 &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// Test operator[]</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;s1[1]: &quot;</span> &lt;&lt; s1[<span class="hljs-number">1</span>] &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// Test insert</span><br>    s<span class="hljs-number">1.</span><span class="hljs-built_in">insert</span>(<span class="hljs-number">1</span>, s2);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;s1 after insert: &quot;</span> &lt;&lt; s1 &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// Test remove</span><br>    s<span class="hljs-number">1.</span><span class="hljs-built_in">remove</span>(<span class="hljs-number">5</span>, <span class="hljs-number">1</span>);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;s1 after remove: &quot;</span> &lt;&lt; s1 &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// Test substr</span><br>    seqString s4 = s<span class="hljs-number">1.</span><span class="hljs-built_in">substr</span>(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;s1.substr(1, 3): &quot;</span> &lt;&lt; s4 &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// Test comparison operators</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;s1 == s2: &quot;</span> &lt;&lt; (s1 == s2) &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;s1 != s2: &quot;</span> &lt;&lt; (s1 != s2) &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;s1 &gt; s2: &quot;</span> &lt;&lt; (s1 &gt; s2) &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;s1 &lt; s2: &quot;</span> &lt;&lt; (s1 &lt; s2) &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Linked-Implementation"><a href="#Linked-Implementation" class="headerlink" title="Linked Implementation"></a>Linked Implementation</h3><p>接下来我们进行字符串的链接实现。最直接的方法就是使用单向链表，如下图所示（图选自Hello 算法）</p><p><img src="https://www.hello-algo.com/chapter_array_and_linkedlist/linked_list.assets/linkedlist_definition.png" alt="Linked List"></p><p>但是，这种方法 <strong>对空间的利用率太低</strong>，一个char字符是1字节，而存储一个指针变量 <strong>需要8字节（对于64位系统而言）</strong>。因此，我们可以使用 <strong>块状链表</strong> 来提高链表的空间利用率。</p><p><img src="https://oi-wiki.org/ds/images/kuaizhuanglianbiao.png" alt="linked list from OI wiki"></p><p>可以把块状链表当做 <strong>链表和连续数组</strong> 的一种tradeoff，链表有利于使用分裂的离散内存，而数组弥补了链表遍历复杂度高和空间利用率低等问题！</p><p>不过块状链表有个比较复杂的问题：<strong>元素的插入和删除</strong>依旧会带来较大的时间复杂度。如果每一个子数组都占满的话，那插入和删除的时间复杂度会是O(n)级别的，因此，<strong>空间换时间</strong>在此处仍然必要，<strong>我们需要再每个子数组中空余一部分空间方便后续的插入删除操作。</strong>同时，我们可能需要使用 <strong>分裂节点</strong> 或者 <strong>合并节点</strong> 的方法，让每一个数组中的空间利用率保持稳定。</p><p>例如下面的例子：</p><p><img src="https://ooo.0x0.ooo/2025/02/04/OGHQYx.png" alt="Block List"></p><p>如果该链表需要完成如下操作：<strong>在F后面插入字符串UVXYZ</strong>，那可以细分为这几步：</p><ul><li>分裂结点，让 EF 和 G 分离。</li><li>将 <strong>UVXYZ</strong> 打包成一个节点，这里因为超出限制，因此打包成了两个节点。</li><li>将打包好的节点（或者可以被称为一个<strong>子串</strong>） 插入到对应的位置。</li><li><strong>归并</strong>利用率比较低的节点。</li></ul><p><img src="https://ooo.0x0.ooo/2025/02/04/OGH0qj.png" alt="Node splitting and merging"></p><p>有了这些准备知识，我们可以给出字符串链接实现的声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">linkString</span>&#123;<br>    <span class="hljs-keyword">friend</span> linkString <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> linkString&amp; s1, <span class="hljs-type">const</span> linkString&amp; s2);<br>    <span class="hljs-keyword">friend</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> linkString&amp; s1, <span class="hljs-type">const</span> linkString&amp; s2);<br>    <span class="hljs-keyword">friend</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-type">const</span> linkString&amp; s1, <span class="hljs-type">const</span> linkString&amp; s2);<br>    <span class="hljs-keyword">friend</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&gt;(<span class="hljs-type">const</span> linkString&amp; s1, <span class="hljs-type">const</span> linkString&amp; s2); <br>    <span class="hljs-keyword">friend</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&gt;=(<span class="hljs-type">const</span> linkString&amp; s1, <span class="hljs-type">const</span> linkString&amp; s2);<br>    <span class="hljs-keyword">friend</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> linkString&amp; s1, <span class="hljs-type">const</span> linkString&amp; s2);<br>    <span class="hljs-keyword">friend</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;=(<span class="hljs-type">const</span> linkString&amp; s1, <span class="hljs-type">const</span> linkString&amp; s2);<br>    <span class="hljs-keyword">friend</span> std::istream&amp; <span class="hljs-keyword">operator</span>&gt;&gt;(std::istream&amp; is,  linkString&amp; s);<br>    <span class="hljs-keyword">friend</span> std::ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="hljs-type">const</span> linkString&amp; s);<br><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span><br>    &#123;<br>        <span class="hljs-type">int</span> size;    <span class="hljs-comment">//valuable numbers of chars in a block node</span><br>        <span class="hljs-type">char</span> *data;<br>        node *next;<br><br>        <span class="hljs-comment">//constructor</span><br>        <span class="hljs-built_in">node</span>(<span class="hljs-type">int</span> maxsize_ = <span class="hljs-number">1</span>, node *n_ = <span class="hljs-literal">nullptr</span>)&#123;<br>            data = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span> [maxsize_];<br>            size = <span class="hljs-number">0</span>;<br>            next = n_;<br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-keyword">private</span>:<br>        node *head; <span class="hljs-comment">//head pointer</span><br>        <span class="hljs-type">int</span> length;  <span class="hljs-comment">//length of the string</span><br>        <span class="hljs-type">int</span> nodesize; <span class="hljs-comment">//capacity for every block node</span><br><br>        <span class="hljs-comment">//several private function tools</span><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">//release all the memories</span><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">findPos</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">int</span>&amp; pos, node *&amp;p)</span> <span class="hljs-type">const</span></span>; <span class="hljs-comment">// find the position of the certain node</span><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">split</span><span class="hljs-params">(node *p, <span class="hljs-type">int</span> pos)</span></span>;  <span class="hljs-comment">//split nodes</span><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(node *p)</span></span>;  <span class="hljs-comment">//merge nodes</span><br><br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">linkString</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* s = <span class="hljs-string">&quot;&quot;</span>);          <span class="hljs-comment">// Constructor with default parameter</span><br>        <span class="hljs-built_in">linkString</span>(<span class="hljs-type">const</span> linkString&amp; other);     <span class="hljs-comment">// Copy constructor</span><br>        ~<span class="hljs-built_in">linkString</span>();                           <span class="hljs-comment">// Destructor</span><br>        linkString&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> linkString&amp; other);  <span class="hljs-comment">// Assignment operator overload</span><br>        linkString&amp; <span class="hljs-keyword">operator</span>+=(<span class="hljs-type">const</span> linkString&amp; other); <span class="hljs-comment">// Compound assignment operator overload (concatenation)</span><br>        linkString&amp; <span class="hljs-keyword">operator</span>-=(<span class="hljs-type">const</span> linkString&amp; other); <span class="hljs-comment">// Compound assignment operator overload (removal)</span><br>        <span class="hljs-type">char</span> <span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> index) <span class="hljs-type">const</span>;                <span class="hljs-comment">// Subscript operator overload</span><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">const</span> linkString&amp; other, <span class="hljs-type">int</span> insertsize = <span class="hljs-number">-1</span>)</span></span>; <span class="hljs-comment">// Insert operation</span><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> deletelength, <span class="hljs-type">int</span> start = <span class="hljs-number">-1</span>)</span></span>;   <span class="hljs-comment">// Remove operation</span><br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">length</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;                              <span class="hljs-comment">// Get the length of the string</span><br>        <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;                            <span class="hljs-comment">// Check if the string is empty</span><br>        <span class="hljs-function">linkString <span class="hljs-title">substr</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">int</span> leng)</span> <span class="hljs-type">const</span></span>;    <span class="hljs-comment">// Get a substring</span><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>研究表明，<strong>块状链表的节点容量和节点个数相同的时候</strong>，算法效率最高。<ul><li>因此，节点容量一个设置为：<code>sqrt(length)</code> ,来尽可能提高算法的效率。</li></ul></li></ul><div class="note note-primary">            <p><strong>附上数学推导</strong>：</p><ul><li>块状链表的查找操作需要遍历块（链表部分）和在块内查找（数组部分）。</li><li>如果节点容量过大，块内查找的时间会增加（因为数组部分变长）。</li><li>如果节点容量过小，块的数量会增加，导致链表部分变长，遍历块的代价增加。</li><li>当节点容量和节点个数相同时，查找和修改的代价达到平衡，整体效率最高。</li></ul><p>假设块状链表有 ( n ) 个元素，块的大小为 ( B )，块的数量为 ( M )，则 <code>n = BM</code>。</p><p> 查找、插入、删除操作的时间复杂度为 <code>O(M + B)</code>（考虑最坏的时间复杂度）。</p><p>做一点小小的数学变形：<code>O(M+B)</code> &#x3D; <code>O(n/B +B)</code>， 是一个对勾函数！因此在<code>sqrt(n)</code> 的时候取到最小值。</p>          </div><p>接下来就是函数的具体实现了，所有的源代码都来自于 <strong>《数据结构：思想与实现》</strong> ，经历了小小的改动。以下附上源代码：</p><p>我的Github 相关代码的仓库：<a href="https://github.com/xiyuanyang-code/Data_structure">GitHub - xiyuanyang-code&#x2F;Data_structure</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// definition</span><br><br><span class="hljs-comment">// default constructor</span><br>linkString::<span class="hljs-built_in">linkString</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s)<br>&#123;<br>    <span class="hljs-comment">// calculate the length of the string, you can just use strlen!</span><br>    length = std::<span class="hljs-built_in">strlen</span>(s);<br>    nodesize = (length == <span class="hljs-number">0</span>) ? <span class="hljs-number">1</span> : <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(std::<span class="hljs-built_in">sqrt</span>(length));<br>    node *p;<br>    p = head = <span class="hljs-keyword">new</span> <span class="hljs-built_in">node</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">while</span> (*s != <span class="hljs-string">&#x27;\0&#x27;</span>)<br>    &#123;<br>        p = p-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">node</span>(nodesize);<br>        <span class="hljs-keyword">for</span> (; (p-&gt;size &lt; nodesize) &amp;&amp; *s != <span class="hljs-string">&#x27;\0&#x27;</span>; ++s, ++p-&gt;size)<br>        &#123;<br>            p-&gt;data[p-&gt;size] = *s;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// copy constructor</span><br>linkString::<span class="hljs-built_in">linkString</span>(<span class="hljs-type">const</span> linkString &amp;other)<br>&#123;<br>    node *p, *otherp = other.head-&gt;next;<br><br>    <span class="hljs-comment">// copy the new linkstring</span><br>    p = head = <span class="hljs-keyword">new</span> <span class="hljs-built_in">node</span>(<span class="hljs-number">1</span>);<br>    length = other.length;<br>    nodesize = other.nodesize;<br>    <span class="hljs-keyword">while</span> (otherp != <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        p = p-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">node</span>(nodesize);<br>        <span class="hljs-keyword">for</span> (; (p-&gt;size) &lt; (otherp-&gt;size); ++(p-&gt;size))<br>        &#123;<br>            <span class="hljs-comment">// if p-&gt;size == other-&gt;size ,then all the valuable data has been copied successfully.</span><br>            p-&gt;data[p-&gt;size] = otherp-&gt;data[p-&gt;size];<br>        &#125;<br>        otherp = otherp-&gt;next; <span class="hljs-comment">// traverse the other link string</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief clear all the memory of the linked list (private func)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">linkString::clear</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    node *p = head-&gt;next, *nextp;<br>    <span class="hljs-comment">// nextp store next pointer temporarily</span><br>    <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        nextp = p-&gt;next;<br>        <span class="hljs-keyword">delete</span> p;<br>        p = nextp;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief destructor</span><br><span class="hljs-comment"> */</span><br>linkString::~<span class="hljs-built_in">linkString</span>()<br>&#123;<br>    <span class="hljs-built_in">clear</span>();<br>    <span class="hljs-keyword">delete</span> head;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief get the length of the string (public func)</span><br><span class="hljs-comment"> * @return the length of string</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">linkString::getlength</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> length;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief judge whether the string is empty</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">linkString::isEmpty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> length == <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief overload of assignment operator</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * @param other the rvalue (const reference) of the assignment operator</span><br><span class="hljs-comment"> * @return the reference of the assigned lvalue</span><br><span class="hljs-comment"> */</span><br>linkString &amp;linkString::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> linkString &amp;other)<br>&#123;<br>    <span class="hljs-keyword">if</span> (&amp;other == <span class="hljs-keyword">this</span>)<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br><br>    <span class="hljs-comment">// Clear the current list</span><br>    <span class="hljs-built_in">clear</span>();<br><br>    <span class="hljs-comment">// Copy the length and nodesize</span><br>    length = other.length;<br>    nodesize = other.nodesize;<br><br>    <span class="hljs-comment">// Copy the nodes</span><br>    node *p = head;<br>    node *otherp = other.head-&gt;next;<br><br>    <span class="hljs-keyword">while</span> (otherp != <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        p-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">node</span>(nodesize);<br>        p = p-&gt;next;<br><br>        <span class="hljs-comment">// Copy the data</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; otherp-&gt;size; ++i)<br>        &#123;<br>            p-&gt;data[i] = otherp-&gt;data[i];<br>        &#125;<br>        p-&gt;size = otherp-&gt;size;<br><br>        <span class="hljs-comment">// Move to the next node in the other list</span><br>        otherp = otherp-&gt;next;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief find the starting position of a given position</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * @param start the given position (or index)</span><br><span class="hljs-comment"> * @param pos find the position in the node (reference)</span><br><span class="hljs-comment"> * @param p find the node where the start lies in</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">linkString::findPos</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">int</span> &amp;pos, node *&amp;p)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;  <span class="hljs-comment">// define a counter</span><br>    p = head-&gt;next; <span class="hljs-comment">// the first node(pointer)</span><br><br>    <span class="hljs-keyword">while</span> (count &lt; start)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (count + p-&gt;size &lt; start)<br>        &#123;<br>            <span class="hljs-comment">// the start isn&#x27;t in this node!</span><br>            count += p-&gt;size;<br>            p = p-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-comment">// the start is in this node!</span><br>            pos = start - count;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief get a substring</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * @param start the start position</span><br><span class="hljs-comment"> * @param sublength the length of the substring</span><br><span class="hljs-comment"> * @throws std::out_of_range If pos is out of range.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">linkString <span class="hljs-title">linkString::substr</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">int</span> sublength)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>    linkString tmp; <span class="hljs-comment">// storing result</span><br>    <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> pos = <span class="hljs-number">0</span>;<br>    node *p, *tp = tmp.head;<br><br>    <span class="hljs-keyword">if</span> (start &lt; <span class="hljs-number">0</span> || start &gt;= length)<br>    &#123;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">out_of_range</span>(<span class="hljs-string">&quot;Invalid starting position!&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-comment">// if the length left is smaller than the given sublength:</span><br>        <span class="hljs-keyword">if</span> (start + sublength &gt;= length)<br>        &#123;<br>            sublength = length - start;<br>        &#125;<br><br>        tmp.length = sublength;<br>        tmp.nodesize = (sublength == <span class="hljs-number">0</span>) ? <span class="hljs-number">1</span> : <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(std::<span class="hljs-built_in">sqrt</span>(sublength));<br><br>        <span class="hljs-comment">// use the findPos function to find p and pos</span><br>        <span class="hljs-built_in">findPos</span>(start, pos, p);<br><br>        <span class="hljs-comment">// after getting the starting position, we can copy the substring!</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> index = <span class="hljs-number">0</span>; index &lt; tmp.length;)<br>        &#123;<br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">             * two for-loop layers, index represents the substring index</span><br><span class="hljs-comment">             * inner loop is used to copy every block, while the outer loop is used to update the block.</span><br><span class="hljs-comment">             */</span><br>            tp = tp-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">node</span>(tmp.nodesize);<br>            <span class="hljs-keyword">while</span> (tp-&gt;size &lt;= tmp.nodesize &amp;&amp; index &lt; tmp.length)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (pos == p-&gt;size)<br>                &#123;<br>                    <span class="hljs-comment">/*</span><br><span class="hljs-comment">                     * the traverse has ended in the block.</span><br><span class="hljs-comment">                     * p needs to be updated to the next block.</span><br><span class="hljs-comment">                     */</span><br>                    p = p-&gt;next;<br>                    pos = <span class="hljs-number">0</span>;<br>                &#125;<br>                tp-&gt;data[tp-&gt;size] = p-&gt;data[pos];<br><br>                <span class="hljs-comment">// value update</span><br>                pos++;<br>                index++;<br>                tp-&gt;size++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> tmp;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief Split operations for a block (one to two) (private func).</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * @param p The node to be split.</span><br><span class="hljs-comment"> * @param pos The specific index where the split happens (the pos position is moved to the second node).</span><br><span class="hljs-comment"> * @throws std::out_of_range If pos is out of range.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">linkString::split</span><span class="hljs-params">(node *p, <span class="hljs-type">int</span> pos)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// Check if p is nullptr</span><br>    <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">invalid_argument</span>(<span class="hljs-string">&quot;The node to be split is null.&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// Check if pos is within the valid range</span><br>    <span class="hljs-keyword">if</span> (pos &lt; <span class="hljs-number">0</span> || pos &gt; p-&gt;size)<br>    &#123;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">out_of_range</span>(<span class="hljs-string">&quot;The split position is out of range.&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// Create a new node and insert it after p</span><br>    node *nextp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">node</span>(nodesize, p-&gt;next);<br>    p-&gt;next = nextp;<br><br>    <span class="hljs-comment">// Move data from p to nextp</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = pos; i &lt; p-&gt;size; i++)<br>    &#123;<br>        nextp-&gt;data[i - pos] = p-&gt;data[i];<br>    &#125;<br><br>    <span class="hljs-comment">// Update sizes of both nodes</span><br>    nextp-&gt;size = p-&gt;size - pos; <span class="hljs-comment">// Size of the new node</span><br>    p-&gt;size = pos;               <span class="hljs-comment">// Size of the original node after split</span><br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief merge two nodes into one</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * @param p one of the nodes that need to be merged</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">linkString::merge</span><span class="hljs-params">(node *p)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">nullptr</span> || p-&gt;next == <span class="hljs-literal">nullptr</span>)<br>        <span class="hljs-keyword">return</span>;<br>    node *nextp = p-&gt;next;<br>    <span class="hljs-keyword">if</span> (p-&gt;size + nextp-&gt;size &lt;= nodesize)<br>    &#123;<br>        <span class="hljs-comment">// merge available</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> pos = <span class="hljs-number">0</span>; pos &lt; nextp-&gt;size; ++pos, ++p-&gt;size)<br>        &#123;<br>            p-&gt;data[p-&gt;size] = nextp-&gt;data[pos];<br>        &#125;<br>        p-&gt;next = nextp-&gt;next;<br>        <span class="hljs-keyword">delete</span> nextp;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief insert a string into linked string, using the findPos, split and merge functions</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * @param start the starting position (using findPos)</span><br><span class="hljs-comment"> * @param other the string that needs to be inserted</span><br><span class="hljs-comment"> * @param insertsize the length of the string needs to be inserted, default value for all string</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">linkString::insert</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">const</span> linkString &amp;other, <span class="hljs-type">int</span> insertsize)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (insertsize == <span class="hljs-number">-1</span>)<br>    &#123;<br>        insertsize = other.length;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (start &lt; <span class="hljs-number">0</span> || start &gt; length)<br>    &#123;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">out_of_range</span>(<span class="hljs-string">&quot;The insert position is out of range&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (insertsize &lt; <span class="hljs-number">0</span> || insertsize &gt; other.length)<br>    &#123;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">out_of_range</span>(<span class="hljs-string">&quot;Invalid insertsize&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * pos and p is calculated by func findPos, representing the insert position</span><br><span class="hljs-comment">     * nextp is right after p, which is used for the split func</span><br><span class="hljs-comment">     * after the insert, the merge function will be used</span><br><span class="hljs-comment">     */</span><br>    node *p, *nextp, *tmp;<br>    <span class="hljs-type">int</span> pos = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">findPos</span>(start, pos, p);<br>    <span class="hljs-built_in">split</span>(p, pos);<br><br>    nextp = p-&gt;next; <span class="hljs-comment">// nextp is used for stroage in case the link string is broken</span><br>    linkString tobeinserted = other.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, insertsize);<br>    tmp = tobeinserted.head-&gt;next;<br>    <span class="hljs-keyword">while</span> (tmp != <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        <span class="hljs-comment">// operate for every node</span><br>        <span class="hljs-keyword">for</span> (pos = <span class="hljs-number">0</span>; pos &lt; tmp-&gt;size; ++pos)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (p-&gt;size == nodesize)<br>            &#123;<br>                <span class="hljs-comment">// need for expansion</span><br>                p = p-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">node</span>(nodesize);<br>            &#125;<br>            p-&gt;data[p-&gt;size] = tmp-&gt;data[pos];<br>            ++p-&gt;size;<br>        &#125;<br>        tmp = tmp-&gt;next;<br>    &#125;<br><br>    length += insertsize;<br>    p-&gt;next = nextp;<br>    <span class="hljs-built_in">merge</span>(p); <span class="hljs-comment">// see whether the merge is available</span><br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief Remove the specific part of a linked string</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * @param deletelength the length to be deleted</span><br><span class="hljs-comment"> * @param start the starting position that needs tobe removed (the start itself is included), default for remove from the back</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">linkString::remove</span><span class="hljs-params">(<span class="hljs-type">int</span> deletelength, <span class="hljs-type">int</span> start)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (start == <span class="hljs-number">-1</span>)<br>    &#123;<br>        start = length - deletelength;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (start &lt; <span class="hljs-number">0</span> || start &gt;= length)<br>    &#123;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;Invalid starting position!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// find the position to be removed</span><br>    node *startp; <span class="hljs-comment">// represent the starting position to be deleted</span><br>    <span class="hljs-type">int</span> pos = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">findPos</span>(start, pos, startp);<br><br>    <span class="hljs-built_in">split</span>(startp, pos); <span class="hljs-comment">// split the node</span><br><br>    <span class="hljs-keyword">if</span> (start + deletelength &gt;= length)<br>    &#123;<br>        deletelength = length - start;<br>        length = start;<br>        <span class="hljs-comment">// if the deletelength goes over the edge</span><br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        length -= deletelength;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>    &#123;<br>        node *nextp = startp-&gt;next;<br>        <span class="hljs-keyword">if</span> (deletelength &gt; nextp-&gt;size)<br>        &#123;<br>            <span class="hljs-comment">// the end node is not here! Then delete this node!</span><br>            deletelength -= nextp-&gt;size;<br>            startp-&gt;next = nextp-&gt;next;<br>            <span class="hljs-keyword">delete</span> nextp;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-comment">// the end node is here!</span><br>            <span class="hljs-built_in">split</span>(nextp, deletelength);<br>            startp-&gt;next = nextp-&gt;next;<br>            <span class="hljs-comment">// now the nextp is all the data needs tobe deleted, while nextp-&gt;next stores the data remaining</span><br>            <span class="hljs-keyword">delete</span> nextp;<br>            <span class="hljs-keyword">break</span>; <span class="hljs-comment">// jump out of the loop after the remove operation is done!</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">merge</span>(startp); <span class="hljs-comment">// merge all the startp;</span><br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief Overloads the [] operator to access a character at a specific index in the linkString.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * @param index The position of the character to access (0-based index).</span><br><span class="hljs-comment"> * @return The character at the specified index.</span><br><span class="hljs-comment"> * @throws std::out_of_range If the index is invalid (less than 0 or greater than or equal to the string length).</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">char</span> linkString::<span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> index) <span class="hljs-type">const</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt;= length)<br>    &#123;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">out_of_range</span>(<span class="hljs-string">&quot;Index &quot;</span> + std::<span class="hljs-built_in">to_string</span>(index) + <span class="hljs-string">&quot; is out of range. Valid range is [0, &quot;</span> + std::<span class="hljs-built_in">to_string</span>(length - <span class="hljs-number">1</span>) + <span class="hljs-string">&quot;].&quot;</span>);<br>    &#125;<br><br>    node *current_node;    <span class="hljs-comment">// Pointer to the node containing the target character</span><br>    <span class="hljs-type">int</span> node_position = <span class="hljs-number">0</span>; <span class="hljs-comment">// Position within the node</span><br>    <span class="hljs-built_in">findPos</span>(index, node_position, current_node);<br><br>    <span class="hljs-keyword">return</span> current_node-&gt;data[node_position];<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief the overload function of += operator</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * @param other the linkString needs to be appended</span><br><span class="hljs-comment"> * @return the reference of the appended string</span><br><span class="hljs-comment"> */</span><br>linkString &amp;linkString::<span class="hljs-keyword">operator</span>+=(<span class="hljs-type">const</span> linkString &amp;other)<br>&#123;<br>    <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">insert</span>(length, other);<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief the overload function of -= operator</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * @param other the linkString needs to be poped (removed)</span><br><span class="hljs-comment"> * @return the reference of the string</span><br><span class="hljs-comment"> */</span><br>linkString &amp;linkString::<span class="hljs-keyword">operator</span>-=(<span class="hljs-type">const</span> linkString &amp;other)<br>&#123;<br>    linkString tmp = <span class="hljs-built_in">substr</span>(length - other.length, other.length);<br>    <span class="hljs-keyword">if</span> (tmp == other)<br>    &#123;<br>        <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">remove</span>(length - other.length, other.length);<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">invalid_argument</span>(<span class="hljs-string">&quot;The string cannot be removed!&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief the overload function of + operator</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * @param s1 the left plus string</span><br><span class="hljs-comment"> * @param s2 the right plus string</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * @return a tmp value of the added string</span><br><span class="hljs-comment"> */</span><br>linkString <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> linkString &amp;s1, <span class="hljs-type">const</span> linkString &amp;s2)<br>&#123;<br>    linkString ans = s1;<br>    ans += s2;<br>    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">move</span>(ans);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief judge whether the two strings is equal</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * @param s1 the left string needs to be judged</span><br><span class="hljs-comment"> * @param s2 the right string needs to be judged</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * @return a bool value</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> linkString &amp;s1, <span class="hljs-type">const</span> linkString &amp;s2)<br>&#123;<br>    <span class="hljs-keyword">if</span> (s<span class="hljs-number">1.l</span>ength != s<span class="hljs-number">2.l</span>ength)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">// uses two pointers to traverse the linkString</span><br><br>    linkString::node *p1 = s<span class="hljs-number">1.</span>head-&gt;next;<br>    linkString::node *p2 = s<span class="hljs-number">2.</span>head-&gt;next;<br>    <span class="hljs-type">int</span> current_pos_for_s1 = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> current_pos_for_s2 = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">while</span> (p1 &amp;&amp; p2)<br>    &#123;<br>        <span class="hljs-comment">// the end statement:one of the node* reacheds to the end</span><br>        <span class="hljs-keyword">if</span> (p1-&gt;data[current_pos_for_s1] != p2-&gt;data[current_pos_for_s2])<br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// update the index</span><br>        current_pos_for_s1++;<br>        current_pos_for_s2++;<br><br>        <span class="hljs-comment">// update the node</span><br>        <span class="hljs-keyword">if</span> (current_pos_for_s1 == p1-&gt;size)<br>        &#123;<br>            p1 = p1-&gt;next;<br>            current_pos_for_s1 = <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (current_pos_for_s2 == p2-&gt;size)<br>        &#123;<br>            p2 = p2-&gt;next;<br>            current_pos_for_s2 = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief judge whether the two strings are not equal</span><br><span class="hljs-comment"> * * All the parameters are equal to the == function</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-type">const</span> linkString &amp;s1, <span class="hljs-type">const</span> linkString &amp;s2)<br>&#123;<br>    <span class="hljs-keyword">return</span> !(s1 == s2);<br>&#125;<br><br><span class="hljs-comment">// several functions for string comparison</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief the sorted function for string comparison, if s1 &gt; s2, then the func returns true.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&gt;(<span class="hljs-type">const</span> linkString &amp;s1, <span class="hljs-type">const</span> linkString &amp;s2)<br>&#123;<br>    <span class="hljs-comment">// pointers for traverse</span><br>    linkString::node *p1 = s<span class="hljs-number">1.</span>head-&gt;next;<br>    linkString::node *p2 = s<span class="hljs-number">2.</span>head-&gt;next;<br>    <span class="hljs-type">int</span> current_pos_for_s1 = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> current_pos_for_s2 = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">while</span> (p1 != <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (p1-&gt;data[current_pos_for_s1] &lt; p2-&gt;data[current_pos_for_s2])<br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (p1-&gt;data[current_pos_for_s1] &gt; p2-&gt;data[current_pos_for_s2])<br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// update the index</span><br>        current_pos_for_s1++;<br>        current_pos_for_s2++;<br><br>        <span class="hljs-comment">// update the node</span><br>        <span class="hljs-keyword">if</span> (current_pos_for_s1 == p1-&gt;size)<br>        &#123;<br>            p1 = p1-&gt;next;<br>            current_pos_for_s1 = <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (current_pos_for_s2 == p2-&gt;size)<br>        &#123;<br>            p2 = p2-&gt;next;<br>            current_pos_for_s2 = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// whatever p2 is (nullptr or not), there is no possilbility s1&gt;s2!</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&gt;=(<span class="hljs-type">const</span> linkString &amp;s1, <span class="hljs-type">const</span> linkString &amp;s2)<br>&#123;<br>    <span class="hljs-keyword">return</span> s1 &gt; s2 || s1 == s2;<br>&#125;<br><br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> linkString &amp;s1, <span class="hljs-type">const</span> linkString &amp;s2)<br>&#123;<br>    <span class="hljs-keyword">return</span> !(s1 &gt;= s2);<br>&#125;<br><br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;=(<span class="hljs-type">const</span> linkString &amp;s1, <span class="hljs-type">const</span> linkString &amp;s2)<br>&#123;<br>    <span class="hljs-keyword">return</span> !(s1 &gt; s2);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief the overload function of &lt;&lt; operator(for output)</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * @param os reference to the istream classes</span><br><span class="hljs-comment"> * @param s the string that needs to be printed.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * @return the l-value for os</span><br><span class="hljs-comment"> */</span><br>std::ostream &amp;<span class="hljs-keyword">operator</span>&lt;&lt;(std::ostream &amp;os, <span class="hljs-type">const</span> linkString &amp;s)<br>&#123;<br>    <span class="hljs-comment">// for traverse</span><br>    linkString::node *p = s.head-&gt;next;<br><br>    <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> index = <span class="hljs-number">0</span>; index &lt; p-&gt;size; index++)<br>        &#123;<br>            os &lt;&lt; p-&gt;data[index];<br>            <span class="hljs-comment">// because the string doesnot have &#x27;\0&#x27;, we cannot &lt;&lt; it at a time.</span><br>        &#125;<br>        p = p-&gt;next;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> os;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief the overload function of &gt;&gt; operator(for input)</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * @param is reference to the istream classes</span><br><span class="hljs-comment"> * @param s the string that needs to be printed.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * @return the l-value for is</span><br><span class="hljs-comment"> */</span><br>std::istream &amp;<span class="hljs-keyword">operator</span>&gt;&gt;(std::istream &amp;is, linkString &amp;s)<br>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> maxinputsize = <span class="hljs-number">1024</span>;<br>    <span class="hljs-type">char</span> *newstring = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[maxinputsize];<br>    <span class="hljs-type">int</span> currrentlength = <span class="hljs-number">0</span>;<br>    newstring[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br><br>    <span class="hljs-type">char</span> current_ch;<br>    <span class="hljs-keyword">while</span> (is.<span class="hljs-built_in">get</span>(current_ch) &amp;&amp; current_ch != <span class="hljs-string">&#x27;\n&#x27;</span>)<br>    &#123;<br>        newstring[currrentlength] = current_ch;<br>        currrentlength++;<br>    &#125;<br>    newstring[currrentlength] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br><br>    <span class="hljs-function">linkString <span class="hljs-title">tmp</span><span class="hljs-params">(newstring)</span></span>;<br>    s = tmp;<br><br>    <span class="hljs-keyword">delete</span>[] newstring;<br>    <span class="hljs-keyword">return</span> is;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief the visualization of linked string</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">linkString::visualPrint</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// for traverse</span><br>    node *current_node = head-&gt;next;<br>    <span class="hljs-type">int</span> current_node_count = <span class="hljs-number">0</span>;<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;The visualization for the linkString:&quot;</span> &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;The string has &quot;</span> &lt;&lt; length &lt;&lt; <span class="hljs-string">&quot;characters&quot;</span> &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">while</span> (current_node != <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Node &quot;</span> &lt;&lt; current_node_count + <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&quot;: &quot;</span> &lt;&lt; std::endl;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;  Address: &quot;</span> &lt;&lt; current_node &lt;&lt; std::endl;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;  Size: &quot;</span> &lt;&lt; current_node-&gt;size &lt;&lt; std::endl;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;  Data: &quot;</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; current_node-&gt;size; ++i)<br>        &#123;<br>            std::cout &lt;&lt; current_node-&gt;data[i];<br>        &#125;<br>        std::cout &lt;&lt; std::endl;<br><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;----------------------------------------------------------------------&quot;</span> &lt;&lt; std::endl;<br><br>        current_node = current_node-&gt;next;<br>        ++current_node_count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="String-in-string"><a href="#String-in-string" class="headerlink" title="String in string"></a>String in <code>string</code></h3><p>自此，我们已经完成了 <strong>字符串string类的几乎所有常见操作</strong>（当然这里STL的实现还很遥远），在C++标准中，string类的相关工具函数被集成到了<string>库里，下文给出一些常见的string类的函数声明和使用方法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 构造函数</span><br><span class="hljs-built_in">string</span>(); <span class="hljs-comment">// 默认构造函数，创建一个空字符串</span><br><span class="hljs-built_in">string</span>(<span class="hljs-type">const</span> string&amp; str); <span class="hljs-comment">// 拷贝构造函数，创建一个与str相同的字符串</span><br><span class="hljs-built_in">string</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* s); <span class="hljs-comment">// 使用C风格字符串初始化</span><br><span class="hljs-built_in">string</span>(<span class="hljs-type">size_t</span> n, <span class="hljs-type">char</span> c); <span class="hljs-comment">// 创建一个包含n个字符c的字符串</span><br><br><span class="hljs-comment">// 赋值操作</span><br>string&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> string&amp; str); <span class="hljs-comment">// 将str赋值给当前字符串</span><br>string&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* s); <span class="hljs-comment">// 将C风格字符串s赋值给当前字符串</span><br>string&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">char</span> c); <span class="hljs-comment">// 将字符c赋值给当前字符串</span><br><br><span class="hljs-comment">// 访问元素</span><br><span class="hljs-type">char</span>&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">size_t</span> pos); <span class="hljs-comment">// 返回pos位置的字符引用</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span>&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">size_t</span> pos) <span class="hljs-type">const</span>; <span class="hljs-comment">// 返回pos位置的字符常量引用</span><br><span class="hljs-function"><span class="hljs-type">char</span>&amp; <span class="hljs-title">at</span><span class="hljs-params">(<span class="hljs-type">size_t</span> pos)</span></span>; <span class="hljs-comment">// 返回pos位置的字符引用，并进行边界检查</span><br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span>&amp; <span class="hljs-title">at</span><span class="hljs-params">(<span class="hljs-type">size_t</span> pos)</span> <span class="hljs-type">const</span></span>; <span class="hljs-comment">// 返回pos位置的字符常量引用，并进行边界检查</span><br><br><span class="hljs-comment">// 字符串长度</span><br><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>; <span class="hljs-comment">// 返回字符串的长度</span><br><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">length</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>; <span class="hljs-comment">// 返回字符串的长度，与size()功能相同</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>; <span class="hljs-comment">// 判断字符串是否为空</span><br><br><span class="hljs-comment">// 字符串操作</span><br><span class="hljs-function">string&amp; <span class="hljs-title">append</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; str)</span></span>; <span class="hljs-comment">// 将str追加到当前字符串末尾</span><br><span class="hljs-function">string&amp; <span class="hljs-title">append</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* s)</span></span>; <span class="hljs-comment">// 将C风格字符串s追加到当前字符串末尾</span><br><span class="hljs-function">string&amp; <span class="hljs-title">append</span><span class="hljs-params">(<span class="hljs-type">size_t</span> n, <span class="hljs-type">char</span> c)</span></span>; <span class="hljs-comment">// 将n个字符c追加到当前字符串末尾</span><br><br><span class="hljs-function">string&amp; <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">size_t</span> pos, <span class="hljs-type">const</span> string&amp; str)</span></span>; <span class="hljs-comment">// 在pos位置插入str</span><br><span class="hljs-function">string&amp; <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">size_t</span> pos, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* s)</span></span>; <span class="hljs-comment">// 在pos位置插入C风格字符串s</span><br><span class="hljs-function">string&amp; <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">size_t</span> pos, <span class="hljs-type">size_t</span> n, <span class="hljs-type">char</span> c)</span></span>; <span class="hljs-comment">// 在pos位置插入n个字符c</span><br><br><span class="hljs-function">string&amp; <span class="hljs-title">erase</span><span class="hljs-params">(<span class="hljs-type">size_t</span> pos = <span class="hljs-number">0</span>, <span class="hljs-type">size_t</span> len = npos)</span></span>; <span class="hljs-comment">// 从pos位置开始删除len个字符</span><br><br><span class="hljs-function">string&amp; <span class="hljs-title">replace</span><span class="hljs-params">(<span class="hljs-type">size_t</span> pos, <span class="hljs-type">size_t</span> len, <span class="hljs-type">const</span> string&amp; str)</span></span>; <span class="hljs-comment">// 从pos位置开始替换len个字符为str</span><br><span class="hljs-function">string&amp; <span class="hljs-title">replace</span><span class="hljs-params">(<span class="hljs-type">size_t</span> pos, <span class="hljs-type">size_t</span> len, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* s)</span></span>; <span class="hljs-comment">// 从pos位置开始替换len个字符为C风格字符串s</span><br><br><span class="hljs-comment">// 子字符串</span><br><span class="hljs-function">string <span class="hljs-title">substr</span><span class="hljs-params">(<span class="hljs-type">size_t</span> pos = <span class="hljs-number">0</span>, <span class="hljs-type">size_t</span> len = npos)</span> <span class="hljs-type">const</span></span>; <span class="hljs-comment">// 返回从pos位置开始长度为len的子字符串</span><br><br><span class="hljs-comment">// 查找</span><br><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; str, <span class="hljs-type">size_t</span> pos = <span class="hljs-number">0</span>)</span> <span class="hljs-type">const</span></span>; <span class="hljs-comment">// 从pos位置开始查找str，返回首次出现的位置</span><br><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* s, <span class="hljs-type">size_t</span> pos = <span class="hljs-number">0</span>)</span> <span class="hljs-type">const</span></span>; <span class="hljs-comment">// 从pos位置开始查找C风格字符串s，返回首次出现的位置</span><br><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">char</span> c, <span class="hljs-type">size_t</span> pos = <span class="hljs-number">0</span>)</span> <span class="hljs-type">const</span></span>; <span class="hljs-comment">// 从pos位置开始查找字符c，返回首次出现的位置</span><br><br><span class="hljs-comment">// 比较</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; str)</span> <span class="hljs-type">const</span></span>; <span class="hljs-comment">// 比较当前字符串与str，返回0表示相等，负数表示小于，正数表示大于</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* s)</span> <span class="hljs-type">const</span></span>; <span class="hljs-comment">// 比较当前字符串与C风格字符串s</span><br></code></pre></td></tr></table></figure><h2 id="String-Pattern-Algorithms-KMP"><a href="#String-Pattern-Algorithms-KMP" class="headerlink" title="String Pattern Algorithms: KMP"></a>String Pattern Algorithms: KMP</h2><h3 id="YOLO-You-only-look-once"><a href="#YOLO-You-only-look-once" class="headerlink" title="YOLO: You only look once!"></a>YOLO: You only look once!</h3><p>接下来，我们介绍在字符串中非常经典的算法之一：<strong>KMP字符串匹配算法</strong>。</p><p>In <a href="https://en.wikipedia.org/wiki/Computer_science" title="Computer science">computer science</a>, the <strong>Knuth–Morris–Pratt algorithm</strong> (or <strong>KMP algorithm</strong>) is a <a href="https://en.wikipedia.org/wiki/String-searching_algorithm" title="String-searching algorithm">string-searching algorithm</a> that searches for occurrences of a “word” <code>W</code> within a main “text string” <code>S</code> by employing the observation that when a mismatch occurs, the word itself embodies sufficient information to determine where the next match could begin, thus bypassing re-examination of previously matched characters. <sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="[Knuth–Morris–Pratt algorithm - Wikipedia](https://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm)">[1]</span></a></sup><sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="[Papers of KMP algorithm - www.cs.jhu.edu](https://www.cs.jhu.edu/~misha/ReadingSeminar/Papers/Knuth77.pdf)">[2]</span></a></sup></p><blockquote><p>KMP算法中的K是Knuth老爷子！也就是图灵奖得主，《The Art of Computer Programming》巨著的作者！</p></blockquote><p><strong>KMP算法解决的核心问题是字符串的子串匹配问题</strong>：给定字符串<code>total_string</code> 和 <code>target_string</code>，是否存在<code>total_string</code> 的一个<code>substr</code>记为<code>sub_tested</code>，使<code>sub_tested</code> &#x3D;&#x3D; <code>target_string</code>？如果有，返回最小的子串首字符的索引值，如果没有，返回-1。</p><p>这个问题最暴力的解决方式是<strong>枚举</strong>，即枚举遍<code>total_string</code>中每一种与<code>target_string</code>等长的子串，并对每一种情况作比较。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">outermatch</span><span class="hljs-params">(seqString target, seqString totalString, <span class="hljs-type">int</span> (*string_match_algorithm[])(seqString, seqString), <span class="hljs-type">int</span> func_choice)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> index = string_match_algorithm[func_choice](target, totalString);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Using &quot;</span> &lt;&lt; func_choice &lt;&lt; <span class="hljs-string">&quot;th algorithm&quot;</span> &lt;&lt; std::endl;<br>    <span class="hljs-keyword">if</span> (index == <span class="hljs-number">-1</span>)<br>    &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Unfortunately, the match fails.&quot;</span> &lt;&lt; std::endl;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;The string &quot;</span> &lt;&lt; totalString &lt;&lt; <span class="hljs-string">&quot; does not have a substring &quot;</span> &lt;&lt; target &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Got it!&quot;</span> &lt;&lt; std::endl;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;There exits a target string with the index of &quot;</span> &lt;&lt; index &lt;&lt; <span class="hljs-string">&quot; and with the length of &quot;</span> &lt;&lt; target.<span class="hljs-built_in">length</span>() &lt;&lt; std::endl;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Which means there exists a substr: &quot;</span> &lt;&lt; totalString.<span class="hljs-built_in">substr</span>(index, target.<span class="hljs-built_in">length</span>()) &lt;&lt; <span class="hljs-string">&quot; ,which matches with target: &quot;</span> &lt;&lt; target &lt;&lt; std::endl;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief The most complex implementation of string-matching, using enumeration</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * @param target The target string needs to be matched</span><br><span class="hljs-comment"> * @param total_string The whole string that needs to be detected</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * @return the index for the first match. return -1 if no match occurs.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">complexStringMatch</span><span class="hljs-params">(seqString target, seqString totalString)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> target_length = target.<span class="hljs-built_in">length</span>();<br>    <span class="hljs-type">int</span> total_length = totalString.<span class="hljs-built_in">length</span>();<br><br>    <span class="hljs-keyword">if</span> (total_length &lt; target_length)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i + target_length &lt;= total_length; ++i)<br>    &#123;<br>        seqString tmp = totalString.<span class="hljs-built_in">substr</span>(i, target_length);<br><br>        <span class="hljs-keyword">if</span> (tmp == target)<br>        &#123;<br>            <span class="hljs-comment">// match successfully</span><br>            <span class="hljs-keyword">return</span> i;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样的算法会带来<code>O(mn)</code>的时间复杂度，m是总串的长度，n是子串的长度，在字符串长度很大时效率很低。<strong>而KMP算法采用了时间换空间的巧妙之举</strong>，将最坏时间复杂度压缩到了<strong>线性级别</strong>。</p><blockquote><p>下面把<code>total_string</code>称为主串，<code>target_string</code>称为子串</p></blockquote><p>具体是如何实现的？<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="[KMP算法可视化 奇乐编程学院](https://www.bilibili.com/video/BV1AY4y157yL/)">[3]</span></a></sup> 类似与<strong>移动指针</strong>的经典算法，KMP算法首先在主串中存在一个<strong>永远不回头的指针</strong>，来检测所指向的字符是否和子串中的字符相对应。很显然，上文的暴力枚举算法多做了很多的重复计算，<strong>为了减少这些重复的匹配计算</strong>，KMP又维护了一个<code>next</code> 数组（或者叫<code>lps</code>数组），用来存储信息，这样保证了<strong>指针可以永不回头，使用以前存储的信息</strong>。</p><blockquote><p>那<code>lps</code>数组储存了什么信息？<strong>LPS 最长公共前后缀</strong>数组的作用是：<strong>当匹配失败时，告诉子串应该回退到哪个位置</strong>。主串指针永不回退，子串指针根据 LPS 值跳跃。</p></blockquote><p>理解起来肯定有困难，我们举一个具体的例子，例如主串ABABABABC，子串ABABC：</p><table><thead><tr><th>主串</th><th>A😈</th><th>B</th><th>A</th><th>B</th><th>A</th><th>B</th><th>A</th><th>B</th><th>C</th></tr></thead><tbody><tr><td><strong>子串</strong></td><td>A😍</td><td>B</td><td>A</td><td>B</td><td>C</td><td></td><td></td><td></td><td></td></tr><tr><td><strong>lps数组</strong></td><td>0</td><td>0</td><td>1</td><td>2</td><td>0</td><td></td><td></td><td></td><td><strong>forward</strong></td></tr></tbody></table><p>我们假设lps数组已经生成好了，现在有两个指针（都位于初始位置起点：😈😍）</p><blockquote><ul><li><p>😈：<strong>位于主串的永不后退的指针</strong>，代表在主串中扫描到的位置。</p></li><li><p>😍：<strong>位于子串的指针</strong>，不过他可能会后退</p></li></ul><p>两个指针指向的字符会进行匹配操作，判断是否对应。</p></blockquote><p>接下来字符进行<strong>第一次匹配</strong>：A &#x3D;&#x3D; A，匹配成功，<strong>两个指针同时向前移动一步进行后续匹配</strong>。</p><p>接着就是第二步，第三步，第四步，匹配都成功。</p><table><thead><tr><th>主串</th><th>A</th><th>B😈</th><th>A</th><th>B</th><th>A</th><th>B</th><th>A</th><th>B</th><th>C</th></tr></thead><tbody><tr><td><strong>子串</strong></td><td>A</td><td>B😍</td><td>A</td><td>B</td><td>C</td><td></td><td></td><td></td><td></td></tr><tr><td><strong>lps数组</strong></td><td>0</td><td>0</td><td>1</td><td>2</td><td>0</td><td></td><td></td><td></td><td><strong>forward</strong></td></tr></tbody></table><table><thead><tr><th>主串</th><th>A</th><th>B</th><th>A😈</th><th>B</th><th>A</th><th>B</th><th>A</th><th>B</th><th>C</th></tr></thead><tbody><tr><td><strong>子串</strong></td><td>A</td><td>B</td><td>A😍</td><td>B</td><td>C</td><td></td><td></td><td></td><td></td></tr><tr><td><strong>lps数组</strong></td><td>0</td><td>0</td><td>1</td><td>2</td><td>0</td><td></td><td></td><td></td><td><strong>forward</strong></td></tr></tbody></table><table><thead><tr><th>主串</th><th>A</th><th>B</th><th>A</th><th>B😈</th><th>A</th><th>B</th><th>A</th><th>B</th><th>C</th></tr></thead><tbody><tr><td><strong>子串</strong></td><td>A</td><td>B</td><td>A</td><td>B😍</td><td>C</td><td></td><td></td><td></td><td></td></tr><tr><td><strong>lps数组</strong></td><td>0</td><td>0</td><td>1</td><td>2</td><td>0</td><td></td><td></td><td></td><td><strong>forward</strong></td></tr></tbody></table><p>第五步开始了，出现了异常情况！字符串匹配失败。</p><table><thead><tr><th>主串</th><th>A</th><th>B</th><th>A</th><th>B</th><th>A😈</th><th>B</th><th>A</th><th>B</th><th>C</th></tr></thead><tbody><tr><td><strong>子串</strong></td><td>A</td><td>B</td><td>A</td><td>B</td><td>C😇</td><td></td><td></td><td></td><td></td></tr><tr><td><strong>lps数组</strong></td><td>0</td><td>0</td><td>1</td><td>2</td><td>0</td><td></td><td></td><td></td><td><strong>failure</strong></td></tr></tbody></table><p>别慌！<strong>虽然匹配失败了，但我们并不是一无所获</strong>。我们至少发现前四位的匹配是有效的，我们如何利用这个有效信息？</p><p>注意力惊人的KMP三人发现，我们可以让子串的😇指针<strong>适当的回退几步</strong>。注意是<strong>适当</strong>，也就是说没有必要回退到第一位重新开始。那回退到哪一步呢？在这里，我们可以<strong>将😇指针回退两步，看看会发生什么</strong>：</p><table><thead><tr><th>主串</th><th>A</th><th>B</th><th><span style="color:red;">A</span></th><th><span style="color:red;">B</span></th><th><span style="color:red;">A</span>😈</th><th>B</th><th>A</th><th>B</th><th>C</th></tr></thead><tbody><tr><td><strong>子串</strong></td><td><span style="color:red;">A</span></td><td><span style="color:red;">B</span></td><td><span style="color:red;">A😍</span></td><td>B</td><td>C</td><td></td><td></td><td></td><td></td></tr><tr><td><strong>lps数组</strong></td><td>0</td><td>0</td><td>1</td><td>2</td><td>0</td><td></td><td></td><td></td><td><strong>&lt;- 2steps</strong></td></tr></tbody></table><p>神奇的事情发生了！我们发现貌似子串的前三位是对应上的，貌似还有希望！此时😈😍已经错开了位置，但依旧可以同时向后移动，进行比较。<strong>换句话说，主串的指针无需向后移动，只需子串的😇向后移动适当的位置，便可重新“错位”对接上，进行后续的移动操作。</strong></p><p>有了这个基本思路，我们便可以走完剩下的扫描过程：</p><blockquote><p>为了方便演示，我们使用😀标注主串和子串中正在匹配字符串的开头位置，这个本身没有任何意义，只是为了更加的直观。</p></blockquote><table><thead><tr><th>主串</th><th>A</th><th>B</th><th>A😀</th><th>B</th><th>A</th><th>B😈</th><th>A</th><th>B</th><th>C</th></tr></thead><tbody><tr><td><strong>子串</strong></td><td>A😀</td><td>B</td><td>A</td><td>B😍</td><td>C</td><td></td><td></td><td></td><td></td></tr><tr><td><strong>lps数组</strong></td><td>0</td><td>0</td><td>1</td><td>2</td><td>0</td><td></td><td></td><td></td><td><strong>success</strong></td></tr></tbody></table><table><thead><tr><th>主串</th><th>A</th><th>B</th><th>A😀</th><th>B</th><th>A</th><th>B</th><th>A😈</th><th>B</th><th>C</th></tr></thead><tbody><tr><td><strong>子串</strong></td><td>A😀</td><td>B</td><td>A</td><td>B</td><td>C😇</td><td></td><td></td><td></td><td></td></tr><tr><td><strong>lps数组</strong></td><td>0</td><td>0</td><td>1</td><td>2</td><td>0</td><td></td><td></td><td></td><td>fuck！</td></tr></tbody></table><table><thead><tr><th>主串</th><th>A</th><th>B</th><th>A</th><th>B</th><th>A😀</th><th>B</th><th>A😈</th><th>B</th><th>C</th></tr></thead><tbody><tr><td><strong>子串</strong></td><td>A😀</td><td>B</td><td>A😍</td><td>B</td><td>C</td><td></td><td></td><td></td><td></td></tr><tr><td><strong>lps数组</strong></td><td>0</td><td>0</td><td>1</td><td>2</td><td>0</td><td></td><td></td><td></td><td><strong>&lt;- 2steps</strong></td></tr></tbody></table><table><thead><tr><th>主串</th><th>A</th><th>B</th><th>A</th><th>B</th><th>A😀</th><th>B</th><th>A</th><th>B</th><th>C😈</th></tr></thead><tbody><tr><td><strong>子串</strong></td><td>A😀</td><td>B</td><td>A</td><td>B</td><td>C😍</td><td></td><td></td><td></td><td></td></tr><tr><td><strong>lps数组</strong></td><td>0</td><td>0</td><td>1</td><td>2</td><td>0</td><td></td><td></td><td></td><td>yeah！</td></tr></tbody></table><p>我们最终找到了匹配的字符串！</p><p>不过有两个问题还未解决：</p><p><strong>第一个问题是：我如何知道在匹配失败的时候应该回退到哪个位置？</strong></p><p>我们再来仔细看看回退的时候到底发生了什么，以第一次回退的情况为例：</p><table><thead><tr><th>主串</th><th><span style="color:blue;">A</span></th><th><span style="color:blue;">B</span></th><th><span style="color:red;">A</span></th><th><span style="color:red;">B</span></th><th><span style="color:black;">A</span>😈</th><th>B</th><th>A</th><th>B</th><th>C</th></tr></thead><tbody><tr><td><strong>子串</strong></td><td><span style="color:red;">A</span></td><td><span style="color:red;">B</span></td><td><span style="color:black;">A😍</span></td><td>B&lt;-</td><td>C&lt;-</td><td></td><td></td><td></td><td></td></tr><tr><td><strong>lps数组</strong></td><td>0</td><td>0</td><td>1</td><td>2</td><td>0</td><td></td><td></td><td></td><td><strong>&lt;- 2steps</strong></td></tr></tbody></table><p>在主串中，本应该是蓝色的AB和子串中红色的AB进行匹配（实际上也确实如此），但是我们巧妙的发现<strong>主串尾部也有相同的AB序列</strong>，这就给我们一种<strong>错位</strong>的机会，即<strong>两个字符串中红色和红色</strong>相匹配的机会。</p><p>换句话说，<strong>我们真正关心的</strong>，是之前已经匹配好的子串中<strong>最长的相同前后缀</strong>（在上文的情况中是AB），也就是最大的错位长度可能性。</p><p><strong>第二个问题是：电脑如何知道匹配失败的时候应该回退到哪个位置？</strong></p><p>答案：<strong>查表</strong>，第三行的lps数组就是答案。当😇位于子串第五个位置的C处时，会peek一下第四个位置（最后一个匹配成功的位置）的lps数组值，发现是2，因此子串的指针回退2格。</p><p>在<strong>假设lps数组已经给出的条件下，我们可以完成KMP算法的大部分内容了！</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// KMP algorithm implementation</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">KMP</span><span class="hljs-params">(seqString pattern, seqString text)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (pattern.<span class="hljs-built_in">isEmpty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">// Empty pattern matches at the start</span><br><br>    <span class="hljs-type">int</span> textLen = text.<span class="hljs-built_in">length</span>();<br>    <span class="hljs-type">int</span> patLen = pattern.<span class="hljs-built_in">length</span>();<br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">lps</span><span class="hljs-params">(patLen, <span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-built_in">computeLPS</span>(pattern, lps);<br><br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;  <span class="hljs-comment">// Index for text</span><br>    <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;  <span class="hljs-comment">// Index for pattern</span><br><br>    <span class="hljs-keyword">while</span> (i &lt; textLen) &#123;<br>        <span class="hljs-keyword">if</span> (pattern[j] == text[i]) &#123;<br>            i++;<br>            j++;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (j == patLen) &#123;<br>            <span class="hljs-keyword">return</span> i - j;  <span class="hljs-comment">// Match found, return the starting index</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i &lt; textLen &amp;&amp; pattern[j] != text[i]) &#123;<br>            <span class="hljs-keyword">if</span> (j != <span class="hljs-number">0</span>) &#123;<br>                j = lps[j - <span class="hljs-number">1</span>];  <span class="hljs-comment">// Fallback using the LPS array</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                i++;  <span class="hljs-comment">// No fallback possible, move to the next character in text</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <span class="hljs-comment">// No match found</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在代码中的<code>computeLPS()</code>函数完成了lps数组的计算工作，稍后完成。</p><h3 id="How-to-compute-LPS"><a href="#How-to-compute-LPS" class="headerlink" title="How to compute LPS"></a>How to compute <code>LPS</code></h3><p>最后一个问题，如何计算LPS数组？我们知道LPS数组的本质就是<strong>计算子串中最长的相同前后缀长度</strong>，也就是说LPS的计算和主串无关，而我们在扫描的过程中肯定会完整的遍历一遍子串，因此可以在扫描的过程中同步更新LPS数组，不过在这里为了方便写封装，我们在开始之前提前计算好LPS数组。</p><p><code>computeLPS()</code>如何也实现线性时间复杂度？<strong>动态规划</strong>，我们首先来规范的定义LPS数组的求解问题：</p><p>给定一个vector<int> 数组lps，计算<code>lps[i]</code>，需要考虑子串的<code>substr(0, i-1)</code>，判断其最大的公共前后缀长度，即为<code>lps[i]</code>的值。</p><p>这可以使用<strong>动态规划</strong>的方法解决，高效地利用之前得到的知识。</p><table><thead><tr><th>子串</th><th>A</th><th>B</th><th>A</th><th>C</th><th>A</th><th>B😍</th><th>B</th><th>C</th></tr></thead></table><ul><li><p>对应 index &#x3D;&#x3D; 0，无法回退，为0。</p></li><li><p>对于 index &#x3D;&#x3D; 1，考虑字符串A，为1。</p></li><li><p>index &#x3D;&#x3D; 2，我们发现新加入的B和A并不相同，为0</p></li><li><p>index &#x3D;&#x3D; 3，为3</p></li><li><p>index &#x3D;&#x3D; 4，为0</p></li><li><p>index &#x3D;&#x3D; 6，😍，增加一个字符lps的值至多增加1，这<strong>取决于新加入的字符和原来最长前缀的下一个字符是否匹配</strong>，如果匹配，lps数组加1.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span>(newaddedchar == target_string[lps[index - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>)&#123;<br>    lps[index] = lps[index - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>对于无法匹配的情况，例如index &#x3D;&#x3D; 7，情况貌似有点遭，因为新加入的B不仅没对上，还打破了ABACAB原有的结构，变成了<strong>AB</strong>AC<strong>AB</strong>B，此时我们需要找到更短的前后缀，我们换一个例子：</p><p><strong>ABDA</strong>AC<strong>ABDA</strong>+B。我们寻找更短的公共前后缀，可以暴力搜索，但也可以巧妙的剪枝：<strong>本质上就是寻找ABDA中最长的公共前后缀</strong>，再重复上面的过程，而这一步可以通过查表得到。</p><p>综上所述，我们可以给出<code>computeLPS()</code>的完整代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">computeLPS</span><span class="hljs-params">(<span class="hljs-type">const</span> seqString&amp; pattern, std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; lps)</span> </span>&#123;<br>    <span class="hljs-type">int</span> len = <span class="hljs-number">0</span>;  <span class="hljs-comment">// Length of the previous longest prefix suffix</span><br>    lps[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;   <span class="hljs-comment">// lps[0] is always 0</span><br>    <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">while</span> (i &lt; pattern.<span class="hljs-built_in">length</span>()) &#123;<br>        <span class="hljs-keyword">if</span> (pattern[i] == pattern[len]) &#123;<br>            len++;<br>            lps[i] = len;<br>            i++;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (len != <span class="hljs-number">0</span>) &#123;<br>                len = lps[len - <span class="hljs-number">1</span>];  <span class="hljs-comment">// Fallback to the previous longest prefix suffix</span><br>                <span class="hljs-comment">//特别注意：此处并未执行i++，因为这个位置的值还没有确定，需要再更新</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                lps[i] = <span class="hljs-number">0</span>;  <span class="hljs-comment">// No matching prefix suffix</span><br>                i++;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后，我们给出一个使用KMP算法的实例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> *The following code is for string-match problems</span><br><span class="hljs-comment"> *We use our handmade string for sequence implementation</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">// declaration</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">outermatch</span><span class="hljs-params">(seqString target, seqString totalString, <span class="hljs-type">int</span> (*string_match_algorithm[])(seqString, seqString), <span class="hljs-type">int</span> func_choice)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">complexStringMatch</span><span class="hljs-params">(seqString target, seqString totalString)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">KMP</span><span class="hljs-params">(seqString target, seqString totalString)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">computeLPS</span><span class="hljs-params">(<span class="hljs-type">const</span> seqString &amp;pattern, std::vector&lt;<span class="hljs-type">int</span>&gt; &amp;next)</span></span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief The outer message output of string-matching problems</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * @param target The target string needs to be matched</span><br><span class="hljs-comment"> * @param total_string The whole string that needs to be detected</span><br><span class="hljs-comment"> * @param string_match_algorithm The specific string-match problems</span><br><span class="hljs-comment"> * @param func_choice Choose one algorithm</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">outermatch</span><span class="hljs-params">(seqString target, seqString totalString, <span class="hljs-type">int</span> (*string_match_algorithm[])(seqString, seqString), <span class="hljs-type">int</span> func_choice)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> index = string_match_algorithm[func_choice](target, totalString);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Using &quot;</span> &lt;&lt; func_choice &lt;&lt; <span class="hljs-string">&quot;th algorithm&quot;</span> &lt;&lt; std::endl;<br>    <span class="hljs-keyword">if</span> (index == <span class="hljs-number">-1</span>)<br>    &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Unfortunately, the match fails.&quot;</span> &lt;&lt; std::endl;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;The string &quot;</span> &lt;&lt; totalString &lt;&lt; <span class="hljs-string">&quot; does not have a substring &quot;</span> &lt;&lt; target &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Got it!&quot;</span> &lt;&lt; std::endl;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;There exits a target string with the index of &quot;</span> &lt;&lt; index &lt;&lt; <span class="hljs-string">&quot; and with the length of &quot;</span> &lt;&lt; target.<span class="hljs-built_in">length</span>() &lt;&lt; std::endl;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Which means there exists a substr: &quot;</span> &lt;&lt; totalString.<span class="hljs-built_in">substr</span>(index, target.<span class="hljs-built_in">length</span>()) &lt;&lt; <span class="hljs-string">&quot; ,which matches with target: &quot;</span> &lt;&lt; target &lt;&lt; std::endl;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * !KMP algorithm</span><br><span class="hljs-comment"> * @brief  the Knuth-Morris-Pratt (KMP) algorithm</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * @param text The main text string to search within</span><br><span class="hljs-comment"> * @param pattern The pattern string to search for</span><br><span class="hljs-comment"> * @return The first occurrence index of the pattern in the text, or -1 if not found</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">computeLPS</span><span class="hljs-params">(<span class="hljs-type">const</span> seqString&amp; pattern, std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; lps)</span> </span>&#123;<br>    <span class="hljs-type">int</span> len = <span class="hljs-number">0</span>;  <span class="hljs-comment">// Length of the previous longest prefix suffix</span><br>    lps[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;   <span class="hljs-comment">// lps[0] is always 0</span><br>    <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">while</span> (i &lt; pattern.<span class="hljs-built_in">length</span>()) &#123;<br>        <span class="hljs-keyword">if</span> (pattern[i] == pattern[len]) &#123;<br>            len++;<br>            lps[i] = len;<br>            i++;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (len != <span class="hljs-number">0</span>) &#123;<br>                len = lps[len - <span class="hljs-number">1</span>];  <span class="hljs-comment">// Fallback to the previous longest prefix suffix</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                lps[i] = <span class="hljs-number">0</span>;  <span class="hljs-comment">// No matching prefix suffix</span><br>                i++;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// KMP algorithm implementation</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">KMP</span><span class="hljs-params">(seqString pattern, seqString text)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (pattern.<span class="hljs-built_in">isEmpty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">// Empty pattern matches at the start</span><br><br>    <span class="hljs-type">int</span> textLen = text.<span class="hljs-built_in">length</span>();<br>    <span class="hljs-type">int</span> patLen = pattern.<span class="hljs-built_in">length</span>();<br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">lps</span><span class="hljs-params">(patLen, <span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-built_in">computeLPS</span>(pattern, lps);<br><br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;  <span class="hljs-comment">// Index for text</span><br>    <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;  <span class="hljs-comment">// Index for pattern</span><br><br>    <span class="hljs-keyword">while</span> (i &lt; textLen) &#123;<br>        <span class="hljs-keyword">if</span> (pattern[j] == text[i]) &#123;<br>            i++;<br>            j++;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (j == patLen) &#123;<br>            <span class="hljs-keyword">return</span> i - j;  <span class="hljs-comment">// Match found, return the starting index</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i &lt; textLen &amp;&amp; pattern[j] != text[i]) &#123;<br>            <span class="hljs-keyword">if</span> (j != <span class="hljs-number">0</span>) &#123;<br>                j -= lps[j - <span class="hljs-number">1</span>];  <span class="hljs-comment">// Fallback using the LPS array</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                i++;  <span class="hljs-comment">// No fallback possible, move to the next character in text</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <span class="hljs-comment">// No match found</span><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">testPackageForKMP</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">seqString <span class="hljs-title">s1</span><span class="hljs-params">(<span class="hljs-string">&quot;Hello my name is YXY and I love learning DS&quot;</span>)</span></span>;<br>    seqString targets[] = &#123;<span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-string">&quot;my&quot;</span>, <span class="hljs-string">&quot;MM&quot;</span>&#125;;<br>    <span class="hljs-built_in">int</span> (*string_match_algorithm[])(seqString, seqString) = &#123;complexStringMatch, KMP&#125;;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> target : targets)<br>        &#123;<br>            <span class="hljs-built_in">outermatch</span>(target, s1, string_match_algorithm, i);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-primary">            <p><strong>KMP</strong>算法的本质也可以看做<strong>对暴力枚举的剪枝操作</strong>，因为如果不满足相同前后缀的条件的话，所选择的子串一定是匹配不上的。LPS数组记录了子串的“自相似性”（即前缀和后缀的重叠部分），而KMP算法通过LPS数组，直接跳过那些不可能匹配的位置，只检查可能匹配的部分。</p>          </div><h3 id="Regex"><a href="#Regex" class="headerlink" title="Regex"></a>Regex</h3><p>KMP算法极大程度的压缩了字符串匹配的时间，但<strong>在实际生活中我们往往需要更加general的字符串匹配</strong>来面对更加刁难的需求，例如我需要找到一个子串，要求这个子串的格式为<code>ILOVEXXX</code>，后三位可以是任何的大写字母，那这时我们应该如何表达这个字符串？如何设计功能更加强大的字符串匹配算法？或许<strong>正则表达式Regex</strong>可以成为解决问题的法宝。</p><p>笔者专门更新了一片博客讲解Regex的语法：<a href="https://xiyuanyang-code.github.io/posts/Regular-Expression/">Xiyuan Yang’s Blog - Regex</a></p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm">Knuth–Morris–Pratt algorithm - Wikipedia</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://www.cs.jhu.edu/~misha/ReadingSeminar/Papers/Knuth77.pdf">Papers of KMP algorithm - www.cs.jhu.edu</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://www.bilibili.com/video/BV1AY4y157yL/">KMP算法可视化 奇乐编程学院</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tutorial</tag>
      
      <tag>Data Structure</tag>
      
      <tag>C/C++</tag>
      
      <tag>string</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MYGITHUB-Lightweight-Speech-Recognition-Conversion-Model</title>
    <link href="/posts/MYGITHUB-Lightweight-speech-recognition-conversion-model/"/>
    <url>/posts/MYGITHUB-Lightweight-speech-recognition-conversion-model/</url>
    
    <content type="html"><![CDATA[<style>  html, body, .markdown-body {    font-family: Georgia, sans, serif;  }</style><div class="note note-info">            <p>This is <strong>My Github Project</strong>:  <a href="https://github.com/xiyuanyang-code/Vosk-based-bilingual-speech-recognition-application">Vosk-based-bilingual-speech-recognition-application</a></p><p>The text below is <code>README.md</code> file.</p>          </div><h1 id="A-Vosk-based-Chinese-English-bilingual-speech-recognition-Python-Application"><a href="#A-Vosk-based-Chinese-English-bilingual-speech-recognition-Python-Application" class="headerlink" title="A Vosk-based Chinese-English bilingual speech recognition Python Application"></a>A Vosk-based Chinese-English bilingual speech recognition Python Application</h1><h2 id="😊Introduction"><a href="#😊Introduction" class="headerlink" title="😊Introduction"></a>😊Introduction</h2><p><strong><a href="https://alphacephei.com/vosk/index">Vosk</a></strong> is an open source <strong>speech recognition</strong> toolk. It focused on providing efficient and accurate speech-to-text functionality. It is based on Kaldi (another famous speech recognition toolkit), but compared to Kaldi, Vosk is more <strong>lightweight</strong> and easy to use, and is suitable for embedding into various applications.</p><p>This application is developed on the basis of vosk, implementing <strong>real-time bilingual speech-to-text function</strong>.</p><blockquote><p>All the installation and usage are demonstrated under <strong>Win 11 Systems</strong>.</p></blockquote><h2 id="🚀Installation"><a href="#🚀Installation" class="headerlink" title="🚀Installation"></a>🚀Installation</h2><h3 id="Requirements"><a href="#Requirements" class="headerlink" title="Requirements"></a>Requirements</h3><p>You need to prepare these stuffs in advance:</p><ul><li>🐍Available Python Environments (<strong>Python &gt;&#x3D; 3.6</strong>)<ul><li><strong>WE RECOMMEND Python 3.9</strong> !</li></ul></li><li>🪟Windows Operating Systems<ul><li><strong>Maybe in MacOS works.</strong> (I don’t have a Macbook. 🤑)</li></ul></li><li>🎙️Available Micro devices.</li></ul><p>We strongly recommend you to install <strong><a href="https://docs.anaconda.com/getting-started/">Anaconda</a> or <a href="https://docs.anaconda.com/miniconda/">Miniconda</a></strong> to create a virtual environment to run the python code.</p><h3 id="Clone-the-project"><a href="#Clone-the-project" class="headerlink" title="Clone the project"></a>Clone the project</h3><p>Clone the remote repository from Git to obtain the Python source code.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/xiyuanyang-code/voice_translation.git<br></code></pre></td></tr></table></figure><p>Open the folder as the current directory.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> voice_translation<br></code></pre></td></tr></table></figure><h3 id="Create-Python-environments"><a href="#Create-Python-environments" class="headerlink" title="Create Python environments"></a>Create Python environments</h3><h4 id="🥳If-you-have-installed-Anaconda…"><a href="#🥳If-you-have-installed-Anaconda…" class="headerlink" title="🥳If you have installed Anaconda…"></a>🥳If you have installed Anaconda…</h4><p>Great! Now run the following commands in the command line:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">conda create -n translate python=3.9<br></code></pre></td></tr></table></figure><p>This would create a new <strong>Conda</strong> environment named <strong>“translate”</strong>. You can also customize your own environment name!</p><p>After that, switch to activate the new environment to install the required packages.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">conda activate translate<br><span class="hljs-comment"># or change to your own virtual environment name!</span><br></code></pre></td></tr></table></figure><p>Then install the required packages.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip install -r requirements.txt<br></code></pre></td></tr></table></figure><p>You can also <strong>install packages manually</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip install sounddevice numpy vosk<br></code></pre></td></tr></table></figure><h4 id="🙂‍↕️If-not"><a href="#🙂‍↕️If-not" class="headerlink" title="🙂‍↕️If not?"></a>🙂‍↕️If not?</h4><p>Then go to install <a href="https://docs.anaconda.com/getting-started/">Anaconda</a> first!😋</p><p>Just a joke. Anaconda is too huge for its size. You can still install these packages using:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip install sounddevice numpy vosk<br></code></pre></td></tr></table></figure><h4 id="Required-packages"><a href="#Required-packages" class="headerlink" title="Required packages"></a>Required packages</h4><p>Required packages are as follows:</p><ol><li><p><strong>tkinter</strong>: This is the standard GUI toolkit for Python, allowing developers to create graphical user interfaces easily. (Standard Library)</p></li><li><p><strong>threading</strong>: A standard library module that provides a way to create and manage threads, enabling concurrent execution of code. (Standard Library)</p></li><li><p><strong>queue</strong>: This standard library module provides a thread-safe FIFO implementation, useful for managing tasks between threads. (Standard Library)</p></li><li><p><strong>time</strong>: A standard library module that provides various time-related functions, including time manipulation and formatting. (Standard Library)</p></li><li><p><strong>json</strong>: This standard library module is used for parsing JSON data and converting Python objects to JSON format. (Standard Library)</p></li><li><p><strong>sounddevice</strong>: A third-party library that allows for audio input and output using NumPy arrays, facilitating sound processing tasks. <strong>(Requires manual installation)</strong></p></li><li><p><strong>numpy</strong>: A widely-used third-party library for numerical computations in Python, providing support for large, multi-dimensional arrays and matrices. <strong>(Requires manual installation)</strong></p></li><li><p><strong>vosk</strong>: A third-party library for speech recognition that provides models for various languages using Kaldi’s speech recognition capabilities. <strong>(Requires manual installation)</strong></p></li><li><p><strong>os</strong>: A standard library module that provides a way to interact with the operating system, including file and directory management functions. (Standard Library)</p></li><li><p><strong>platform</strong>: This standard library module allows access to underlying platform’s identifying data, such as OS type and version. (Standard Library)</p></li></ol><h2 id="💓Usage"><a href="#💓Usage" class="headerlink" title="💓Usage"></a>💓Usage</h2><p><strong>Make sure you have passed through the <code>installation</code> section successfully.</strong> </p><h3 id="Create-a-folder-to-store-results"><a href="#Create-a-folder-to-store-results" class="headerlink" title="Create a folder to store results"></a>Create a folder to store results</h3><p>Firstly, create a folder named <strong>“results”</strong> in the current directory.</p><ul><li>For <strong>Bash</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> results<br></code></pre></td></tr></table></figure><ul><li>For <strong>Powershell</strong></li></ul><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">New-Item</span> <span class="hljs-literal">-Path</span> . <span class="hljs-literal">-Name</span> <span class="hljs-string">&quot;results&quot;</span> <span class="hljs-literal">-ItemType</span> Directory<br></code></pre></td></tr></table></figure><h3 id="Download-and-Unzip-the-vosk-model"><a href="#Download-and-Unzip-the-vosk-model" class="headerlink" title="Download and Unzip the vosk-model"></a>Download and Unzip the vosk-model</h3><p>For the core part of the translation model, we use <strong>Vosk-model</strong>, which is both lightweight and powerful.</p><p>For <strong>Bash</strong> and <strong>Powershell</strong> both:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Install the Chinese packages</span><br>wget https://alphacephei.com/vosk/models/vosk-model-cn-0.22.zip<br><br><span class="hljs-comment"># Install the English packages</span><br>wget https://alphacephei.com/vosk/models/vosk-model-en-us-0.22.zip<br></code></pre></td></tr></table></figure><blockquote><p>Or you can just download the zip file online and drag the zip-file into the current folder.</p></blockquote><p>Then extract the downloaded ZIP file:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">unzip vosk-model-cn-0.22.zip<br><br>unzip vosk-model-en-us-0.22.zip<br></code></pre></td></tr></table></figure><p>(Optional) After the unzip process, you can delete the <code>zip</code> file, it’s too huge!</p><p>After all these requirements, your current directory should be like this:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs bash">.<br>├── LICENSE<br>├── README.md<br>├── main<br>│   └── main.py<br>├── requirements.txt<br>├── results<br>├── vosk-model-cn-0.22<br>│   ├── README<br>│   ├── am<br>│   │   └── final.mdl<br>│   ├── conf<br>│   │   ├── mfcc.conf<br>│   │   └── model.conf<br>│   ├── graph<br>│   │   ├── HCLG.fst<br>│   │   ├── phones<br>│   │   │   └── word_boundary.int<br>│   │   └── words.txt<br>│   ├── ivector<br>│   │   ├── final.dubm<br>│   │   ├── final.ie<br>│   │   ├── final.mat<br>│   │   ├── global_cmvn.stats<br>│   │   ├── online_cmvn.conf<br>│   │   └── splice.conf<br>│   ├── rescore<br>│   │   ├── G.carpa<br>│   │   └── G.fst<br>│   └── rnnlm<br>│       ├── feat_embedding.final.mat<br>│       ├── features.txt<br>│       ├── final.raw<br>│       ├── oov.txt<br>│       ├── special_symbol_opts.conf<br>│       ├── special_symbol_opts.txt<br>│       └── word_feats.txt<br>└── vosk-model-en-us-0.22<br>    ├── README<br>    ├── am<br>    │   ├── final.mdl<br>    │   └── tree<br>    ├── conf<br>    │   ├── ivector.conf<br>    │   ├── mfcc.conf<br>    │   └── model.conf<br>    ├── graph<br>    │   ├── HCLG.fst<br>    │   ├── disambig_tid.int<br>    │   ├── num_pdfs<br>    │   ├── phones<br>    │   │   ├── align_lexicon.int<br>    │   │   ├── align_lexicon.txt<br>    │   │   ├── disambig.int<br>    │   │   ├── disambig.txt<br>    │   │   ├── optional_silence.csl<br>    │   │   ├── optional_silence.int<br>    │   │   ├── optional_silence.txt<br>    │   │   ├── silence.csl<br>    │   │   ├── word_boundary.int<br>    │   │   └── word_boundary.txt<br>    │   ├── phones.txt<br>    │   └── words.txt<br>    ├── ivector<br>    │   ├── final.dubm<br>    │   ├── final.ie<br>    │   ├── final.mat<br>    │   ├── global_cmvn.stats<br>    │   ├── online_cmvn.conf<br>    │   └── splice.conf<br>    ├── rescore<br>    │   ├── G.carpa<br>    │   └── G.fst<br>    └── rnnlm<br>        ├── feat_embedding.final.mat<br>        ├── final.raw<br>        ├── special_symbol_opts.conf<br>        ├── special_symbol_opts.txt<br>        └── word_feats.txt<br></code></pre></td></tr></table></figure><p>Check your current directory or simply using <strong>tree</strong> command for WSL.</p><h3 id="Run-Python-code"><a href="#Run-Python-code" class="headerlink" title="Run Python code"></a>Run Python code</h3><p>You should run the python code using the conda environment you have created <strong>accordingly</strong>!</p><p>Switch to the <code>main</code> folder and run <code>main.py</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> main<br>python main.py<br></code></pre></td></tr></table></figure><p>You will probably see the following pop-up window as follows.</p><p><img src="https://ooo.0x0.ooo/2025/01/29/OGRa7L.png" alt="Demo 1"></p><p>We have three modes to choose from, including “Chinese Mode”, “English Mode” and “Bilingual Mode”.</p><p>Choose the mode you like and then the translation will begin!</p><blockquote><p><strong>Warning:</strong> It may take approximately 10~20 seconds for the code to load the <strong>Vosk-model</strong>, for the Bilingual one, it may even take longer.😭Sorry about that.</p></blockquote><p>After the long wait, you will see a green-colored information said “Model loaded successfully!” That means you can begin your words now!</p><ul><li>The results of the conversion will be displayed in real-time in the terminal.</li><li>To end the conversion process, you can <strong>right-click your mouse</strong>, which will terminate the program.</li><li>For the bilingual model, you can click on <code>Select Language</code> in the middle to switch languages.<br><img src="https://ooo.0x0.ooo/2025/01/29/OGRqXX.png" alt="demo 2"></li></ul><h3 id="Obtain-transcriptions"><a href="#Obtain-transcriptions" class="headerlink" title="Obtain transcriptions"></a>Obtain transcriptions</h3><p>You can get the transcriptions in the <code>results</code> folder, including the <code>.txt</code> file and <code>.md</code> file.</p><h2 id="🤖Discussion"><a href="#🤖Discussion" class="headerlink" title="🤖Discussion"></a>🤖Discussion</h2><h3 id="Advantages"><a href="#Advantages" class="headerlink" title="Advantages"></a>Advantages</h3><ul><li>If you want to get the voice transcriptions for free instead of paying for professional apps. This one is suitable for you!</li><li>You can modify the source code to customize your own GUI interface or implement some advanced functions on your own!<ul><li>I think it’s a great chance to learn Python, isn’t it?</li></ul></li></ul><h3 id="Disadvantages-FUTURE-OUTLOOK"><a href="#Disadvantages-FUTURE-OUTLOOK" class="headerlink" title="Disadvantages FUTURE OUTLOOK"></a><del>Disadvantages</del> FUTURE OUTLOOK</h3><ul><li>WE WILL create a more lightweight version.</li><li>WE WILL implement the speech-to-text conversion for mixed input of Chinese and English.</li><li>WE WILL build a more aesthetically pleasing GUI.</li><li>WE WILL optimize the transcriptions, including automatically add punctuation, segment text, and organize it into a coherent article.</li></ul><h2 id="👍Advertisement"><a href="#👍Advertisement" class="headerlink" title="👍Advertisement"></a>👍Advertisement</h2><p>My personal Blog: <a href="https://xiyuanyang-code.github.io/">Xiyuan Yang’s Blog</a></p>]]></content>
    
    
    <categories>
      
      <category>Project</category>
      
    </categories>
    
    
    <tags>
      
      <tag>speech recognition</tag>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vim-Tutorial</title>
    <link href="/posts/Vim-tutorial/"/>
    <url>/posts/Vim-tutorial/</url>
    
    <content type="html"><![CDATA[<style>  html, body, .markdown-body {    font-family: Georgia, sans, serif;  }</style><h1 id="Vim-Basic-Learning-Notes"><a href="#Vim-Basic-Learning-Notes" class="headerlink" title="Vim Basic Learning Notes"></a>Vim Basic Learning Notes</h1><p>The Learning curve for vim is too damn steep! I have tried several times trying to get used to using vim. :cry:</p><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>This document provides a comprehensive guide to the <strong>basic functionalities of Vim</strong>, a powerful text editor. It covers essential commands and modes, including Command Line, Normal Mode, Visual Mode, and Insert Mode. The guide also includes common shortcuts and tips for efficient text editing, such as moving within documents, searching, copying, cutting, and pasting text.</p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><h3 id="What-is-Vim"><a href="#What-is-Vim" class="headerlink" title="What is Vim"></a>What is Vim</h3><p><strong>Vim</strong> is a <a href="https://en.wikipedia.org/wiki/Free_and_open-source">free and open-source</a>, <a href="https://en.wikipedia.org/wiki/Screen-based_text_editor">screen-based text editor</a> program.</p><p>Just like the powerful <code>Vscode</code>, which is the most popular code editor used in <strong>GUI</strong>, <strong>vim</strong> is the most powerful text editor used in <strong>Command Line</strong>.</p><p>We will not discuss how powerful Vim is in the text, because <strong>Vim is a text editor</strong>. You can also implement the same tasks without using vim, with the expense of sacrificing a huge amount of time.</p><p>Before diving deeply into Vim’s world, we need to ensure the <strong>core principle of Vim</strong>: <strong>make all the operations executed in the keyboard, not with the mouse.</strong></p><p><strong>Vim’s interface is a programming language</strong>!</p><blockquote><p>So you’ve better not type too slowly in English. You need to ensure typing letters is more efficient for you than moving mouse to everywhere!</p></blockquote><h2 id="Modes-in-Vim"><a href="#Modes-in-Vim" class="headerlink" title="Modes in Vim"></a>Modes in Vim</h2><ul><li>normal mode</li><li>insert mode (<code>i</code>)</li><li>replace mode (<code>R</code>)</li><li>visual mode (<code>v</code>)<ul><li>visual line (<code>S-V</code>)</li><li>visual block (<code>C-V</code>)</li></ul></li><li>command line mode (<code>:</code>)</li></ul><h3 id="Command-Line-Mode"><a href="#Command-Line-Mode" class="headerlink" title="Command Line Mode"></a>Command Line Mode</h3><p>Command mode can be entered by typing <code>:</code> in Normal mode. Your cursor will jump to the command line at the bottom of the screen upon pressing <code>:</code>. This mode has many functionalities, including opening, saving, and closing files, and <a href="https://twitter.com/iamdevloper/status/435555976687923200">quitting Vim</a>.</p><ul><li><code>:q</code> quit (close window)</li><li><code>:w</code> save (“write”)</li><li><code>:wq</code>  save and quit</li><li><code>:e &#123;name of file&#125;</code> open file for editing</li><li><code>:ls</code> show open buffers</li><li><code>:help &#123;topic&#125;</code> open help<ul><li><code>:help :w</code> opens help for the <code>:w</code> command</li><li><code>:help w</code> opens help for the <code>w</code> movement</li></ul></li></ul><h3 id="Normal-Mode"><a href="#Normal-Mode" class="headerlink" title="Normal Mode"></a>Normal Mode</h3><h4 id="Movement"><a href="#Movement" class="headerlink" title="Movement"></a>Movement</h4><p>In vim, you cannot simply click the mouse to certain positions to change where the cursor is. <strong>In normal mode</strong>, you can implement this using several keys to efficiently move your cursor to everywhere you want!</p><p>Based on <strong>precision</strong>, Vim’s movement keys can be divided into different categories.</p><ul><li><p><strong>Movement in characters</strong></p><ul><li><code>hjkl</code> (left, down, up, right)</li></ul></li><li><p><strong>Movement in words</strong></p><ul><li><code>w</code> : to the next word</li><li><code>b</code> : <strong>Beginning of the word</strong></li><li><code>e</code> : <strong>End of the word</strong></li></ul></li><li><p><strong>Movement in lines</strong></p><ul><li><p><code>0</code> : (beginning of line) </p><ul><li>The combination <code>j+0</code> : move to the beginning of next line.</li><li>The combination <code>k+0</code> : move to the beginning of last line.</li></ul></li><li><p><code>Enter</code> : <strong>The beginning of next line</strong></p></li><li><p><code>^</code> : (first non-blank character)</p></li><li><p><code>$</code> : (end of line)</p></li><li><p><code>+</code> : The first non-blank character of next line</p></li><li><p><code>&#123;</code> and <code>&#125;</code> : move to the next empty line</p></li><li><p>Line numbers: <code>:&#123;number&#125;&lt;CR&gt;</code> or <code>&#123;number&#125;G</code> (line {number})</p><blockquote><p><code>&lt;CR&gt;</code> means press the <code>Enter</code> key.</p></blockquote><ul><li><strong><code>:&#123;number&#125;&lt;CR&gt;</code></strong>: Enter command mode, type the line number, and press <code>Enter</code> to jump to that line.</li><li><strong><code>&#123;number&#125;G</code></strong>: Directly jump to the specified line number (e.g., <code>10G</code> goes to line 10).</li></ul></li></ul></li><li><p><strong>Movement in screens</strong></p><ul><li><code>H</code> : (top of screen)</li><li><code>M</code> : (middle of screen)</li><li><code>L</code> : (bottom of screen)</li><li><strong>scrolling</strong><ul><li>(I often use my touchpad)</li><li><code>Ctrl-u</code> : scrolls the screen <strong>up by half a page</strong> while keeping the cursor in place.</li><li><code>Ctrl-d</code> : scrolls the screen <strong>down by half a page</strong> while keeping the cursor in place.</li></ul></li></ul></li><li><p><strong>Movement in files</strong></p><ul><li><code>gg</code> (beginning of file), <code>G</code> (end of file)</li><li>You can also use <code>]]</code> (top) and <code>[[</code> (end) commands.</li><li><strong><code>%</code></strong>: Jump to the corresponding matching item (e.g., between <code>()</code>, <code>&#123;&#125;</code>, <code>[]</code>, etc.)<ul><li><strong>This is quite useful while coding in Vim!</strong></li></ul></li></ul></li></ul><h4 id="Navigation"><a href="#Navigation" class="headerlink" title="Navigation"></a>Navigation</h4><p>In Vim, the <code>f</code>, <code>t</code>, <code>F</code>, and <code>T</code> commands are used for <strong>character-based navigation within the current line</strong>. </p><ul><li><p><strong><code>f</code></strong>: Move to the next character.</p></li><li><p><strong><code>t</code></strong>: Move just before the next character.</p></li><li><p><strong><code>F</code></strong>: Move to the previous character.</p></li><li><p><strong><code>T</code></strong>: Move just after the previous character.</p></li><li><p><strong><code>,</code></strong>: Repeat the last find command in reverse.</p></li><li><p><strong><code>;</code></strong>: Repeat the last find command forward.</p></li></ul><ol><li><p><strong>Find Character on the Current Line</strong></p><ul><li><p><strong><code>f&#123;character&#125;</code></strong>:  </p><ul><li>Moves the cursor <strong>to</strong> the next occurrence of <code>&#123;character&#125;</code> <strong>on the current line</strong>.  </li><li>Example: <code>fa</code> moves the cursor to the next <code>a</code> on the line.</li></ul></li><li><p><strong><code>t&#123;character&#125;</code></strong>:  </p><ul><li>Moves the cursor <strong>just before</strong> (up to) the next occurrence of <code>&#123;character&#125;</code> on the current line.  </li><li>Example: <code>ta</code> moves the cursor to the character right before the next <code>a</code>.</li></ul></li></ul></li><li><p><strong>Find Character Backward on the Current Line</strong></p><ul><li><p><strong><code>F&#123;character&#125;</code></strong>:  </p><ul><li>Moves the cursor <strong>to</strong> the previous occurrence of <code>&#123;character&#125;</code> on the current line (backward search).  </li><li>Example: <code>Fa</code> moves the cursor to the previous <code>a</code> on the line.</li></ul></li><li><p><strong><code>T&#123;character&#125;</code></strong>:  </p><ul><li>Moves the cursor <strong>just after</strong> (up to) the previous occurrence of <code>&#123;character&#125;</code> on the current line (backward search).  </li><li>Example: <code>Ta</code> moves the cursor to the character right after the previous <code>a</code>.</li></ul></li></ul></li><li><p><strong>Navigating Between Matches</strong></p><ul><li><p><strong><code>,</code> (comma)</strong>:  </p><ul><li>Repeats the last <code>f</code>, <code>t</code>, <code>F</code>, or <code>T</code> command in the <strong>reverse direction</strong>.  </li><li>Example: If you used <code>fa</code> to move to the next <code>a</code>, pressing <code>,</code> will move to the previous <code>a</code>.</li></ul></li><li><p><strong><code>;</code> (semicolon)</strong>:  </p><ul><li>Repeats the last <code>f</code>, <code>t</code>, <code>F</code>, or <code>T</code> command in the <strong>same direction</strong>.  </li><li>Example: If you used <code>fa</code> to move to the next <code>a</code>, pressing <code>;</code> will move to the next <code>a</code> after that.</li></ul></li></ul></li></ol><h4 id="Searching"><a href="#Searching" class="headerlink" title="Searching"></a>Searching</h4><ol><li><p><strong>Search Forward</strong></p><ul><li><strong><code>/&#123;regex&#125;&lt;CR&gt;</code></strong>:  <ul><li>Searches forward in the file for the specified regular expression (<code>&#123;regex&#125;</code>).  </li><li>Example: <code>/hello&lt;CR&gt;</code> searches for the next occurrence of the word <code>hello</code>.  </li><li>After pressing <code>Enter</code>, the cursor jumps to the first match.</li></ul></li></ul></li><li><p><strong>Navigate Matches</strong></p><ul><li><p><strong><code>n</code></strong>:  </p><ul><li>Moves the cursor to the <strong>next match</strong> of the search pattern.  </li><li>Example: After searching for <code>/hello</code>, pressing <code>n</code> jumps to the next occurrence of <code>hello</code>.</li></ul></li><li><p><strong><code>N</code></strong>:  </p><ul><li>Moves the cursor to the <strong>previous match</strong> of the search pattern.  </li><li>Example: After searching for <code>/hello</code>, pressing <code>N</code> jumps to the previous occurrence of <code>hello</code>.</li></ul></li></ul></li><li><p><strong>Search Backward</strong></p><ul><li><strong><code>?&#123;regex&#125;&lt;CR&gt;</code></strong>:  <ul><li>Searches backward in the file for the specified regular expression (<code>&#123;regex&#125;</code>).  </li><li>Example: <code>?hello&lt;CR&gt;</code> searches for the previous occurrence of the word <code>hello</code>.  </li><li>After pressing <code>Enter</code>, the cursor jumps to the first match.</li></ul></li></ul></li><li><p><strong>Additional Tips</strong></p><ul><li><strong>Highlight Matches</strong>:  <ul><li>Use <code>:set hlsearch</code> to highlight all matches of the search pattern.  <ul><li>This can be written into <code>~/.vimrc</code> file to become global settings.</li></ul></li><li>Use <code>:nohlsearch</code> (or <code>:noh</code>) to temporarily disable highlighting.</li></ul></li><li><strong>Case Sensitivity</strong>:  <ul><li>Use <code>:set ignorecase</code> (<code>:set ic</code>) to make searches case-insensitive.  </li><li>Use <code>:set smartcase</code> to make searches case-insensitive unless the search pattern contains uppercase letters.</li></ul></li></ul></li></ol><h4 id="Editing"><a href="#Editing" class="headerlink" title="Editing"></a>Editing</h4><ul><li><p><code>d&#123;motion&#125;</code> : <strong>DELETE</strong></p><ul><li><code>dw</code> is delete <strong>word</strong></li><li><code>d$</code> is delete to <strong>end of line</strong></li><li><code>d0</code> is delete to <strong>beginning of line</strong>.</li><li><code>de</code> is delete to <strong>end of word</strong></li><li><code>db</code> is delete to <strong>beginning of word</strong></li><li><code>x</code> delete character (equal to <code>dl</code>)</li><li><code>dd</code> delete the whole line.</li></ul></li><li><p><code>r&#123;motion&#125;</code> : <strong>REPLACE</strong></p><ul><li>replace the letter with the given letter where the cursor lies.</li><li>e.g. <code>rf</code> will replace the character to f where the cursor lies.</li></ul></li><li><p><code>u</code> : <strong>UNDO</strong></p><ul><li><p><code>u</code> to undo, <code>&lt;C-r&gt;</code> to redo</p><blockquote><p><code>&lt;C-r&gt;</code> means press <code>Ctrl+r</code> and it will redo the operations.</p></blockquote></li></ul></li><li><p><code>~</code> flips the case of a character.</p></li></ul><h3 id="Insert-Mode"><a href="#Insert-Mode" class="headerlink" title="Insert Mode"></a>Insert Mode</h3><p>Here you are free to text in and modify the contents.</p><ul><li><code>i</code> Enter Insert Mode<ul><li><code>a</code> is also useful for entering Inert Mode after the cursor. (For position)</li></ul></li><li><code>o</code> &#x2F; <code>O</code> insert line below &#x2F; above (in Normal mode)<ul><li>This command will <strong>first insert a new line and then change the mode from normal mode to insert mode.</strong></li></ul></li><li><code>c&#123;motion&#125;</code> : <strong>CHANGE</strong><ul><li><code>cw</code> : equals to <code>dw</code> and then enter into <strong>Insert Mode</strong>.</li><li><strong>Others are the same!</strong> <ul><li><code>cw</code>, <code>c$</code>, <code>c0</code>, <code>ce</code>, <code>cb</code>, <code>cl</code></li></ul></li><li><code>s</code> substitute character (equal to <code>cl</code>)</li><li><code>cc</code> delete the whole line and then enter into insert mode.</li></ul></li></ul><h3 id="Visual-Mode"><a href="#Visual-Mode" class="headerlink" title="Visual Mode"></a>Visual Mode</h3><p><strong>Visual mode</strong> is used to select text, which are often combined with several text-editing command.</p><ul><li><p>Visual: <code>v</code></p><ul><li>Selects text at the character level.</li></ul></li><li><p>Visual Line: <code>V</code></p><ul><li>Selects entire lines of text.</li></ul></li><li><p>Visual Block: <code>Ctrl-v</code></p><ul><li>Selects a rectangular block of text, useful for editing tables or performing the same operation on multiple lines.</li></ul></li></ul><p><strong>Shrink Selection</strong>: Press <code>o</code> to switch the cursor to the other end of the selection, then move the cursor to shrink the selection.</p><h4 id="Copy-and-Paste"><a href="#Copy-and-Paste" class="headerlink" title="Copy and Paste"></a>Copy and Paste</h4><ul><li><code>y</code> for copy<ul><li><code>yy</code> for copying for the whole line.</li><li><code>yw</code> for copying the current word.</li><li><code>y$</code> and <code>y0</code> is for the same syntax.</li></ul></li><li><code>p</code> for paste<ul><li><code>p</code> : paste after the cursor.</li><li><code>P</code> : paste before the cursor.</li></ul></li></ul><div class="note note-primary">            <p>In Vim, the <code>y</code> command copies the selected content into Vim’s <strong>registers</strong>, not the system clipboard. The <code>p</code> command pastes the content from Vim’s registers at the cursor position.</p><p><strong>How to Achieve Compatibility Between Vim and the System Clipboard</strong></p><ol><li><p><strong>Use the <code>+</code> or <code>*</code> Registers</strong>:</p><ul><li>Vim provides the <code>+</code> (system clipboard) and <code>*</code> (primary selection buffer) registers for interacting with the system clipboard.</li><li>When copying, use <code>&quot;+y</code> or <code>&quot;*y</code> to copy content to the system clipboard.<ul><li>Example: <code>&quot;+yy</code> copies the current line to the system clipboard.</li></ul></li><li>When pasting, use <code>&quot;+p</code> or <code>&quot;*p</code> to paste content from the system clipboard.<ul><li>Example: <code>&quot;+p</code> pastes content from the system clipboard.</li></ul></li></ul></li><li><p><strong>Check if Vim Supports the System Clipboard</strong>:</p><ul><li><p>Run the following command to check if Vim supports the system clipboard:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim --version | grep clipboard<br></code></pre></td></tr></table></figure></li><li><p>If the output includes <code>+clipboard</code>, Vim supports the system clipboard.</p></li><li><p>If not, you can install a version of Vim that supports the clipboard (e.g., <code>vim-gtk</code> or <code>vim-gnome</code>).</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> apt install vim-gtk<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>Configure Vim to Use the System Clipboard by Default</strong>:</p><ul><li><p>Add the following line to your Vim configuration file (<code>~/.vimrc</code> or <code>~/.config/nvim/init.vim</code>):</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">set</span> clipboard=unnamedplus<br></code></pre></td></tr></table></figure><p>This makes <code>y</code> and <code>p</code> use the system clipboard (<code>+</code> register) by default.</p></li></ul></li></ol>          </div><h2 id="Advanced-Usage"><a href="#Advanced-Usage" class="headerlink" title="Advanced Usage"></a>Advanced Usage</h2><h3 id="Counts"><a href="#Counts" class="headerlink" title="Counts"></a>Counts</h3><p>You can combine nouns and verbs with a count, which will perform a given action a number of times.</p><ul><li><code>3w</code> move 3 words forward</li><li><code>5j</code> move 5 lines down</li><li><code>7dw</code> delete 7 words</li></ul><h3 id="Modifiers"><a href="#Modifiers" class="headerlink" title="Modifiers"></a>Modifiers</h3><p>You can use modifiers to change the meaning of a noun. Some modifiers are <code>i</code>, which means “inner” or “inside”, and <code>a</code>, which means “around”.</p><ul><li><strong><code>i</code></strong> - “inner” or “inside”, acts on the inside of brackets, quotes, etc.<ul><li><code>ci(</code> change inside parentheses.</li><li><code>ci[</code> change inside square brackets.</li><li><code>ci&quot;</code> change inside double quotes.</li><li><code>ci&#39;</code> change inside single quotes.</li></ul></li><li><strong><code>a</code></strong> - “around”, includes the brackets, quotes, etc.<ul><li><code>ca(</code> change around parentheses.</li><li><code>ca[</code> change around square brackets.</li><li><code>ca&quot;</code> change around double quotes.</li><li><code>ca&#39;</code> change around single quotes.</li></ul></li></ul><h3 id="Repeat"><a href="#Repeat" class="headerlink" title="Repeat"></a>Repeat</h3><p>In Vim, the <code>.</code> command repeats the last change made, such as insertions, deletions, or replacements, making it a powerful tool for efficient editing. Additionally, <code>n .</code> repeats the last change <code>n</code> times, while <code>@:</code> repeats the last Ex command (e.g., <code>:s/foo/bar/g</code>), further enhancing productivity.</p><h2 id="Common-Shortcuts"><a href="#Common-Shortcuts" class="headerlink" title="Common Shortcuts"></a>Common Shortcuts</h2><p>It’s common for green hands to feelHere’s the table you requested, comparing common text editing shortcuts, their functions, and their corresponding Vim operations:</p><table><thead><tr><th><strong>Shortcut</strong></th><th><strong>Function</strong></th><th><strong>Vim Equivalent</strong></th></tr></thead><tbody><tr><td><code>Ctrl + C</code></td><td>Copy selected text</td><td><code>y</code> (yank, copy)</td></tr><tr><td><code>Ctrl + V</code></td><td>Paste text from clipboard</td><td><code>p</code> (paste)</td></tr><tr><td><code>Ctrl + A</code></td><td>Select all text</td><td><code>ggVG</code> (select entire file)</td></tr><tr><td><code>Ctrl + X</code></td><td>Cut selected text</td><td><code>d</code> (delete, cut)</td></tr><tr><td><code>Ctrl + S</code></td><td>Save the current file</td><td><code>:w</code> (write, save file)</td></tr></tbody></table><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p><a href="https://missing.csail.mit.edu/2020/editors/">Missing Semester</a> : It’s enough for learning vim for the first time!</p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p><strong>Vim is used for programming, yet Vim itself is a programming language!</strong> As a developer, time is the most valuable stuff, just learn it and confront it!</p><blockquote><p>The text below is the Chinese translation.</p></blockquote><h1 id="Vim-基础学习笔记"><a href="#Vim-基础学习笔记" class="headerlink" title="Vim 基础学习笔记"></a>Vim 基础学习笔记</h1><p>Vim 的学习曲线实在是太陡峭了！我已经尝试了好几次，试图习惯使用 Vim。:cry:</p><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>本文档提供了 <strong>Vim 基本功能</strong> 的全面指南，Vim 是一款功能强大的文本编辑器。它涵盖了基本命令和模式，包括命令行模式、普通模式、可视模式和插入模式。本指南还包括常见快捷键和高效文本编辑的技巧，例如在文档中移动、搜索、复制、剪切和粘贴文本。</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><h3 id="什么是-Vim"><a href="#什么是-Vim" class="headerlink" title="什么是 Vim"></a>什么是 Vim</h3><p><strong>Vim</strong> 是一个 <a href="https://en.wikipedia.org/wiki/Free_and_open-source">免费且开源的</a> <a href="https://en.wikipedia.org/wiki/Screen-based_text_editor">基于屏幕的文本编辑器</a> 程序。</p><p>就像强大的 <code>Vscode</code> 是 <strong>GUI</strong> 中最流行的代码编辑器一样，<strong>Vim</strong> 是 <strong>命令行</strong> 中最强大的文本编辑器。</p><p>我们不会在本文中讨论 Vim 有多强大，因为 <strong>Vim 是一个文本编辑器</strong>。你也可以在不使用 Vim 的情况下完成相同的任务，但会牺牲大量的时间。</p><p>在深入 Vim 的世界之前，我们需要确保 <strong>Vim 的核心原则</strong>：<strong>所有操作都通过键盘执行，而不是鼠标</strong>。</p><p><strong>Vim 的界面是一种编程语言</strong>！</p><blockquote><p>所以你最好在英文打字时不要太慢。你需要确保打字比用鼠标到处点击更高效！</p></blockquote><h2 id="Vim-中的模式"><a href="#Vim-中的模式" class="headerlink" title="Vim 中的模式"></a>Vim 中的模式</h2><ul><li>普通模式</li><li>插入模式 (<code>i</code>)</li><li>替换模式 (<code>R</code>)</li><li>可视模式 (<code>v</code>)<ul><li>行可视模式 (<code>Shift + V</code>)</li><li>块可视模式 (<code>Ctrl + V</code>)</li></ul></li><li>命令行模式 (<code>:</code>)</li></ul><h3 id="命令行模式"><a href="#命令行模式" class="headerlink" title="命令行模式"></a>命令行模式</h3><p>在普通模式下按 <code>:</code> 可以进入命令行模式。按下 <code>:</code> 后，光标会跳转到屏幕底部的命令行。此模式具有许多功能，包括打开、保存和关闭文件，以及 <a href="https://twitter.com/iamdevloper/status/435555976687923200">退出 Vim</a>。</p><ul><li><code>:q</code> 退出（关闭窗口）</li><li><code>:w</code> 保存（“写入”）</li><li><code>:wq</code> 保存并退出</li><li><code>:e &#123;文件名&#125;</code> 打开文件进行编辑</li><li><code>:ls</code> 显示打开的缓冲区</li><li><code>:help &#123;主题&#125;</code> 打开帮助<ul><li><code>:help :w</code> 打开 <code>:w</code> 命令的帮助</li><li><code>:help w</code> 打开 <code>w</code> 移动命令的帮助</li></ul></li></ul><h3 id="普通模式"><a href="#普通模式" class="headerlink" title="普通模式"></a>普通模式</h3><h4 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h4><p>在 Vim 中，你不能简单地用鼠标点击某个位置来移动光标。<strong>在普通模式下</strong>，你可以使用几个键来高效地将光标移动到任何你想要的位置！</p><p>根据 <strong>精确度</strong>，Vim 的移动键可以分为不同的类别。</p><ul><li><p><strong>字符级移动</strong></p><ul><li><code>hjkl</code>（左、下、上、右）</li></ul></li><li><p><strong>单词级移动</strong></p><ul><li><code>w</code>：移动到下一个单词</li><li><code>b</code>：移动到单词的开头</li><li><code>e</code>：移动到单词的末尾</li></ul></li><li><p><strong>行级移动</strong></p><ul><li><p><code>0</code>：移动到行首</p><ul><li>组合键 <code>j+0</code>：移动到下一行的行首。</li><li>组合键 <code>k+0</code>：移动到上一行的行首。</li></ul></li><li><p><code>Enter</code>：移动到下一行的行首</p></li><li><p><code>^</code>：移动到第一个非空白字符</p></li><li><p><code>$</code>：移动到行尾</p></li><li><p><code>+</code>：移动到下一行的第一个非空白字符</p></li><li><p><code>&#123;</code> 和 <code>&#125;</code>：移动到下一个空行</p></li><li><p>行号：<code>:&#123;number&#125;&lt;CR&gt;</code> 或 <code>&#123;number&#125;G</code>（跳转到第 {number} 行）</p><blockquote><p><code>&lt;CR&gt;</code> 表示按下 <code>Enter</code> 键。</p></blockquote><ul><li>**<code>:&#123;number&#125;&lt;CR&gt;</code>**：进入命令行模式，输入行号，然后按 <code>Enter</code> 跳转到该行。</li><li>**<code>&#123;number&#125;G</code>**：直接跳转到指定行号（例如，<code>10G</code> 跳转到第 10 行）。</li></ul></li></ul></li><li><p><strong>屏幕级移动</strong></p><ul><li><code>H</code>：移动到屏幕顶部</li><li><code>M</code>：移动到屏幕中间</li><li><code>L</code>：移动到屏幕底部</li><li><strong>滚动</strong><ul><li>（我通常使用触摸板）</li><li><code>Ctrl-u</code>：向上滚动半页，同时保持光标位置不变。</li><li><code>Ctrl-d</code>：向下滚动半页，同时保持光标位置不变。</li></ul></li></ul></li><li><p><strong>文件级移动</strong></p><ul><li><code>gg</code>（文件开头），<code>G</code>（文件末尾）</li><li>你也可以使用 <code>]]</code>（顶部）和 <code>[[</code>（末尾）命令。</li><li>**<code>%</code>**：跳转到匹配的符号（例如 <code>()</code>、<code>&#123;&#125;</code>、<code>[]</code> 等）<ul><li><strong>这在 Vim 中编程时非常有用！</strong></li></ul></li></ul></li></ul><h4 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h4><p>在 Vim 中，<code>f</code>、<code>t</code>、<code>F</code> 和 <code>T</code> 命令用于 <strong>在当前行内进行基于字符的导航</strong>。</p><ul><li><p>**<code>f</code>**：移动到下一个字符。</p></li><li><p>**<code>t</code>**：移动到下一个字符的前一个位置。</p></li><li><p>**<code>F</code>**：移动到上一个字符。</p></li><li><p>**<code>T</code>**：移动到上一个字符的后一个位置。</p></li><li><p>**<code>,</code>**：反向重复上一次查找命令。</p></li><li><p>**<code>;</code>**：正向重复上一次查找命令。</p></li></ul><ol><li><p><strong>在当前行查找字符</strong></p><ul><li>**<code>f&#123;字符&#125;</code>**：<ul><li>将光标移动到当前行中下一个 <code>&#123;字符&#125;</code> 的位置。</li><li>示例：<code>fa</code> 将光标移动到下一个 <code>a</code>。</li></ul></li><li>**<code>t&#123;字符&#125;</code>**：<ul><li>将光标移动到当前行中下一个 <code>&#123;字符&#125;</code> 的前一个位置。</li><li>示例：<code>ta</code> 将光标移动到下一个 <code>a</code> 的前一个位置。</li></ul></li></ul></li><li><p><strong>在当前行反向查找字符</strong></p><ul><li>**<code>F&#123;字符&#125;</code>**：<ul><li>将光标移动到当前行中上一个 <code>&#123;字符&#125;</code> 的位置（反向搜索）。</li><li>示例：<code>Fa</code> 将光标移动到上一个 <code>a</code>。</li></ul></li><li>**<code>T&#123;字符&#125;</code>**：<ul><li>将光标移动到当前行中上一个 <code>&#123;字符&#125;</code> 的后一个位置（反向搜索）。</li><li>示例：<code>Ta</code> 将光标移动到上一个 <code>a</code> 的后一个位置。</li></ul></li></ul></li><li><p><strong>在匹配项之间导航</strong></p><ul><li><strong><code>,</code>（逗号）</strong>：<ul><li>反向重复上一次 <code>f</code>、<code>t</code>、<code>F</code> 或 <code>T</code> 命令。</li><li>示例：如果你使用 <code>fa</code> 移动到下一个 <code>a</code>，按 <code>,</code> 将移动到上一个 <code>a</code>。</li></ul></li><li><strong><code>;</code>（分号）</strong>：<ul><li>正向重复上一次 <code>f</code>、<code>t</code>、<code>F</code> 或 <code>T</code> 命令。</li><li>示例：如果你使用 <code>fa</code> 移动到下一个 <code>a</code>，按 <code>;</code> 将移动到下一个 <code>a</code>。</li></ul></li></ul></li></ol><h4 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h4><ol><li><p><strong>向前搜索</strong></p><ul><li>**<code>/&#123;正则表达式&#125;&lt;CR&gt;</code>**：<ul><li>在文件中向前搜索指定的正则表达式（<code>&#123;正则表达式&#125;</code>）。</li><li>示例：<code>/hello&lt;CR&gt;</code> 搜索下一个 <code>hello</code>。</li><li>按下 <code>Enter</code> 后，光标跳转到第一个匹配项。</li></ul></li></ul></li><li><p><strong>导航匹配项</strong></p><ul><li>**<code>n</code>**：<ul><li>将光标移动到搜索模式的下一个匹配项。</li><li>示例：搜索 <code>/hello</code> 后，按 <code>n</code> 跳转到下一个 <code>hello</code>。</li></ul></li><li>**<code>N</code>**：<ul><li>将光标移动到搜索模式的上一个匹配项。</li><li>示例：搜索 <code>/hello</code> 后，按 <code>N</code> 跳转到上一个 <code>hello</code>。</li></ul></li></ul></li><li><p><strong>向后搜索</strong></p><ul><li>**<code>?&#123;正则表达式&#125;&lt;CR&gt;</code>**：<ul><li>在文件中向后搜索指定的正则表达式（<code>&#123;正则表达式&#125;</code>）。</li><li>示例：<code>?hello&lt;CR&gt;</code> 搜索上一个 <code>hello</code>。</li><li>按下 <code>Enter</code> 后，光标跳转到第一个匹配项。</li></ul></li></ul></li><li><p><strong>额外提示</strong></p><ul><li><strong>高亮匹配项</strong>：<ul><li>使用 <code>:set hlsearch</code> 高亮所有匹配项。<ul><li>可以将其写入 <code>~/.vimrc</code> 文件以成为全局设置。</li></ul></li><li>使用 <code>:nohlsearch</code>（或 <code>:noh</code>）暂时禁用高亮。</li></ul></li><li><strong>大小写敏感</strong>：<ul><li>使用 <code>:set ignorecase</code>（<code>:set ic</code>）使搜索不区分大小写。</li><li>使用 <code>:set smartcase</code> 使搜索不区分大小写，除非搜索模式包含大写字母。</li></ul></li></ul></li></ol><h4 id="编辑"><a href="#编辑" class="headerlink" title="编辑"></a>编辑</h4><ul><li><p><code>d&#123;移动命令&#125;</code>：<strong>删除</strong></p><ul><li><code>dw</code> 删除一个单词</li><li><code>d$</code> 删除到行尾</li><li><code>d0</code> 删除到行首</li><li><code>de</code> 删除到单词末尾</li><li><code>db</code> 删除到单词开头</li><li><code>x</code> 删除字符（等同于 <code>dl</code>）</li><li><code>dd</code> 删除整行</li></ul></li><li><p><code>r&#123;移动命令&#125;</code>：<strong>替换</strong></p><ul><li>将光标处的字符替换为指定字符。</li><li>例如：<code>rf</code> 将光标处的字符替换为 <code>f</code>。</li></ul></li><li><p><code>u</code>：<strong>撤销</strong></p><ul><li><p><code>u</code> 撤销，<code>Ctrl + r</code> 重做</p><blockquote><p><code>Ctrl + r</code> 表示按下 <code>Ctrl + r</code>，它将重做操作。</p></blockquote></li></ul></li><li><p><code>~</code> 切换字符的大小写</p></li></ul><h3 id="插入模式"><a href="#插入模式" class="headerlink" title="插入模式"></a>插入模式</h3><p>在这里，你可以自由输入和修改内容。</p><ul><li><code>i</code> 进入插入模式<ul><li><code>a</code> 也可以用于在光标后进入插入模式（用于定位）</li></ul></li><li><code>o</code> &#x2F; <code>O</code> 在下方 &#x2F; 上方插入新行（在普通模式下）<ul><li>此命令会 <strong>先插入新行，然后将模式从普通模式切换到插入模式</strong>。</li></ul></li><li><code>c&#123;移动命令&#125;</code>：<strong>更改</strong><ul><li><code>cw</code>：等同于 <code>dw</code>，然后进入 <strong>插入模式</strong>。</li><li><strong>其他命令类似！</strong><ul><li><code>cw</code>、<code>c$</code>、<code>c0</code>、<code>ce</code>、<code>cb</code>、<code>cl</code></li></ul></li><li><code>s</code> 替换字符（等同于 <code>cl</code>）</li><li><code>cc</code> 删除整行并进入插入模式。</li></ul></li></ul><h3 id="可视模式"><a href="#可视模式" class="headerlink" title="可视模式"></a>可视模式</h3><p><strong>可视模式</strong> 用于选择文本，通常与多个文本编辑命令结合使用。</p><ul><li><p>可视模式：<code>v</code></p><ul><li>以字符级别选择文本。</li></ul></li><li><p>行可视模式：<code>V</code></p><ul><li>选择整行文本。</li></ul></li><li><p>块可视模式：<code>Ctrl + v</code></p><ul><li>选择一个矩形文本块，适用于编辑表格或在多行上执行相同操作。</li></ul></li></ul><p><strong>缩小选择范围</strong>：按 <code>o</code> 将光标切换到选择的另一端，然后移动光标以缩小选择范围。</p><h4 id="复制和粘贴"><a href="#复制和粘贴" class="headerlink" title="复制和粘贴"></a>复制和粘贴</h4><ul><li><code>y</code> 复制<ul><li><code>yy</code> 复制整行</li><li><code>yw</code> 复制当前单词</li><li><code>y$</code> 和 <code>y0</code> 语法相同</li></ul></li><li><code>p</code> 粘贴<ul><li><code>p</code>：粘贴到光标后</li><li><code>P</code>：粘贴到光标前</li></ul></li></ul><div class="note note-primary">            <p>在 Vim 中，<code>y</code> 命令将选中的内容复制到 Vim 的 <strong>寄存器</strong> 中，而不是系统剪贴板。<code>p</code> 命令将内容从 Vim 的寄存器粘贴到光标位置。</p><p><strong>如何实现 Vim 与系统剪贴板的兼容性</strong></p><ol><li><p><strong>使用 <code>+</code> 或 <code>*</code> 寄存器</strong>：</p><ul><li>Vim 提供了 <code>+</code>（系统剪贴板）和 <code>*</code>（主选择缓冲区）寄存器，用于与系统剪贴板交互。</li><li>复制时，使用 <code>&quot;+y</code> 或 <code>&quot;*y</code> 将内容复制到系统剪贴板。<ul><li>示例：<code>&quot;+yy</code> 将当前行复制到系统剪贴板。</li></ul></li><li>粘贴时，使用 <code>&quot;+p</code> 或 <code>&quot;*p</code> 从系统剪贴板粘贴内容。<ul><li>示例：<code>&quot;+p</code> 从系统剪贴板粘贴内容。</li></ul></li></ul></li><li><p><strong>检查 Vim 是否支持系统剪贴板</strong>：</p><ul><li><p>运行以下命令检查 Vim 是否支持系统剪贴板：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim --version | grep clipboard<br></code></pre></td></tr></table></figure></li><li><p>如果输出包含 <code>+clipboard</code>，则 Vim 支持系统剪贴板。</p></li><li><p>如果不支持，可以安装支持剪贴板的 Vim 版本（例如 <code>vim-gtk</code> 或 <code>vim-gnome</code>）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> apt install vim-gtk<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>配置 Vim 默认使用系统剪贴板</strong>：</p><ul><li><p>在 Vim 配置文件（<code>~/.vimrc</code> 或 <code>~/.config/nvim/init.vim</code>）中添加以下行：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">set</span> clipboard=unnamedplus<br></code></pre></td></tr></table></figure><p>这将使 <code>y</code> 和 <code>p</code> 默认使用系统剪贴板（<code>+</code> 寄存器）。</p></li></ul></li></ol>          </div><h2 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h2><h3 id="计数"><a href="#计数" class="headerlink" title="计数"></a>计数</h3><p>你可以将名词和动词与计数结合使用，以执行给定次数的操作。</p><ul><li><code>3w</code> 向前移动 3 个单词</li><li><code>5j</code> 向下移动 5 行</li><li><code>7dw</code> 删除 7 个单词</li></ul><h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><p>你可以使用修饰符来改变名词的含义。一些修饰符包括 <code>i</code>，表示“内部”或“里面”，以及 <code>a</code>，表示“周围”。</p><ul><li><strong><code>i</code></strong> - “内部” 或 “里面”，作用于括号、引号等的内部。<ul><li><code>ci(</code> 更改括号内的内容。</li><li><code>ci[</code> 更改方括号内的内容。</li><li><code>ci&quot;</code> 更改双引号内的内容。</li><li><code>ci&#39;</code> 更改单引号内的内容。</li></ul></li><li><strong><code>a</code></strong> - “周围”，包括括号、引号等。<ul><li><code>ca(</code> 更改括号及其内容。</li><li><code>ca[</code> 更改方括号及其内容。</li><li><code>ca&quot;</code> 更改双引号及其内容。</li><li><code>ca&#39;</code> 更改单引号及其内容。</li></ul></li></ul><h3 id="重复"><a href="#重复" class="headerlink" title="重复"></a>重复</h3><p>在 Vim 中，<code>.</code> 命令重复上一次的更改操作，例如插入、删除或替换，使其成为高效编辑的强大工具。此外，<code>n .</code> 重复上一次更改 <code>n</code> 次，而 <code>@:</code> 重复上一次 Ex 命令（例如 <code>:s/foo/bar/g</code>），进一步提高生产力。</p><h2 id="常见快捷键"><a href="#常见快捷键" class="headerlink" title="常见快捷键"></a>常见快捷键</h2><p>新手常常感到困惑，以下表格比较了常见的文本编辑快捷键、它们的功能以及对应的 Vim 操作：</p><table><thead><tr><th><strong>快捷键</strong></th><th><strong>功能</strong></th><th><strong>Vim 等效操作</strong></th></tr></thead><tbody><tr><td><code>Ctrl + C</code></td><td>复制选中的文本</td><td><code>y</code>（复制）</td></tr><tr><td><code>Ctrl + V</code></td><td>粘贴剪贴板中的文本</td><td><code>p</code>（粘贴）</td></tr><tr><td><code>Ctrl + A</code></td><td>全选文本</td><td><code>ggVG</code>（选择整个文件）</td></tr><tr><td><code>Ctrl + X</code></td><td>剪切选中的文本</td><td><code>d</code>（删除，剪切）</td></tr><tr><td><code>Ctrl + S</code></td><td>保存当前文件</td><td><code>:w</code>（写入，保存文件）</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>Efficient Tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tutorial</tag>
      
      <tag>Vim</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DataStructure-Queue</title>
    <link href="/posts/DataStructure-Queue/"/>
    <url>/posts/DataStructure-Queue/</url>
    
    <content type="html"><![CDATA[<style>  html, body, .markdown-body {    font-family: Georgia, sans, serif;  }</style><h1 id="Data-Structure-Queue"><a href="#Data-Structure-Queue" class="headerlink" title="Data_Structure Queue"></a>Data_Structure Queue</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>在之前的学习过程中，我们主要介绍了<strong>线性数据结构</strong>——线性表，同时介绍了一种非常特殊的线性表：<strong>栈</strong>。栈的关键在于<strong>约束了数据结构输入数据和输出数据的顺序</strong>：即<strong>LIFO</strong>的顺序。（不过有个前提，栈是线性的数据结构，因此数据结构的排列一定是线性的）</p><p><strong>LIFO</strong>的顺序可以帮助我们完成很多事，例如在上一讲的末尾：<strong>括号匹配器和简单的计算器（中缀转后缀）</strong>，尤其在<strong>输入和输出顺序不一致的情况下</strong>，栈可以发挥很大的作用。</p><blockquote><p>这再次印证了那句话：数据结构的本质是对实际情形的抽象数据建模。</p></blockquote><p>我们可以沿着这条线继续思考，我们是否可以人为更改<strong>输入数据顺序和输出数据顺序的约束</strong>，而创建新的数据类型？答案当然是肯定的，今天，我们来介绍一种新的数据结构——队列（Queue）</p><h2 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h2><p><strong>栈</strong>：元素的插入和删除操作只能在<strong>栈的一端</strong>进行，这一端称为 <strong>栈顶（Top）</strong>，另一端称为 <strong>栈底（Bottom）</strong>。</p><p><strong>队列</strong>：元素的插入操作在队列的一端进行，称为 <strong>队尾（Rear）</strong>，删除操作在另一端进行，称为 <strong>队头（Front）</strong>。</p><blockquote><p>双向队列是一种允许在 <strong>两端</strong> 进行插入和删除操作的线性数据结构。它结合了栈和队列的特性，既可以从队头操作，也可以从队尾操作。</p><p>双向队列即有栈的性质，也有队列的性质，后续会专门花一讲的时间辨析这三者使用上的区别。</p></blockquote><p><img src="https://www.hello-algo.com/chapter_stack_and_queue/queue.assets/queue_operations.png" alt="队列的先入先出规则 Hello算法"></p><p>形象化理解非常的容易，就像元素在<strong>排队一样</strong>，满足先来后到的顺序，这也是队列区别于栈的最显著的差别，也是队列最核心的性质：<strong>FIFO (First in First out)<strong>，也就是说，</strong>队列不会导致输入顺序和输出顺序的差异</strong>。</p><h2 id="Basic-Usage"><a href="#Basic-Usage" class="headerlink" title="Basic Usage"></a>Basic Usage</h2><p>和栈类似，队列的基本操作如下：</p><ul><li>创建一个队列<code>create()</code></li><li>入队<code>push(const T&amp; value)</code>：将<code>value</code>插入成为<strong>队尾元素</strong></li><li>出队<code>pop()</code>：使队头元素出队并且返回这个元素的值。</li><li>读队头元素<code>getHead()</code></li><li>判断队空<code>isEmpty()</code></li></ul><p>下文代码是实现该定义的抽象基类：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//Abstract class</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">queue</span>&#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">queue</span>()&#123;&#125;<br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>=<span class="hljs-number">0</span>;<br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> T <span class="hljs-title">getHead</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>=<span class="hljs-number">0</span>;<br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> T <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; value)</span></span>=<span class="hljs-number">0</span>;<br>&#125;;<br><span class="hljs-comment">//抽象基类仅仅定义接口，没有具体的数据成员</span><br></code></pre></td></tr></table></figure><h2 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h2><h3 id="Sequential-Implementation"><a href="#Sequential-Implementation" class="headerlink" title="Sequential Implementation"></a>Sequential Implementation</h3><blockquote><p>下面的思考和优化过程非常的精彩，请反复回味。</p></blockquote><p>下文实现队列的顺序实现，即使用<strong>一块动态内存来存储线性的所有数据</strong>。在栈中，由于所有的操作都是在栈顶完成的，因此，我们只需要<strong>对栈顶元素进行操作</strong>，时间复杂度为O(1)。但是，在队列中<strong>涉及双端操作：即输入端和输出端不在一起</strong>。这就会带来时间复杂度上的提升：例如固定队首元素，并且将此作为<strong>出队口</strong>，（就像超市结账人们在收银台处排队一样），入队的操作复杂度为O(1)，但是出队的时候所有元素都要前移一格，时间复杂度为O(n)。</p><p>这并不符合我们的预期——<strong>我们希望出队和入队都达到最简单的O（1）时间复杂度</strong>，如何优化？</p><p>这就是第一个优化策略：<strong>维护一个类似于头指针的东西</strong>，在顺序实现中，就是一个<code>int</code>值<code>front</code>来<strong>维护队头元素的索引</strong>。同时我们也会维护一个<code>int</code>值<code>rear</code>来锚定队尾元素。在队列为空的时候，设置<code>front</code>和<code>rear</code>均为-1。</p><p><img src="https://www.hello-algo.com/chapter_stack_and_queue/queue.assets/array_queue_step1.png" alt="基于数组实现队列的入队出队操作"></p><p>这样很好的解决了我们的问题，实现了入队和出队的时间复杂度均为常数时间复杂度。但是这有一个很隐蔽的问题：空间利用率问题。<strong>出队是数组元素没有移动而是索引<code>front</code>向后移动</strong>，这样会造成空间上的浪费，<code>front</code>索引之前的部分无法再存储新的数据元素，这样的情况会随着出队元素的不断增多而更加凸显出来。</p><p>于是，我们需要第二个优化策略：<strong>循环队列</strong>。那这样两个索引在分配的内存上无论怎么移动都不会造成空间使用上的浪费了，具体实现也很简单：<strong>使用取余操作</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//非循环队列的入队操作：</span><br>rear++;<br><span class="hljs-comment">//循环队列的入队操作：</span><br>rear=(rear<span class="hljs-number">+1</span>)%Maxsize;<br><br><span class="hljs-comment">//非循环队列的出队操作:</span><br>front++;<br><span class="hljs-comment">//循环队列的出队操作：</span><br>front=(front<span class="hljs-number">+1</span>)%MAxsize;<br></code></pre></td></tr></table></figure><p><strong>使用取余操作可以保证<code>rear</code>和<code>front</code>这两个索引值始终都在<code>[0,Maxsize-1]</code>这个区间范围内</strong>。</p><p>这样看似就没有问题了！真的如此吗？</p><p>我们重新回看<code>rear</code>和<code>front</code>这两个索引值，这两个索引值表示的是什么？<code>front</code>指向的是首元素，而<code>rear</code>指向的是尾元素+1。当初始建队时，这两个值都设置为0，如果不断入队，rear不断递增直到走完了一个周期，取余后<strong>和front重合</strong>，此时队列的元素达到了<strong>100%<strong>的空间利用率，但是无法判断</strong>队满还是队空</strong>。</p><p>因此，一定的牺牲肯定是必要的，就像链表中的头结点不储存值一样，<strong>循环队列需要保证rear索引所在的地方不存储值</strong>，即理论上队列的最大存储值的个数是<code>Maxsize-1</code>个。</p><p><img src="https://docs.oldtimes.me/c.biancheng.net/cpp/uploads/allimg/140713/1-140G32234251B.jpg" alt="循环队列"></p><blockquote><p>教材上设置的是<strong>front</strong>不存储值，没有太大的影响。</p></blockquote><p>做了这样的规定之后，我们就能确定队满和队空了。</p><blockquote><p>实际上还有一种操作，维护一个int值表示队列的长度，此时就可以达到100%的空间利用率</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//队满的判定条件：</span><br>(rear<span class="hljs-number">+1</span>) % Maxsize == front;<br>    <span class="hljs-comment">//注意这里是对rear做操作而不是front，因为对rear做操作代表着入队操作。</span><br><span class="hljs-comment">//队空的判定条件：</span><br>front == rear;<br></code></pre></td></tr></table></figure><p>理解了上面精彩的演绎推理过程，我们轻而易举的可以实现队列的顺序实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @Author: Xiyuan Yang   xiyuan_yang@outlook.com</span><br><span class="hljs-comment"> * @Date: 2025-01-22 15:06:31</span><br><span class="hljs-comment"> * @LastEditors: Xiyuan Yang   xiyuan_yang@outlook.com</span><br><span class="hljs-comment"> * @LastEditTime: 2025-01-22 17:23:51</span><br><span class="hljs-comment"> * @FilePath: \CODE_for_Vscode\Data_structure\Class_implementation\Stack.cpp</span><br><span class="hljs-comment"> * @Description: </span><br><span class="hljs-comment"> * Do you code and make progress today?</span><br><span class="hljs-comment"> * Copyright (c) 2025 by Xiyuan Yang, All Rights Reserved. </span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">This is the implementation of the stack</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdexcept&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><br><span class="hljs-comment">//Abstract class</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">queue</span>&#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">queue</span>()&#123;&#125;<br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>=<span class="hljs-number">0</span>;<br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> T <span class="hljs-title">getHead</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>=<span class="hljs-number">0</span>;<br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> T <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; value)</span></span>=<span class="hljs-number">0</span>;<br>&#125;;<br><span class="hljs-comment">//抽象基类仅仅定义接口，没有具体的数据成员</span><br><br><span class="hljs-comment">//Sequential Implementation of stack</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">seqQueue</span>:<span class="hljs-keyword">public</span> queue&lt;T&gt;&#123;<br>    <span class="hljs-keyword">private</span>:<br>        T* elem;<span class="hljs-comment">//the elements</span><br>        <span class="hljs-type">int</span> maxsize;<br>        <span class="hljs-type">int</span> front,rear;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DoubleSpace</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//Tool functions for space extensions</span><br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">seqQueue</span>(<span class="hljs-type">int</span> size=<span class="hljs-number">10</span>);<br>        ~<span class="hljs-built_in">seqQueue</span>();<br>        <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; value)</span></span>;<br>        <span class="hljs-function">T <span class="hljs-title">getHead</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>        <span class="hljs-function">T <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>;<br><br>        <span class="hljs-comment">//Only for debugging</span><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">length</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>&#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br>seqQueue&lt;T&gt;::<span class="hljs-built_in">seqQueue</span>(<span class="hljs-type">int</span> size):<span class="hljs-built_in">maxsize</span>(size)&#123;<br>    elem = <span class="hljs-keyword">new</span> T[maxsize];<br>    <span class="hljs-comment">//but the maximum capacity is maxsize-1</span><br>    front = rear =<span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br>seqQueue&lt;T&gt;::~<span class="hljs-built_in">seqQueue</span>()&#123;<br>    <span class="hljs-keyword">delete</span>[] elem;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br>T seqQueue&lt;T&gt;::<span class="hljs-built_in">getHead</span>() <span class="hljs-type">const</span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isEmpty</span>()) &#123;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;Queue is empty&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> elem[front];<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-type">bool</span> seqQueue&lt;T&gt;::<span class="hljs-built_in">isEmpty</span>() <span class="hljs-type">const</span>&#123;<br>    <span class="hljs-keyword">return</span> front==rear;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-type">void</span> seqQueue&lt;T&gt;::<span class="hljs-built_in">push</span>(<span class="hljs-type">const</span> T&amp; value)&#123;<br>    <span class="hljs-comment">//入队操作，需要对rear操作</span><br>    <span class="hljs-keyword">if</span>((rear<span class="hljs-number">+1</span>) % maxsize == front)&#123;<br>        <span class="hljs-comment">//judge if the queue is full</span><br>        <span class="hljs-built_in">DoubleSpace</span>();<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        elem[rear]=value;<br>        rear=(rear<span class="hljs-number">+1</span>)%maxsize;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br>T seqQueue&lt;T&gt;::<span class="hljs-built_in">pop</span>()&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isEmpty</span>()) &#123;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;Queue is empty&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//出队操作，对front操作</span><br>    T temp = elem[front];<span class="hljs-comment">//the top element of the queue</span><br>    front = (front<span class="hljs-number">+1</span>)%maxsize;<br>    <span class="hljs-keyword">return</span> temp;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-type">void</span> seqQueue&lt;T&gt;::<span class="hljs-built_in">DoubleSpace</span>()&#123;<br>    <span class="hljs-comment">//double the space of the queue</span><br>    T* tmp=elem;<br>    elem = <span class="hljs-keyword">new</span> T[<span class="hljs-number">2</span>*maxsize];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;maxsize<span class="hljs-number">-1</span>;i++)&#123;<br>        elem[i] = tmp[(front+i)%maxsize];<br>        <span class="hljs-comment">//you only need to copy maxsize-1 elements!</span><br>    &#125;<br>    front = <span class="hljs-number">0</span>;<br>    rear = maxsize<span class="hljs-number">-1</span>;<br>    maxsize*=<span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">delete</span>[] tmp;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-type">void</span> seqQueue&lt;T&gt;::<span class="hljs-built_in">print</span>()<span class="hljs-type">const</span> &#123;<br>    <span class="hljs-comment">//print the whole queue</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isEmpty</span>())&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;The queue is empty!&quot;</span>&lt;&lt;endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;The queue has &quot;</span>&lt;&lt;<span class="hljs-built_in">length</span>()&lt;&lt;<span class="hljs-string">&quot; members.&quot;</span>&lt;&lt;endl;<br>        <span class="hljs-type">int</span> index = front;<br>        <span class="hljs-keyword">while</span>(index != rear)&#123;<br>            cout&lt;&lt;elem[index]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>            index = (index<span class="hljs-number">+1</span>)%maxsize;<br>        &#125;<br>        cout&lt;&lt;endl;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-type">int</span> seqQueue&lt;T&gt;::<span class="hljs-built_in">length</span>() <span class="hljs-type">const</span>&#123;<br>    <span class="hljs-keyword">if</span>(rear &gt;= front) <span class="hljs-keyword">return</span> rear-front;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> rear+maxsize-front;<br>&#125;<br><span class="hljs-comment">//The following function implements some small debugging features.</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    seqQueue&lt;<span class="hljs-type">int</span>&gt; list;<br>    list.<span class="hljs-built_in">print</span>();<br>    list.<span class="hljs-built_in">push</span>(<span class="hljs-number">2</span>);<br>    list.<span class="hljs-built_in">push</span>(<span class="hljs-number">5</span>);<br>    cout&lt;&lt;list.<span class="hljs-built_in">isEmpty</span>()&lt;&lt;endl;<br>    list.<span class="hljs-built_in">print</span>();<br>    cout&lt;&lt;list.<span class="hljs-built_in">pop</span>();<br>    cout&lt;&lt;list.<span class="hljs-built_in">pop</span>();<br>    cout&lt;&lt;list.<span class="hljs-built_in">isEmpty</span>()&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Linked-Implementation"><a href="#Linked-Implementation" class="headerlink" title="Linked Implementation"></a>Linked Implementation</h3><p>队列的链接实现被称为<strong>链接队列</strong>。由于队列不会涉及<strong>遍历</strong>（而这是链接实现所不擅长的），只会设计单个元素的<strong>出队和入队</strong>等操作，因此队列的链接实现使用最简单的<strong>单链表</strong>即可。</p><p>同时，出队就将队首元素释放，入队就在队尾新增一个元素，因此也不涉及<strong>循环队列</strong>的使用。</p><p>唯一不同的是，为了快速的定位到队尾元素，链接队列需要额外储存<strong>队尾元素的地址</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">linkQueue</span> : <span class="hljs-keyword">public</span> queue&lt;T&gt;&#123;<br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span><br>        &#123;<br>            T data;<br>            Node* next;<br>            <span class="hljs-comment">//parameterized constructor(default)</span><br>            <span class="hljs-built_in">Node</span>(<span class="hljs-type">const</span> T&amp; value = <span class="hljs-number">0</span>, Node *p = <span class="hljs-literal">nullptr</span>)&#123;<br>                data = value;<br>                next = p;<br>            &#125;<br>            <span class="hljs-comment">//destructor</span><br>            ~<span class="hljs-built_in">Node</span>()&#123;&#125;<br>        &#125;;<br>        Node *front, *rear;<br>        <span class="hljs-comment">//two pointers point at the front or the end of the queue.</span><br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">linkQueue</span>();<br>        <span class="hljs-comment">//This constructor is used to create a new linked queue.</span><br>        <span class="hljs-comment">//Todo: implement copy constructor and the overload of = (assignment)</span><br>        ~<span class="hljs-built_in">linkQueue</span>();<br>        <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>        <span class="hljs-function">T <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>;<br>        <span class="hljs-function">T <span class="hljs-title">getHead</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; value)</span></span>;<br><br>        <span class="hljs-comment">//for debugging</span><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">length</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>        <br>&#125;;<br><br><br><span class="hljs-comment">//Implementation of linked queue</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br>linkQueue&lt;T&gt;::<span class="hljs-built_in">linkQueue</span>()&#123;<br>    <span class="hljs-comment">//set nullptr for both pointers</span><br>    front = rear = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-comment">//it is also the judgement of an empty queue</span><br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br>linkQueue&lt;T&gt;::~<span class="hljs-built_in">linkQueue</span>()&#123;<br>    Node * temp;<br>    <span class="hljs-keyword">while</span>(front != <span class="hljs-literal">nullptr</span>)&#123;<br>        <span class="hljs-comment">//simulate the process of leaving the queue until the queue is empty.</span><br>        temp = front;<br>        front = front -&gt; next;<br>        <span class="hljs-keyword">delete</span> temp;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-type">bool</span> linkQueue&lt;T&gt;::<span class="hljs-built_in">isEmpty</span>() <span class="hljs-type">const</span> &#123;<br>    <span class="hljs-keyword">return</span> front == <span class="hljs-literal">nullptr</span>;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br>T linkQueue&lt;T&gt;::<span class="hljs-built_in">getHead</span>() <span class="hljs-type">const</span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isEmpty</span>()) &#123;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;Queue is empty&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> front -&gt; data;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-type">void</span> linkQueue&lt;T&gt;::<span class="hljs-built_in">push</span>(<span class="hljs-type">const</span> T&amp; value)&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isEmpty</span>())&#123;<br>        front = rear = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(value);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        Node *newnode = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(value);<br>        rear -&gt; next = newnode;<br>        rear = rear -&gt; next;<br>        <span class="hljs-comment">//! ensure the rear -&gt; next often points to the nullptr</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br>T linkQueue&lt;T&gt;::<span class="hljs-built_in">pop</span>()&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isEmpty</span>()) &#123;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;Queue is empty&quot;</span>);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        T ans = front -&gt; data;<br>        Node* tmp = front;<br>        front = front -&gt; next;<br>        <span class="hljs-keyword">if</span>(front == <span class="hljs-literal">nullptr</span>)&#123;<br>            rear = <span class="hljs-literal">nullptr</span>;<br>            <span class="hljs-comment">//now the queue is empty!</span><br>            <span class="hljs-comment">//This is necessary, because before the pop process, the front and the rear pointer points at the same space</span><br>            <span class="hljs-comment">//now front moves to nullptr, rear pointer becomes INVALID! </span><br>        &#125;<br>        <span class="hljs-keyword">delete</span> tmp;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-type">int</span> linkQueue&lt;T&gt;::<span class="hljs-built_in">length</span>() <span class="hljs-type">const</span> &#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isEmpty</span>())&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> length=<span class="hljs-number">0</span>;<br>    Node* traverseptr = front;<br>    <span class="hljs-keyword">while</span>(traverseptr != <span class="hljs-literal">nullptr</span>)&#123;<br>        traverseptr = traverseptr -&gt; next;<br>        length++; <br>    &#125;<br>    <span class="hljs-keyword">return</span> length;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-type">void</span> linkQueue&lt;T&gt;::<span class="hljs-built_in">print</span>()<span class="hljs-type">const</span> &#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isEmpty</span>())&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;The queue is empty!&quot;</span> &lt;&lt; std::endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-type">int</span> length=<span class="hljs-number">0</span>;<br>        Node* traverseptr = front;<br>        <span class="hljs-keyword">while</span>(traverseptr != <span class="hljs-literal">nullptr</span>)&#123;<br>            std::cout &lt;&lt; traverseptr -&gt; data &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>            traverseptr = traverseptr -&gt; next;<br>            length++; <br>        &#125;<br>        std::cout &lt;&lt; std::endl;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;The queue has &quot;</span> &lt;&lt; length &lt;&lt; <span class="hljs-string">&quot; elements&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//The main function is used for Debugging only.</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    seqQueue&lt;<span class="hljs-type">int</span>&gt; list;<br>    list.<span class="hljs-built_in">print</span>();<br>    list.<span class="hljs-built_in">push</span>(<span class="hljs-number">2</span>);<br>    list.<span class="hljs-built_in">push</span>(<span class="hljs-number">5</span>);<br>    std::cout &lt;&lt; list.<span class="hljs-built_in">isEmpty</span>() &lt;&lt; std::endl;<br>    list.<span class="hljs-built_in">print</span>();<br>    std::cout &lt;&lt; list.<span class="hljs-built_in">pop</span>();<br>    std::cout &lt;&lt; list.<span class="hljs-built_in">pop</span>();<br>    std::cout &lt;&lt; list.<span class="hljs-built_in">isEmpty</span>() &lt;&lt; std::endl;<br>    <span class="hljs-comment">//The debug of link queue</span><br>    std::cout &lt;&lt; std::endl;<br>    linkQueue&lt;<span class="hljs-type">int</span>&gt; list2;<br>    list<span class="hljs-number">2.</span><span class="hljs-built_in">print</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)&#123;<br>        list<span class="hljs-number">2.</span><span class="hljs-built_in">push</span>(i * i);<br>        list<span class="hljs-number">2.</span><span class="hljs-built_in">print</span>();<br>    &#125;<br><br>    std::cout &lt;&lt; list<span class="hljs-number">2.</span><span class="hljs-built_in">isEmpty</span>() &lt;&lt; std::endl;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)<br>    &#123;<br>        std::cout &lt;&lt; list<span class="hljs-number">2.</span><span class="hljs-built_in">pop</span>() &lt;&lt;std::endl;<br>        list<span class="hljs-number">2.</span><span class="hljs-built_in">print</span>();<br>    &#125;<br>    <br>    std::cout &lt;&lt; list<span class="hljs-number">2.</span><span class="hljs-built_in">isEmpty</span>() &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Queue-in-STL"><a href="#Queue-in-STL" class="headerlink" title="Queue in STL"></a>Queue in STL</h2><p>在C++标准模板库（STL）中，<code>queue</code> 是一种容器适配器，用于实现先进先出（FIFO）的数据结构。它基于其他容器（如 <code>deque</code> 或 <code>list</code>）实现，默认使用 <code>deque</code> 作为底层容器。</p><ol><li><strong>先进先出（FIFO）</strong>：元素从队尾插入，从队头移除。</li><li><strong>操作受限</strong>：只允许在队尾插入元素，在队头移除元素，不支持随机访问。</li></ol><h3 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h3><ul><li>**push()**：在队尾插入元素。</li><li>**pop()**：移除队头元素。</li><li>**front()**：访问队头元素。</li><li>**back()**：访问队尾元素。</li><li>**empty()**：检查队列是否为空。</li><li>**size()**：返回队列中元素的数量。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::queue&lt;<span class="hljs-type">int</span>&gt; q;<br><br>    q.<span class="hljs-built_in">push</span>(<span class="hljs-number">10</span>); <span class="hljs-comment">// 队尾插入10</span><br>    q.<span class="hljs-built_in">push</span>(<span class="hljs-number">20</span>); <span class="hljs-comment">// 队尾插入20</span><br>    q.<span class="hljs-built_in">push</span>(<span class="hljs-number">30</span>); <span class="hljs-comment">// 队尾插入30</span><br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;队头元素: &quot;</span> &lt;&lt; q.<span class="hljs-built_in">front</span>() &lt;&lt; std::endl; <span class="hljs-comment">// 输出10</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;队尾元素: &quot;</span> &lt;&lt; q.<span class="hljs-built_in">back</span>() &lt;&lt; std::endl;  <span class="hljs-comment">// 输出30</span><br><br>    q.<span class="hljs-built_in">pop</span>(); <span class="hljs-comment">// 移除队头元素10</span><br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;队头元素: &quot;</span> &lt;&lt; q.<span class="hljs-built_in">front</span>() &lt;&lt; std::endl; <span class="hljs-comment">// 输出20</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="底层容器"><a href="#底层容器" class="headerlink" title="底层容器"></a>底层容器</h3><p><code>queue</code> 默认使用 <code>deque</code>，但可以通过模板参数指定其他容器，如 <code>list</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::queue&lt;<span class="hljs-type">int</span>, std::list&lt;<span class="hljs-type">int</span>&gt;&gt; q;<br></code></pre></td></tr></table></figure><div class="note note-primary">            <h2 id="deque-in-STL"><a href="#deque-in-STL" class="headerlink" title="deque in STL"></a><code>deque</code> in STL</h2><p><code>deque</code>（<strong>双端队列，全称 double-ended queue</strong>）是 C++ 标准模板库（STL）中的一种序列式容器，支持在两端高效地插入和删除元素。与 <code>vector</code> 类似，<code>deque</code> 也支持随机访问，但在某些操作上比 <code>vector</code> 更加灵活。</p><h3 id="主要特点"><a href="#主要特点" class="headerlink" title="主要特点"></a><strong>主要特点</strong></h3><ol><li><p><strong>双端操作</strong>：</p><ul><li>可以在队列的头部和尾部高效地插入和删除元素。</li><li>支持 <code>push_front()</code>、<code>push_back()</code>、<code>pop_front()</code> 和 <code>pop_back()</code> 操作。</li></ul></li><li><p><strong>动态扩容</strong>：</p><ul><li><code>deque</code> 的内部实现通常由多个固定大小的块（buffer）组成，因此它可以在两端动态扩展，而不需要像 <code>vector</code> 那样在扩容时复制所有元素。</li></ul></li><li><p><strong>随机访问</strong>：</p><ul><li>支持通过下标（<code>[]</code>）或 <code>at()</code> 方法随机访问元素，时间复杂度为 (O(1))。</li></ul></li><li><p><strong>内存非连续</strong>：</p><ul><li><code>deque</code> 的元素并不存储在连续的内存空间中，而是分布在多个块中。这与 <code>vector</code> 不同，<code>vector</code> 的元素是连续存储的。</li></ul></li></ol><h3 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a><strong>常用操作</strong></h3><p>以下是 <code>deque</code> 的常用成员函数：</p><ul><li><p><strong>插入和删除</strong>：</p><ul><li><code>push_front(x)</code>：在头部插入元素 <code>x</code>。</li><li><code>push_back(x)</code>：在尾部插入元素 <code>x</code>。</li><li><code>pop_front()</code>：删除头部元素。</li><li><code>pop_back()</code>：删除尾部元素。</li><li><code>insert(pos, x)</code>：在指定位置插入元素 <code>x</code>。</li><li><code>erase(pos)</code>：删除指定位置的元素。</li></ul></li><li><p><strong>访问元素</strong>：</p><ul><li><code>front()</code>：返回头部元素的引用。</li><li><code>back()</code>：返回尾部元素的引用。</li><li><code>operator[]</code> 或 <code>at(index)</code>：通过索引访问元素。</li></ul></li><li><p><strong>容量相关</strong>：</p><ul><li><code>size()</code>：返回当前元素的数量。</li><li><code>empty()</code>：检查容器是否为空。</li><li><code>resize(n)</code>：调整容器的大小为 <code>n</code>。</li></ul></li><li><p><strong>其他操作</strong>：</p><ul><li><code>clear()</code>：清空容器中的所有元素。</li><li><code>swap(deque)</code>：交换两个 <code>deque</code> 的内容。</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;deque&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::deque&lt;<span class="hljs-type">int</span>&gt; dq;<br><br>    <span class="hljs-comment">// 在尾部插入元素</span><br>    dq.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">10</span>);<br>    dq.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);<br><br>    <span class="hljs-comment">// 在头部插入元素</span><br>    dq.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">5</span>);<br>    dq.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">1</span>);<br><br>    <span class="hljs-comment">// 访问元素</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;头部元素: &quot;</span> &lt;&lt; dq.<span class="hljs-built_in">front</span>() &lt;&lt; std::endl; <span class="hljs-comment">// 输出 1</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;尾部元素: &quot;</span> &lt;&lt; dq.<span class="hljs-built_in">back</span>() &lt;&lt; std::endl;  <span class="hljs-comment">// 输出 20</span><br><br>    <span class="hljs-comment">// 随机访问</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;第二个元素: &quot;</span> &lt;&lt; dq[<span class="hljs-number">1</span>] &lt;&lt; std::endl;    <span class="hljs-comment">// 输出 5</span><br><br>    <span class="hljs-comment">// 删除头部元素</span><br>    dq.<span class="hljs-built_in">pop_front</span>();<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;删除后头部元素: &quot;</span> &lt;&lt; dq.<span class="hljs-built_in">front</span>() &lt;&lt; std::endl; <span class="hljs-comment">// 输出 5</span><br><br>    <span class="hljs-comment">// 遍历 deque</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : dq) &#123;<br>        std::cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>; <span class="hljs-comment">// 输出 5 10 20</span><br>    &#125;<br>    std::cout &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="deque-的内部实现"><a href="#deque-的内部实现" class="headerlink" title="deque 的内部实现"></a><strong><code>deque</code> 的内部实现</strong></h3><p><code>deque</code> 通常由多个固定大小的块（buffer）组成，这些块通过一个中央控制器（通常是数组或指针数组）管理。这种设计使得 <code>deque</code> 在两端插入和删除元素时非常高效，同时支持随机访问。</p><ul><li><p><strong>优点</strong>：</p><ul><li>两端插入和删除的时间复杂度为 *O(1)*。</li><li>不需要像 <code>vector</code> 那样在扩容时复制所有元素。</li></ul></li><li><p><strong>缺点</strong>：</p><ul><li>内存分布不连续，可能导致缓存不友好。</li><li>随机访问的性能略低于 <code>vector</code>。</li></ul></li></ul><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a><strong>适用场景</strong></h3><ol><li>需要在两端频繁插入和删除元素的场景。</li><li>需要随机访问，但不需要内存连续性的场景。</li><li>作为 <code>queue</code> 或 <code>stack</code> 的底层容器。</li></ol><h3 id="deque-与-vector-的对比"><a href="#deque-与-vector-的对比" class="headerlink" title="deque 与 vector 的对比"></a><strong><code>deque</code> 与 <code>vector</code> 的对比</strong></h3><table><thead><tr><th>特性</th><th><code>deque</code></th><th><code>vector</code></th></tr></thead><tbody><tr><td><strong>内存布局</strong></td><td>非连续</td><td>连续</td></tr><tr><td><strong>随机访问性能</strong></td><td>略低</td><td>高</td></tr><tr><td><strong>两端插入&#x2F;删除</strong></td><td>高效（(O(1))）</td><td>尾部高效（(O(1))），头部低效（(O(n))）</td></tr><tr><td><strong>扩容机制</strong></td><td>按需分配新块，无需复制所有元素</td><td>需要复制所有元素</td></tr><tr><td><strong>缓存友好性</strong></td><td>较差</td><td>较好</td></tr></tbody></table><blockquote><p>The above content is generated by <code>DeepSeek V3</code>.</p><p>后文会专门花一讲的时间梳理各种线性数据结构之间的异同~</p></blockquote>          </div><h2 id="Applications-of-Queue"><a href="#Applications-of-Queue" class="headerlink" title="Applications of Queue"></a>Applications of Queue</h2><h3 id="单服务器模拟"><a href="#单服务器模拟" class="headerlink" title="单服务器模拟"></a>单服务器模拟</h3><h3 id="多服务器模拟（优先级队列）"><a href="#多服务器模拟（优先级队列）" class="headerlink" title="多服务器模拟（优先级队列）"></a>多服务器模拟（优先级队列）</h3><p>在多服务器模拟中，<strong>先处理事件的离开时间</strong>可能晚于<strong>后处理事件对应的离开事件</strong>，如果使用一个单纯的简单队列无法实现，因此在此处需要使用<strong>优先级队列</strong>，时间戳更靠前的（绝对时间）优先级更高。</p><ul><li><p>初始化：产生所有到达事件，存入<strong>事件队列</strong>。</p></li><li><p>模拟器：</p><ul><li><strong>取出一个到达事件</strong>：<ul><li>如果有空<ul><li>如果存在空闲柜台，加上服务时间生成离开时间</li><li>将离开时间插入队列</li></ul></li><li>如果没空<ul><li>加入等待队列</li></ul></li></ul></li><li><strong>取出一个离开事件</strong>：<ul><li>如果等待队列非空：<ul><li>服务（类似于<strong>取出到达事件——有空</strong>）</li></ul></li><li>空闲柜台 + 1</li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tutorial</tag>
      
      <tag>Data Structure</tag>
      
      <tag>C/C++</tag>
      
      <tag>Queue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python-Update-Learning</title>
    <link href="/posts/Python-Update-Learning/"/>
    <url>/posts/Python-Update-Learning/</url>
    
    <content type="html"><![CDATA[<style>  html, body, .markdown-body {    font-family: Georgia, sans, serif;  }</style><h1 id="Python-Update-Learning"><a href="#Python-Update-Learning" class="headerlink" title="Python Update Learning"></a>Python Update Learning</h1><h2 id="Pytest"><a href="#Pytest" class="headerlink" title="Pytest"></a><code>Pytest</code></h2><h2 id="Pygame"><a href="#Pygame" class="headerlink" title="Pygame"></a><code>Pygame</code></h2><h2 id="Duck-Typing"><a href="#Duck-Typing" class="headerlink" title="Duck Typing"></a>Duck Typing</h2><h3 id="Introduction-to-Duck-Typing"><a href="#Introduction-to-Duck-Typing" class="headerlink" title="Introduction to Duck Typing"></a>Introduction to Duck Typing</h3><p><strong>Duck Typing</strong> is a programming concept often used in dynamically-typed languages, where the type or class of an object is determined by its behavior (methods and properties) rather than its explicit inheritance or interface implementation. The term originates from the phrase: </p><blockquote><p><em>“If it walks like a duck and quacks like a duck, then it must be a duck.”</em></p></blockquote><p>In essence, Duck Typing focuses on what an object <strong>can do</strong> rather than what it <strong>is</strong>. This approach provides flexibility and promotes code reusability, but it also requires careful handling to avoid runtime errors due to missing methods or properties.</p><h3 id="Key-Characteristics-of-Duck-Typing"><a href="#Key-Characteristics-of-Duck-Typing" class="headerlink" title="Key Characteristics of Duck Typing"></a>Key Characteristics of Duck Typing</h3><ol><li><p><strong>Behavior Over Type</strong>:</p><ul><li>An object’s suitability is determined by the presence of specific methods or properties, not by its class or type.</li><li>For example, if an object has a <code>quack()</code> method and a <code>walk()</code> method, it can be treated as a “duck” regardless of its actual class.</li></ul></li><li><p><strong>Flexibility</strong>:</p><ul><li>Code can work with any object that implements the required behavior, making it highly adaptable and reusable.</li><li>This eliminates the need for strict type hierarchies or interfaces.</li></ul></li><li><p><strong>Common in Dynamic Languages</strong>:</p><ul><li>Duck Typing is frequently used in dynamically-typed languages like Python, Ruby, and JavaScript, where type checking is done at runtime rather than compile time.</li></ul></li></ol><h3 id="Example-Duck-Typing-in-Python"><a href="#Example-Duck-Typing-in-Python" class="headerlink" title="Example: Duck Typing in Python"></a>Example: Duck Typing in Python</h3><p>Below is an example that demonstrates Duck Typing using a <code>Duck</code> class, a <code>Person</code> class, and even a <code>Chicken</code> class. The key idea is that any object with the required methods (<code>quack()</code> and <code>walk()</code>) can be treated as a “duck.”</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Define a Duck class</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Duck</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">quack</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Quack!&quot;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">walk</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Walking like a duck&quot;</span>)<br><br><span class="hljs-comment"># Define a Person class</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">quack</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;I&#x27;m quacking like a duck!&quot;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">walk</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;I&#x27;m walking like a duck&quot;</span>)<br><br><span class="hljs-comment"># Define a Chicken class</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Chicken</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">quack</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Cluck cluck! (Pretending to quack)&quot;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">walk</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Walking like a duck (but I&#x27;m actually a chicken)&quot;</span>)<br><br><span class="hljs-comment"># Function to check if an object is a &quot;duck&quot;</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">check_if_duck</span>(<span class="hljs-params">animal</span>):<br>    <span class="hljs-keyword">try</span>:<br>        animal.quack()<br>        animal.walk()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;This is a duck!&quot;</span>)<br>    <span class="hljs-keyword">except</span> AttributeError:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;This is not a duck!&quot;</span>)<br><br><span class="hljs-comment"># Test the function</span><br>duck = Duck()<br>person = Person()<br>chicken = Chicken()<br><br>check_if_duck(duck)     <span class="hljs-comment"># Output: Quack! Walking like a duck. This is a duck!</span><br>check_if_duck(person)   <span class="hljs-comment"># Output: I&#x27;m quacking like a duck! I&#x27;m walking like a duck. This is a duck!</span><br>check_if_duck(chicken)  <span class="hljs-comment"># Output: Cluck cluck! (Pretending to quack) Walking like a duck (but I&#x27;m actually a chicken). This is a duck!</span><br></code></pre></td></tr></table></figure><h3 id="Explanation-of-the-Code"><a href="#Explanation-of-the-Code" class="headerlink" title="Explanation of the Code"></a>Explanation of the Code</h3><ol><li><p><strong>Duck Typing in Action</strong>:</p><ul><li>The <code>check_if_duck</code> function does not check the type of the <code>animal</code> object. Instead, it checks whether the object has the <code>quack()</code> and <code>walk()</code> methods.</li><li>If the object has these methods, it is treated as a “duck,” regardless of whether it is an instance of <code>Duck</code>, <code>Person</code>, or even <code>Chicken</code>.</li></ul></li><li><p><strong>Flexibility and Reusability</strong>:</p><ul><li>The <code>Chicken</code> class is not a duck, but it can still be treated as one because it implements the required methods.</li><li>This demonstrates how Duck Typing allows objects of different types to be used interchangeably, as long as they exhibit the expected behavior.</li></ul></li><li><p><strong>Runtime Risks</strong>:</p><ul><li>If an object passed to <code>check_if_duck</code> does not have the required methods (e.g., a <code>Dog</code> class without <code>quack()</code> and <code>walk()</code>), the program will raise an <code>AttributeError</code> at runtime.</li></ul></li></ol><h3 id="Advantages-of-Duck-Typing"><a href="#Advantages-of-Duck-Typing" class="headerlink" title="Advantages of Duck Typing"></a>Advantages of Duck Typing</h3><ol><li><p><strong>Code Simplicity</strong>:</p><ul><li>Duck Typing reduces the need for complex type hierarchies and interfaces, making code simpler and more concise.</li></ul></li><li><p><strong>Enhanced Flexibility</strong>:</p><ul><li>Functions and methods can operate on any object that meets the required behavior, promoting code reuse and adaptability.</li></ul></li><li><p><strong>Dynamic Nature</strong>:</p><ul><li>Duck Typing aligns well with the dynamic nature of languages like Python, enabling rapid prototyping and development.</li></ul></li></ol><h3 id="Disadvantages-of-Duck-Typing"><a href="#Disadvantages-of-Duck-Typing" class="headerlink" title="Disadvantages of Duck Typing"></a>Disadvantages of Duck Typing</h3><ol><li><p><strong>Runtime Errors</strong>:</p><ul><li>Since type checking is deferred to runtime, errors related to missing methods or properties may only surface during execution.</li></ul></li><li><p><strong>Reduced Readability</strong>:</p><ul><li>Without explicit type declarations, it can be harder to understand what types of objects are expected by a function or method.</li></ul></li><li><p><strong>Testing Overhead</strong>:</p><ul><li>Comprehensive testing is required to ensure that objects passed to Duck Typing functions behave as expected.</li></ul></li></ol><h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><p>Duck Typing is a powerful and flexible programming paradigm that emphasizes behavior over explicit type definitions. By focusing on what an object <strong>can do</strong> rather than what it <strong>is</strong>, Duck Typing enables highly adaptable and reusable code. However, this flexibility comes with the trade-off of potential runtime errors and the need for thorough testing. The example of the <code>Chicken</code> class demonstrates how even non-duck objects can be treated as ducks if they implement the required behavior, showcasing the true essence of Duck Typing.</p><p>In summary, Duck Typing is a valuable tool in dynamically-typed languages, but it requires careful design and testing to ensure robustness and reliability.</p>]]></content>
    
    
    <categories>
      
      <category>Code</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Updating</tag>
      
      <tag>Python</tag>
      
      <tag>Tutorial</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python-Advanced-File-Management</title>
    <link href="/posts/Python-advanced-File-Management/"/>
    <url>/posts/Python-advanced-File-Management/</url>
    
    <content type="html"><![CDATA[<style>  html, body, .markdown-body {    font-family: Georgia, sans, serif;  }</style><h1 id="Advanced-Python-Techniques-File-Management"><a href="#Advanced-Python-Techniques-File-Management" class="headerlink" title="Advanced Python Techniques: File Management"></a>Advanced Python Techniques: File Management</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p><a href="https://xiyuanyang-code.github.io/posts/Python-tutorial/">Updating  Plan</a></p><p>Today, we will introduce how to manage files (such as reading files and writing files) in Python.</p><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><h2 id="Table-of-Contents"><a href="#Table-of-Contents" class="headerlink" title="Table of Contents"></a>Table of Contents</h2><h2 id="Import-Modules"><a href="#Import-Modules" class="headerlink" title="Import Modules"></a>Import Modules</h2><p>在Python中，<strong>模块（Module）</strong>是一个包含Python代码的文件，通常以 <code>.py</code> 为扩展名。模块可以包含函数、类、变量和可执行代码。</p><h3 id="Basic-Grammer"><a href="#Basic-Grammer" class="headerlink" title="Basic Grammer"></a>Basic Grammer</h3><p>导入模块最常用的命令是<code>import</code>命令，我们可以使用<code>import</code>命令导入<strong>Python中的第三方模块</strong>。（类似于C++中的<code>#include</code>命令）</p><p>在导入模块的过程中，有如下的四种方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-comment"># 第一种导入方式：把整个模块全部导入</span><br><span class="hljs-keyword">import</span> math<br><span class="hljs-comment"># 使用 math 模块中的 sqrt 函数</span><br>result = math.sqrt(<span class="hljs-number">16</span>)<br><span class="hljs-built_in">print</span>(result)  <span class="hljs-comment"># 输出: 4.0</span><br><br><br><span class="hljs-comment"># 第二种导入方式：导入模块的特定内容</span><br><span class="hljs-keyword">from</span> math <span class="hljs-keyword">import</span> sqrt<br><span class="hljs-comment"># 直接使用 sqrt 函数</span><br>result = sqrt(<span class="hljs-number">16</span>)<br><span class="hljs-built_in">print</span>(result)  <span class="hljs-comment"># 输出: 4.0</span><br><br><br><span class="hljs-comment"># 第三种导入方式：导入模块的全部内容</span><br><span class="hljs-keyword">from</span> math <span class="hljs-keyword">import</span> *<br><span class="hljs-comment"># 直接使用 sqrt 函数</span><br>result = sqrt(<span class="hljs-number">16</span>)<br><span class="hljs-built_in">print</span>(result)  <span class="hljs-comment"># 输出: 4.0</span><br><br><br><span class="hljs-comment"># 第四种导入方式：起别名 </span><br><span class="hljs-keyword">import</span> math <span class="hljs-keyword">as</span> m<br><span class="hljs-comment"># 使用别名 m 访问 sqrt 函数</span><br>result = m.sqrt(<span class="hljs-number">16</span>)<br><span class="hljs-built_in">print</span>(result)  <span class="hljs-comment"># 输出: 4.0</span><br><br><span class="hljs-keyword">from</span> math <span class="hljs-keyword">import</span> sqrt <span class="hljs-keyword">as</span> square_root<br><span class="hljs-comment"># 使用别名 square_root</span><br>result = square_root(<span class="hljs-number">16</span>)<br><span class="hljs-built_in">print</span>(result)  <span class="hljs-comment"># 输出: 4.0</span><br></code></pre></td></tr></table></figure><h3 id="Import-Class"><a href="#Import-Class" class="headerlink" title="Import Class"></a>Import Class</h3><p>为了提升代码的简洁性，<strong>类的定义</strong>被储存在特定的文件中，在开发者使用是可以被<strong>特定的导入</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># All_the_class.py</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">pass</span><br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bike</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">pass</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Truck</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">pass</span><br><br><span class="hljs-comment"># main.py</span><br><br><span class="hljs-keyword">import</span> All_the_class<br><br><span class="hljs-keyword">from</span> All_the_class <span class="hljs-keyword">import</span> Car<br><br><span class="hljs-keyword">from</span> All_the_class <span class="hljs-keyword">import</span> Bike,Car<br><span class="hljs-comment"># 这三种导入方式都是合法的！</span><br></code></pre></td></tr></table></figure><h3 id="Dive-Deeper"><a href="#Dive-Deeper" class="headerlink" title="Dive Deeper"></a>Dive Deeper</h3><div class="note note-info">            <h4 id="How-do-Python-import-modules"><a href="#How-do-Python-import-modules" class="headerlink" title="How do Python import modules?"></a>How do Python import modules?</h4><p>当你导入一个模块时，Python 会按照以下顺序查找模块：</p><ol><li><strong>内置模块</strong>：Python 自带的标准库模块。</li><li><strong>当前目录</strong>：运行脚本所在的目录。</li><li>**环境变量 <code>PYTHONPATH</code>**：包含目录列表的环境变量。</li><li><strong>安装的第三方库</strong>：通过 <code>pip</code> 安装的第三方模块。</li></ol><p><strong>当前目录</strong>是指该文件所在的目录地址，例如下面的文件结构：</p><ul><li><code>thefilefolder</code><ul><li><code>testcode2.py</code></li><li><code>testcode3.py</code></li></ul></li><li><code>testcode1.py</code></li></ul><p>对于<code>testcode2.py</code>来说，当前目录下有文件<code>testcode3.py</code>，而没有<code>testcode1.py</code>。</p><p><strong><code>PYTHONPATH</code> 允许你添加自定义的目录路径</strong>，使得 Python 在导入模块时能够从这些目录中查找模块文件。这对于以下场景非常有用：</p><ol><li><strong>自定义模块路径</strong>：当你有一些自定义的模块不在当前目录或 Python 的标准库路径中时，可以通过 <code>PYTHONPATH</code> 指定这些模块所在的目录。</li><li><strong>项目结构管理</strong>：在大型项目中，模块可能分布在不同的目录中，通过 <code>PYTHONPATH</code> 可以方便地管理这些模块的路径。</li></ol>          </div><p>从上文可知，文件的导入并不局限于官方库文件的导入，你也可以导入<strong>自己写的Python文件</strong>！</p><h4 id="name"><a href="#name" class="headerlink" title="__name__"></a><code>__name__</code></h4><p>我们来看下面的例子，这是在同一个目录下的两个Python文件<code>testcode4.py</code>和<code>testcode5.py</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># testcode5.py</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hello! This is the file testcode5.py!&quot;</span>)<br><br><span class="hljs-comment"># testcode4.py</span><br><span class="hljs-keyword">import</span> testcode5<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hello! this is testcode4.py&quot;</span>)<br></code></pre></td></tr></table></figure><p>运行<code>testcode4.py</code>，输出结果如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">Hello! This <span class="hljs-keyword">is</span> the file testcode5.py!<br>Hello! <span class="hljs-keyword">this</span> <span class="hljs-keyword">is</span> testcode4.py<br></code></pre></td></tr></table></figure><p>实际上，Python解释器运行代码的顺序和逻辑如下：</p><ol><li>**运行 <code>testcode4.py</code>**：<ul><li>Python 解释器开始执行 <code>testcode4.py</code> 文件。</li><li>当遇到 <code>import testcode5</code> 时，Python 会查找并加载 <code>testcode5.py</code> 模块。</li></ul></li><li>**加载并执行 <code>testcode5.py</code>**：<ul><li>Python 会执行 <code>testcode5.py</code> 文件中的<strong>所有顶层代码（即不在函数或类中的代码）</strong>。</li><li>在 <code>testcode5.py</code> 中，<code>print(&quot;Hello! This is the file testcode5.py!&quot;)</code> 是顶层代码，因此会被执行。</li><li>执行完 <code>testcode5.py</code> 后，Python 会回到 <code>testcode4.py</code> 继续执行。</li></ul></li><li>**继续执行 <code>testcode4.py</code>**：<ul><li>在 <code>testcode4.py</code> 中，<code>import testcode5</code> 已经完成，接下来执行 <code>print(&quot;Hello! this is testcode4.py&quot;)</code>。</li><li>因此，<code>testcode4.py</code> 中的 <code>print</code> 语句会被执行。</li></ul></li></ol><p>这就出现了很尴尬的问题，我们设置<code>print</code>语句的初衷是告知程序员现在在运行哪一个文件，我们<strong>不希望模块被导入的输出相同的结果</strong>，换句话说，我们希望将一个程序<strong>作为模块被导入运行和直接运行</strong>的行为产生差异。</p><blockquote><p>这是一个很实际的问题，模块的使用者直接导入模块，而模块的开发者需要调试信息，就需要这样一种<strong>分离</strong>的策略。</p></blockquote><p>一种方法是将所有的代码写成函数，<strong>这样不存在顶层代码一说了</strong>，但是这对模块开发和调试的功能有增添了不便之处。实际上，每个文件都有一个**<code>__name__</code> 属性**，灵活使用<code>__name__</code>可以很好的解决这个问题。</p><p>我们略微修改刚刚的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># testcode5.py</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hello! This is the file testcode5.py!&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;testcode5 __name__: <span class="hljs-subst">&#123;__name__&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># testcode4.py</span><br><span class="hljs-keyword">import</span> testcode5<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hello! this is testcode4.py&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;testcode4 __name__: <span class="hljs-subst">&#123;__name__&#125;</span>&quot;</span>)<br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">when you run testcode5.py:</span><br><span class="hljs-string">Hello! This is the file testcode5.py!</span><br><span class="hljs-string">testcode5 __name__: __main__</span><br><span class="hljs-string"></span><br><span class="hljs-string">when you run testcode4.py:</span><br><span class="hljs-string">Hello! This is the file testcode5.py!</span><br><span class="hljs-string">testcode5 __name__: testcode5</span><br><span class="hljs-string">Hello! this is testcode4.py</span><br><span class="hljs-string">testcode4 __name__: __main__</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><p>我们很惊喜的发现，<strong>被导入的文件</strong>和<strong>直接被运行的文件</strong>的<code>__name__</code>属性是不一样的！当一个文件被导入的时候，<code>__name__</code>字符串的值就是其文件名（例如<code>testcode5</code>），而被直接运行的时候，<code>__name__</code>的值变成了<code>__main__</code>。</p><p>因此，我们可以使用<code>if __name__ == &quot;__main__&quot;</code>语句来封装<strong>顶层代码</strong>，实现我们上文的需求！</p><h2 id="File-Reading-and-Writing"><a href="#File-Reading-and-Writing" class="headerlink" title="File Reading and Writing"></a>File Reading and Writing</h2><h3 id="What-is-path"><a href="#What-is-path" class="headerlink" title="What is path?"></a>What is path?</h3><p><strong>路径（path）</strong>是指文件或文件夹在系统中的准确位置，<strong>类似于每家每户的门牌号</strong>。当Python想要读取一个文件时，首先需要获得<strong>文件的地址（即路径）</strong>，这样文件才能被找到并被成功读取。</p><p>路径分为两类，<strong>相对路径</strong>和<strong>绝对路径</strong>。</p><ul><li>绝对路径是从文件系统的根目录开始的完整路径，它唯一地标识一个文件或目录的位置。</li><li>相对路径是相对于当前工作目录的路径，它依赖于当前的工作环境。</li></ul><blockquote><p>通俗一点来说，如果我们要描述小明的绝对路径，我们要从<strong>根目录</strong>（不妨假设为地球）开始说，小明住在哪个大洲哪个国家哪个区域哪个街道哪个门牌号…但如果我站在<strong>当前工作目录</strong>（不妨假设为<code>地球/亚洲/中国</code>）,我们可以直接从小明住在哪个区域开始说起就行了。但是如果远在美洲的朋友就无法识别这个相对路径（因为<strong>当前工作目录发生了改变</strong>）。</p></blockquote><p><img src="https://ooo.0x0.ooo/2025/01/19/OGkztG.png" alt="The Absolute Path and the Relative Path"></p><h3 id="pathlib"><a href="#pathlib" class="headerlink" title="pathlib"></a><code>pathlib</code></h3><p><code>pathlib</code> 是 Python 3.4 引入的一个模块，提供了一种面向对象的方式来处理文件系统路径。</p><p><code>pathlib</code> 的核心类是 <code>Path</code>，它表示文件系统路径。<code>Path</code> 类有两种主要子类：</p><ul><li>**<code>PurePath</code>**：纯路径类，只处理路径字符串，不涉及实际文件系统操作。</li><li>**<code>Path</code>**：具体路径类，继承自 <code>PurePath</code>，可以执行实际的文件系统操作（如创建文件、读取文件等）。</li></ul><ol><li>创建 <code>Path</code> 对象</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pathlib <span class="hljs-keyword">import</span> Path<br><br><span class="hljs-comment"># 创建 Path 对象</span><br>p = Path(<span class="hljs-string">&#x27;example.txt&#x27;</span>)<br><span class="hljs-built_in">print</span>(p)  <span class="hljs-comment"># 输出: example.txt</span><br></code></pre></td></tr></table></figure><ol start="2"><li>路径拼接</li></ol><p>使用 <code>/</code> 运算符可以轻松拼接路径。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">p = Path(<span class="hljs-string">&#x27;/path/to&#x27;</span>)<br>p = p / <span class="hljs-string">&#x27;subdir&#x27;</span> / <span class="hljs-string">&#x27;file.txt&#x27;</span><br><span class="hljs-built_in">print</span>(p)  <span class="hljs-comment"># 输出: /path/to/subdir/file.txt</span><br></code></pre></td></tr></table></figure><ol start="3"><li>获取路径的组成部分</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">p = Path(<span class="hljs-string">&#x27;/path/to/file.txt&#x27;</span>)<br><br><span class="hljs-built_in">print</span>(p.name)       <span class="hljs-comment"># 输出: file.txt（文件名）</span><br><span class="hljs-built_in">print</span>(p.stem)       <span class="hljs-comment"># 输出: file（文件名不带后缀）</span><br><span class="hljs-built_in">print</span>(p.suffix)     <span class="hljs-comment"># 输出: .txt（文件后缀）</span><br><span class="hljs-built_in">print</span>(p.parent)     <span class="hljs-comment"># 输出: /path/to（父目录）</span><br><span class="hljs-built_in">print</span>(p.absolute()) <span class="hljs-comment"># 输出: 绝对路径</span><br></code></pre></td></tr></table></figure><ol start="4"><li>检查路径是否存在</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">p = Path(<span class="hljs-string">&#x27;example.txt&#x27;</span>)<br><span class="hljs-keyword">if</span> p.exists():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;文件存在&quot;</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;文件不存在&quot;</span>)<br><span class="hljs-comment"># 这里查找的是相对目录下的文件</span><br></code></pre></td></tr></table></figure><ol start="5"><li>创建文件和目录</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 创建文件</span><br>p = Path(<span class="hljs-string">&#x27;new_file.txt&#x27;</span>)<br>p.touch()  <span class="hljs-comment"># 创建空文件</span><br><br><span class="hljs-comment"># 创建目录</span><br>p = Path(<span class="hljs-string">&#x27;new_directory&#x27;</span>)<br>p.mkdir(exist_ok=<span class="hljs-literal">True</span>)  <span class="hljs-comment"># exist_ok=True 避免目录已存在时报错</span><br></code></pre></td></tr></table></figure><ol start="6"><li>读取和写入文件</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 写入文件</span><br>p = Path(<span class="hljs-string">&#x27;example.txt&#x27;</span>)<br>p.write_text(<span class="hljs-string">&#x27;Hello, World!&#x27;</span>)<br><br><span class="hljs-comment"># 注意！原来文件中的内容会被write_text()所覆盖</span><br>path.<span class="hljs-built_in">open</span>(mode=<span class="hljs-string">&#x27;a&#x27;</span>).write(<span class="hljs-string">&quot;Hello&quot;</span>)<br><span class="hljs-comment"># 可以使用追加模式</span><br><br><br><span class="hljs-comment"># 读取文件</span><br>content = p.read_text()<br><span class="hljs-built_in">print</span>(content)  <span class="hljs-comment"># 输出: Hello, World!</span><br></code></pre></td></tr></table></figure><p>我们还可以实现一些更高级的操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pathlib <span class="hljs-keyword">import</span> Path<br><br>path = Path(<span class="hljs-string">&quot;example.txt&quot;</span>)<br>contents = path.read_text()<br><br>lines = contents.splitlines()<br><span class="hljs-comment"># 会返回一个列表</span><br><span class="hljs-keyword">for</span> i,line <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(lines):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;The <span class="hljs-subst">&#123;i+<span class="hljs-number">1</span>&#125;</span> line is <span class="hljs-subst">&#123;line&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">The <span class="hljs-number">1</span> <span class="hljs-type">line</span> <span class="hljs-keyword">is</span> hello my <span class="hljs-type">name</span> <span class="hljs-keyword">is</span> van<br>The <span class="hljs-number">2</span> <span class="hljs-type">line</span> <span class="hljs-keyword">is</span> i am an artist<br>The <span class="hljs-number">3</span> <span class="hljs-type">line</span> <span class="hljs-keyword">is</span> a performance artist<br></code></pre></td></tr></table></figure><ol start="7"><li>遍历目录</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">p = Path(<span class="hljs-string">&#x27;.&#x27;</span>)<br><span class="hljs-keyword">for</span> file <span class="hljs-keyword">in</span> p.iterdir():<br>    <span class="hljs-built_in">print</span>(file)  <span class="hljs-comment"># 打印当前目录下的所有文件和目录</span><br></code></pre></td></tr></table></figure><ol start="8"><li>查找文件</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 查找当前目录下的所有 .txt 文件</span><br><span class="hljs-keyword">for</span> file <span class="hljs-keyword">in</span> p.glob(<span class="hljs-string">&#x27;*.txt&#x27;</span>):<br>    <span class="hljs-built_in">print</span>(file)<br></code></pre></td></tr></table></figure><ol start="9"><li>删除文件或目录</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 删除文件</span><br>p = Path(<span class="hljs-string">&#x27;example.txt&#x27;</span>)<br>p.unlink()<br><br><span class="hljs-comment"># 删除目录（目录必须为空）</span><br>p = Path(<span class="hljs-string">&#x27;empty_directory&#x27;</span>)<br>p.rmdir()<br></code></pre></td></tr></table></figure><p>   10.获取当前文件目录（这里使用了<strong>os</strong>库）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">from</span> pathlib <span class="hljs-keyword">import</span> Path<br><br><span class="hljs-comment"># 获取当前工作目录</span><br>cwd = os.getcwd()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;当前工作目录: <span class="hljs-subst">&#123;cwd&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># 使用 Path.cwd() 获取当前工作目录</span><br>cwd_path = Path.cwd()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;当前工作目录: <span class="hljs-subst">&#123;cwd_path&#125;</span>&quot;</span>)<br><span class="hljs-comment"># 获取的是根目录</span><br></code></pre></td></tr></table></figure><h2 id="FileNotFoundError"><a href="#FileNotFoundError" class="headerlink" title="FileNotFoundError"></a><code>FileNotFoundError</code></h2><p>当我们进行文件操作时，一不小心可能会拼错或者搞错了文件的路径，导致<strong>程序无法找到对应的文件</strong>。</p><p>例如，如下程序的目录中有文件<code>example.txt</code>，但没有<code>exammple.txt</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> pathlib <span class="hljs-keyword">import</span> Path<br><br><span class="hljs-comment"># for a neater traceback information</span><br><span class="hljs-keyword">from</span> rich <span class="hljs-keyword">import</span> traceback<br>traceback.install(show_locals=<span class="hljs-literal">True</span>)<br><br><br>correct_path = Path(<span class="hljs-string">&quot;example.txt&quot;</span>)<br>wrong_path = Path(<span class="hljs-string">&quot;exammple.txt&quot;</span>)<br><br>contents_correct = correct_path.read_text()<br>contents_wrong = wrong_path.read_text()<br></code></pre></td></tr></table></figure><p>程序的输出结果如下：</p><p><img src="https://ooo.0x0.ooo/2025/01/20/OGktrC.png" alt="FileNotfound Error"></p><p>归根结底就一句话：<code>FileNotFoundError: [Errno 2] No such file or directory: &#39;exammple.txt&#39;</code>。</p><p>和C++一样，Python也有<strong>异常处理</strong>的机制。<code>FileNotFoundError</code> 是 Python 中的一个<strong>内置异常类</strong>，用于表示程序尝试访问一个不存在的文件或目录时抛出的错误。它是 <code>OSError</code> 的子类（在 Python 3.3 之前是 <code>IOError</code> 的子类），专门用于处理文件未找到的情况。</p><p>在C++中，我们可以使用<code>try-catch</code>块来捕获异常，保证其他程序的正常运行，在Python中，<code>try-except</code>块也发挥了类似的作用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> pathlib <span class="hljs-keyword">import</span> Path<br><br><span class="hljs-comment"># for a neater traceback information</span><br><span class="hljs-keyword">from</span> rich <span class="hljs-keyword">import</span> traceback<br>traceback.install(show_locals=<span class="hljs-literal">True</span>)<br><br><br>correct_path = Path(<span class="hljs-string">&quot;example.txt&quot;</span>)<br>wrong_path = Path(<span class="hljs-string">&quot;exammple.txt&quot;</span>)<br><br>contents_correct = correct_path.read_text()<br><br><span class="hljs-keyword">try</span>:<br>    contents_wrong = wrong_path.read_text()<br><span class="hljs-keyword">except</span> FileNotFoundError:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Haha,File not found!&quot;</span>)<br></code></pre></td></tr></table></figure><p>再次运行程序，就不会出现<code>traceback</code>报错，而只会输出：<code>Haha,File not found!</code></p><h2 id="Data-Storage：JSON"><a href="#Data-Storage：JSON" class="headerlink" title="Data Storage：JSON"></a>Data Storage：<code>JSON</code></h2><h3 id="What-is-JSON"><a href="#What-is-JSON" class="headerlink" title="What is JSON ?"></a>What is <code>JSON</code> ?</h3><p><strong>JSON 文件</strong> 是一种用于<strong>存储和交换数据的文件格式</strong>，全称是 <strong>JavaScript Object Notation</strong>（JavaScript 对象表示法）。它的设计目标是易于人类阅读和编写，同时也易于机器解析和生成。</p><p>JSON 文件的内容是由 <strong>“键值对”</strong> 组成的，就像字典一样。是一种轻量级的数据格式。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Alice&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;age&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">25</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;isStudent&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;courses&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;Math&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;Science&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;History&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;address&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;city&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Beijing&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;postalCode&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;100000&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p><code>JSON</code>文件最强大的用处在于<strong>数据的传输和存储</strong>，例如前后端之间API的调用、软件的配置信息、存储结构化数据（日志，用户信息）等等。</p><h3 id="JSON-in-Python"><a href="#JSON-in-Python" class="headerlink" title="JSON in Python"></a><code>JSON</code> in Python</h3><p>在Python中，也可以使用<code>json</code>模块来进行文件管理。</p><ol><li><strong>将 Python 对象转换为 JSON 字符串</strong></li></ol><p>使用 <code>json.dumps()</code> 可以将 Python 对象（如字典、列表）转换为 JSON 格式的字符串。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pathlib <span class="hljs-keyword">import</span> Path<br><span class="hljs-keyword">import</span> json<br><br><span class="hljs-comment"># 准备数据</span><br>data = &#123;<br>    <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;小红&quot;</span>,<br>    <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">20</span>,<br>    <span class="hljs-string">&quot;isStudent&quot;</span>: <span class="hljs-literal">False</span>,<br>    <span class="hljs-string">&quot;favoriteFoods&quot;</span>: [<span class="hljs-string">&quot;火锅&quot;</span>, <span class="hljs-string">&quot;冰淇淋&quot;</span>]<br>&#125;<br><br><span class="hljs-comment"># 将 Python 对象转换为 JSON 字符串</span><br>json_string = json.dumps(data, indent=<span class="hljs-number">4</span>, ensure_ascii=<span class="hljs-literal">False</span>)<br><span class="hljs-comment"># 这一步会在当前目录下生成一个data.json文件</span><br><span class="hljs-built_in">print</span>(json_string)<br><br><br><span class="hljs-comment"># 使用 pathlib 写入文件</span><br>file_path = Path(<span class="hljs-string">&quot;data.json&quot;</span>)<br>file_path.write_text(json_string, encoding=<span class="hljs-string">&quot;utf-8&quot;</span>)<br></code></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;小明&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;age&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">18</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;isStudent&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;hobbies&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-string">&quot;打篮球&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;听音乐&quot;</span><br>    <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><ul><li>**<code>indent=4</code>**：让 JSON 字符串格式化输出，缩进 4 个空格。</li><li>**<code>ensure_ascii=False</code>**：确保非 ASCII 字符（如中文）正常显示。</li></ul><ol start="2"><li><strong>将 JSON 字符串转换为 Python 对象</strong></li></ol><p>使用 <code>json.loads()</code> 可以将 JSON 格式的字符串转换为 Python 对象（如字典、列表）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pathlib <span class="hljs-keyword">import</span> Path<br><span class="hljs-keyword">import</span> json<br><br><span class="hljs-comment"># 使用 pathlib 读取文件</span><br>file_path = Path(<span class="hljs-string">&quot;data.json&quot;</span>)<br>json_string = file_path.read_text(encoding=<span class="hljs-string">&quot;utf-8&quot;</span>)<br><br><span class="hljs-comment"># 将 JSON 字符串转换为 Python 对象</span><br>data = json.loads(json_string)<br><span class="hljs-built_in">print</span>(data[<span class="hljs-string">&quot;name&quot;</span>])  <span class="hljs-comment"># 输出：小红</span><br><span class="hljs-built_in">print</span>(data[<span class="hljs-string">&quot;favoriteFoods&quot;</span>])  <span class="hljs-comment"># 输出：[&#x27;火锅&#x27;, &#x27;冰淇淋&#x27;]</span><br></code></pre></td></tr></table></figure><h3 id="Usage-User-info-management"><a href="#Usage-User-info-management" class="headerlink" title="Usage: User_info management"></a>Usage: User_info management</h3><p>学会了<code>json</code>的基本操作后，我们可以实现一个<strong>迷你数据库</strong>：用来存储用户的数据，进行读写等操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> pathlib <span class="hljs-keyword">import</span> Path<br><span class="hljs-keyword">import</span> json<br><br><span class="hljs-comment"># 获取用户输入的名字</span><br>user_name = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;Hello! What is your name? &quot;</span>)<br>user_name_path = Path(<span class="hljs-string">&quot;user_info.json&quot;</span>)<br><br><span class="hljs-comment"># 初始化用户数据</span><br>all_user_data = []<br><br><span class="hljs-comment"># 如果文件存在，读取文件内容</span><br><span class="hljs-keyword">if</span> user_name_path.exists():<br>    all_user_contents = user_name_path.read_text(encoding=<span class="hljs-string">&quot;utf-8&quot;</span>)<br>    all_user_data = json.loads(all_user_contents)<br><br><span class="hljs-comment"># 检查用户是否已经存在</span><br>user_exists = <span class="hljs-literal">False</span><br>user_info = <span class="hljs-literal">None</span><br><br><span class="hljs-keyword">for</span> user <span class="hljs-keyword">in</span> all_user_data:<br>    <span class="hljs-keyword">if</span> user.get(<span class="hljs-string">&quot;name&quot;</span>) == user_name:<br>        user_exists = <span class="hljs-literal">True</span><br>        user_info = user<br>        <span class="hljs-keyword">break</span><br><br><span class="hljs-keyword">if</span> user_exists:<br>    <span class="hljs-comment"># 用户已经注册过</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Welcome Back, <span class="hljs-subst">&#123;user_name&#125;</span>!&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Your favourite food is <span class="hljs-subst">&#123;user_info.get(<span class="hljs-string">&#x27;food&#x27;</span>)&#125;</span>&quot;</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-comment"># 新用户</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Hello <span class="hljs-subst">&#123;user_name&#125;</span>! It seems that you are new here.&quot;</span>)<br>    fav_food = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;What is your favourite food? &quot;</span>)<br><br>    <span class="hljs-comment"># 创建新用户数据</span><br>    new_user = &#123;<br>        <span class="hljs-string">&quot;name&quot;</span>: user_name,<br>        <span class="hljs-string">&quot;food&quot;</span>: fav_food<br>    &#125;<br><br>    <span class="hljs-comment"># 将新用户添加到用户列表中</span><br>    all_user_data.append(new_user)<br><br>    <span class="hljs-comment"># 将更新后的用户列表写入文件</span><br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;user_info.json&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, encoding=<span class="hljs-string">&quot;utf-8&quot;</span>) <span class="hljs-keyword">as</span> json_file:<br>        json.dump(all_user_data, json_file, ensure_ascii=<span class="hljs-literal">False</span>, indent=<span class="hljs-number">4</span>)<br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Your information has been saved. Welcome!&quot;</span>)<br></code></pre></td></tr></table></figure><p><strong>这样的Python代码习惯实在是太差了！</strong>下面是对函数体封装后的优化写法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> pathlib <span class="hljs-keyword">import</span> Path<br><span class="hljs-keyword">import</span> json<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">load_user_data</span>(<span class="hljs-params">file_path</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    从 JSON 文件加载用户数据。</span><br><span class="hljs-string">    如果文件不存在，返回空列表。</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">if</span> file_path.exists():<br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(file_path, <span class="hljs-string">&quot;r&quot;</span>, encoding=<span class="hljs-string">&quot;utf-8&quot;</span>) <span class="hljs-keyword">as</span> file:<br>                <span class="hljs-keyword">return</span> json.load(file)<br>        <span class="hljs-keyword">except</span> json.JSONDecodeError:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;错误：文件 <span class="hljs-subst">&#123;file_path&#125;</span> 不是有效的 JSON 文件！&quot;</span>)<br>            <span class="hljs-keyword">return</span> []<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> []<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">save_user_data</span>(<span class="hljs-params">file_path, data</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    将用户数据保存到 JSON 文件。</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(file_path, <span class="hljs-string">&quot;w&quot;</span>, encoding=<span class="hljs-string">&quot;utf-8&quot;</span>) <span class="hljs-keyword">as</span> file:<br>        json.dump(data, file, ensure_ascii=<span class="hljs-literal">False</span>, indent=<span class="hljs-number">4</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">find_user_by_name</span>(<span class="hljs-params">users, name</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    在用户列表中查找指定名字的用户。</span><br><span class="hljs-string">    如果找到，返回用户信息；否则返回 None。</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">for</span> user <span class="hljs-keyword">in</span> users:<br>        <span class="hljs-keyword">if</span> user.get(<span class="hljs-string">&quot;name&quot;</span>) == name:<br>            <span class="hljs-keyword">return</span> user<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">register_new_user</span>(<span class="hljs-params">users, name</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    注册新用户并返回更新后的用户列表。</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Hello <span class="hljs-subst">&#123;name&#125;</span>! It seems that you are new here.&quot;</span>)<br>    fav_food = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;What is your favourite food? &quot;</span>)<br>    new_user = &#123;<span class="hljs-string">&quot;name&quot;</span>: name, <span class="hljs-string">&quot;food&quot;</span>: fav_food&#125;<br>    users.append(new_user)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Your information has been saved. Welcome!&quot;</span>)<br>    <span class="hljs-keyword">return</span> users<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    主程序逻辑。</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 文件路径</span><br>    user_file_path = Path(<span class="hljs-string">&quot;user_info.json&quot;</span>)<br><br>    <span class="hljs-comment"># 加载用户数据</span><br>    users = load_user_data(user_file_path)<br><br>    <span class="hljs-comment"># 获取用户输入的名字</span><br>    user_name = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;Hello! What is your name? &quot;</span>)<br><br>    <span class="hljs-comment"># 查找用户是否已存在</span><br>    user_info = find_user_by_name(users, user_name)<br><br>    <span class="hljs-keyword">if</span> user_info:<br>        <span class="hljs-comment"># 用户已存在</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Welcome Back, <span class="hljs-subst">&#123;user_name&#125;</span>!&quot;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Your favourite food is <span class="hljs-subst">&#123;user_info.get(<span class="hljs-string">&#x27;food&#x27;</span>)&#125;</span>&quot;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-comment"># 新用户注册</span><br>        users = register_new_user(users, user_name)<br>        <span class="hljs-comment"># 保存更新后的用户数据</span><br>        save_user_data(user_file_path, users)<br><br><span class="hljs-comment"># 运行主程序</span><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    main()<br></code></pre></td></tr></table></figure><h2 id="Project-Data-Visualization"><a href="#Project-Data-Visualization" class="headerlink" title="Project: Data Visualization"></a>Project: Data Visualization</h2><h3 id="Chapter-15-Data-Creation"><a href="#Chapter-15-Data-Creation" class="headerlink" title="Chapter 15 Data_Creation"></a>Chapter 15 Data_Creation</h3><h4 id="Matplotlib"><a href="#Matplotlib" class="headerlink" title="Matplotlib"></a><code>Matplotlib</code></h4><p>Python的强大之处之一在于<strong>其活跃的社区生态</strong>，通过<code>pip install</code>他人的第三方库，我们可以实现更多强大的功能，接下来的章节笔者将重点介绍<code>Matplotlib</code>的使用。</p><blockquote><p>这一章的学习非常有趣，强烈建议初学者一起上手操作。</p></blockquote><p><code>Matplotlib</code> 是 Python 中最流行的数据可视化库之一，广泛用于创建静态、动态和交互式的图表。它提供了类似于 MATLAB 的绘图接口，简单易用且功能强大。以下是 <code>Matplotlib</code> 的简单介绍和基本用法：</p><p>(1) <strong>绘制简单的折线图</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br><span class="hljs-comment"># 数据</span><br>x = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br>y = [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">11</span>]<br><br><span class="hljs-comment"># 创建图表</span><br>plt.plot(x, y)<br><br><span class="hljs-comment"># 添加标题和标签</span><br>plt.title(<span class="hljs-string">&quot;Simple Line Plot&quot;</span>)<br>plt.xlabel(<span class="hljs-string">&quot;X-axis&quot;</span>)<br>plt.ylabel(<span class="hljs-string">&quot;Y-axis&quot;</span>)<br><br><span class="hljs-comment"># 显示图表</span><br>plt.show()<br></code></pre></td></tr></table></figure><img src="https://matplotlib.org/stable/_images/sphx_glr_pyplot_001.png" alt="Simple Line Plot" style="zoom:67%;" /><p>(2) <strong>绘制散点图</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br><span class="hljs-comment"># 数据</span><br>x = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br>y = [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">11</span>]<br><br><span class="hljs-comment"># 创建散点图</span><br>plt.scatter(x, y, s=<span class="hljs-number">10</span>)<br><span class="hljs-comment"># s代表点的大小</span><br><br><span class="hljs-comment"># 添加标题和标签</span><br>plt.title(<span class="hljs-string">&quot;Scatter Plot&quot;</span>)<br>plt.xlabel(<span class="hljs-string">&quot;X-axis&quot;</span>)<br>plt.ylabel(<span class="hljs-string">&quot;Y-axis&quot;</span>)<br><br><span class="hljs-comment"># 显示图表</span><br>plt.show()<br></code></pre></td></tr></table></figure><img src="https://matplotlib.org/stable/_images/sphx_glr_scatter_001.png" alt="Scatter Plot" style="zoom:67%;" /><p>(3) <strong>绘制柱状图</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br><span class="hljs-comment"># 数据</span><br>categories = [<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;D&#x27;</span>]<br>values = [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">15</span>, <span class="hljs-number">25</span>]<br><br><span class="hljs-comment"># 创建柱状图</span><br>plt.bar(categories, values)<br><br><span class="hljs-comment"># 添加标题和标签</span><br>plt.title(<span class="hljs-string">&quot;Bar Chart&quot;</span>)<br>plt.xlabel(<span class="hljs-string">&quot;Categories&quot;</span>)<br>plt.ylabel(<span class="hljs-string">&quot;Values&quot;</span>)<br><br><span class="hljs-comment"># 显示图表</span><br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="https://matplotlib.org/stable/_images/sphx_glr_bar_001.png" alt="Bar Chart"></p><p>(4) <strong>绘制饼图</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br><span class="hljs-comment"># 数据</span><br>labels = [<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;D&#x27;</span>]<br>sizes = [<span class="hljs-number">15</span>, <span class="hljs-number">30</span>, <span class="hljs-number">45</span>, <span class="hljs-number">10</span>]<br><br><span class="hljs-comment"># 创建饼图</span><br>plt.pie(sizes, labels=labels, autopct=<span class="hljs-string">&#x27;%1.1f%%&#x27;</span>)<br><br><span class="hljs-comment"># 添加标题</span><br>plt.title(<span class="hljs-string">&quot;Pie Chart&quot;</span>)<br><br><span class="hljs-comment"># 显示图表</span><br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="https://matplotlib.org/stable/_images/sphx_glr_pie_001.png" alt="Pie Chart"></p><p>使用 <code>plt.subplots</code> 可以在一个窗口中绘制多个子图。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br><span class="hljs-comment"># 数据</span><br>x = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br>y1 = [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">11</span>]<br>y2 = [<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">9</span>, <span class="hljs-number">16</span>, <span class="hljs-number">25</span>]<br><br><span class="hljs-comment"># 创建子图</span><br>fig, (ax1, ax2) = plt.subplots(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, figsize=(<span class="hljs-number">10</span>, <span class="hljs-number">5</span>))<br><br><span class="hljs-comment"># 子图 1：折线图</span><br>ax1.plot(x, y1)<br>ax1.set_title(<span class="hljs-string">&quot;Line Plot&quot;</span>)<br><br><span class="hljs-comment"># 子图 2：散点图</span><br>ax2.scatter(x, y2)<br>ax2.set_title(<span class="hljs-string">&quot;Scatter Plot&quot;</span>)<br><br><span class="hljs-comment"># 显示图表</span><br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="https://ooo.0x0.ooo/2025/01/20/OGkwSP.png" alt="Subplots"></p><p><code>Matplotlib</code> 支持丰富的自定义选项，例如颜色、线型、标记等。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br><span class="hljs-comment"># 数据</span><br>x = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br>y = [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">11</span>]<br><br><span class="hljs-comment"># 创建图表</span><br>plt.plot(x, y, color=<span class="hljs-string">&#x27;red&#x27;</span>, linestyle=<span class="hljs-string">&#x27;--&#x27;</span>, marker=<span class="hljs-string">&#x27;o&#x27;</span>, label=<span class="hljs-string">&#x27;Data&#x27;</span>)<br><br><span class="hljs-comment"># 添加标题、标签和图例</span><br>plt.title(<span class="hljs-string">&quot;Customized Line Plot&quot;</span>)<br>plt.xlabel(<span class="hljs-string">&quot;X-axis&quot;</span>)<br>plt.ylabel(<span class="hljs-string">&quot;Y-axis&quot;</span>)<br>plt.legend()<br><br><span class="hljs-comment"># 显示图表</span><br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="https://matplotlib.org/stable/_images/sphx_glr_line_demo_dash_control_001.png" alt="Customized Line Plot"></p><p>使用 <code>plt.savefig</code> 可以将图表保存为图片文件。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br><span class="hljs-comment"># 数据</span><br>x = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br>y = [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">11</span>]<br><br><span class="hljs-comment"># 创建图表</span><br>plt.plot(x, y)<br><br><span class="hljs-comment"># 保存图表</span><br>plt.savefig(<span class="hljs-string">&quot;line_plot.png&quot;</span>)<br></code></pre></td></tr></table></figure><p>也可以使用<strong>内置样式</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br><span class="hljs-comment"># 查看所有内置样式</span><br><span class="hljs-built_in">print</span>(plt.style.available)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br><span class="hljs-comment"># 应用内置样式</span><br>plt.style.use(<span class="hljs-string">&#x27;seaborn-v0_8-dark&#x27;</span>)<br><br><span class="hljs-comment"># 数据</span><br>x = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br>y = [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">11</span>]<br><br><span class="hljs-comment"># 创建图表</span><br>plt.plot(x, y, label=<span class="hljs-string">&quot;Data&quot;</span>)<br><br><span class="hljs-comment"># 添加标题和标签</span><br>plt.title(<span class="hljs-string">&quot;Line Plot with Seaborn Darkgrid Style&quot;</span>)<br>plt.xlabel(<span class="hljs-string">&quot;X-axis&quot;</span>)<br>plt.ylabel(<span class="hljs-string">&quot;Y-axis&quot;</span>)<br><br><span class="hljs-comment"># 添加图例</span><br>plt.legend()<br><br><span class="hljs-comment"># 显示图表</span><br>plt.show()<br></code></pre></td></tr></table></figure><blockquote><p>Matplotlib提供了很多自定义的设置，例如<code>ticklable_format(style=)</code>来设置<strong>刻度标记</strong>，自定义RGB颜色<code>color=(0,0.8,0)</code></p></blockquote><h4 id="Application：Random-Walk"><a href="#Application：Random-Walk" class="headerlink" title="Application：Random Walk"></a>Application：Random Walk</h4><p>下文给出实现<code>Random Walk</code> 的Python代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> random <span class="hljs-keyword">import</span> choice<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">from</span> tqdm <span class="hljs-keyword">import</span> tqdm<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RandomWalk</span>:<br>    <span class="hljs-string">&#x27;&#x27;&#x27;A class represents the random walk&#x27;&#x27;&#x27;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, num_points=<span class="hljs-number">500</span></span>):<br>        <span class="hljs-variable language_">self</span>.num_points = num_points<br><br>        <span class="hljs-variable language_">self</span>.x_values=[<span class="hljs-number">0</span>]<br>        <span class="hljs-variable language_">self</span>.y_values=[<span class="hljs-number">0</span>]<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">fill_walk</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>((<span class="hljs-variable language_">self</span>.x_values))&lt;<span class="hljs-variable language_">self</span>.num_points:<br>            x_direction = choice([<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>])<br>            x_distance = choice([<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>])<br>            x_step = x_distance * x_direction<br><br>            y_direction = choice([<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>])<br>            y_distance = choice([<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>])<br>            y_step = y_distance * y_direction<br><br>            <span class="hljs-keyword">if</span> x_step==<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> y_step==<span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">continue</span><br><br>            x_new = <span class="hljs-variable language_">self</span>.x_values[-<span class="hljs-number">1</span>] + x_step<br>            y_new = <span class="hljs-variable language_">self</span>.y_values[-<span class="hljs-number">1</span>] + y_step<br><br>            <span class="hljs-variable language_">self</span>.x_values.append(x_new)<br>            <span class="hljs-variable language_">self</span>.y_values.append(y_new)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">imitate_walk</span>(<span class="hljs-params">index</span>):<br>    Total_steps= <span class="hljs-number">10000</span><br>    rw_orange = RandomWalk(Total_steps)<br>    rw_red = RandomWalk(Total_steps)<br>    rw_blue = RandomWalk(Total_steps)<br><br>    rw_orange.fill_walk()<br>    rw_blue.fill_walk()<br>    rw_red.fill_walk()<br><br>    plt.style.use(<span class="hljs-string">&#x27;classic&#x27;</span>)<br>    fig, ax = plt.subplots()<br>    point_numbers = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(Total_steps))<br><br>    ax.scatter(rw_orange.x_values, rw_orange.y_values, c=point_numbers,cmap=plt.cm.Oranges,edgecolors=<span class="hljs-string">&#x27;none&#x27;</span>, s=<span class="hljs-number">2</span>)<br>    ax.scatter(rw_blue.x_values, rw_blue.y_values, c=point_numbers,cmap=plt.cm.Blues,edgecolors=<span class="hljs-string">&#x27;none&#x27;</span>, s=<span class="hljs-number">2</span>)<br>    ax.scatter(rw_red.x_values, rw_red.y_values, c=point_numbers,cmap=plt.cm.Reds,edgecolors=<span class="hljs-string">&#x27;none&#x27;</span>, s=<span class="hljs-number">2</span>)<br><br><br>    ax.set_aspect(<span class="hljs-string">&#x27;equal&#x27;</span>)<br><br>    ax.get_xaxis().set_visible(<span class="hljs-literal">False</span>)<br>    ax.get_yaxis().set_visible(<span class="hljs-literal">False</span>)<br><br><br>    plt.suptitle(<span class="hljs-string">f&#x27;Random Walk<span class="hljs-subst">&#123;index+<span class="hljs-number">1</span>&#125;</span>&#x27;</span>, fontsize=<span class="hljs-number">16</span>, fontweight=<span class="hljs-string">&#x27;bold&#x27;</span>)<br>    plt.savefig(<span class="hljs-string">f&#x27;Random_walk<span class="hljs-subst">&#123;index+<span class="hljs-number">1</span>&#125;</span>.png&#x27;</span>, bbox_inches=<span class="hljs-string">&#x27;tight&#x27;</span>)<br>    plt.close()<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> tqdm(<span class="hljs-built_in">range</span>(<span class="hljs-number">1000</span>)):<br>        imitate_walk(i)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-string">&#x27;&#x27;&#x27;The main function&#x27;&#x27;&#x27;</span><br>    main()<br><br></code></pre></td></tr></table></figure><p>这个代码会实现1000次的Random_Walk，其中每一次的步长为10000。最后画出的图片效果还是非常震撼的！</p><h3 id="Chapter-16-Download-Data"><a href="#Chapter-16-Download-Data" class="headerlink" title="Chapter 16 Download Data"></a>Chapter 16 Download Data</h3><h4 id="CSV"><a href="#CSV" class="headerlink" title="CSV"></a>CSV</h4><p>CSV（Comma-Separated Values，逗号分隔值）是一种简单的文件格式，用于存储和交换表格数据。它以纯文本形式存储数据，每行代表一条记录，每个字段用逗号分隔。CSV 文件易于生成和解析，广泛应用于数据存储、导入和导出。</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><span class="hljs-built_in">Name,</span>Age,City<br><span class="hljs-built_in">Alice,</span><span class="hljs-number">30</span>,<span class="hljs-keyword">New</span> York<br><span class="hljs-built_in">Bob,</span><span class="hljs-number">25</span>,Los Angeles<br><span class="hljs-built_in">Charlie,</span><span class="hljs-number">35</span>,Chicago<br></code></pre></td></tr></table></figure><ul><li><strong>表头（Header）</strong>：第一行通常是字段名称（如 <code>Name, Age, City</code>）。</li><li><strong>数据行</strong>：每行代表一条记录，字段之间用逗号分隔。</li><li><strong>分隔符</strong>：默认是逗号（<code>,</code>），但也可以是其他字符（如分号 <code>;</code> 或制表符 <code>\t</code>）。</li></ul><p>我们会发现，CSV数据文件阅读起来还是比较麻烦的，（作为存储便捷性的牺牲）我们可以使用Python来帮助我们解析CSV数据并且完成数据的可视化。</p><h3 id="CSV-in-Python：Data-Processing"><a href="#CSV-in-Python：Data-Processing" class="headerlink" title="CSV in Python：Data Processing"></a>CSV in Python：Data Processing</h3><p>在原书中，作者使用了天气数据作为示范，我们可以来一点更好玩的~</p><p>在接下来的篇幅中，笔者将使用<strong>Python完成一个简单的机器学习项目——Titanic二分类问题</strong></p><p>数据集来源：<a href="https://www.kaggle.com/c/titanic/overview">Kaggle Titanic</a></p><p>在Vscode中新建一个文件夹作为项目主目录，并且下载官方提供的数据集：<code>gender_submission.csv</code>,<code>test.csv</code>,<code>train.csv</code></p><p>先看看官方给我们的要求是什么：</p><blockquote><p><strong>The training set</strong> should be used to build your machine learning models. For the training set, we provide the outcome (also known as the “ground truth”) for each passenger. Your model will be based on “features” like passengers’ gender and class. You can also use <a href="https://triangleinequality.wordpress.com/2013/09/08/basic-feature-engineering-with-the-titanic-data/">feature engineering </a>to create new features.</p><p><strong>The test set</strong> should be used to see how well your model performs on unseen data. For the test set, we do not provide the ground truth for each passenger. It is your job to predict these outcomes. For each passenger in the test set, use the model you trained to predict whether or not they survived the sinking of the Titanic.</p><p>We also include <strong>gender_submission.csv</strong>, a set of predictions that assume all and only female passengers survive, as an example of what a submission file should look like.</p></blockquote><p>通俗来说，就是给了泰坦尼克号上部分成员的数据信息，然后建立自己的机器学习模型预测<strong>“ground truth”</strong>,最后提交一份类似于<code>gender_submission.csv</code>的报告（第三份文件只是输出示例，假设所有女人幸存而所有男人牺牲）</p><h5 id="Loading-Data"><a href="#Loading-Data" class="headerlink" title="Loading Data"></a>Loading Data</h5><p>我们首先需要<strong>读取csv文件中的数据</strong>，可以使用Python中的<code>csv</code>模块。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> csv<br><span class="hljs-keyword">from</span> pathlib <span class="hljs-keyword">import</span> Path<br><span class="hljs-keyword">import</span> json<br><br>test_data_path = Path(<span class="hljs-string">&#x27;test.csv&#x27;</span>)<br>train_data_path = Path(<span class="hljs-string">&#x27;train.csv&#x27;</span>)<br><br>train_lines = train_data_path.read_text().splitlines()<br>test_lines = test_data_path.read_text().splitlines()<br><span class="hljs-comment"># 将文本字符串按行拆分成列表</span><br><br>train_reader = csv.reader(train_lines)<br>test_reader = csv.reader(test_lines)<br><br>header_row_train = <span class="hljs-built_in">next</span>(train_reader)<br>header_row_test = <span class="hljs-built_in">next</span>(test_reader)<br><span class="hljs-comment">#得到第一行题头</span><br><br><span class="hljs-built_in">print</span>(header_row_train)<br><span class="hljs-built_in">print</span>(header_row_test)<br><br></code></pre></td></tr></table></figure><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scheme">[<span class="hljs-symbol">&#x27;PassengerId</span>&#x27;, <span class="hljs-symbol">&#x27;Survived</span>&#x27;, <span class="hljs-symbol">&#x27;Pclass</span>&#x27;, <span class="hljs-symbol">&#x27;Name</span>&#x27;, <span class="hljs-symbol">&#x27;Sex</span>&#x27;, <span class="hljs-symbol">&#x27;Age</span>&#x27;, <span class="hljs-symbol">&#x27;SibSp</span>&#x27;, <span class="hljs-symbol">&#x27;Parch</span>&#x27;, <span class="hljs-symbol">&#x27;Ticket</span>&#x27;, <span class="hljs-symbol">&#x27;Fare</span>&#x27;, <span class="hljs-symbol">&#x27;Cabin</span>&#x27;, <span class="hljs-symbol">&#x27;Embarked</span>&#x27;]<br>[<span class="hljs-symbol">&#x27;PassengerId</span>&#x27;, <span class="hljs-symbol">&#x27;Pclass</span>&#x27;, <span class="hljs-symbol">&#x27;Name</span>&#x27;, <span class="hljs-symbol">&#x27;Sex</span>&#x27;, <span class="hljs-symbol">&#x27;Age</span>&#x27;, <span class="hljs-symbol">&#x27;SibSp</span>&#x27;, <span class="hljs-symbol">&#x27;Parch</span>&#x27;, <span class="hljs-symbol">&#x27;Ticket</span>&#x27;, <span class="hljs-symbol">&#x27;Fare</span>&#x27;, <span class="hljs-symbol">&#x27;Cabin</span>&#x27;, <span class="hljs-symbol">&#x27;Embarked</span>&#x27;]<br></code></pre></td></tr></table></figure><p>接下来，我们将要将数据处理成方便获取的JSON格式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs Python">train_data_json = []<br>test_data_json = []<br><br><span class="hljs-comment"># 将训练集数据转换为 JSON</span><br><span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> train_reader:<br>    <span class="hljs-comment"># 将每一行数据与题头组合成字典</span><br>    row_dict = &#123;header: value <span class="hljs-keyword">for</span> header, value <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(header_row_train, row)&#125;<br>    train_data_json.append(row_dict)<br><br><span class="hljs-comment"># 将测试集数据转换为 JSON</span><br><span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> test_reader:<br>    <span class="hljs-comment"># 将每一行数据与题头组合成字典</span><br>    row_dict = &#123;header: value <span class="hljs-keyword">for</span> header, value <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(header_row_test, row)&#125;<br>    test_data_json.append(row_dict)<br><br><span class="hljs-comment"># 打印结果</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;训练集 JSON 数据：&quot;</span>)<br><span class="hljs-built_in">print</span>(train_data_json[:<span class="hljs-number">2</span>])<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n测试集 JSON 数据：&quot;</span>)<br><span class="hljs-built_in">print</span>(test_data_json[:<span class="hljs-number">2</span>])<br><br><span class="hljs-comment"># 保存训练集 JSON 数据</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;train_data.json&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    json.dump(train_data_json, f, indent=<span class="hljs-number">2</span>)  <span class="hljs-comment"># indent=2 用于美化输出</span><br><br><span class="hljs-comment"># 保存测试集 JSON 数据</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;test_data.json&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    json.dump(test_data_json, f, indent=<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><p>运行程序，我们就成功的把csv格式的文件存储成为<code>JSON</code>文件！</p><h5 id="Data-Washing"><a href="#Data-Washing" class="headerlink" title="Data Washing"></a>Data Washing</h5><p>接下来，我们需要进行数据的预处理，包括<strong>处理空缺的数据</strong>等等。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> json<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-string">&#x27;&#x27;&#x27;Data washing&#x27;&#x27;&#x27;</span><br><br><span class="hljs-comment"># 加载训练集 JSON 数据</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;train_data.json&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    train_data = json.load(f)<br><br><span class="hljs-comment"># 加载测试集 JSON 数据</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;test_data.json&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    test_data = json.load(f)<br><br><br><span class="hljs-comment"># 将 JSON 数据转换为 DataFrame</span><br>train_df = pd.DataFrame(train_data)<br>test_df = pd.DataFrame(test_data)<br><br><span class="hljs-comment"># 将字符串类型的数值转换为数值类型</span><br>train_df[<span class="hljs-string">&#x27;Age&#x27;</span>] = train_df[<span class="hljs-string">&#x27;Age&#x27;</span>].replace(<span class="hljs-string">&#x27;&#x27;</span>, np.nan)<br>train_df[<span class="hljs-string">&#x27;Fare&#x27;</span>] = train_df[<span class="hljs-string">&#x27;Fare&#x27;</span>].replace(<span class="hljs-string">&#x27;&#x27;</span>, np.nan)<br>test_df[<span class="hljs-string">&#x27;Age&#x27;</span>] = test_df[<span class="hljs-string">&#x27;Age&#x27;</span>].replace(<span class="hljs-string">&#x27;&#x27;</span>, np.nan)<br>test_df[<span class="hljs-string">&#x27;Fare&#x27;</span>] = test_df[<span class="hljs-string">&#x27;Fare&#x27;</span>].replace(<span class="hljs-string">&#x27;&#x27;</span>, np.nan)<br><br>train_df[<span class="hljs-string">&#x27;Age&#x27;</span>] = train_df[<span class="hljs-string">&#x27;Age&#x27;</span>].astype(<span class="hljs-built_in">float</span>)<br>train_df[<span class="hljs-string">&#x27;Fare&#x27;</span>] = train_df[<span class="hljs-string">&#x27;Fare&#x27;</span>].astype(<span class="hljs-built_in">float</span>)<br><br>test_df[<span class="hljs-string">&#x27;Age&#x27;</span>] = test_df[<span class="hljs-string">&#x27;Age&#x27;</span>].astype(<span class="hljs-built_in">float</span>)<br>test_df[<span class="hljs-string">&#x27;Fare&#x27;</span>] = test_df[<span class="hljs-string">&#x27;Fare&#x27;</span>].astype(<span class="hljs-built_in">float</span>)<br><br><br><span class="hljs-comment"># 处理缺失值</span><br>train_df[<span class="hljs-string">&#x27;Age&#x27;</span>] = train_df[<span class="hljs-string">&#x27;Age&#x27;</span>].fillna(train_df[<span class="hljs-string">&#x27;Age&#x27;</span>].median())<br>train_df[<span class="hljs-string">&#x27;Embarked&#x27;</span>] = train_df[<span class="hljs-string">&#x27;Embarked&#x27;</span>].fillna(train_df[<span class="hljs-string">&#x27;Embarked&#x27;</span>].mode()[<span class="hljs-number">0</span>])<br>train_df[<span class="hljs-string">&#x27;Cabin&#x27;</span>] = train_df[<span class="hljs-string">&#x27;Cabin&#x27;</span>].fillna(<span class="hljs-string">&#x27;Unknown&#x27;</span>)<br><br>test_df[<span class="hljs-string">&#x27;Age&#x27;</span>] = test_df[<span class="hljs-string">&#x27;Age&#x27;</span>].fillna(test_df[<span class="hljs-string">&#x27;Age&#x27;</span>].median())<br>test_df[<span class="hljs-string">&#x27;Fare&#x27;</span>] = test_df[<span class="hljs-string">&#x27;Fare&#x27;</span>].fillna(test_df[<span class="hljs-string">&#x27;Fare&#x27;</span>].median())<br>test_df[<span class="hljs-string">&#x27;Cabin&#x27;</span>] = test_df[<span class="hljs-string">&#x27;Cabin&#x27;</span>].fillna(<span class="hljs-string">&#x27;Unknown&#x27;</span>)<br><br><span class="hljs-comment"># check</span><br><span class="hljs-comment"># 检查训练集的缺失值</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;The loss of train set:&quot;</span>)<br><span class="hljs-built_in">print</span>(train_df.isnull().<span class="hljs-built_in">sum</span>())<br><br><span class="hljs-comment"># 检查测试集的缺失值</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\nThe loss of test set:&quot;</span>)<br><span class="hljs-built_in">print</span>(test_df.isnull().<span class="hljs-built_in">sum</span>())<br></code></pre></td></tr></table></figure><p>检查输出，说明数据预处理完成。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs bash">The loss of train <span class="hljs-built_in">set</span>:<br>PassengerId    0<br>Survived       0<br>Pclass         0<br>Name           0<br>Sex            0<br>Age            0<br>SibSp          0<br>Parch          0<br>Ticket         0<br>Fare           0<br>Cabin          0<br>Embarked       0<br>dtype: int64<br><br>The loss of <span class="hljs-built_in">test</span> <span class="hljs-built_in">set</span>:<br>PassengerId    0<br>Pclass         0<br>Name           0<br>Sex            0<br>Age            0<br>SibSp          0<br>Parch          0<br>Ticket         0<br>Fare           0<br>Cabin          0<br>Embarked       0<br>dtype: int64<br></code></pre></td></tr></table></figure><blockquote><p>这就是第一步储存在<code>JSON</code>的好处，模块化的处理保证了程序员可以独立地执行各部分的程序，如果出错了也可以重新进行Loading Data获得原始数据。</p></blockquote><h5 id="Machine-Learning"><a href="#Machine-Learning" class="headerlink" title="Machine Learning"></a>Machine Learning</h5><p>接下来就是<strong>机器学习</strong>的专场了，笔者使用的是<strong>随机森林RandomBoost</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-comment"># %%</span><br><span class="hljs-keyword">import</span> json<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-comment"># %%</span><br><br><span class="hljs-string">&#x27;&#x27;&#x27;Data washing&#x27;&#x27;&#x27;</span><br><br><span class="hljs-comment"># 加载训练集 JSON 数据</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;train_data.json&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    train_data = json.load(f)<br><br><span class="hljs-comment"># 加载测试集 JSON 数据</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;test_data.json&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    test_data = json.load(f)<br><br><br><span class="hljs-comment"># 将 JSON 数据转换为 DataFrame</span><br>train_df = pd.DataFrame(train_data)<br>test_df = pd.DataFrame(test_data)<br><br><span class="hljs-comment"># 将字符串类型的数值转换为数值类型</span><br>train_df[<span class="hljs-string">&#x27;Age&#x27;</span>] = train_df[<span class="hljs-string">&#x27;Age&#x27;</span>].replace(<span class="hljs-string">&#x27;&#x27;</span>, np.nan)<br>train_df[<span class="hljs-string">&#x27;Fare&#x27;</span>] = train_df[<span class="hljs-string">&#x27;Fare&#x27;</span>].replace(<span class="hljs-string">&#x27;&#x27;</span>, np.nan)<br>test_df[<span class="hljs-string">&#x27;Age&#x27;</span>] = test_df[<span class="hljs-string">&#x27;Age&#x27;</span>].replace(<span class="hljs-string">&#x27;&#x27;</span>, np.nan)<br>test_df[<span class="hljs-string">&#x27;Fare&#x27;</span>] = test_df[<span class="hljs-string">&#x27;Fare&#x27;</span>].replace(<span class="hljs-string">&#x27;&#x27;</span>, np.nan)<br><br>train_df[<span class="hljs-string">&#x27;Age&#x27;</span>] = train_df[<span class="hljs-string">&#x27;Age&#x27;</span>].astype(<span class="hljs-built_in">float</span>)<br>train_df[<span class="hljs-string">&#x27;Fare&#x27;</span>] = train_df[<span class="hljs-string">&#x27;Fare&#x27;</span>].astype(<span class="hljs-built_in">float</span>)<br><br>train_df[<span class="hljs-string">&#x27;Parch&#x27;</span>] = train_df[<span class="hljs-string">&#x27;Parch&#x27;</span>].astype(<span class="hljs-built_in">int</span>)<br>train_df[<span class="hljs-string">&#x27;SibSp&#x27;</span>] = train_df[<span class="hljs-string">&#x27;SibSp&#x27;</span>].astype(<span class="hljs-built_in">int</span>)<br>train_df[<span class="hljs-string">&#x27;Pclass&#x27;</span>] = train_df[<span class="hljs-string">&#x27;Pclass&#x27;</span>].astype(<span class="hljs-built_in">int</span>)<br><br><br>test_df[<span class="hljs-string">&#x27;Age&#x27;</span>] = test_df[<span class="hljs-string">&#x27;Age&#x27;</span>].astype(<span class="hljs-built_in">float</span>)<br>test_df[<span class="hljs-string">&#x27;Fare&#x27;</span>] = test_df[<span class="hljs-string">&#x27;Fare&#x27;</span>].astype(<span class="hljs-built_in">float</span>)<br><br>test_df[<span class="hljs-string">&#x27;Parch&#x27;</span>] = test_df[<span class="hljs-string">&#x27;Parch&#x27;</span>].astype(<span class="hljs-built_in">int</span>)<br>test_df[<span class="hljs-string">&#x27;SibSp&#x27;</span>] = test_df[<span class="hljs-string">&#x27;SibSp&#x27;</span>].astype(<span class="hljs-built_in">int</span>)<br>test_df[<span class="hljs-string">&#x27;Pclass&#x27;</span>] = test_df[<span class="hljs-string">&#x27;Pclass&#x27;</span>].astype(<span class="hljs-built_in">int</span>)<br><br><br><span class="hljs-comment"># 处理缺失值</span><br>train_df[<span class="hljs-string">&#x27;Age&#x27;</span>] = train_df[<span class="hljs-string">&#x27;Age&#x27;</span>].fillna(train_df[<span class="hljs-string">&#x27;Age&#x27;</span>].median())<br>train_df[<span class="hljs-string">&#x27;Embarked&#x27;</span>] = train_df[<span class="hljs-string">&#x27;Embarked&#x27;</span>].fillna(train_df[<span class="hljs-string">&#x27;Embarked&#x27;</span>].mode()[<span class="hljs-number">0</span>])<br>train_df[<span class="hljs-string">&#x27;Cabin&#x27;</span>] = train_df[<span class="hljs-string">&#x27;Cabin&#x27;</span>].fillna(<span class="hljs-string">&#x27;Unknown&#x27;</span>)<br><br>test_df[<span class="hljs-string">&#x27;Age&#x27;</span>] = test_df[<span class="hljs-string">&#x27;Age&#x27;</span>].fillna(test_df[<span class="hljs-string">&#x27;Age&#x27;</span>].median())<br>test_df[<span class="hljs-string">&#x27;Fare&#x27;</span>] = test_df[<span class="hljs-string">&#x27;Fare&#x27;</span>].fillna(test_df[<span class="hljs-string">&#x27;Fare&#x27;</span>].median())<br>test_df[<span class="hljs-string">&#x27;Cabin&#x27;</span>] = test_df[<span class="hljs-string">&#x27;Cabin&#x27;</span>].fillna(<span class="hljs-string">&#x27;Unknown&#x27;</span>)<br><br><br><br><span class="hljs-comment"># check</span><br><span class="hljs-comment"># 检查训练集的缺失值</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;The loss of train set:&quot;</span>)<br><span class="hljs-built_in">print</span>(train_df.isnull().<span class="hljs-built_in">sum</span>())<br><br><span class="hljs-comment"># 检查测试集的缺失值</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\nThe loss of test set:&quot;</span>)<br><span class="hljs-built_in">print</span>(test_df.isnull().<span class="hljs-built_in">sum</span>())<br><br><span class="hljs-comment"># %%</span><br><span class="hljs-comment"># 从姓名中提取称呼（如 Mr, Miss, Mrs）</span><br>train_df[<span class="hljs-string">&#x27;Title&#x27;</span>] = train_df[<span class="hljs-string">&#x27;Name&#x27;</span>].apply(<span class="hljs-keyword">lambda</span> x: x.split(<span class="hljs-string">&#x27;,&#x27;</span>)[<span class="hljs-number">1</span>].split(<span class="hljs-string">&#x27;.&#x27;</span>)[<span class="hljs-number">0</span>].strip())<br>test_df[<span class="hljs-string">&#x27;Title&#x27;</span>] = test_df[<span class="hljs-string">&#x27;Name&#x27;</span>].apply(<span class="hljs-keyword">lambda</span> x: x.split(<span class="hljs-string">&#x27;,&#x27;</span>)[<span class="hljs-number">1</span>].split(<span class="hljs-string">&#x27;.&#x27;</span>)[<span class="hljs-number">0</span>].strip())<br><br><span class="hljs-comment"># 将性别转换为数值</span><br>train_df[<span class="hljs-string">&#x27;Sex&#x27;</span>] = train_df[<span class="hljs-string">&#x27;Sex&#x27;</span>].<span class="hljs-built_in">map</span>(&#123;<span class="hljs-string">&#x27;male&#x27;</span>: <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;female&#x27;</span>: <span class="hljs-number">1</span>&#125;)<br>test_df[<span class="hljs-string">&#x27;Sex&#x27;</span>] = test_df[<span class="hljs-string">&#x27;Sex&#x27;</span>].<span class="hljs-built_in">map</span>(&#123;<span class="hljs-string">&#x27;male&#x27;</span>: <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;female&#x27;</span>: <span class="hljs-number">1</span>&#125;)<br><br><span class="hljs-comment"># 创建家庭大小特征</span><br>train_df[<span class="hljs-string">&#x27;FamilySize&#x27;</span>] = train_df[<span class="hljs-string">&#x27;SibSp&#x27;</span>] + train_df[<span class="hljs-string">&#x27;Parch&#x27;</span>] + <span class="hljs-number">1</span><br>test_df[<span class="hljs-string">&#x27;FamilySize&#x27;</span>] = test_df[<span class="hljs-string">&#x27;SibSp&#x27;</span>] + test_df[<span class="hljs-string">&#x27;Parch&#x27;</span>] + <span class="hljs-number">1</span><br><br><span class="hljs-comment"># 将登船港口转换为数值</span><br>train_df[<span class="hljs-string">&#x27;Embarked&#x27;</span>] = train_df[<span class="hljs-string">&#x27;Embarked&#x27;</span>].<span class="hljs-built_in">map</span>(&#123;<span class="hljs-string">&#x27;S&#x27;</span>: <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;C&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;Q&#x27;</span>: <span class="hljs-number">2</span>&#125;)<br>test_df[<span class="hljs-string">&#x27;Embarked&#x27;</span>] = test_df[<span class="hljs-string">&#x27;Embarked&#x27;</span>].<span class="hljs-built_in">map</span>(&#123;<span class="hljs-string">&#x27;S&#x27;</span>: <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;C&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;Q&#x27;</span>: <span class="hljs-number">2</span>&#125;)<br><br><span class="hljs-comment"># %%</span><br><span class="hljs-comment"># 选择特征</span><br>features = [<span class="hljs-string">&#x27;Pclass&#x27;</span>, <span class="hljs-string">&#x27;Sex&#x27;</span>, <span class="hljs-string">&#x27;Age&#x27;</span>, <span class="hljs-string">&#x27;SibSp&#x27;</span>, <span class="hljs-string">&#x27;Parch&#x27;</span>, <span class="hljs-string">&#x27;Fare&#x27;</span>, <span class="hljs-string">&#x27;Embarked&#x27;</span>, <span class="hljs-string">&#x27;FamilySize&#x27;</span>]<br>X_train = train_df[features]<br>y_train = train_df[<span class="hljs-string">&#x27;Survived&#x27;</span>]<br><br>X_test = test_df[features]<br><br><span class="hljs-comment"># %%</span><br><span class="hljs-built_in">print</span>(X_train.dtypes)<br><br><span class="hljs-comment"># %%</span><br><span class="hljs-keyword">from</span> sklearn.ensemble <span class="hljs-keyword">import</span> RandomForestClassifier<br><br><span class="hljs-comment"># 初始化模型</span><br>model = RandomForestClassifier(n_estimators=<span class="hljs-number">100</span>, random_state=<span class="hljs-number">42</span>)<br><br><span class="hljs-comment"># 训练模型</span><br>model.fit(X_train, y_train)<br><br><span class="hljs-comment"># %%</span><br><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> accuracy_score, confusion_matrix<br><br><span class="hljs-comment"># 在训练集上进行预测</span><br>y_train_pred = model.predict(X_train)<br><br><span class="hljs-comment"># 计算准确率</span><br>accuracy = accuracy_score(y_train, y_train_pred)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;训练集准确率: <span class="hljs-subst">&#123;accuracy:<span class="hljs-number">.2</span>f&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># 绘制混淆矩阵</span><br>conf_matrix = confusion_matrix(y_train, y_train_pred)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;混淆矩阵:&quot;</span>)<br><span class="hljs-built_in">print</span>(conf_matrix)<br><br><span class="hljs-comment"># %%</span><br><span class="hljs-comment"># 对测试集进行预测</span><br>test_predictions = model.predict(X_test)<br><br><span class="hljs-comment"># 将预测结果保存到 CSV 文件</span><br>output = pd.DataFrame(&#123;<br>    <span class="hljs-string">&#x27;PassengerId&#x27;</span>: test_df[<span class="hljs-string">&#x27;PassengerId&#x27;</span>],<br>    <span class="hljs-string">&#x27;Survived&#x27;</span>: test_predictions<br>&#125;)<br>output.to_csv(<span class="hljs-string">&#x27;submission.csv&#x27;</span>, index=<span class="hljs-literal">False</span>)<br><br><br><br></code></pre></td></tr></table></figure><blockquote><p>相关文件将会开源到我的Github上。</p></blockquote><p>结果:clown_face:</p><p><img src="https://ooo.0x0.ooo/2025/01/21/OGF0ms.png" alt="Result"></p><h3 id="Chapter-17-Using-API"><a href="#Chapter-17-Using-API" class="headerlink" title="Chapter 17 Using API"></a>Chapter 17 Using API</h3><h2 id="Advanced-Techniques"><a href="#Advanced-Techniques" class="headerlink" title="Advanced Techniques"></a>Advanced Techniques</h2>]]></content>
    
    
    <categories>
      
      <category>Code</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Tutorial</tag>
      
      <tag>Files</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python-Cheatsheet</title>
    <link href="/posts/Python-cheatsheet/"/>
    <url>/posts/Python-cheatsheet/</url>
    
    <content type="html"><![CDATA[<style>  html, body, .markdown-body {    font-family: Georgia, sans, serif;  }</style><h1 id="Python-Quick-Tutorial"><a href="#Python-Quick-Tutorial" class="headerlink" title="Python Quick Tutorial"></a>Python Quick Tutorial</h1><h2 id="The-Zen-of-Python"><a href="#The-Zen-of-Python" class="headerlink" title="The Zen of Python"></a>The Zen of Python</h2><div style="text-align: center;">Beautiful is better than ugly.<br>Explicit is better than implicit.<br>Simple is better than complex.<br>Complex is better than complicated.<br>Flat is better than nested.<br>Sparse is better than dense.<br>Readability counts.<br>Special cases aren't special enough to break the rules.<br>Although practicality beats purity.<br>Errors should never pass silently.<br>Unless explicitly silenced.<br>In the face of ambiguity, refuse the temptation to guess.<br>There should be one-- and preferably only one --obvious way to do it.<br>Although that way may not be obvious at first unless you're Dutch.<br>Now is better than never.<br>Although never is often better than right now.<br>If the implementation is hard to explain, it's a bad idea.<br>If the implementation is easy to explain, it may be a good idea.<br>Namespaces are one honking great idea -- let's do more of those!<br></div>## Announcement<p><a href="https://xiyuanyang-code.github.io/posts/Python-tutorial/">详情请点这里</a></p><p>这是<strong>Python快速教程系列</strong>的第一篇，内容覆盖：<strong>Python中的各种数据类型&#x2F;循环&#x2F;函数&#x2F;面向对象编程</strong>等基础的语法知识。 </p><h2 id="Table-of-Contents"><a href="#Table-of-Contents" class="headerlink" title="Table of Contents"></a>Table of Contents</h2><ul><li>Data Types</li><li>String</li><li>Basic Data Structures<ul><li>List</li><li>Tuple</li><li>Dictionaries</li></ul></li><li>Loops</li><li>Functions</li><li>OOP</li></ul><h2 id="Data-Types"><a href="#Data-Types" class="headerlink" title="Data Types"></a>Data Types</h2><p>在 Python 中，数据类型可以分为 <strong>可变数据类型</strong>（Mutable Data Types）和 <strong>不可变数据类型</strong>（Immutable Data Types）。它们的区别在于是否可以在创建后修改其内容。</p><h3 id="Immutable-Data-Types"><a href="#Immutable-Data-Types" class="headerlink" title="Immutable Data Types"></a><strong>Immutable Data Types</strong></h3><p>不可变数据类型是指一旦创建，其内容就不能被修改的数据类型。如果尝试修改不可变对象，Python 会创建一个新的对象，而不是修改原对象。</p><ol><li><p><strong>整数（<code>int</code>）</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">x = <span class="hljs-number">10</span><br>x = x + <span class="hljs-number">5</span>  <span class="hljs-comment"># 创建一个新的整数对象，x 指向新对象</span><br></code></pre></td></tr></table></figure></li><li><p><strong>浮点数（<code>float</code>）</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">y = <span class="hljs-number">3.14</span><br>y = y + <span class="hljs-number">1.0</span>  <span class="hljs-comment"># 创建一个新的浮点数对象，y 指向新对象</span><br></code></pre></td></tr></table></figure></li><li><p><strong>字符串（<code>str</code>）</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">s = <span class="hljs-string">&quot;hello&quot;</span><br>s = s + <span class="hljs-string">&quot; world&quot;</span>  <span class="hljs-comment"># 创建一个新的字符串对象，s 指向新对象</span><br></code></pre></td></tr></table></figure></li><li><p><strong>元组（<code>tuple</code>）</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">t = (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br>t = t + (<span class="hljs-number">4</span>,)  <span class="hljs-comment"># 创建一个新的元组对象，t 指向新对象</span><br></code></pre></td></tr></table></figure></li><li><p><strong>布尔值（<code>bool</code>）</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">b = <span class="hljs-literal">True</span><br>b = <span class="hljs-literal">False</span>  <span class="hljs-comment"># 创建一个新的布尔对象，b 指向新对象</span><br></code></pre></td></tr></table></figure></li><li><p><strong>冻结集合（<code>frozenset</code>）</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">fs = <span class="hljs-built_in">frozenset</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])<br>fs = fs.union([<span class="hljs-number">4</span>])  <span class="hljs-comment"># 创建一个新的冻结集合对象，fs 指向新对象</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="Mutable-Data-Types"><a href="#Mutable-Data-Types" class="headerlink" title="Mutable Data Types"></a>Mutable Data Types</h3><p>可变数据类型是指可以在创建后修改其内容的数据类型。修改可变对象时，不会创建新的对象，而是直接修改原对象。</p><ol><li><p><strong>列表（<code>list</code>）</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">lst = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>lst.append(<span class="hljs-number">4</span>)  <span class="hljs-comment"># 直接修改原列表</span><br></code></pre></td></tr></table></figure></li><li><p><strong>字典（<code>dict</code>）</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">d = &#123;<span class="hljs-string">&quot;a&quot;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&quot;b&quot;</span>: <span class="hljs-number">2</span>&#125;<br>d[<span class="hljs-string">&quot;c&quot;</span>] = <span class="hljs-number">3</span>  <span class="hljs-comment"># 直接修改原字典</span><br></code></pre></td></tr></table></figure></li><li><p><strong>集合（<code>set</code>）</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">s = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br>s.add(<span class="hljs-number">4</span>)  <span class="hljs-comment"># 直接修改原集合</span><br></code></pre></td></tr></table></figure></li><li><p><strong>字节数组（<code>bytearray</code>）</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">ba = <span class="hljs-built_in">bytearray</span>(<span class="hljs-string">b&quot;hello&quot;</span>)<br>ba[<span class="hljs-number">0</span>] = <span class="hljs-number">72</span>  <span class="hljs-comment"># 直接修改原字节数组</span><br></code></pre></td></tr></table></figure></li><li><p><strong>自定义类的对象</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, value</span>):<br>        <span class="hljs-variable language_">self</span>.value = value<br><br>obj = MyClass(<span class="hljs-number">10</span>)<br>obj.value = <span class="hljs-number">20</span>  <span class="hljs-comment"># 直接修改对象的属性</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="String-in-Python"><a href="#String-in-Python" class="headerlink" title="String in Python"></a>String in Python</h2><p>在 C&#x2F;C++ 中，字符串的实现的核心是<code>char*</code>（依靠指针操作内存）来实现的。但是在Python中，字符串在<strong>使用</strong>上相对来说更加灵活，方法也更丰富。</p><ol><li><strong>大小写转换</strong></li></ol><ul><li><p><code>str.capitalize()</code>：将字符串的第一个字符大写，其余字符小写。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">name = <span class="hljs-string">&quot;hello world&quot;</span><br><span class="hljs-built_in">print</span>(name.capitalize())  <span class="hljs-comment"># 输出: Hello world</span><br></code></pre></td></tr></table></figure></li><li><p><code>str.casefold()</code>：将字符串转换为小写，支持更多语言（如德语）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">name = <span class="hljs-string">&quot;HELLO WORLD&quot;</span><br><span class="hljs-built_in">print</span>(name.casefold())  <span class="hljs-comment"># 输出: hello world</span><br></code></pre></td></tr></table></figure></li><li><p><code>str.lower()</code>：将字符串转换为小写。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">name = <span class="hljs-string">&quot;HELLO WORLD&quot;</span><br><span class="hljs-built_in">print</span>(name.lower())  <span class="hljs-comment"># 输出: hello world</span><br></code></pre></td></tr></table></figure></li><li><p><code>str.upper()</code>：将字符串转换为大写。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">name = <span class="hljs-string">&quot;hello world&quot;</span><br><span class="hljs-built_in">print</span>(name.upper())  <span class="hljs-comment"># 输出: HELLO WORLD</span><br></code></pre></td></tr></table></figure></li><li><p><code>str.swapcase()</code>：将字符串中的大小写互换。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">name = <span class="hljs-string">&quot;Hello World&quot;</span><br><span class="hljs-built_in">print</span>(name.swapcase())  <span class="hljs-comment"># 输出: hELLO wORLD</span><br></code></pre></td></tr></table></figure></li><li><p><code>str.title()</code>：将字符串中每个单词的首字母大写。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">name = <span class="hljs-string">&quot;hello world&quot;</span><br><span class="hljs-built_in">print</span>(name.title())  <span class="hljs-comment"># 输出: Hello World</span><br></code></pre></td></tr></table></figure></li></ul><ol start="2"><li><strong>对齐与填充</strong></li></ol><ul><li><p><code>str.center(width[, fillchar])</code>：将字符串居中，并用指定字符填充至指定宽度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">name = <span class="hljs-string">&quot;hello&quot;</span><br><span class="hljs-built_in">print</span>(name.center(<span class="hljs-number">10</span>, <span class="hljs-string">&quot;-&quot;</span>))  <span class="hljs-comment"># 输出: --hello---</span><br></code></pre></td></tr></table></figure></li><li><p><code>str.ljust(width[, fillchar])</code>：将字符串左对齐，并用指定字符填充至指定宽度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">name = <span class="hljs-string">&quot;hello&quot;</span><br><span class="hljs-built_in">print</span>(name.ljust(<span class="hljs-number">10</span>, <span class="hljs-string">&quot;-&quot;</span>))  <span class="hljs-comment"># 输出: hello-----</span><br></code></pre></td></tr></table></figure></li><li><p><code>str.rjust(width[, fillchar])</code>：将字符串右对齐，并用指定字符填充至指定宽度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">name = <span class="hljs-string">&quot;hello&quot;</span><br><span class="hljs-built_in">print</span>(name.rjust(<span class="hljs-number">10</span>, <span class="hljs-string">&quot;-&quot;</span>))  <span class="hljs-comment"># 输出: -----hello</span><br></code></pre></td></tr></table></figure></li><li><p><code>str.zfill(width)</code>：用 <code>0</code> 填充字符串至指定宽度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">num = <span class="hljs-string">&quot;42&quot;</span><br><span class="hljs-built_in">print</span>(num.zfill(<span class="hljs-number">5</span>))  <span class="hljs-comment"># 输出: 00042</span><br></code></pre></td></tr></table></figure></li></ul><ol start="3"><li><strong>查找与替换</strong></li></ol><ul><li><p><code>str.find(sub[, start[, end]])</code>：查找子字符串，返回第一次出现的索引，未找到返回 <code>-1</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">name = <span class="hljs-string">&quot;hello world&quot;</span><br><span class="hljs-built_in">print</span>(name.find(<span class="hljs-string">&quot;world&quot;</span>))  <span class="hljs-comment"># 输出: 6</span><br></code></pre></td></tr></table></figure></li><li><p><code>str.rfind(sub[, start[, end]])</code>：从右向左查找子字符串，返回第一次出现的索引，未找到返回 <code>-1</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">name = <span class="hljs-string">&quot;hello world&quot;</span><br><span class="hljs-built_in">print</span>(name.rfind(<span class="hljs-string">&quot;o&quot;</span>))  <span class="hljs-comment"># 输出: 7</span><br></code></pre></td></tr></table></figure></li><li><p><code>str.index(sub[, start[, end]])</code>：查找子字符串，返回第一次出现的索引，未找到抛出 <code>ValueError</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">name = <span class="hljs-string">&quot;hello world&quot;</span><br><span class="hljs-built_in">print</span>(name.index(<span class="hljs-string">&quot;world&quot;</span>))  <span class="hljs-comment"># 输出: 6</span><br></code></pre></td></tr></table></figure></li><li><p><code>str.rindex(sub[, start[, end]])</code>：从右向左查找子字符串，返回第一次出现的索引，未找到抛出 <code>ValueError</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">name = <span class="hljs-string">&quot;hello world&quot;</span><br><span class="hljs-built_in">print</span>(name.rindex(<span class="hljs-string">&quot;o&quot;</span>))  <span class="hljs-comment"># 输出: 7</span><br></code></pre></td></tr></table></figure></li><li><p><code>str.replace(old, new[, count])</code>：替换字符串中的子字符串。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">name = <span class="hljs-string">&quot;hello world&quot;</span><br><span class="hljs-built_in">print</span>(name.replace(<span class="hljs-string">&quot;world&quot;</span>, <span class="hljs-string">&quot;python&quot;</span>))  <span class="hljs-comment"># 输出: hello python</span><br></code></pre></td></tr></table></figure></li></ul><ol start="4"><li><strong>分割与连接</strong></li></ol><ul><li><p><code>str.split(sep=None, maxsplit=-1)</code>：根据分隔符分割字符串，返回列表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">name = <span class="hljs-string">&quot;hello,world,python&quot;</span><br><span class="hljs-built_in">print</span>(name.split(<span class="hljs-string">&quot;,&quot;</span>))  <span class="hljs-comment"># 输出: [&#x27;hello&#x27;, &#x27;world&#x27;, &#x27;python&#x27;]</span><br></code></pre></td></tr></table></figure></li><li><p><code>str.rsplit(sep=None, maxsplit=-1)</code>：从右向左分割字符串，返回列表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">name = <span class="hljs-string">&quot;hello,world,python&quot;</span><br><span class="hljs-built_in">print</span>(name.rsplit(<span class="hljs-string">&quot;,&quot;</span>, <span class="hljs-number">1</span>))  <span class="hljs-comment"># 输出: [&#x27;hello,world&#x27;, &#x27;python&#x27;]</span><br></code></pre></td></tr></table></figure></li><li><p><code>str.splitlines([keepends])</code>：按行分割字符串，返回列表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">text = <span class="hljs-string">&quot;hello\nworld\npython&quot;</span><br><span class="hljs-built_in">print</span>(text.splitlines())  <span class="hljs-comment"># 输出: [&#x27;hello&#x27;, &#x27;world&#x27;, &#x27;python&#x27;]</span><br></code></pre></td></tr></table></figure></li><li><p><code>str.join(iterable)</code>：将可迭代对象中的元素用字符串连接。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">words = [<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>, <span class="hljs-string">&quot;python&quot;</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;-&quot;</span>.join(words))  <span class="hljs-comment"># 输出: hello-world-python</span><br></code></pre></td></tr></table></figure></li></ul><ol start="5"><li><strong>去除空白字符</strong></li></ol><ul><li><p><code>str.strip([chars])</code>：去除字符串两端的空白字符或指定字符。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">name = <span class="hljs-string">&quot;  hello world  &quot;</span><br><span class="hljs-built_in">print</span>(name.strip())  <span class="hljs-comment"># 输出: hello world</span><br></code></pre></td></tr></table></figure></li><li><p><code>str.lstrip([chars])</code>：去除字符串左端的空白字符或指定字符。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">name = <span class="hljs-string">&quot;  hello world  &quot;</span><br><span class="hljs-built_in">print</span>(name.lstrip())  <span class="hljs-comment"># 输出: hello world  </span><br></code></pre></td></tr></table></figure></li><li><p><code>str.rstrip([chars])</code>：去除字符串右端的空白字符或指定字符。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">name = <span class="hljs-string">&quot;  hello world  &quot;</span><br><span class="hljs-built_in">print</span>(name.rstrip())  <span class="hljs-comment"># 输出:   hello world</span><br></code></pre></td></tr></table></figure></li></ul><ol start="6"><li><strong>判断与验证</strong></li></ol><ul><li><p><code>str.startswith(prefix[, start[, end]])</code>：判断字符串是否以指定前缀开头。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">name = <span class="hljs-string">&quot;hello world&quot;</span><br><span class="hljs-built_in">print</span>(name.startswith(<span class="hljs-string">&quot;hello&quot;</span>))  <span class="hljs-comment"># 输出: True</span><br></code></pre></td></tr></table></figure></li><li><p><code>str.endswith(suffix[, start[, end]])</code>：判断字符串是否以指定后缀结尾。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">name = <span class="hljs-string">&quot;hello world&quot;</span><br><span class="hljs-built_in">print</span>(name.endswith(<span class="hljs-string">&quot;world&quot;</span>))  <span class="hljs-comment"># 输出: True</span><br></code></pre></td></tr></table></figure></li><li><p><code>str.isalnum()</code>：判断字符串是否只包含字母和数字。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">name = <span class="hljs-string">&quot;hello123&quot;</span><br><span class="hljs-built_in">print</span>(name.isalnum())  <span class="hljs-comment"># 输出: True</span><br></code></pre></td></tr></table></figure></li><li><p><code>str.isalpha()</code>：判断字符串是否只包含字母。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">name = <span class="hljs-string">&quot;hello&quot;</span><br><span class="hljs-built_in">print</span>(name.isalpha())  <span class="hljs-comment"># 输出: True</span><br></code></pre></td></tr></table></figure></li><li><p><code>str.isdigit()</code>：判断字符串是否只包含数字。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">num = <span class="hljs-string">&quot;123&quot;</span><br><span class="hljs-built_in">print</span>(num.isdigit())  <span class="hljs-comment"># 输出: True</span><br></code></pre></td></tr></table></figure></li><li><p><code>str.islower()</code>：判断字符串是否全部为小写。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">name = <span class="hljs-string">&quot;hello&quot;</span><br><span class="hljs-built_in">print</span>(name.islower())  <span class="hljs-comment"># 输出: True</span><br></code></pre></td></tr></table></figure></li><li><p><code>str.isupper()</code>：判断字符串是否全部为大写。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">name = <span class="hljs-string">&quot;HELLO&quot;</span><br><span class="hljs-built_in">print</span>(name.isupper())  <span class="hljs-comment"># 输出: True</span><br></code></pre></td></tr></table></figure></li><li><p><code>str.isspace()</code>：判断字符串是否只包含空白字符。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">name = <span class="hljs-string">&quot;   &quot;</span><br><span class="hljs-built_in">print</span>(name.isspace())  <span class="hljs-comment"># 输出: True</span><br></code></pre></td></tr></table></figure></li></ul><ol start="7"><li><strong>格式化</strong></li></ol><ul><li><p><code>str.format(*args, kwargs)</code>**：格式化字符串。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">name = <span class="hljs-string">&quot;world&quot;</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;hello &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(name))  <span class="hljs-comment"># 输出: hello world</span><br></code></pre></td></tr></table></figure></li><li><p><code>f-string</code>：Python 3.6 引入的<strong>格式化方法</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">name = <span class="hljs-string">&quot;world&quot;</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;hello <span class="hljs-subst">&#123;name&#125;</span>&quot;</span>)  <span class="hljs-comment"># 输出: hello world</span><br></code></pre></td></tr></table></figure></li></ul><ol start="8"><li><strong>其他方法</strong></li></ol><ul><li><p><code>str.count(sub[, start[, end]])</code>：统计子字符串出现的次数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">name = <span class="hljs-string">&quot;hello world&quot;</span><br><span class="hljs-built_in">print</span>(name.count(<span class="hljs-string">&quot;o&quot;</span>))  <span class="hljs-comment"># 输出: 2</span><br></code></pre></td></tr></table></figure></li><li><p><code>str.encode(encoding=&quot;utf-8&quot;, errors=&quot;strict&quot;)</code>：将字符串编码为字节。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">name = <span class="hljs-string">&quot;hello&quot;</span><br><span class="hljs-built_in">print</span>(name.encode())  <span class="hljs-comment"># 输出: b&#x27;hello&#x27;</span><br></code></pre></td></tr></table></figure></li><li><p><code>str.maketrans(x[, y[, z]])</code>：创建字符映射表，用于 <code>translate()</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">trans = <span class="hljs-built_in">str</span>.maketrans(<span class="hljs-string">&quot;aeiou&quot;</span>, <span class="hljs-string">&quot;12345&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;hello&quot;</span>.translate(trans))  <span class="hljs-comment"># 输出: h2ll4</span><br></code></pre></td></tr></table></figure></li><li><p><code>str.translate(table)</code>：根据映射表替换字符。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">trans = <span class="hljs-built_in">str</span>.maketrans(<span class="hljs-string">&quot;aeiou&quot;</span>, <span class="hljs-string">&quot;12345&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;hello&quot;</span>.translate(trans))  <span class="hljs-comment"># 输出: h2ll4</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="Basic-Data-Structures-in-Python"><a href="#Basic-Data-Structures-in-Python" class="headerlink" title="Basic Data Structures in Python"></a>Basic Data Structures in Python</h2><h3 id="List-in-Python"><a href="#List-in-Python" class="headerlink" title="List in Python"></a>List in Python</h3><p>在Python中，列表是动态的，可以随着列表的运行增删元素。</p><p>以下是 Python 列表（<code>list</code>）的常用操作整理，涵盖了列表的创建、访问、修改、排序、遍历、切片、列表推导式等操作。</p><blockquote><p>Python列表的底层实现本质上就是一个<strong>C语言的动态数组</strong>。</p></blockquote><ol><li><strong>列表的创建</strong></li></ol><ul><li>使用方括号 <code>[]</code> 创建列表。</li><li>使用 <code>list()</code> 函数将其他可迭代对象转换为列表。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 创建空列表</span><br>empty_list = []<br><br><span class="hljs-comment"># 创建包含元素的列表</span><br>fruits = [<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-string">&quot;cherry&quot;</span>]<br><br><span class="hljs-comment"># 使用 list() 函数创建列表</span><br>numbers = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>))  <span class="hljs-comment"># 输出: [0, 1, 2, 3, 4]</span><br></code></pre></td></tr></table></figure><ol start="2"><li><strong>访问列表元素</strong></li></ol><ul><li>使用索引访问列表元素（索引从 <code>0</code> 开始）。</li><li>使用负数索引从列表末尾访问元素。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">fruits = [<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-string">&quot;cherry&quot;</span>]<br><span class="hljs-built_in">print</span>(fruits[<span class="hljs-number">0</span>])   <span class="hljs-comment"># 输出: apple</span><br><span class="hljs-built_in">print</span>(fruits[-<span class="hljs-number">1</span>])  <span class="hljs-comment"># 输出: cherry</span><br></code></pre></td></tr></table></figure><ol start="3"><li><strong>修改列表元素</strong></li></ol><ul><li>通过索引直接修改列表元素。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">fruits = [<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-string">&quot;cherry&quot;</span>]<br>fruits[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;blueberry&quot;</span><br><span class="hljs-built_in">print</span>(fruits)  <span class="hljs-comment"># 输出: [&#x27;apple&#x27;, &#x27;blueberry&#x27;, &#x27;cherry&#x27;]</span><br></code></pre></td></tr></table></figure><ol start="4"><li><strong>列表的常用方法</strong></li></ol><p><strong>添加元素</strong></p><ul><li><p><code>append()</code>：在列表末尾添加一个元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">fruits = [<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;banana&quot;</span>]<br>fruits.append(<span class="hljs-string">&quot;cherry&quot;</span>)<br><span class="hljs-built_in">print</span>(fruits)  <span class="hljs-comment"># 输出: [&#x27;apple&#x27;, &#x27;banana&#x27;, &#x27;cherry&#x27;]</span><br></code></pre></td></tr></table></figure></li><li><p><code>extend()</code>：将另一个可迭代对象的元素添加到列表末尾。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">fruits = [<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;banana&quot;</span>]<br>fruits.extend([<span class="hljs-string">&quot;cherry&quot;</span>, <span class="hljs-string">&quot;orange&quot;</span>])<br><span class="hljs-built_in">print</span>(fruits)  <span class="hljs-comment"># 输出: [&#x27;apple&#x27;, &#x27;banana&#x27;, &#x27;cherry&#x27;, &#x27;orange&#x27;]</span><br></code></pre></td></tr></table></figure></li><li><p><code>insert()</code>：在指定位置插入一个元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">fruits = [<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;banana&quot;</span>]<br>fruits.insert(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;cherry&quot;</span>)<br><span class="hljs-built_in">print</span>(fruits)  <span class="hljs-comment"># 输出: [&#x27;apple&#x27;, &#x27;cherry&#x27;, &#x27;banana&#x27;]</span><br></code></pre></td></tr></table></figure></li></ul><p><strong>删除元素</strong></p><ul><li><p><code>remove()</code>：删除列表中第一个匹配的元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">fruits = [<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-string">&quot;cherry&quot;</span>]<br>fruits.remove(<span class="hljs-string">&quot;banana&quot;</span>)<br><span class="hljs-built_in">print</span>(fruits)  <span class="hljs-comment"># 输出: [&#x27;apple&#x27;, &#x27;cherry&#x27;]</span><br></code></pre></td></tr></table></figure></li><li><p><code>pop()</code>：删除并返回指定位置的元素（默认删除最后一个元素）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">fruits = [<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-string">&quot;cherry&quot;</span>]<br>fruits.pop(<span class="hljs-number">1</span>)  <span class="hljs-comment"># 删除索引为 1 的元素</span><br><span class="hljs-built_in">print</span>(fruits)  <span class="hljs-comment"># 输出: [&#x27;apple&#x27;, &#x27;cherry&#x27;]</span><br></code></pre></td></tr></table></figure></li><li><p><code>clear()</code>：清空列表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">fruits = [<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-string">&quot;cherry&quot;</span>]<br>fruits.clear()<br><span class="hljs-built_in">print</span>(fruits)  <span class="hljs-comment"># 输出: []</span><br></code></pre></td></tr></table></figure></li></ul><p><strong>查找元素</strong></p><ul><li><p><code>index()</code>：返回指定元素的索引（如果存在）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">fruits = [<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-string">&quot;cherry&quot;</span>]<br><span class="hljs-built_in">print</span>(fruits.index(<span class="hljs-string">&quot;banana&quot;</span>))  <span class="hljs-comment"># 输出: 1</span><br></code></pre></td></tr></table></figure></li><li><p><code>count()</code>：返回指定元素在列表中出现的次数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">fruits = [<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-string">&quot;cherry&quot;</span>, <span class="hljs-string">&quot;banana&quot;</span>]<br><span class="hljs-built_in">print</span>(fruits.count(<span class="hljs-string">&quot;banana&quot;</span>))  <span class="hljs-comment"># 输出: 2</span><br></code></pre></td></tr></table></figure></li></ul><p><strong>排序与反转</strong></p><ul><li><p><code>sort()</code>：对列表进行排序（默认升序）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">numbers = [<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">9</span>]<br>numbers.sort()<br><span class="hljs-built_in">print</span>(numbers)  <span class="hljs-comment"># 输出: [1, 1, 3, 4, 5, 9]</span><br></code></pre></td></tr></table></figure></li><li><p><code>reverse()</code>：反转列表中的元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">fruits = [<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-string">&quot;cherry&quot;</span>]<br>fruits.reverse()<br><span class="hljs-built_in">print</span>(fruits)  <span class="hljs-comment"># 输出: [&#x27;cherry&#x27;, &#x27;banana&#x27;, &#x27;apple&#x27;]</span><br></code></pre></td></tr></table></figure></li><li><p><code>sorted()</code>：对列表进行临时排序</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">fruits = [<span class="hljs-string">&quot;banana&quot;</span>,<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;cherry&quot;</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">sorted</span>(fruits))<br><span class="hljs-built_in">print</span>(fruits)<br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">[&#x27;apple&#x27;, &#x27;banana&#x27;, &#x27;cherry&#x27;]</span><br><span class="hljs-string">[&#x27;banana&#x27;, &#x27;apple&#x27;, &#x27;cherry&#x27;]</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><div class="note note-info">            <p><strong>Python 中的自定义比较函数</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">students = [<br>    &#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">25</span>&#125;,<br>    &#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">22</span>&#125;,<br>    &#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;Charlie&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">28</span>&#125;<br>]<br><br><span class="hljs-comment"># 按年龄升序排序</span><br>students.sort(key=<span class="hljs-keyword">lambda</span> x: x[<span class="hljs-string">&quot;age&quot;</span>])<br><span class="hljs-built_in">print</span>(students)<br><span class="hljs-comment"># 输出: [&#123;&#x27;name&#x27;: &#x27;Bob&#x27;, &#x27;age&#x27;: 22&#125;, &#123;&#x27;name&#x27;: &#x27;Alice&#x27;, &#x27;age&#x27;: 25&#125;, &#123;&#x27;name&#x27;: &#x27;Charlie&#x27;, &#x27;age&#x27;: 28&#125;]</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> cmp_to_key<br><br>students = [<br>    &#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">25</span>, <span class="hljs-string">&quot;grade&quot;</span>: <span class="hljs-number">88</span>&#125;,<br>    &#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">22</span>, <span class="hljs-string">&quot;grade&quot;</span>: <span class="hljs-number">92</span>&#125;,<br>    &#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;Charlie&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">22</span>, <span class="hljs-string">&quot;grade&quot;</span>: <span class="hljs-number">85</span>&#125;<br>]<br><br><span class="hljs-comment"># 自定义比较函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">compare</span>(<span class="hljs-params">a, b</span>):<br>    <span class="hljs-keyword">if</span> a[<span class="hljs-string">&quot;age&quot;</span>] != b[<span class="hljs-string">&quot;age&quot;</span>]:<br>        <span class="hljs-keyword">return</span> a[<span class="hljs-string">&quot;age&quot;</span>] - b[<span class="hljs-string">&quot;age&quot;</span>]  <span class="hljs-comment"># 按年龄升序</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> b[<span class="hljs-string">&quot;grade&quot;</span>] - a[<span class="hljs-string">&quot;grade&quot;</span>]  <span class="hljs-comment"># 按成绩降序</span><br><br><span class="hljs-comment"># 使用 cmp_to_key 将比较函数转换为 key 函数</span><br>students.sort(key=cmp_to_key(compare))<br><span class="hljs-built_in">print</span>(students)<br><span class="hljs-comment"># 输出: [&#123;&#x27;name&#x27;: &#x27;Charlie&#x27;, &#x27;age&#x27;: 22, &#x27;grade&#x27;: 85&#125;, &#123;&#x27;name&#x27;: &#x27;Bob&#x27;, &#x27;age&#x27;: 22, &#x27;grade&#x27;: 92&#125;, &#123;&#x27;name&#x27;: &#x27;Alice&#x27;, &#x27;age&#x27;: 25, &#x27;grade&#x27;: 88&#125;]</span><br></code></pre></td></tr></table></figure>          </div><ol start="5"><li><strong>列表的遍历</strong></li></ol><ul><li>使用 <code>for</code> 循环遍历列表。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">fruits = [<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-string">&quot;cherry&quot;</span>]<br><span class="hljs-keyword">for</span> fruit <span class="hljs-keyword">in</span> fruits:<br>    <span class="hljs-built_in">print</span>(fruit)<br></code></pre></td></tr></table></figure><ol start="6"><li><strong>列表的切片</strong></li></ol><ul><li>使用切片操作获取列表的子集。</li><li>语法：<code>list[start:stop:step]</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">numbers = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>]<br><span class="hljs-built_in">print</span>(numbers[<span class="hljs-number">2</span>:<span class="hljs-number">5</span>])    <span class="hljs-comment"># 输出: [2, 3, 4]</span><br><span class="hljs-built_in">print</span>(numbers[::<span class="hljs-number">2</span>])    <span class="hljs-comment"># 输出: [0, 2, 4, 6, 8]</span><br><span class="hljs-built_in">print</span>(numbers[::-<span class="hljs-number">1</span>])   <span class="hljs-comment"># 输出: [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]</span><br></code></pre></td></tr></table></figure><ol start="7"><li><strong>列表的复制</strong></li></ol><ul><li>使用切片或 <code>copy()</code> 方法复制列表。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">fruits = [<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-string">&quot;cherry&quot;</span>]<br>fruits_copy = fruits[:]  <span class="hljs-comment"># 使用切片复制</span><br>fruits_copy2 = fruits.copy()  <span class="hljs-comment"># 使用 copy() 方法复制</span><br></code></pre></td></tr></table></figure><ol start="8"><li><strong>列表推导式</strong></li></ol><ul><li>使用列表推导式快速生成列表。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 生成平方数列表</span><br>squares = [x**<span class="hljs-number">2</span> <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>)]<br><span class="hljs-built_in">print</span>(squares)  <span class="hljs-comment"># 输出: [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]</span><br><br><span class="hljs-comment"># 生成偶数列表</span><br>evens = [x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">if</span> x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>]<br><span class="hljs-built_in">print</span>(evens)  <span class="hljs-comment"># 输出: [0, 2, 4, 6, 8]</span><br></code></pre></td></tr></table></figure><ol start="9"><li><strong>列表的嵌套</strong></li></ol><ul><li>列表可以包含其他列表，形成嵌套列表。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">matrix = [<br>    [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>],<br>    [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>],<br>    [<span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>]<br>]<br><span class="hljs-built_in">print</span>(matrix[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>])  <span class="hljs-comment"># 输出: 6</span><br></code></pre></td></tr></table></figure><ol start="10"><li><strong>列表的其他操作</strong></li></ol><ul><li><p><code>len()</code>：获取列表的长度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">fruits = [<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-string">&quot;cherry&quot;</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>(fruits))  <span class="hljs-comment"># 输出: 3</span><br></code></pre></td></tr></table></figure></li><li><p><code>in</code> 和 <code>not in</code>：检查元素是否在列表中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">fruits = [<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-string">&quot;cherry&quot;</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;banana&quot;</span> <span class="hljs-keyword">in</span> fruits)  <span class="hljs-comment"># 输出: True</span><br></code></pre></td></tr></table></figure></li><li><p><code>+</code> 和 <code>*</code>：列表的拼接和重复。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">list1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>list2 = [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]<br><span class="hljs-built_in">print</span>(list1 + list2)  <span class="hljs-comment"># 输出: [1, 2, 3, 4, 5, 6]</span><br><span class="hljs-built_in">print</span>(list1 * <span class="hljs-number">2</span>)      <span class="hljs-comment"># 输出: [1, 2, 3, 1, 2, 3]</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="Tuple-in-Python"><a href="#Tuple-in-Python" class="headerlink" title="Tuple in Python"></a>Tuple in Python</h3><p>在 Python 中，<strong>元组（Tuple）</strong> 是一种不可变的序列类型，用于存储一组有序的元素。元组与列表（<code>list</code>）类似，但元组一旦创建，其内容不可修改。</p><ul><li><strong>不可变性</strong>：元组一旦创建，其元素不能被修改、添加或删除。</li><li><strong>有序性</strong>：元组中的元素是有序的，可以通过索引访问。</li><li><strong>异构性</strong>：元组可以存储不同类型的元素（如整数、字符串、列表等）。</li><li><strong>支持嵌套</strong>：元组可以嵌套其他元组或列表。</li></ul><p>元组使用圆括号 <code>()</code> 定义，元素之间用逗号 <code>,</code> 分隔。</p><p><strong>元组的创建</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 创建一个元组</span><br>my_tuple = (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br><span class="hljs-built_in">print</span>(my_tuple)  <span class="hljs-comment"># 输出: (1, 2, 3)</span><br><br><span class="hljs-comment"># 创建包含不同类型元素的元组</span><br>mixed_tuple = (<span class="hljs-number">1</span>, <span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-number">3.14</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])<br><span class="hljs-built_in">print</span>(mixed_tuple)  <span class="hljs-comment"># 输出: (1, &#x27;hello&#x27;, 3.14, [1, 2, 3])</span><br><br><span class="hljs-comment"># 创建空元组</span><br>empty_tuple = ()<br><span class="hljs-built_in">print</span>(empty_tuple)  <span class="hljs-comment"># 输出: ()</span><br></code></pre></td></tr></table></figure><ul><li>如果元组只有一个元素，需要在元素后面加一个逗号 <code>,</code>，否则会被认为是普通括号。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">single_element_tuple = (<span class="hljs-number">42</span>,)  <span class="hljs-comment"># 这是一个元组</span><br>not_a_tuple = (<span class="hljs-number">42</span>)            <span class="hljs-comment"># 这是一个整数</span><br></code></pre></td></tr></table></figure><strong>元组的遍历</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">my_tuple = (<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>)<br><br><span class="hljs-comment"># 访问第一个元素</span><br><span class="hljs-built_in">print</span>(my_tuple[<span class="hljs-number">0</span>])  <span class="hljs-comment"># 输出: 10</span><br><br><span class="hljs-comment"># 访问最后一个元素</span><br><span class="hljs-built_in">print</span>(my_tuple[-<span class="hljs-number">1</span>])  <span class="hljs-comment"># 输出: 50</span><br><br><span class="hljs-comment"># 访问切片</span><br><span class="hljs-built_in">print</span>(my_tuple[<span class="hljs-number">1</span>:<span class="hljs-number">4</span>])  <span class="hljs-comment"># 输出: (20, 30, 40)</span><br></code></pre></td></tr></table></figure><p>元组是不可变的，因此不能修改、添加或删除元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python">my_tuple = (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br><br><span class="hljs-comment"># 尝试修改元素</span><br>my_tuple[<span class="hljs-number">0</span>] = <span class="hljs-number">10</span>  <span class="hljs-comment"># 会抛出 TypeError: &#x27;tuple&#x27; object does not support item assignment</span><br><br><span class="hljs-comment"># 尝试添加元素</span><br>my_tuple.append(<span class="hljs-number">4</span>)  <span class="hljs-comment"># 会抛出 AttributeError: &#x27;tuple&#x27; object has no attribute &#x27;append&#x27;</span><br><br><span class="hljs-comment"># 尝试删除元素</span><br><span class="hljs-keyword">del</span> my_tuple[<span class="hljs-number">0</span>]  <span class="hljs-comment"># 会抛出 TypeError: &#x27;tuple&#x27; object doesn&#x27;t support item deletion</span><br><br><span class="hljs-comment"># 但是可以给表示元组的变量赋值</span><br>my_tuple=(<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>) <span class="hljs-comment">#VALID</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">tuple1 = (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br>tuple2 = (<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>)<br>combined_tuple = tuple1 + tuple2<br><span class="hljs-built_in">print</span>(combined_tuple)  <span class="hljs-comment"># 输出: (1, 2, 3, 4, 5, 6)</span><br></code></pre></td></tr></table></figure><p><strong>元组的基本操作</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 元组的基本操作</span><br><span class="hljs-comment"># 元组的拼接</span><br>tuple1 = (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br>tuple2 = (<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>)<br>combined_tuple = tuple1 + tuple2<br><span class="hljs-built_in">print</span>(combined_tuple)  <span class="hljs-comment"># 输出: (1, 2, 3, 4, 5, 6)</span><br><br><span class="hljs-comment"># 元组的重复</span><br>my_tuple = (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br>repeated_tuple = my_tuple * <span class="hljs-number">3</span><br><span class="hljs-built_in">print</span>(repeated_tuple)  <span class="hljs-comment"># 输出: (1, 2, 3, 1, 2, 3, 1, 2, 3)、</span><br><br><span class="hljs-comment"># 元组的长度</span><br>my_tuple = (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>(my_tuple))  <span class="hljs-comment"># 输出: 5</span><br><br><span class="hljs-comment"># 元组的遍历</span><br>my_tuple = (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)<br><span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> my_tuple:<br>    <span class="hljs-built_in">print</span>(item)<br>    <br><span class="hljs-comment"># 元组的解包</span><br>my_tuple = (<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>)<br>a, b, c = my_tuple<br><span class="hljs-built_in">print</span>(a, b, c)  <span class="hljs-comment"># 输出: 10 20 30</span><br><br><span class="hljs-comment"># 元组嵌套其他元组或列表</span><br>nested_tuple = ((<span class="hljs-number">1</span>, <span class="hljs-number">2</span>), (<span class="hljs-number">3</span>, <span class="hljs-number">4</span>), [<span class="hljs-number">5</span>, <span class="hljs-number">6</span>])<br><span class="hljs-built_in">print</span>(nested_tuple)  <span class="hljs-comment"># 输出: ((1, 2), (3, 4), [5, 6])</span><br></code></pre></td></tr></table></figure><p><strong>元组与列表的区别</strong></p><table><thead><tr><th>特性</th><th>元组 (<code>tuple</code>)</th><th>列表 (<code>list</code>)</th></tr></thead><tbody><tr><td><strong>可变性</strong></td><td>不可变</td><td>可变</td></tr><tr><td><strong>语法</strong></td><td>使用圆括号 <code>()</code></td><td>使用方括号 <code>[]</code></td></tr><tr><td><strong>性能</strong></td><td>访问速度更快，占用内存更少</td><td>访问速度较慢，占用内存较多</td></tr><tr><td><strong>适用场景</strong></td><td>存储不可变数据（如常量、配置等）</td><td>存储可变数据（如动态集合等）</td></tr></tbody></table><h3 id="Dictionaries-in-Python"><a href="#Dictionaries-in-Python" class="headerlink" title="Dictionaries in Python"></a>Dictionaries in Python</h3><p>在Python中，<strong>字典</strong>是一种基于键值对的数据结构，底层原理是<strong>哈希表（Hash Table）</strong>。字典中的键必须是唯一的，而值可以是任意类型的数据。字典是无序的（在 Python 3.7 及以上版本中，字典保持了插入顺序），并且通过键来快速查找对应的值。以下是字典的详细介绍：</p><p><strong>字典的创建</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 创建一个字典</span><br>my_dict = &#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">25</span>, <span class="hljs-string">&quot;city&quot;</span>: <span class="hljs-string">&quot;New York&quot;</span>&#125;<br><span class="hljs-comment"># 注意：需要使用花括号！</span><br><span class="hljs-built_in">print</span>(my_dict)  <span class="hljs-comment"># 输出: &#123;&#x27;name&#x27;: &#x27;Alice&#x27;, &#x27;age&#x27;: 25, &#x27;city&#x27;: &#x27;New York&#x27;&#125;</span><br><br><span class="hljs-comment"># 创建空字典</span><br>empty_dict = &#123;&#125;<br><span class="hljs-built_in">print</span>(empty_dict)  <span class="hljs-comment"># 输出: &#123;&#125;</span><br><br><span class="hljs-comment"># 使用 dict() 函数创建字典</span><br>my_dict = <span class="hljs-built_in">dict</span>(name=<span class="hljs-string">&quot;Alice&quot;</span>, age=<span class="hljs-number">25</span>, city=<span class="hljs-string">&quot;New York&quot;</span>)<br><span class="hljs-built_in">print</span>(my_dict)  <span class="hljs-comment"># 输出: &#123;&#x27;name&#x27;: &#x27;Alice&#x27;, &#x27;age&#x27;: 25, &#x27;city&#x27;: &#x27;New York&#x27;&#125;</span><br></code></pre></td></tr></table></figure><p><strong>通过键来访问字典的值</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">my_dict = &#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">25</span>, <span class="hljs-string">&quot;city&quot;</span>: <span class="hljs-string">&quot;New York&quot;</span>&#125;<br><br><span class="hljs-comment"># 访问键对应的值</span><br><span class="hljs-built_in">print</span>(my_dict[<span class="hljs-string">&quot;name&quot;</span>])  <span class="hljs-comment"># 输出: Alice</span><br><br><span class="hljs-comment"># 访问不存在的键会抛出 KeyError</span><br><span class="hljs-comment"># print(my_dict[&quot;gender&quot;])  # KeyError: &#x27;gender&#x27;</span><br><br><span class="hljs-comment"># 使用get访问，一种更安全的方法</span><br><span class="hljs-built_in">print</span>(my_dict.get(<span class="hljs-string">&quot;name&quot;</span>))      <span class="hljs-comment"># 输出: Alice</span><br><span class="hljs-built_in">print</span>(my_dict.get(<span class="hljs-string">&quot;gender&quot;</span>))    <span class="hljs-comment"># 输出: None</span><br><span class="hljs-built_in">print</span>(my_dict.get(<span class="hljs-string">&quot;gender&quot;</span>, <span class="hljs-string">&quot;unknown&quot;</span>))  <span class="hljs-comment"># 输出: unknown</span><br></code></pre></td></tr></table></figure><p><strong>修改，插入，删除</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python">my_dict = &#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">25</span>, <span class="hljs-string">&quot;city&quot;</span>: <span class="hljs-string">&quot;New York&quot;</span>&#125;<br><br><span class="hljs-comment"># 修改值</span><br>my_dict[<span class="hljs-string">&quot;age&quot;</span>] = <span class="hljs-number">26</span><br><span class="hljs-built_in">print</span>(my_dict)  <span class="hljs-comment"># 输出: &#123;&#x27;name&#x27;: &#x27;Alice&#x27;, &#x27;age&#x27;: 26, &#x27;city&#x27;: &#x27;New York&#x27;&#125;</span><br><br><span class="hljs-comment"># 添加新的键值对</span><br>my_dict[<span class="hljs-string">&quot;gender&quot;</span>] = <span class="hljs-string">&quot;female&quot;</span><br><span class="hljs-built_in">print</span>(my_dict)  <span class="hljs-comment"># 输出: &#123;&#x27;name&#x27;: &#x27;Alice&#x27;, &#x27;age&#x27;: 26, &#x27;city&#x27;: &#x27;New York&#x27;, &#x27;gender&#x27;: &#x27;female&#x27;&#125;</span><br><br><span class="hljs-comment"># 使用 del 删除键值对</span><br><span class="hljs-keyword">del</span> my_dict[<span class="hljs-string">&quot;city&quot;</span>]<br><span class="hljs-built_in">print</span>(my_dict)  <span class="hljs-comment"># 输出: &#123;&#x27;name&#x27;: &#x27;Alice&#x27;, &#x27;age&#x27;: 25&#125;</span><br><br><span class="hljs-comment"># 使用 pop() 删除键值对并返回值</span><br>age = my_dict.pop(<span class="hljs-string">&quot;age&quot;</span>)<br><span class="hljs-built_in">print</span>(age)      <span class="hljs-comment"># 输出: 25</span><br><span class="hljs-built_in">print</span>(my_dict)  <span class="hljs-comment"># 输出: &#123;&#x27;name&#x27;: &#x27;Alice&#x27;&#125;</span><br><br><span class="hljs-comment"># 清空字典</span><br>my_dict.clear()<br><span class="hljs-built_in">print</span>(my_dict)  <span class="hljs-comment"># 输出: &#123;&#125;</span><br></code></pre></td></tr></table></figure><p><strong>其他操作</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python">my_dict = &#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">25</span>, <span class="hljs-string">&quot;city&quot;</span>: <span class="hljs-string">&quot;New York&quot;</span>&#125;<br><br><span class="hljs-comment"># 遍历键</span><br><span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> my_dict:<br>    <span class="hljs-built_in">print</span>(key)<br><br><span class="hljs-comment"># 遍历值</span><br><span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> my_dict.values():<br>    <span class="hljs-built_in">print</span>(value)<br><br><span class="hljs-comment"># 遍历键值对</span><br><span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> my_dict.items():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;key&#125;</span>: <span class="hljs-subst">&#123;value&#125;</span>&quot;</span>)<br>    <br><span class="hljs-comment"># 使用in检查是否存在</span><br>my_dict = &#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">25</span>, <span class="hljs-string">&quot;city&quot;</span>: <span class="hljs-string">&quot;New York&quot;</span>&#125;<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-keyword">in</span> my_dict)  <span class="hljs-comment"># 输出: True</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;gender&quot;</span> <span class="hljs-keyword">in</span> my_dict)  <span class="hljs-comment"># 输出: False</span><br><br><br><span class="hljs-comment"># 获取所有键</span><br><span class="hljs-built_in">print</span>(my_dict.keys())  <span class="hljs-comment"># 输出: dict_keys([&#x27;name&#x27;, &#x27;age&#x27;, &#x27;city&#x27;])</span><br><br><span class="hljs-comment"># 获取所有值</span><br><span class="hljs-built_in">print</span>(my_dict.values())  <span class="hljs-comment"># 输出: dict_values([&#x27;Alice&#x27;, 25, &#x27;New York&#x27;])</span><br><br><span class="hljs-comment"># 获取所有键值对</span><br><span class="hljs-built_in">print</span>(my_dict.items())  <span class="hljs-comment"># 输出: dict_items([(&#x27;name&#x27;, &#x27;Alice&#x27;), (&#x27;age&#x27;, 25), (&#x27;city&#x27;, &#x27;New York&#x27;)])</span><br><br>dict1 = &#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">25</span>&#125;<br>dict2 = &#123;<span class="hljs-string">&quot;city&quot;</span>: <span class="hljs-string">&quot;New York&quot;</span>, <span class="hljs-string">&quot;gender&quot;</span>: <span class="hljs-string">&quot;female&quot;</span>,<span class="hljs-string">&quot;age&quot;</span>:<span class="hljs-number">15</span>&#125;<br>dict1.update(dict2)<br><span class="hljs-built_in">print</span>(dict1)  <span class="hljs-comment"># 输出: &#123;&#x27;name&#x27;: &#x27;Alice&#x27;, &#x27;age&#x27;: 15, &#x27;city&#x27;: &#x27;New York&#x27;, &#x27;gender&#x27;: &#x27;female&#x27;&#125;</span><br><span class="hljs-comment"># 合并冲突的键值对时会自动覆盖成新的</span><br></code></pre></td></tr></table></figure><hr><p><strong>字典推导式</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 创建一个字典，键为数字，值为数字的平方（使用花括号&#123;&#125;）</span><br>squares = &#123;x: x**<span class="hljs-number">2</span> <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>)&#125;<br><span class="hljs-built_in">print</span>(squares)  <span class="hljs-comment"># 输出: &#123;0: 0, 1: 1, 2: 4, 3: 9, 4: 16&#125;</span><br></code></pre></td></tr></table></figure><h2 id="Loops-in-Python"><a href="#Loops-in-Python" class="headerlink" title="Loops in Python"></a>Loops in Python</h2><h3 id="While-loops"><a href="#While-loops" class="headerlink" title="While-loops"></a>While-loops</h3><p>在Python中，<code>while</code>循环的基本用法和C&#x2F;C++基本相同，唯一需要注意的是<strong>Python中不加花括号并且要注意缩进</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">count = <span class="hljs-number">0</span><br><span class="hljs-keyword">while</span> count &lt; <span class="hljs-number">5</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Count is: <span class="hljs-subst">&#123;count&#125;</span>&quot;</span>)<br>    count += <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><code>while</code> 循环可以有一个可选的 <code>else</code> 子句。当循环正常结束（即条件变为 <code>False</code>）时，<code>else</code> 子句会被执行。如果循环是通过 <code>break</code> 退出的，<code>else</code> 子句不会执行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">count = <span class="hljs-number">0</span><br><span class="hljs-keyword">while</span> count &lt; <span class="hljs-number">5</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Count is: <span class="hljs-subst">&#123;count&#125;</span>&quot;</span>)<br>    count += <span class="hljs-number">1</span><br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Loop finished normally.&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="For-loops"><a href="#For-loops" class="headerlink" title="For-loops"></a>For-loops</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 遍历列表</span><br>fruits = [<span class="hljs-string">&#x27;apple&#x27;</span>, <span class="hljs-string">&#x27;banana&#x27;</span>, <span class="hljs-string">&#x27;cherry&#x27;</span>]<br><span class="hljs-keyword">for</span> fruit <span class="hljs-keyword">in</span> fruits:<br>    <span class="hljs-built_in">print</span>(fruit)<br><br><span class="hljs-comment"># 遍历字符串</span><br><span class="hljs-keyword">for</span> char <span class="hljs-keyword">in</span> <span class="hljs-string">&quot;hello&quot;</span>:<br>    <span class="hljs-built_in">print</span>(char)<br><br><span class="hljs-comment"># 遍历字典的键值对</span><br>my_dict = &#123;<span class="hljs-string">&#x27;a&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;b&#x27;</span>: <span class="hljs-number">2</span>&#125;<br><span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> my_dict.items():<br>    <span class="hljs-built_in">print</span>(key, value)<br></code></pre></td></tr></table></figure><p>range <strong>的使用</strong></p><p>在 Python 中，<code>range</code> 是一个内置函数，用于生成一个整数序列。它通常用于 <code>for</code> 循环中，也可以用于创建列表或其他需要整数序列的场景。<code>range</code> 函数有三种调用方式：</p><p>（1）<code>range(stop)</code></p><p>生成从 <code>0</code> 开始到 <code>stop-1</code> 的整数序列。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>    <span class="hljs-built_in">print</span>(i)<br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">0</span><br><span class="hljs-string">1</span><br><span class="hljs-string">2</span><br><span class="hljs-string">3</span><br><span class="hljs-string">4</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><p>（2）<code>range(start, stop)</code></p><p>生成从 <code>start</code> 开始到 <code>stop-1</code> 的整数序列。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, <span class="hljs-number">6</span>):<br>    <span class="hljs-built_in">print</span>(i)<br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">2</span><br><span class="hljs-string">3</span><br><span class="hljs-string">4</span><br><span class="hljs-string">5</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><p>（3）<code>range(start, stop, step)</code></p><p>生成从 <code>start</code> 开始到 <code>stop-1</code> 的整数序列，步长为 <code>step</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>, <span class="hljs-number">2</span>):<br>    <span class="hljs-built_in">print</span>(i)<br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">1</span><br><span class="hljs-string">3</span><br><span class="hljs-string">5</span><br><span class="hljs-string">7</span><br><span class="hljs-string">9</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><ul><li><strong>惰性求值</strong>：<code>range</code> 返回的是一个 <code>range</code> 对象，而不是一个列表。它只在需要时生成值，因此非常节省内存。</li><li><strong>不可变性</strong>：<code>range</code> 对象是不可变的，不能直接修改其内容。</li><li><strong>支持负步长</strong>：<code>step</code> 可以为负数，表示反向生成序列。</li></ul><p>可以通过 <code>list()</code> 函数将 <code>range</code> 对象转换为列表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">numbers = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>))<br><span class="hljs-built_in">print</span>(numbers)  <span class="hljs-comment"># 输出: [0, 1, 2, 3, 4]</span><br></code></pre></td></tr></table></figure><ol><li><p><strong>遍历字典</strong>：</p><ul><li>你可以使用 <code>for</code> 循环直接遍历字典的键、值，或者键值对。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">my_dict = &#123;<span class="hljs-string">&#x27;a&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;b&#x27;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;c&#x27;</span>: <span class="hljs-number">3</span>&#125;<br><span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> my_dict:<br>    <span class="hljs-built_in">print</span>(key, my_dict[key])<br><br><span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> my_dict.items():<br>    <span class="hljs-built_in">print</span>(key, value)<br></code></pre></td></tr></table></figure></li><li><p>**使用 <code>enumerate()</code>**：</p><ul><li><code>enumerate()</code> 函数可以在遍历列表时获取元素的索引。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">my_list = [<span class="hljs-string">&#x27;apple&#x27;</span>, <span class="hljs-string">&#x27;banana&#x27;</span>, <span class="hljs-string">&#x27;cherry&#x27;</span>]<br><span class="hljs-keyword">for</span> index, value <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(my_list):<br>    <span class="hljs-built_in">print</span>(index, value)<br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">0 apple</span><br><span class="hljs-string">1 banana</span><br><span class="hljs-string">2 cherry</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure></li><li><p>使用 <code>zip()</code>：</p><ul><li><code>zip()</code> 函数可以同时遍历多个序列。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">names = [<span class="hljs-string">&#x27;Alice&#x27;</span>, <span class="hljs-string">&#x27;Bob&#x27;</span>, <span class="hljs-string">&#x27;Charlie&#x27;</span>]<br>scores = [<span class="hljs-number">85</span>, <span class="hljs-number">90</span>, <span class="hljs-number">95</span>]<br><span class="hljs-keyword">for</span> name, score <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(names, scores):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;name&#125;</span> scored <span class="hljs-subst">&#123;score&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure></li><li><p><strong>列表推导式</strong>：</p><ul><li>列表推导式是一种简洁的方式来生成列表。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">squares = [x**<span class="hljs-number">2</span> <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>)]<br><span class="hljs-built_in">print</span>(squares)<br></code></pre></td></tr></table></figure></li><li><p><strong>生成器表达式</strong>：</p><ul><li>与列表推导式类似，但生成器表达式使用圆括号，生成元素时不会立即存储在内存中。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">squares_gen = (x**<span class="hljs-number">2</span> <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>))<br><span class="hljs-keyword">for</span> square <span class="hljs-keyword">in</span> squares_gen:<br>    <span class="hljs-built_in">print</span>(square)<br></code></pre></td></tr></table></figure></li><li><p><strong>条件过滤</strong>：</p><ul><li>你可以在 <code>for</code> 循环中使用条件语句来过滤元素。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">even_squares = [x**<span class="hljs-number">2</span> <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">if</span> x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>]<br><span class="hljs-built_in">print</span>(even_squares)<br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">[0, 4, 16, 36, 64]</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>嵌套循环</strong>：</p><ul><li>列表推导式和生成器表达式中可以包含嵌套循环。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">pairs = [(x, y) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>) <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>)]<br><span class="hljs-built_in">print</span>(pairs)<br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">[(0, 0), (0, 1), (0, 2), (1, 0), (1, 1), (1, 2), (2, 0), (2, 1), (2, 2)]</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="Functions-in-Python"><a href="#Functions-in-Python" class="headerlink" title="Functions in Python"></a>Functions in Python</h2><p>在Python中，自定义函数的语法格式和运行逻辑有较大的不同。</p><h3 id="Basic-Usage"><a href="#Basic-Usage" class="headerlink" title="Basic Usage"></a>Basic Usage</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># example one</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">greet_users</span>():<br>    <span class="hljs-string">&#x27;&#x27;&#x27;for the greetings to new users&#x27;&#x27;&#x27;</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hello!&quot;</span>)<br><br>    <br><span class="hljs-comment"># example two</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">greet_users2</span>(<span class="hljs-params">username</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27;functions with input&#x27;&#x27;&#x27;</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Hello! <span class="hljs-subst">&#123;username.title()&#125;</span>&quot;</span>)<br>    <br><span class="hljs-comment"># example three</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">greet_users3</span>(<span class="hljs-params">username</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27;functions with outpput&#x27;&#x27;&#x27;</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Hello! <span class="hljs-subst">&#123;username.title()&#125;</span>&quot;</span>)<br>    <span class="hljs-keyword">return</span> username<br><br><br>greet_users()<br>greet_users2(<span class="hljs-string">&quot;wowo&quot;</span>)<br>output=greet_users3(<span class="hljs-string">&quot;wowO&quot;</span>)<br><span class="hljs-built_in">print</span> (output)<br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">Hello!</span><br><span class="hljs-string">Hello! Wowo</span><br><span class="hljs-string">Hello! Wowo</span><br><span class="hljs-string">wowO</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><p>这是一个最基本的<strong>函数定义</strong>，包括<strong>函数名，文档字符串（Optional）和具体的函数代码</strong>。</p><blockquote><p>值得注意的是，python中的函数不需要显式声明返回类型。</p></blockquote><p><strong>python中也存在形参和实参的传递</strong>，但并不完全是拷贝传递（可变对象和不可变对象）</p><ul><li><p>不可变对象（如整数、字符串、元组）在传递时，形参和实参指向同一个对象。但如果形参尝试修改对象，Python 会创建一个新的对象，形参会指向这个新对象，而实参仍然指向原来的对象。</p></li><li><p>可变对象（如列表、字典、集合）在传递时，形参和实参指向同一个对象。如果形参修改了对象的内容，实参也会受到影响。</p><ul><li>可以使用切片的方法实现<strong>拷贝传参</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">function_name(list_name[:])<br></code></pre></td></tr></table></figure></li></ul><h3 id="Advanced-Usage"><a href="#Advanced-Usage" class="headerlink" title="Advanced Usage"></a>Advanced Usage</h3><ul><li><p>关键词实参（参数列表的一一对应）</p></li><li><p>返回值的多样性</p><ul><li>Python 函数可以返回 <strong>字典</strong>、<strong>列表</strong> 或 <strong>元组</strong>，甚至可以返回它们的组合。</li><li>Python 的函数非常灵活，可以返回任意类型的对象，包括复杂的数据结构。</li></ul></li><li><p>使用<code>def function(*args)</code>可以创建一个名为<code>nums</code>的元组。</p><ul><li><p>在函数定义中，<code>*</code> 和 <code>**</code> 可以用于接收任意数量的位置参数和关键字参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">print_args</span>(<span class="hljs-params">*args, **kwargs</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Positional arguments:&quot;</span>, args)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Keyword arguments:&quot;</span>, kwargs)<br><br><span class="hljs-comment"># 调用函数</span><br>print_args(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, name=<span class="hljs-string">&quot;Alice&quot;</span>, age=<span class="hljs-number">25</span>)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">Positional arguments: (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br>Keyword arguments: &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;Alice&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">25</span>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>*args</code> 接收所有位置参数，并将其存储为一个元组。</li><li><code>**kwargs</code> 接收所有关键字参数，并将其存储为一个字典。</li></ul></li></ul></li></ul><h2 id="OOP-in-Python"><a href="#OOP-in-Python" class="headerlink" title="OOP in Python"></a>OOP in Python</h2><p>在Python中，也可以实现面向对象编程。下文笔者将从C++的视角出发，向读者展示Python中相对应的用法。</p><h3 id="A-simple-class-for-Matrix"><a href="#A-simple-class-for-Matrix" class="headerlink" title="A simple class for Matrix"></a>A simple class for Matrix</h3><p>下文给出一个简单的矩阵类实现（C++语言）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Matrix</span>&#123;<br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-type">int</span> row,col;<br>        <span class="hljs-type">int</span>** thenumlist;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">Matrix</span>(<span class="hljs-type">int</span> row_,<span class="hljs-type">int</span> col_):<span class="hljs-built_in">row</span>(row_),<span class="hljs-built_in">col</span>(col_)&#123;<br>            thenumlist=<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>*[row];<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;row;i++)&#123;<br>                thenumlist[i]=<span class="hljs-keyword">new</span> <span class="hljs-type">int</span> [col];<br>            &#125;<br>        &#125;;<br><br>        ~<span class="hljs-built_in">Matrix</span>()&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;row;i++)&#123;<br>                <span class="hljs-keyword">delete</span>[] thenumlist[i];<br>            &#125;<br>            <span class="hljs-keyword">delete</span>[] thenumlist;<br>        &#125;<br><br>        <span class="hljs-built_in">Matrix</span>(<span class="hljs-type">const</span> Matrix&amp; x)&#123;<br>            row=x.row;<br>            col=x.col;<br>            thenumlist=<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>*[row];<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;row;i++)&#123;<br>                thenumlist[i]=<span class="hljs-keyword">new</span> <span class="hljs-type">int</span> [col];<br>            &#125;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;row;i++)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;col;j++)&#123;<br>                    thenumlist[i][j]=x.thenumlist[i][j];<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>;<br>        <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> Matrix &amp;x)&#123;<br>            <span class="hljs-comment">//bool judge=true;</span><br>            <span class="hljs-keyword">if</span>(x.row!=<span class="hljs-keyword">this</span>-&gt;row) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">if</span>(x.col!=<span class="hljs-keyword">this</span>-&gt;col) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;x.row;i++)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;x.col;j++)&#123;<br>                    <span class="hljs-keyword">if</span>(x.thenumlist[i][j]!=(<span class="hljs-keyword">this</span>-&gt;thenumlist)[i][j])&#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        Matrix <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Matrix &amp;x)&#123;<br>            <span class="hljs-keyword">if</span>(*<span class="hljs-keyword">this</span>==x)&#123;<br>                <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;row;i++)&#123;<br>                <span class="hljs-keyword">delete</span>[] thenumlist[i];<br>            &#125;<br>            <span class="hljs-keyword">delete</span>[] thenumlist;<br><br>            row=x.row;col=x.col;<br>            thenumlist=<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>*[row];<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;row;i++)&#123;<br>                thenumlist[i]=<span class="hljs-keyword">new</span> <span class="hljs-type">int</span> [col];<br>            &#125;<br><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;row;i++)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;col;j++)&#123;<br>                    thenumlist[i][j]=x.thenumlist[i][j];<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">friend</span> istream&amp; <span class="hljs-keyword">operator</span>&gt;&gt;(istream&amp; is,Matrix&amp; x);<br>        <span class="hljs-keyword">friend</span> ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; os,Matrix&amp; x);<br>        <span class="hljs-keyword">friend</span> Matrix <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Matrix&amp;x1,<span class="hljs-type">const</span> Matrix&amp;x2);<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Matrix::operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> thenumlist[x][y];<br>&#125;<br><br>istream&amp; <span class="hljs-keyword">operator</span>&gt;&gt;(istream&amp; is,Matrix&amp; x)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;x.row;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;x.col;j++)&#123;<br>            is&gt;&gt;x.thenumlist[i][j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> is;<br>&#125;<br><br>ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; os,Matrix&amp; x)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;x.row;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;x.col;j++)&#123;<br>            os&lt;&lt;x.thenumlist[i][j];<br>            <span class="hljs-keyword">if</span>(j!=x.col<span class="hljs-number">-1</span>) os&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>        os&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> os;<br>&#125;<br><br>Matrix <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Matrix&amp;x1,<span class="hljs-type">const</span> Matrix&amp;x2)&#123;<br>    <span class="hljs-function">Matrix <span class="hljs-title">temp</span><span class="hljs-params">(x<span class="hljs-number">1.</span>row,x<span class="hljs-number">1.</span>col)</span></span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;x<span class="hljs-number">1.</span>row;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;x<span class="hljs-number">1.</span>col;j++)&#123;<br>            temp.thenumlist[i][j]=x<span class="hljs-number">1.</span>thenumlist[i][j]+x<span class="hljs-number">2.</span>thenumlist[i][j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> temp;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> m, n, x, y;<br>    cin &gt;&gt; m &gt;&gt; n &gt;&gt; x &gt;&gt; y;<br>    <span class="hljs-function">Matrix <span class="hljs-title">a</span><span class="hljs-params">(m, n)</span>, <span class="hljs-title">b</span><span class="hljs-params">(m, n)</span></span>;<br>    cin &gt;&gt; a &gt;&gt; b;<br>    Matrix c = a+b;<br>    cout &lt;&lt; c;<br>    a = b+c;<br>    <span class="hljs-comment">// print element at row-x column-y of Matrix a, row and column count from 0</span><br>    cout &lt;&lt; <span class="hljs-built_in">a</span>(x, y) &lt;&lt; endl; <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>下面改写成Python的版本进行迁移学习：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Matrix</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, row=<span class="hljs-number">1</span>, col=<span class="hljs-number">1</span></span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        Default constructor for the Matrix class.</span><br><span class="hljs-string">        Initializes a matrix with the given number of rows and columns.</span><br><span class="hljs-string">        If no dimensions are provided, defaults to a 1x1 matrix.</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-variable language_">self</span>.row = row<br>        <span class="hljs-variable language_">self</span>.col = col<br>        <span class="hljs-comment"># Create a 2D list (matrix) filled with zeros</span><br>        <span class="hljs-variable language_">self</span>.thenumlist = [[<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(col)] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(row)]<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__del__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        Destructor for the Matrix class.</span><br><span class="hljs-string">        In Python, this is rarely used because memory management is handled by the garbage collector.</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Matrix object destroyed.&quot;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__copy__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        Copy constructor for the Matrix class.</span><br><span class="hljs-string">        Creates a new Matrix object that is a copy of the current object.</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        new_matrix = Matrix(<span class="hljs-variable language_">self</span>.row, <span class="hljs-variable language_">self</span>.col)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-variable language_">self</span>.row):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-variable language_">self</span>.col):<br>                new_matrix.thenumlist[i][j] = <span class="hljs-variable language_">self</span>.thenumlist[i][j]<br>        <span class="hljs-keyword">return</span> new_matrix<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__call__</span>(<span class="hljs-params">self, x, y</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        Overloads the () operator to access elements of the matrix.</span><br><span class="hljs-string">        Returns the element at the specified row and column.</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.thenumlist[x][y]<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__eq__</span>(<span class="hljs-params">self, other</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        Overloads the == operator to compare two matrices.</span><br><span class="hljs-string">        Returns True if the matrices have the same dimensions and elements, otherwise False.</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.row != other.row <span class="hljs-keyword">or</span> <span class="hljs-variable language_">self</span>.col != other.col:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-variable language_">self</span>.row):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-variable language_">self</span>.col):<br>                <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.thenumlist[i][j] != other.thenumlist[i][j]:<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__assign__</span>(<span class="hljs-params">self, other</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        Overloads the = operator to assign one matrix to another.</span><br><span class="hljs-string">        Performs a deep copy of the elements.</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span> == other:<br>            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span><br>        <span class="hljs-variable language_">self</span>.row = other.row<br>        <span class="hljs-variable language_">self</span>.col = other.col<br>        <span class="hljs-variable language_">self</span>.thenumlist = [[<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-variable language_">self</span>.col)] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-variable language_">self</span>.row)]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-variable language_">self</span>.row):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-variable language_">self</span>.col):<br>                <span class="hljs-variable language_">self</span>.thenumlist[i][j] = other.thenumlist[i][j]<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__add__</span>(<span class="hljs-params">self, other</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        Overloads the + operator to add two matrices.</span><br><span class="hljs-string">        Returns a new Matrix object that is the sum of the two matrices.</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.row != other.row <span class="hljs-keyword">or</span> <span class="hljs-variable language_">self</span>.col != other.col:<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&quot;Matrix dimensions do not match for addition.&quot;</span>)<br>        result = Matrix(<span class="hljs-variable language_">self</span>.row, <span class="hljs-variable language_">self</span>.col)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-variable language_">self</span>.row):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-variable language_">self</span>.col):<br>                result.thenumlist[i][j] = <span class="hljs-variable language_">self</span>.thenumlist[i][j] + other.thenumlist[i][j]<br>        <span class="hljs-keyword">return</span> result<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        Overloads the str() function to provide a string representation of the matrix.</span><br><span class="hljs-string">        Returns the matrix as a formatted string.</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;\n&quot;</span>.join([<span class="hljs-string">&quot; &quot;</span>.join(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">str</span>, row)) <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>.thenumlist])<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__repr__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        Overloads the repr() function to provide a detailed string representation of the matrix.</span><br><span class="hljs-string">        Useful for debugging.</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">f&quot;Matrix(<span class="hljs-subst">&#123;self.row&#125;</span>, <span class="hljs-subst">&#123;self.col&#125;</span>, data=<span class="hljs-subst">&#123;self.thenumlist&#125;</span>)&quot;</span><br><br><span class="hljs-meta">    @staticmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">from_input</span>(<span class="hljs-params">rows, cols</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        Static method to create a Matrix object from user input.</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        matrix = Matrix(rows, cols)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(rows):<br>            row = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split()))<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(row) != cols:<br>                <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&quot;Invalid number of elements in row.&quot;</span>)<br>            matrix.thenumlist[i] = row<br>        <span class="hljs-keyword">return</span> matrix<br><br><br><span class="hljs-comment"># Main function to test the Matrix class</span><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-comment"># Read matrix dimensions and element indices</span><br>    m, n, x, y = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br><br>    <span class="hljs-comment"># Create two matrices from user input</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Enter elements for matrix A:&quot;</span>)<br>    a = Matrix.from_input(m, n)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Enter elements for matrix B:&quot;</span>)<br>    b = Matrix.from_input(m, n)<br><br>    <span class="hljs-comment"># Perform matrix addition</span><br>    c = a + b<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Matrix C (A + B):&quot;</span>)<br>    <span class="hljs-built_in">print</span>(c)<br><br>    <span class="hljs-comment"># Assign the result of (B + C) to A</span><br>    a = b + c<br><br>    <span class="hljs-comment"># Print the element at row-x, column-y of matrix A</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Element at (<span class="hljs-subst">&#123;x&#125;</span>, <span class="hljs-subst">&#123;y&#125;</span>) in matrix A: <span class="hljs-subst">&#123;a(x, y)&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="Data-and-functions？"><a href="#Data-and-functions？" class="headerlink" title="Data and functions？"></a>Data and functions？</h3><p>在C++中，类的定义主要包括两个方面的定义：<strong>数据成员和方法</strong>（即数据类型和成员函数）。但是在Python的代码中，我们没有看到明确的一块区域来专门定义数据成员。</p><p>实际上，Python中的类实现更加的灵活，数据成员的定义可以直接在构造函数中实现，也可以在<strong>后续的使用中添加新的数据成员</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.data_member = <span class="hljs-number">42</span>  <span class="hljs-comment"># 定义数据成员</span><br>        <span class="hljs-variable language_">self</span>.name = <span class="hljs-string">&quot;Python&quot;</span>   <span class="hljs-comment"># 定义另一个数据成员</span><br><br>obj = MyClass()<br><span class="hljs-built_in">print</span>(obj.data_member)  <span class="hljs-comment"># 输出: 42</span><br><span class="hljs-built_in">print</span>(obj.name)         <span class="hljs-comment"># 输出: Python</span><br><br>obj.new_data_member = <span class="hljs-string">&quot;Dynamic&quot;</span>  <span class="hljs-comment"># 动态添加数据成员</span><br><span class="hljs-built_in">print</span>(obj.new_data_member)       <span class="hljs-comment"># 输出: Dynamic</span><br><br><span class="hljs-comment"># 使用slots可以显式地规定不可以添加新的数据成员</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>:<br>    __slots__ = [<span class="hljs-string">&#x27;data_member&#x27;</span>, <span class="hljs-string">&#x27;name&#x27;</span>]  <span class="hljs-comment"># 限制只能有这两个数据成员</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.data_member = <span class="hljs-number">42</span><br>        <span class="hljs-variable language_">self</span>.name = <span class="hljs-string">&quot;Python&quot;</span><br><br>obj = MyClass()<br><span class="hljs-built_in">print</span>(obj.data_member)  <span class="hljs-comment"># 输出: 42</span><br><span class="hljs-built_in">print</span>(obj.name)         <span class="hljs-comment"># 输出: Python</span><br><br><span class="hljs-comment"># obj.new_member = &quot;Dynamic&quot;  # 报错: AttributeError</span><br></code></pre></td></tr></table></figure><p>值得注意的是，Python中存在<strong>类一级的数据成员</strong>，类似于C++中的静态数据成员。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>:<br>    class_data_member = <span class="hljs-number">100</span>  <span class="hljs-comment"># 定义类变量（类数据成员）</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.instance_data_member = <span class="hljs-number">42</span>  <span class="hljs-comment"># 定义实例变量</span><br><br>obj1 = MyClass()<br>obj2 = MyClass()<br><br><span class="hljs-built_in">print</span>(MyClass.class_data_member)  <span class="hljs-comment"># 输出: 100（通过类名访问）</span><br><span class="hljs-built_in">print</span>(obj1.class_data_member)     <span class="hljs-comment"># 输出: 100（通过对象访问）</span><br><span class="hljs-built_in">print</span>(obj1.instance_data_member)  <span class="hljs-comment"># 输出: 42</span><br><br><span class="hljs-comment"># 修改类变量</span><br>MyClass.class_data_member = <span class="hljs-number">200</span><br><span class="hljs-built_in">print</span>(obj2.class_data_member)     <span class="hljs-comment"># 输出: 200（所有对象共享类变量）</span><br></code></pre></td></tr></table></figure><h3 id="Public-and-Private？"><a href="#Public-and-Private？" class="headerlink" title="Public and Private？"></a>Public and Private？</h3><p>继续观察Python代码，发现<strong>Python中没有private和public</strong>的区别了！</p><blockquote><p>这实际上是一个很严重的问题，因为OOP的核心精神之一就是封装，而不同访问权限的设置是封装精神实现的基础。</p></blockquote><p>在 Python 中，确实没有像 C++ 或 Java 那样严格的 <code>private</code> 和 <code>public</code> 访问控制关键字。Python 采用了一种更加灵活的方式来控制成员的访问权限，主要通过<strong>命名约定</strong>和<strong>特殊机制</strong>来实现类似的功能。</p><p>默认情况下，<strong>类的所有成员（属性和方法）</strong>都是公有的。没错，Python中的类实现牺牲了封装性。也没有友元的实现。</p><div class="note note-primary">            <p><strong>Python为什么要这么做？</strong>请看这个链接：  <a href="https://mail.python.org/pipermail/tutor/2003-October/025932.html">Pythonic</a></p><p>I came across a quote “<strong>we are all consenting adults here</strong>“ I think in explaining why it is not necessary to have type declaration statements in Python, in contrast to other strongly-typed languages.</p><p>This expression is also used in the object-oriented python literature to explain python’s attitudes about private class members, which python doesn’t have. </p><p>When you create an instance of some class there is nothing to prevent you from poking around inside and using various internal,<br>private methods that are (a) necessary for the class to function, BUT (b) not intended for direct use&#x2F;access.</p><p>Nothing is really private in python. No class or class instance can keep you away from all what’s inside (this makes introspection possible and powerful). Python trusts you. It says “hey, if you want to go poking around in dark places, I’m gonna trust that you’ve got a good reason and you’re not making trouble.”</p><p>After all, <strong>we’re all consenting adults here</strong>. C++ and Java don’t have this philosophy (not to the same extent). They allow you create private methods and static members. Perl culture is like python in this respect, but Perl expresses the sentiment a bit differently. As the Camel book puts it,</p><p>  “a Perl module would prefer that you stayed out of its living room because you weren’t invited, not because it has a shotgun.” But the sentiment is identical.</p><p>–karl</p><p>我偶然看到一句话：“<strong>we are all consenting adults here</strong>”（我们都是成年人），这句话通常用来解释为什么 Python 不需要像其他强类型语言那样有类型声明语句。</p><p>这个表达也用在 Python 面向对象编程的文献中，用来解释 Python 对于<strong>私有类成员</strong>的态度——Python 并没有真正的私有成员。当你创建某个类的实例时，没有什么能阻止你去探索类的内部并使用各种内部的、私有的方法，这些方法（a）是类正常运行所必需的，但（b）并不打算让你直接使用或访问。</p><p>在 Python 中，<strong>没有什么东西是真正私有的</strong>。没有任何类或类的实例能阻止你访问内部的所有内容（这使得 Python 的内省机制变得可能且强大）。Python 信任你。它说：“嘿，如果你想深入探索那些黑暗的角落，我会相信你有充分的理由，而不是在捣乱。”</p><p>毕竟，<strong>我们都是成年人</strong>。C++ 和 Java 并没有这种哲学（至少不像 Python 这样）。它们允许你创建私有方法和静态成员。Perl 的文化在这方面与 Python 类似，但 Perl 的表达方式略有不同。正如《骆驼书》（Perl 的经典书籍）中所说：</p><blockquote><p>“Perl 模块更希望你远离它的客厅，因为你没有被邀请，而不是因为它有一把猎枪。”</p></blockquote><p>但两者的理念是相同的。</p><p>——Karl</p>          </div><p>不过实际上，Python中也允许一些<strong>类似私有成员</strong>的实现方式，不过并没有像C++一样那么严格。</p><h4 id="Protected-Members"><a href="#Protected-Members" class="headerlink" title="Protected Members"></a><strong>Protected Members</strong></h4><ul><li><p><strong>定义</strong>：通过在成员名前加一个下划线 <code>_</code> 来表示受保护成员。</p></li><li><p><strong>特点</strong>：</p><ul><li>这是一种命名约定，表示该成员<strong>不应该</strong>在类的外部直接访问，但 Python 并不会阻止你访问。</li><li>主要用于提示开发者：“这是一个内部实现细节，请谨慎使用”。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>._protected_var = <span class="hljs-number">20</span>  <span class="hljs-comment"># 受保护变量</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_protected_method</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;This is a protected method.&quot;</span>)  <span class="hljs-comment"># 受保护方法</span><br><br>obj = MyClass()<br><span class="hljs-built_in">print</span>(obj._protected_var)  <span class="hljs-comment"># 可以访问，但不推荐</span><br>obj._protected_method()    <span class="hljs-comment"># 可以调用，但不推荐</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="Private-Members"><a href="#Private-Members" class="headerlink" title="Private Members"></a><strong>Private Members</strong></h4><ul><li><p><strong>定义</strong>：通过在成员名前加两个下划线 <code>__</code> 来表示私有成员。</p></li><li><p><strong>特点</strong>：</p><ul><li>Python 会对私有成员进行名称改写（Name Mangling），使其在类的外部无法直接访问。</li><li>名称改写规则：<code>__var</code> 会被改写为 <code>_ClassName__var</code>。</li><li>这是一种更严格的访问控制，但仍然可以通过改写后的名称访问（不推荐）。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.__private_var = <span class="hljs-number">30</span>  <span class="hljs-comment"># 私有变量</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__private_method</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;This is a private method.&quot;</span>)  <span class="hljs-comment"># 私有方法</span><br><br>obj = MyClass()<br><span class="hljs-comment"># print(obj.__private_var)  # 直接访问会报错：AttributeError</span><br><span class="hljs-comment"># obj.__private_method()    # 直接调用会报错：AttributeError</span><br><br><span class="hljs-comment"># 通过名称改写访问（不推荐）</span><br><span class="hljs-built_in">print</span>(obj._MyClass__private_var)  <span class="hljs-comment"># 输出：30</span><br>obj._MyClass__private_method()    <span class="hljs-comment"># 输出：This is a private method</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="Constructor"><a href="#Constructor" class="headerlink" title="Constructor"></a>Constructor</h3><h4 id="Default-Constructor-and-parameterized-Constructor"><a href="#Default-Constructor-and-parameterized-Constructor" class="headerlink" title="Default Constructor and parameterized Constructor"></a><strong>Default Constructor and parameterized Constructor</strong></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, row=<span class="hljs-number">1</span>, col=<span class="hljs-number">1</span></span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        Default constructor for the Matrix class.</span><br><span class="hljs-string">        Initializes a matrix with the given number of rows and columns.</span><br><span class="hljs-string">        If no dimensions are provided, defaults to a 1x1 matrix.</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-variable language_">self</span>.row = row<br>        <span class="hljs-variable language_">self</span>.col = col<br>        <span class="hljs-comment"># Create a 2D list (matrix) filled with zeros</span><br>        <span class="hljs-variable language_">self</span>.thenumlist = [[<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(col)] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(row)]<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">Matrix</span>(<span class="hljs-type">int</span> row_=<span class="hljs-number">1</span>,<span class="hljs-type">int</span> col_=<span class="hljs-number">1</span>):<span class="hljs-built_in">row</span>(row_),<span class="hljs-built_in">col</span>(col_)&#123;<br>            thenumlist=<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>*[row];<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;row;i++)&#123;<br>                thenumlist[i]=<span class="hljs-keyword">new</span> <span class="hljs-type">int</span> [col];<br>            &#125;<br>        &#125;;<br></code></pre></td></tr></table></figure><p>讲面向对象编程肯定得从构造函数讲起，下面着重分析两种语言中在语法上的差异：</p><ul><li><code>self</code>：<code>self</code> 是类的方法（包括构造函数 <code>__init__</code>）中的第一个参数，用于表示<strong>当前对象的实例</strong>。有点类似于C++中的<strong>隐式this指针</strong>！</li><li>Python中的数据成员的声明主要都是在构造函数中进行的，并且没有提供访问权限的控制。</li></ul><h4 id="Copy-Constructor"><a href="#Copy-Constructor" class="headerlink" title="Copy Constructor"></a>Copy Constructor</h4><p>在C++中，由于涉及到指针，使用<strong>复制构造函数</strong>是非常有必要的！在 Python 中，<strong>没有显式的拷贝构造函数</strong>（Copy Constructor），因为 Python 的内存管理和对象复制机制与 C++ 不同。但是在Python的<code>copy</code>库中，也有类似的实现方式。</p><h5 id="Shallow-Copy"><a href="#Shallow-Copy" class="headerlink" title="Shallow Copy"></a>Shallow Copy</h5><ul><li><p><strong>定义</strong>：浅拷贝创建一个新对象，但不会递归复制对象内部的子对象。</p></li><li><p><strong>实现方式</strong>：</p><ul><li>使用 <code>copy.copy()</code> 函数。</li><li>使用对象的 <code>copy()</code> 方法（如果对象支持）。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> copy<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, value,valist</span>):<br>        <span class="hljs-variable language_">self</span>.value = value<br>        <span class="hljs-variable language_">self</span>.valist= valist<br><br>obj1 = MyClass(<span class="hljs-number">42</span>,[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>])<br>obj2 = copy.copy(obj1)<br><br><span class="hljs-built_in">print</span>(obj1.value)  <br><span class="hljs-built_in">print</span>(obj2.value)<br><br><span class="hljs-built_in">print</span>(obj1.valist)<br><span class="hljs-built_in">print</span>(obj2.valist)<br><br><span class="hljs-comment"># obj2.valist=[1,2,3,3,4] 这样会让obj2.valist指向一个新的列表对象</span><br>obj2.value+=<span class="hljs-number">1</span><br>obj2.valist.append(<span class="hljs-number">33</span>)<br><br><span class="hljs-built_in">print</span>(obj1.valist)<br><span class="hljs-built_in">print</span>(obj2.valist)<br><br><span class="hljs-built_in">print</span>(obj1.value)  <br><span class="hljs-built_in">print</span>(obj2.value)<br><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Bash">42<br>42<br>[1, 2, 3, 4]<br>[1, 2, 3, 4]<br>[1, 2, 3, 4, 33]<br>[1, 2, 3, 4, 33]<br>42<br>43<br></code></pre></td></tr></table></figure><ul><li>如果对象包含可变子对象（如列表、字典），<strong>浅拷贝</strong>会共享这些子对象。</li></ul><p><strong>分析</strong>：在上述代码中，<code>obj2 = copy.copy(obj1)</code>让两个对象的<code>valist</code>数据成员指向了<strong>同一个列表！</strong>因此对obj2进行修改的时候obj1也会修改。</p><blockquote><p>这一点和C++一样，相当于<strong>一条绳上的蚂蚱</strong>！</p></blockquote></li></ul><h5 id="Deep-Copy"><a href="#Deep-Copy" class="headerlink" title="Deep Copy"></a>Deep Copy</h5><ul><li><p><strong>定义</strong>：深拷贝创建一个新对象，并递归复制对象内部的所有子对象。</p></li><li><p><strong>实现方式</strong>：</p><ul><li>使用 <code>copy.deepcopy()</code> 函数。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> copy<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, value,valist</span>):<br>        <span class="hljs-variable language_">self</span>.value = value<br>        <span class="hljs-variable language_">self</span>.valist= valist<br><br>obj1 = MyClass(<span class="hljs-number">42</span>,[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>])<br>obj2 = copy.deepcopy(obj1) <span class="hljs-comment">#仅修改这一处</span><br><br><span class="hljs-built_in">print</span>(obj1.value)  <br><span class="hljs-built_in">print</span>(obj2.value)<br><br><span class="hljs-built_in">print</span>(obj1.valist)<br><span class="hljs-built_in">print</span>(obj2.valist)<br><br><span class="hljs-comment"># obj2.valist=[1,2,3,3,4] 这样会让obj2.valist指向一个新的列表对象</span><br>obj2.value+=<span class="hljs-number">1</span><br>obj2.valist.append(<span class="hljs-number">33</span>)<br><br><span class="hljs-built_in">print</span>(obj1.valist)<br><span class="hljs-built_in">print</span>(obj2.valist)<br><br><span class="hljs-built_in">print</span>(obj1.value)  <br><span class="hljs-built_in">print</span>(obj2.value)<br><br></code></pre></td></tr></table></figure></li><li><p><strong>注意</strong>：</p><ul><li>深拷贝会递归复制所有子对象，因此不会共享任何可变子对象。</li></ul></li></ul><h5 id="Define-Copy-Constructor-explicitly"><a href="#Define-Copy-Constructor-explicitly" class="headerlink" title="Define Copy Constructor explicitly"></a>Define Copy Constructor <strong>explicitly</strong></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">__copy__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        Copy constructor for the Matrix class.</span><br><span class="hljs-string">        Creates a new Matrix object that is a copy of the current object.</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        new_matrix = Matrix(<span class="hljs-variable language_">self</span>.row, <span class="hljs-variable language_">self</span>.col)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-variable language_">self</span>.row):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-variable language_">self</span>.col):<br>                new_matrix.thenumlist[i][j] = <span class="hljs-variable language_">self</span>.thenumlist[i][j]<br>        <span class="hljs-keyword">return</span> new_matrix<br></code></pre></td></tr></table></figure><div class="note note-danger">            <p><strong>注意！在这里本质上还是进行浅拷贝（和C++有很大不同）</strong>。因为Python允许<code>thenumlist[i][j]</code>是任何数据类型（甚至是<strong>可变数据，例如列表</strong>）。如果是不可变数据例如一个<code>int</code>整数，深拷贝和浅拷贝的行为没有差别，但如果是一个可变数据类型例如列表，那么其本质上还是指向同一个列表，是一条绳上的蚂蚱！</p>          </div><p>不过，Python也支持自定义深拷贝函数。<strong>但我们为什么不用<code>copy</code>库中给好的函数呢？</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> copy<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, value</span>):<br>        <span class="hljs-variable language_">self</span>.value = value<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__copy__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;自定义浅拷贝行为&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">return</span> MyClass(<span class="hljs-variable language_">self</span>.value)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__deepcopy__</span>(<span class="hljs-params">self, memo</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;自定义深拷贝行为&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">return</span> MyClass(copy.deepcopy(<span class="hljs-variable language_">self</span>.value, memo))<br><br>obj1 = MyClass(<span class="hljs-number">42</span>)<br>obj2 = copy.copy(obj1)      <span class="hljs-comment"># 调用 __copy__</span><br>obj3 = copy.deepcopy(obj1)  <span class="hljs-comment"># 调用 __deepcopy__</span><br><br><span class="hljs-built_in">print</span>(obj1.value)  <span class="hljs-comment"># 输出: 42</span><br><span class="hljs-built_in">print</span>(obj2.value)  <span class="hljs-comment"># 输出: 42</span><br><span class="hljs-built_in">print</span>(obj3.value)  <span class="hljs-comment"># 输出: 42</span><br></code></pre></td></tr></table></figure><table><thead><tr><th>特性</th><th>Python 中的对象复制</th><th>C++ 中的拷贝构造函数</th></tr></thead><tbody><tr><td><strong>实现方式</strong></td><td>通过 <code>copy.copy()</code> 或 <code>copy.deepcopy()</code></td><td>通过显式的拷贝构造函数</td></tr><tr><td><strong>默认行为</strong></td><td>浅拷贝（共享子对象）</td><td>深拷贝（递归复制子对象）</td></tr><tr><td><strong>自定义行为</strong></td><td>通过 <code>__copy__</code> 和 <code>__deepcopy__</code></td><td>通过自定义拷贝构造函数</td></tr><tr><td><strong>内存管理</strong></td><td>自动垃圾回收</td><td>手动内存管理</td></tr></tbody></table><h3 id="Destructor"><a href="#Destructor" class="headerlink" title="Destructor"></a>Destructor</h3><p>Python中不用实现具体的动态内存分配的回收，不过可以实现一些其他的功能。（例如输出特定的信息）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__del__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># 析构函数的代码</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Object is being destroyed&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="Operator-Overloading"><a href="#Operator-Overloading" class="headerlink" title="Operator Overloading"></a>Operator Overloading</h3><p>在 Python 中，<strong>运算符重载</strong>（Operator Overloading）是通过定义类的特殊方法（Magic Methods 或 Dunder Methods）来实现的。这些特殊方法以双下划线 <code>__</code> 开头和结尾，例如 <code>__add__</code>、<code>__sub__</code> 等。通过实现这些方法，可以让自定义类的对象支持 Python 的内置运算符（如 <code>+</code>、<code>-</code>、<code>*</code> 等）。</p><table><thead><tr><th align="left">运算符</th><th align="left">方法名</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>+</code></td><td align="left"><code>__add__</code></td><td align="left">加法运算</td></tr><tr><td align="left"><code>-</code></td><td align="left"><code>__sub__</code></td><td align="left">减法运算</td></tr><tr><td align="left"><code>*</code></td><td align="left"><code>__mul__</code></td><td align="left">乘法运算</td></tr><tr><td align="left"><code>/</code></td><td align="left"><code>__truediv__</code></td><td align="left">除法运算</td></tr><tr><td align="left"><code>//</code></td><td align="left"><code>__floordiv__</code></td><td align="left">整除运算</td></tr><tr><td align="left"><code>%</code></td><td align="left"><code>__mod__</code></td><td align="left">取模运算</td></tr><tr><td align="left"><code>**</code></td><td align="left"><code>__pow__</code></td><td align="left">幂运算</td></tr><tr><td align="left"><code>==</code></td><td align="left"><code>__eq__</code></td><td align="left">等于运算</td></tr><tr><td align="left"><code>!=</code></td><td align="left"><code>__ne__</code></td><td align="left">不等于运算</td></tr><tr><td align="left"><code>&lt;</code></td><td align="left"><code>__lt__</code></td><td align="left">小于运算</td></tr><tr><td align="left"><code>&lt;=</code></td><td align="left"><code>__le__</code></td><td align="left">小于等于运算</td></tr><tr><td align="left"><code>&gt;</code></td><td align="left"><code>__gt__</code></td><td align="left">大于运算</td></tr><tr><td align="left"><code>&gt;=</code></td><td align="left"><code>__ge__</code></td><td align="left">大于等于运算</td></tr><tr><td align="left"><code>[]</code></td><td align="left"><code>__getitem__</code></td><td align="left">索引操作</td></tr><tr><td align="left"><code>[]=</code></td><td align="left"><code>__setitem__</code></td><td align="left">索引赋值操作</td></tr><tr><td align="left"><code>len()</code></td><td align="left"><code>__len__</code></td><td align="left">获取对象长度</td></tr><tr><td align="left"><code>str()</code></td><td align="left"><code>__str__</code></td><td align="left">返回对象的字符串表示</td></tr><tr><td align="left"><code>repr()</code></td><td align="left"><code>__repr__</code></td><td align="left">返回对象的官方字符串表示</td></tr><tr><td align="left"><code>in</code></td><td align="left"><code>__contains__</code></td><td align="left">检查元素是否在对象中</td></tr><tr><td align="left"><code>()</code></td><td align="left"><code>__call__</code></td><td align="left">使对象可调用（像函数一样）</td></tr></tbody></table><p>以上文的矩阵类为例，看一看具体是如何实现的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">__call__</span>(<span class="hljs-params">self, x, y</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        Overloads the () operator to access elements of the matrix.</span><br><span class="hljs-string">        Returns the element at the specified row and column.</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.thenumlist[x][y]<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__eq__</span>(<span class="hljs-params">self, other</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        Overloads the == operator to compare two matrices.</span><br><span class="hljs-string">        Returns True if the matrices have the same dimensions and elements, otherwise False.</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.row != other.row <span class="hljs-keyword">or</span> <span class="hljs-variable language_">self</span>.col != other.col:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-variable language_">self</span>.row):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-variable language_">self</span>.col):<br>                <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.thenumlist[i][j] != other.thenumlist[i][j]:<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__assign__</span>(<span class="hljs-params">self, other</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        Overloads the = operator to assign one matrix to another.</span><br><span class="hljs-string">        Performs a deep copy of the elements.</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span> == other:<br>            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span><br>        <span class="hljs-variable language_">self</span>.row = other.row<br>        <span class="hljs-variable language_">self</span>.col = other.col<br>        <span class="hljs-variable language_">self</span>.thenumlist = [[<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-variable language_">self</span>.col)] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-variable language_">self</span>.row)]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-variable language_">self</span>.row):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-variable language_">self</span>.col):<br>                <span class="hljs-variable language_">self</span>.thenumlist[i][j] = other.thenumlist[i][j]<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__add__</span>(<span class="hljs-params">self, other</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        Overloads the + operator to add two matrices.</span><br><span class="hljs-string">        Returns a new Matrix object that is the sum of the two matrices.</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.row != other.row <span class="hljs-keyword">or</span> <span class="hljs-variable language_">self</span>.col != other.col:<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&quot;Matrix dimensions do not match for addition.&quot;</span>)<br>        result = Matrix(<span class="hljs-variable language_">self</span>.row, <span class="hljs-variable language_">self</span>.col)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-variable language_">self</span>.row):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-variable language_">self</span>.col):<br>                result.thenumlist[i][j] = <span class="hljs-variable language_">self</span>.thenumlist[i][j] + other.thenumlist[i][j]<br>        <span class="hljs-keyword">return</span> result<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        Overloads the str() function to provide a string representation of the matrix.</span><br><span class="hljs-string">        Returns the matrix as a formatted string.</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;\n&quot;</span>.join([<span class="hljs-string">&quot; &quot;</span>.join(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">str</span>, row)) <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>.thenumlist])<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__repr__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        Overloads the repr() function to provide a detailed string representation of the matrix.</span><br><span class="hljs-string">        Useful for debugging.</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">f&quot;Matrix(<span class="hljs-subst">&#123;self.row&#125;</span>, <span class="hljs-subst">&#123;self.col&#125;</span>, data=<span class="hljs-subst">&#123;self.thenumlist&#125;</span>)&quot;</span><br></code></pre></td></tr></table></figure><h3 id="Static-Members"><a href="#Static-Members" class="headerlink" title="Static Members"></a>Static Members</h3><p>对于<strong>静态数据成员</strong>来说，可以通过类一级的数据成员实现，在上文有讲。[跳转链接](#Data and functions？)</p><p>对于静态成员函数来说，使用 <code>@staticmethod</code> 装饰器定义静态方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>:<br><span class="hljs-meta">    @staticmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">static_method</span>():<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;This is a static method&quot;</span>)<br><br><span class="hljs-comment"># 通过类名调用静态方法</span><br>MyClass.static_method()  <span class="hljs-comment"># 输出: This is a static method</span><br><br><span class="hljs-comment"># 通过实例调用静态方法</span><br>obj = MyClass()<br>obj.static_method()      <span class="hljs-comment"># 输出: This is a static method</span><br></code></pre></td></tr></table></figure><h3 id="Class-Inheritance"><a href="#Class-Inheritance" class="headerlink" title="Class Inheritance"></a>Class Inheritance</h3><p>在Python中，也可以实现类的继承。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ParentClass</span>:<br>    <span class="hljs-comment"># 父类的属性和方法</span><br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ChildClass</span>(<span class="hljs-title class_ inherited__">ParentClass</span>):<br>    <span class="hljs-comment"># 子类的属性和方法</span><br>    <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><p>下文以一个简化的矩阵类为示例，演示一下类的继承：</p><blockquote><p>是<strong>公有继承</strong>，即一种<strong>is-a</strong>关系。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Matrix</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, rows, cols</span>):<br>        <span class="hljs-variable language_">self</span>.rows = rows<br>        <span class="hljs-variable language_">self</span>.cols = cols<br>        <span class="hljs-variable language_">self</span>.data = [[i+j <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(cols)] <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(rows)]  <span class="hljs-comment"># 初始化矩阵</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;返回矩阵的字符串表示&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;\n&quot;</span>.join(<span class="hljs-string">&quot; &quot;</span>.join(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">str</span>, row)) <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>.data)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">self, other</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;矩阵加法&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.rows != other.rows <span class="hljs-keyword">or</span> <span class="hljs-variable language_">self</span>.cols != other.cols:<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&quot;矩阵维度不匹配&quot;</span>)<br>        result = Matrix(<span class="hljs-variable language_">self</span>.rows, <span class="hljs-variable language_">self</span>.cols)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-variable language_">self</span>.rows):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-variable language_">self</span>.cols):<br>                result.data[i][j] = <span class="hljs-variable language_">self</span>.data[i][j] + other.data[i][j]<br>        <span class="hljs-keyword">return</span> result<br><br>    <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SquareMatrix</span>(<span class="hljs-title class_ inherited__">Matrix</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, size</span>):<br>        <span class="hljs-built_in">super</span>().__init__(size, size)  <span class="hljs-comment"># 调用父类的构造函数</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">is_identity</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;检查是否是单位矩阵&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-variable language_">self</span>.rows):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-variable language_">self</span>.cols):<br>                <span class="hljs-keyword">if</span> i == j <span class="hljs-keyword">and</span> <span class="hljs-variable language_">self</span>.data[i][j] != <span class="hljs-number">1</span>:<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>                <span class="hljs-keyword">if</span> i != j <span class="hljs-keyword">and</span> <span class="hljs-variable language_">self</span>.data[i][j] != <span class="hljs-number">0</span>:<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>    <br>obj1=Matrix(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)<br>obj2=SquareMatrix(<span class="hljs-number">6</span>)<br><span class="hljs-built_in">print</span>(obj2)<br></code></pre></td></tr></table></figure><ul><li><p><strong><code>super()</code> 函数</strong>：</p><ul><li>在 <code>SquareMatrix</code> 的构造函数中，使用 <code>super().__init__(size, size)</code> 调用父类的构造函数。</li></ul></li><li><p>派生类对象可以使用基类对象的方法</p><ul><li>上述代码的输出：</li></ul><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">0 </span><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span><br><span class="hljs-symbol">5 </span><span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span> <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><blockquote><p>本质上是使用了基类重载的<code>def __str__(self)</code></p></blockquote></li><li><p>在派生类中实现和基类同名的方法可以实现<strong>对基类方法的覆盖</strong>。</p></li></ul><h3 id="Advanced-Usage-1"><a href="#Advanced-Usage-1" class="headerlink" title="Advanced Usage"></a>Advanced Usage</h3><h4 id="Property-Decorator"><a href="#Property-Decorator" class="headerlink" title="Property Decorator"></a>Property Decorator</h4><p><strong>Property Decorator</strong>（属性装饰器）是 Python 中用于将方法转换为属性的机制。它允许你像访问属性一样访问方法，同时可以在访问时执行额外的逻辑（如验证、计算等）。属性装饰器通过 <code>@property</code>、<code>@属性名.setter</code> 和 <code>@属性名.deleter</code> 来实现。</p><ol><li><p><strong>将方法转换为只读属性</strong>：</p><ul><li>使用 <code>@property</code> 装饰器，可以将一个方法转换为只读属性。</li><li>这样，你可以像访问属性一样调用方法，而不需要使用 <code>()</code>。</li></ul></li><li><p><strong>实现属性的写操作</strong>：</p><ul><li>使用 <code>@属性名.setter</code> 装饰器，可以为属性添加写操作逻辑。</li><li>这样，你可以在赋值时执行额外的逻辑（如验证、计算等）。</li></ul></li><li><p><strong>实现属性的删除操作</strong>：</p><ul><li>使用 <code>@属性名.deleter</code> 装饰器，可以为属性添加删除操作逻辑。</li></ul></li><li><p><strong>只读属性</strong></p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, radius</span>):<br>        <span class="hljs-variable language_">self</span>.radius = radius<br><br><span class="hljs-meta">    @property</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">area</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;计算圆的面积&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">3.14</span> * <span class="hljs-variable language_">self</span>.radius ** <span class="hljs-number">2</span><br><br><span class="hljs-comment"># 使用</span><br>c = Circle(<span class="hljs-number">5</span>)<br><span class="hljs-built_in">print</span>(c.area)  <span class="hljs-comment"># 输出: 78.5（像访问属性一样调用方法）</span><br><span class="hljs-comment"># c.area = 100  # 报错：AttributeError（只读属性）</span><br></code></pre></td></tr></table></figure><ol start="2"><li><strong>可读写属性</strong></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Temperature</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, celsius</span>):<br>        <span class="hljs-variable language_">self</span>._celsius = celsius<br><br><span class="hljs-meta">    @property</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">celsius</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;获取摄氏温度&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>._celsius<br><br><span class="hljs-meta">    @celsius.setter</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">celsius</span>(<span class="hljs-params">self, value</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;设置摄氏温度&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> value &lt; -<span class="hljs-number">273.15</span>:<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&quot;Temperature cannot be below absolute zero.&quot;</span>)<br>        <span class="hljs-variable language_">self</span>._celsius = value<br><br><span class="hljs-meta">    @property</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">fahrenheit</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;获取华氏温度&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>._celsius * <span class="hljs-number">9</span> / <span class="hljs-number">5</span> + <span class="hljs-number">32</span><br><br><span class="hljs-meta">    @fahrenheit.setter</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">fahrenheit</span>(<span class="hljs-params">self, value</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;设置华氏温度&quot;&quot;&quot;</span><br>        <span class="hljs-variable language_">self</span>._celsius = (value - <span class="hljs-number">32</span>) * <span class="hljs-number">5</span> / <span class="hljs-number">9</span><br><br><span class="hljs-comment"># 使用</span><br>t = Temperature(<span class="hljs-number">25</span>)<br><span class="hljs-built_in">print</span>(t.celsius)      <span class="hljs-comment"># 输出: 25</span><br><span class="hljs-built_in">print</span>(t.fahrenheit)   <span class="hljs-comment"># 输出: 77.0</span><br><br>t.fahrenheit = <span class="hljs-number">100</span><br><span class="hljs-built_in">print</span>(t.celsius)      <span class="hljs-comment"># 输出: 37.777...</span><br></code></pre></td></tr></table></figure><ol start="3"><li><strong>删除属性</strong></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>._value = <span class="hljs-number">42</span><br><br><span class="hljs-meta">    @property</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">value</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>._value<br><br><span class="hljs-meta">    @value.setter</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">value</span>(<span class="hljs-params">self, new_value</span>):<br>        <span class="hljs-variable language_">self</span>._value = new_value<br><br><span class="hljs-meta">    @value.deleter</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">value</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Deleting value&quot;</span>)<br>        <span class="hljs-keyword">del</span> <span class="hljs-variable language_">self</span>._value<br><br><span class="hljs-comment"># 使用</span><br>obj = MyClass()<br><span class="hljs-built_in">print</span>(obj.value)  <span class="hljs-comment"># 输出: 42</span><br><span class="hljs-keyword">del</span> obj.value     <span class="hljs-comment"># 输出: Deleting value</span><br><span class="hljs-comment"># print(obj.value)  # 报错：AttributeError（属性已被删除）</span><br></code></pre></td></tr></table></figure><table><thead><tr><th>特性</th><th>属性装饰器 (<code>@property</code>)</th><th>普通方法</th></tr></thead><tbody><tr><td><strong>访问方式</strong></td><td>像访问属性一样（无括号）</td><td>需要调用方法（带括号）</td></tr><tr><td><strong>逻辑封装</strong></td><td>可以在访问时执行额外逻辑</td><td>需要显式调用方法</td></tr><tr><td><strong>只读性</strong></td><td>可以通过 <code>@property</code> 实现只读</td><td>需要额外逻辑实现只读</td></tr><tr><td><strong>写操作</strong></td><td>通过 <code>@setter</code> 实现写操作</td><td>需要额外方法实现写操作</td></tr><tr><td><strong>删除操作</strong></td><td>通过 <code>@deleter</code> 实现删除操作</td><td>需要额外方法实现删除操作</td></tr></tbody></table><blockquote><p>The END</p><p>更多Python的高级操作的教程见后续的更新。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Code</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Finished</tag>
      
      <tag>Python</tag>
      
      <tag>Tutorial</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python-Tutorial</title>
    <link href="/posts/Python-tutorial/"/>
    <url>/posts/Python-tutorial/</url>
    
    <content type="html"><![CDATA[<style>  html, body, .markdown-body {    font-family: Georgia, sans, serif;  }</style><h1 id="Python-tutorial"><a href="#Python-tutorial" class="headerlink" title="Python tutorial"></a>Python tutorial</h1><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><h2 id="The-Zen-of-Python"><a href="#The-Zen-of-Python" class="headerlink" title="The Zen of Python"></a>The Zen of Python</h2>]]></content>
    
    
    <categories>
      
      <category>Code</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Announcement</tag>
      
      <tag>Python</tag>
      
      <tag>Tutorial</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux-Bash-Introduction</title>
    <link href="/posts/Linux-Bash-Introduction/"/>
    <url>/posts/Linux-Bash-Introduction/</url>
    
    <content type="html"><![CDATA[<p>封面出处：<a href="https://www.makeuseof.com/linux-bash-what-use-for/">Bash and Linux</a></p><style>  html, body, .markdown-body {    font-family: Georgia, sans, serif;  }</style><h1 id="Linux-and-Bash-Introduction"><a href="#Linux-and-Bash-Introduction" class="headerlink" title="Linux and Bash Introduction"></a>Linux and Bash Introduction</h1><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/3/35/Tux.svg/150px-Tux.svg.png" alt="Tux the penguin"></p><blockquote><p>思来想去还是用中文写吧。。。全英文的博客写作还需要一段时间来适应。</p><p>中文敲字是真的快。。。</p></blockquote><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>当你在网上下载软件时，你可能会看到这样的页面：</p><center><img src="https://s1.imagehub.cc/images/2025/02/14/590ddd670394edd6af67cae090b2d6fb.png" alt="Screenshot 2025 02 14 140426" border="0"></center><p><strong>Windows</strong> 和 <strong>MacOS</strong> 相信大家并不陌生，但中间这个有点蠢蠢的小企鹅是什么？这便是大名鼎鼎的 <strong>Linux</strong> 系统，本文将会介绍 <strong>有关Linux最基本的知识</strong>，以及从 <strong>Linux</strong> 延伸到 <strong>Bash</strong>等命令行工具，提供为CLI新手的导引。</p><h2 id="What-is-Linux"><a href="#What-is-Linux" class="headerlink" title="What is Linux"></a>What is Linux</h2><p>和 <strong>Windows</strong> 与 <strong>MacOS</strong>一样，<strong>Linux</strong>是一种 <strong>操作系统</strong>。（这里主要涉及 <strong>桌面操作系统</strong>，Linux也可以用于服务器部署和嵌入式开发等领域，此文不涉及）</p><p><strong>什么是操作系统</strong>？官方定义：</p><blockquote><p><strong>操作系统</strong>是是<strong>管理计算机硬件和软件资源的系统软件</strong>，它是计算机系统的核心组成部分。操作系统为用户和应用程序提供了一个与硬件交互的接口，同时负责管理计算机的资源，确保系统高效、稳定地运行。它的作用主要包括：</p><ul><li><strong>进程管理</strong></li><li><strong>内存管理</strong></li><li><strong>文件系统管理</strong></li><li><strong>设备管理</strong></li><li><strong>用户界面</strong><ul><li>命令行界面（CLI）</li><li>图形用户界面（GUI）</li></ul></li></ul></blockquote><p>换句话说，<strong>Operating System</strong>就像管家，负责管理计算机的<strong>硬件资源</strong>并与 <strong>软件程序</strong>沟通，让用户更方便的操作并使用计算机。通俗来说，你只需要使用电脑上的软件（例如点击图标，打字等），而不需要查看每一根内存条的使用情况，因为操作系统帮你完成了这一步。</p><p><strong>Linux</strong> 就是一个类 <strong>Unix</strong> 的操作系统，和Windows系统有很大的差异。</p><h3 id="Philosophy-of-Linux"><a href="#Philosophy-of-Linux" class="headerlink" title="Philosophy of Linux"></a>Philosophy of Linux</h3><p>Linux的哲学是Linux操作系统设计和使用的核心理念，它源于<strong>Unix哲学</strong>，并在此基础上发展出独特的思想体系。</p><blockquote><p><strong>Philosophy of Unix</strong> (from Wikipedia<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://en.wikipedia.org/wiki/Unix_philosophy">[2]</span></a></sup>)</p><p>The <strong>Unix philosophy</strong>, originated by <a href="https://en.wikipedia.org/wiki/Ken_Thompson">Ken Thompson</a>, is a set of cultural norms and philosophical approaches to <a href="https://en.wikipedia.org/wiki/Minimalism_(computing)">minimalist</a>, <a href="https://en.wikipedia.org/wiki/Modularity_(programming)">modular</a> <a href="https://en.wikipedia.org/wiki/Software_development">software development</a>. It is based on the experience of leading developers of the <a href="https://en.wikipedia.org/wiki/Unix">Unix</a> <a href="https://en.wikipedia.org/wiki/Operating_system">operating system</a>.</p><ol><li>Make each program <strong>do one thing well</strong>. To do a new job, build afresh rather than complicate old programs by adding new “features”.</li><li><strong>Expect the output of every program to become the input to another</strong>, as yet unknown, program. Don’t clutter output with extraneous information. Avoid stringently columnar or binary input formats. Don’t insist on interactive input.</li><li>Design and build software, even operating systems, to be tried early, ideally within weeks. Don’t hesitate to throw away the clumsy parts and rebuild them.</li><li>Use tools in preference to unskilled help to lighten a programming task, even if you have to detour to build the tools and expect to throw some of them out after you’ve finished using them.</li></ol></blockquote><p>Linux哲学的核心实现和Unix哲学差不了太多，即 <strong>简化</strong> 的思想渗透到方方面面，下面我们来逐条解释：</p><h4 id="✨一切皆文件"><a href="#✨一切皆文件" class="headerlink" title="✨一切皆文件"></a>✨一切皆文件</h4><p>Linux系统将几乎所有资源都抽象为<strong>文件</strong>，包括硬件设备、进程、网络连接等。这种设计使得用户可以通过统一的文件操作接口（如读写、权限管理）来管理系统的各种资源。例如：</p><ul><li>硬件设备：<code>/dev/sda</code> 表示硬盘设备。</li><li>进程信息：<code>/proc/</code> 目录下存储了运行中进程的信息。</li><li>网络连接：<code>/etc/hosts</code> 文件存储了主机名和IP地址的映射。</li></ul><p>这种设计简化了系统的复杂性，使得用户可以通过简单的命令行工具（如<code>cat</code>、<code>echo</code>）来操作各种资源。</p><p><strong>这是非常重要的一点！</strong>例如，很少有人会去C盘查看并且魔改自己的系统盘（当然很大一方面是因为Windows操作系统是闭源收费的），但是在Linux系统下，一切都被规整地以文件的形式摆放，<strong>你甚至可以使用命令行控制硬件！（例如调节屏幕亮度等与硬件直接关联的操作）</strong>。</p><h4 id="✨小即是美"><a href="#✨小即是美" class="headerlink" title="✨小即是美"></a>✨小即是美</h4><p>Linux鼓励使用小而专注的工具，每个工具只完成一个特定的任务，但可以高效地组合起来完成复杂的工作。例如：</p><ul><li><code>ls</code> 用于列出目录内容。</li><li><code>grep</code> 用于搜索文本。</li><li><code>awk</code> 用于处理文本数据。</li></ul><p>通过<strong>管道</strong>（<code>|</code>）将这些工具组合起来，可以实现强大的功能。</p><blockquote><p>这与Unix哲学的第二条不谋而合。</p></blockquote><h4 id="模块化设计"><a href="#模块化设计" class="headerlink" title="模块化设计"></a>模块化设计</h4><p>Linux系统由许多独立的模块组成，每个模块负责特定的功能。这种设计使得系统易于维护和扩展。例如：</p><ul><li>内核模块可以动态加载和卸载。</li><li>用户可以<strong>根据需要安装或卸载软件包</strong>。</li></ul><p>在Windows系统下，安装软件往往需要繁杂的<strong>安装向导</strong>步骤，但是在Linux系统下，几乎一条<code>sudo apt install XXX</code>就可以搞定一切安装。</p><h4 id="自由与开源"><a href="#自由与开源" class="headerlink" title="自由与开源"></a>自由与开源</h4><p><strong>Linux</strong> 是开源且免费的操作系统，<strong>所有源代码公开且任何人可以查看，修改，分发</strong>。</p><p>开源精神，伟大无需多言！</p><p><img src="https://data.crazyengineers.com/old-attachments/3/3041-Linus-Nvidia-fuck-you-portada2.jpg" alt="Linus-Nvidia-fuck-you-portada2"></p><h4 id="✨命令行优先（避免令人困惑的操作界面）"><a href="#✨命令行优先（避免令人困惑的操作界面）" class="headerlink" title="✨命令行优先（避免令人困惑的操作界面）"></a>✨命令行优先（避免令人困惑的操作界面）</h4><p>这一点是对Linux新手来说最重要的一点，也是最不适应的一点。（对于初学者）</p><p>举个例子，假设Xiyuan Yang需要制作PPT，他可能会使用 <strong>Powerpoint</strong> 或者 <strong>Slides</strong>进行幻灯片制作，效率很高，也很巴适。</p><p>但是情况并非如此，例如，Xiyuan Yang需要新建一份txt文件来储存自己的OpenAI的API密钥，如果他在Windows系统上，会需要哪几步呢？</p><blockquote><ul><li>首先在合适的目录下面新建一个新的目录</li><li>将新的目录重命名为<code>OpenAI_API_key</code></li><li>右键选择“新建”，找到“.txt”文件选项，命名为<code>API_key_1</code></li><li>使用文本编辑器打开这个文件，鼠标右键点击<strong>粘贴</strong></li><li>点击保存，然后退出文件</li></ul></blockquote><p>这个过程看似在30s内就能完成，但实际上还是相对比较繁琐，或者说，<strong>仍然有简化的余地</strong>。</p><p>什么叫 <strong>简化的余地</strong>？对于绝大部分时间，我们与电脑都是使用 <strong>图形交互页面</strong> 进行交互，我们在 <strong>可视化的电脑屏幕</strong> 上通过移动、点击鼠标或者键入键盘来实现我们需要的操作。<strong>图形界面</strong>意味着 <strong>更形象化的表示但同时带来冗余的信息</strong>。例如在上面的例子中，当你点击一个文件夹，GUI会显示这个文件夹中的所有文件（夹），这确实更加直观，但是<strong>显示的其他文件夹</strong>是冗余的信息，你并不想要看见他！（在这个任务中）举个更极端的例子，当你电脑开机，看见桌面的第一眼，信息的冗余就开始产生了，毕竟你还什么都没有做，就已经看见了放在桌面上的“多余信息”。</p><p>因此，<strong>Linux</strong>的设计哲学的核心之一就是 <strong>避免令人困惑的操作界面</strong>：更细致地来说就是<strong>使用命令行界面，同时显示极简的信息但又不失工作效率</strong>。通过命令行，用户可以精确控制系统，并编写脚本自动化任务。</p><p>这是我的Linux命令行页面，只会保留最基本的时间等基本信息。</p><img src="https://s1.imagehub.cc/images/2025/02/14/ba665b70f5a9490a8cb66cd3ede32390.png" alt="Screenshot 2025 02 14 235049" border="0"><p>对于上面的任务，在Linux中只需三行命令就可搞定：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-built_in">mkdir</span> Bash_exercise/syntax/Test_for_openAI_API<br><br><span class="hljs-built_in">ls</span> Bash_exercise/syntax/Test_for_openAI_API<br><br>vim API1.txt<br></code></pre></td></tr></table></figure><h4 id="避免重复造轮子"><a href="#避免重复造轮子" class="headerlink" title="避免重复造轮子"></a>避免重复造轮子</h4><p>这点对开发者来说很重要，使用现成的工具提高工作效率，把更多的精力专注于项目本身，这一点不多解释。</p><h3 id="Linux-Kernel-and-Releases"><a href="#Linux-Kernel-and-Releases" class="headerlink" title="Linux Kernel and Releases"></a>Linux Kernel and Releases</h3><p>上文提到过，<strong>操作系统最核心的功能之一就是和硬件进行交互</strong>。在Linux系统中，这个部分叫做<strong>内核</strong>。</p><blockquote><p>对于Linux新手，并不需要对Linux的内核有过多深入的了解。此处略过</p></blockquote><p><strong>Linux</strong>内核相当于一个操作系统的心脏，也是核心部分，但单单有一个心脏是不可行的，因此，Linux操作系统在内核之外，还需要预安装一些软件包和工具。在安装好之后便可以发行给大众使用了，而<strong>安装的软件包和工具</strong>，不同的开发者可以设计自己的软件包，因此便有了<strong>不同的Linux发行版</strong>。</p><p>以下是一些常见的Linux发行版：</p><ul><li><strong>Ubuntu</strong>：适合初学者，拥有庞大的社区支持。</li><li><strong>Fedora</strong>：由Red Hat支持，专注于新技术的采用。</li><li><strong>Debian</strong>：以稳定性和自由软件著称，是Ubuntu的基础。</li><li><strong>CentOS</strong>：基于Red Hat Enterprise Linux（RHEL），适合企业服务器。</li><li><strong>Arch Linux</strong>：面向高级用户，强调定制性和简洁性。</li></ul><h3 id="Why-Linux？"><a href="#Why-Linux？" class="headerlink" title="Why Linux？"></a>Why Linux？</h3><p>你说的对，但为什么我们要去使用Linux系统？</p><p>在半年前，当笔者第一次装好了虚拟机（现在换成WSL了），并且输入第一个<code>ls</code>命令的时候，脑中便不由自主地冒出这个问题。对于一个资深的开发者，这个问题简直就是玩笑话，他可以随意地列举出无数Linux在开发中优于Windows的理由，有关三大操作系统的鄙视链之争吵一直也没有停歇<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://www.zhihu.com/question/295142135">[1]</span></a></sup>。</p><p>因此，对于新手，对这个问题一直揪着不放是没有任何意义的？或者换句话说，<strong>对于绝大多数Linux的使用者</strong>，了解Linux的使用远比了解Linux的原理要重要得多。<strong>在上手实践中</strong>，你便会体会到Linux的强大之处。</p><p><strong>This is the art of the command line</strong>！</p><h2 id="Bash-and-Shell"><a href="#Bash-and-Shell" class="headerlink" title="Bash and Shell"></a>Bash and Shell</h2><h3 id="What-is-Shell"><a href="#What-is-Shell" class="headerlink" title="What is Shell?"></a>What is Shell?</h3><p><strong>Shell</strong> 是 Linux 和类 Unix 操作系统中的一个核心概念，它是<strong>用户与操作系统内核之间的桥梁</strong>。简单来说，Shell 是一个<strong>命令行解释器</strong>，它接收用户输入的命令，并将其传递给操作系统内核执行，然后将结果返回给用户。</p><p>在 Linux 中，有多种不同的 Shell，常见的有：</p><ul><li><strong>Bash（Bourne Again Shell）</strong>：最流行的 Shell，大多数 Linux 发行版的默认 Shell。</li><li><strong>Sh（Bourne Shell）</strong>：早期的 Shell，Bash 的前身。</li><li><strong>Zsh（Z Shell）</strong>：功能强大的 Shell，支持更丰富的自动补全和主题配置。</li><li><strong>Ksh（Korn Shell）</strong>：结合了 Bash 和 C Shell 的特性。</li><li><strong>Csh&#x2F;Tcsh（C Shell）</strong>：语法类似于 C 语言，适合有编程经验的用户。</li></ul><p>当然，Shell的概念也不只局限于类Unix系统，例如Windows系统的Powershell。</p><h2 id="Bash-Scripts"><a href="#Bash-Scripts" class="headerlink" title="Bash Scripts"></a>Bash Scripts</h2><p>上文介绍了Shell是命令行解释器，而如果我们希望实现<strong>自动化办公</strong>，我们就需要让Shell自动解释我们提前编写好的命令，这样就不用每一次都手动输入了。</p><p><strong>Bash 脚本</strong>（Bash Scripts）是用 Bash（Bourne Again Shell）编写的脚本文件，用于自动化执行一系列命令和任务。Bash 是 Linux 和类 Unix 系统中最常用的 Shell，而 Bash 脚本则是利用 Bash 的功能来实现复杂的操作、批量处理任务或系统管理。Bash 脚本的本质是一个<strong>文本文件</strong>，其中包含一系列 Bash 命令和控制结构（如条件判断、循环等），通过运行这个脚本文件，系统会逐行执行其中的命令。</p><blockquote><p>可以把Bash看做一门编程语言来使用！</p></blockquote><p>有关Bash脚本编写的具体内容见后期更新~</p><h1 id="Memo-for-Bash"><a href="#Memo-for-Bash" class="headerlink" title="Memo for Bash"></a>Memo for Bash</h1><blockquote><p>This section is being updated during my learning process of bash scripts.</p></blockquote><h2 id="Shortcut-in-Bash"><a href="#Shortcut-in-Bash" class="headerlink" title="Shortcut in Bash"></a>Shortcut in Bash</h2><h3 id="Cursor-Movement"><a href="#Cursor-Movement" class="headerlink" title="Cursor Movement"></a><strong>Cursor Movement</strong></h3><ul><li><p><strong>Ctrl + A</strong>: Move the cursor to the beginning of the line.</p></li><li><p><strong>Ctrl + E</strong>: Move the cursor to the end of the line.</p></li><li><p><strong>Alt + B</strong>: Move the cursor back one word. or <strong>Ctrl + &lt;-</strong>.</p></li><li><p><strong>Alt + F</strong>: Move the cursor forward one word.or <strong>Ctrl + -&gt;</strong>.</p></li><li><p><strong>Ctrl + XX</strong>: Toggle between the beginning of the line and the current cursor position.</p></li></ul><h3 id="Editing-Commands"><a href="#Editing-Commands" class="headerlink" title="Editing Commands"></a><strong>Editing Commands</strong></h3><ul><li><p><strong>Ctrl + U</strong>: Cut text from the cursor to the beginning of the line.</p></li><li><p><strong>Ctrl + K</strong>: Cut text from the cursor to the end of the line.</p></li><li><p><strong>Ctrl + W</strong>: Cut the word before the cursor.</p></li><li><p><strong>Alt + D</strong>: Cut the word after the cursor.</p></li><li><p><strong>Ctrl + Y</strong>: Paste the last cut text.</p></li><li><p><strong>Ctrl + T</strong>: Swap the last two characters before the cursor.</p></li><li><p><strong>Alt + T</strong>: Swap the current word with the previous word.</p></li></ul><h3 id="Command-History"><a href="#Command-History" class="headerlink" title="Command History"></a><strong>Command History</strong></h3><ul><li><p><strong>Ctrl + P</strong>: Move to the previous command in history (same as Up Arrow).</p></li><li><p><strong>Ctrl + N</strong>: Move to the next command in history (same as Down Arrow).</p></li><li><p><strong>Ctrl + R</strong>: Search command history interactively.</p></li><li><p><strong>Ctrl + G</strong>: Exit the history search mode.</p></li></ul><h3 id="Process-Control"><a href="#Process-Control" class="headerlink" title="Process Control"></a><strong>Process Control</strong></h3><ul><li><p><strong>Ctrl + C</strong>: Terminate the current process.</p></li><li><p><strong>Ctrl + Z</strong>: Suspend the current process.</p></li><li><p><strong>Ctrl + L</strong>: Clear the terminal screen.</p></li><li><p><strong>Ctrl + D</strong>: Exit the shell or close the terminal.</p></li></ul><h3 id="Miscellaneous"><a href="#Miscellaneous" class="headerlink" title="Miscellaneous"></a><strong>Miscellaneous</strong></h3><ul><li><p><strong>Ctrl + S</strong>: Pause terminal output (useful for stopping fast-scrolling text).</p></li><li><p><strong>Ctrl + Q</strong>: Resume terminal output after pausing.</p></li><li><p><strong>Ctrl + _</strong>: Undo the last change.</p></li><li><p><strong>Alt + .</strong>: Insert the last argument of the previous command.</p></li></ul><h3 id="Tab-Completion"><a href="#Tab-Completion" class="headerlink" title="Tab Completion"></a><strong>Tab Completion</strong></h3><ul><li><p><strong>Tab</strong>: Auto-complete file names, directories, or commands.</p></li><li><p><strong>Double Tab</strong>: Show all possible completions.</p></li></ul><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://www.zhihu.com/question/295142135">https://www.zhihu.com/question/295142135</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://en.wikipedia.org/wiki/Unix_philosophy">https://en.wikipedia.org/wiki/Unix_philosophy</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Efficient Tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tutorial</tag>
      
      <tag>Finished</tag>
      
      <tag>Bash</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Tools-Tutorial</title>
    <link href="/posts/Tools-Tutorial/"/>
    <url>/posts/Tools-Tutorial/</url>
    
    <content type="html"><![CDATA[<style>  html, body, .markdown-body {    font-family: Georgia, sans, serif;  }</style><h1 id="Tools-Tutorial-for-Computer-Science"><a href="#Tools-Tutorial-for-Computer-Science" class="headerlink" title="Tools Tutorial for Computer Science"></a>Tools Tutorial for Computer Science</h1><p><a href="https://developerguru.in/full_stack_development.php"><strong>封面出处</strong></a></p><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>In this article, you will learn a set of <strong>methodologies</strong> for using tools in computer science. It will teach you how to quickly get started and master the use of tools through <strong>practical approaches</strong>, while continuously improving your skills through ongoing practice.</p><h2 id="Table-of-contents"><a href="#Table-of-contents" class="headerlink" title="Table of contents"></a>Table of contents</h2><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>程序员之间很流行一句话，<strong>不要重复造轮子</strong>。</p><blockquote><p>造轮子其实是个很值得探讨的话题，有机会日后开一篇聊一聊~</p></blockquote><p>的确，作为轮子的<strong>使用者</strong>，我们不需要过分关注开发者所封装好的具体的实现细节，只需要掌握工具最基本的使用手段，就可以最大化地提升自己的效率。</p><p>然而，在实际的学习过程中时，笔者经常会为<strong>工具的学习</strong>而感到苦恼，比如：</p><ul><li>在<code>Github</code>上淘到一个很有意思的project，想开箱玩一玩，但是止步于<strong>读懂用户手册</strong>。</li><li>Be trapped in 各种讨人厌的配置环境和报错信息中。</li><li>尝试学习一项新技能，但发现这项技能需要许多的<strong>前置技能</strong>，导致迟迟无法获得学习的正向反馈，最后学习的热情被浇灭不了了之。</li><li>学习曲线过于陡峭，导致在使用初期开发效率<strong>不升反降</strong>。</li><li>学会了但总是没有养成经常使用的习惯，导致学了忘忘了学，每次需要一些命令还得很麻烦的问<code>GPT</code>。</li></ul><p>日后，在与其他同学的交流中，发现这样的问题并非个例，而是普遍存在的问题！在下文中，笔者将以<code>git</code>的学习历程为例，手把手搭建工具学习的高效方法论。在博客的最后，笔者将会对方法论作系统性的总结，并对上文提到的5个问题做针对性的解答。</p><h2 id="Basic-Principles"><a href="#Basic-Principles" class="headerlink" title="Basic Principles"></a>Basic Principles</h2><p>用12字概括这一套方法论，就是：</p><p><div style="width: 80%; margin: auto;"><strong style="color: red;    font-size: 30px;    "><b>提高效率，二八法则，基于实践。</b></strong></div></p><ul><li>提高效率：这是<strong>工具使用的目的</strong>。</li><li><strong>二八法则</strong>：这其实还是<strong>提高效率</strong>的另一种表达：花较短的时间学习工具20%的功能，便可以解决80%的问题。</li><li><strong>实践为王</strong>：工具使用的落脚点不是纸上谈兵而是具体落地到项目中去使用。</li></ul><h2 id="Showcasing-Usage-with-Git"><a href="#Showcasing-Usage-with-Git" class="headerlink" title="Showcasing Usage with Git"></a>Showcasing Usage with Git</h2><h3 id="Overall-Perception-of-Basic-information"><a href="#Overall-Perception-of-Basic-information" class="headerlink" title="Overall Perception of Basic information"></a>Overall Perception of Basic information</h3><p><span style="font-size: 14pt;"><strong><font  color="red">感知新内容的基本信息&amp;初步构建较为完整的知识网络</font></strong></span></p><p>学习新技能的第一步，就是<strong>很好的认识他</strong>！</p><p>这一点其实非常重要，而恰恰被网上天花乱坠的保姆级无脑手把手教程所忽略了，就是<strong>这个工具是怎么来的？为什么我们需要这一个工具？ <strong>这涉及到工具的根本属性：</strong>改善工作流，提高生产力</strong>。一切工具的使用都是基于这一点而出发的，换句话说，工具的使用都是为了<strong>解决现实生活中的实际问题</strong>。</p><p>因此，认识工具的第一步就是回答下面三个问题：</p><ul><li>这个工具是什么？用一句话概括展现其本质的属性。</li><li>这个工具是为了解决什么实际问题而存在的？</li><li>这个工具有什么用处？</li></ul><p>新的问题来了，我们该如何高效地获取上面这三个问题的答案？下文笔者将以<code>Git</code>做示范。</p><h4 id="What-is-Git"><a href="#What-is-Git" class="headerlink" title="What is Git?"></a>What is Git?</h4><p>如何迈出我们学习的第一步？那当然是从<strong>网上获取答案</strong>。在这一步，我们需要重点关注<strong><font  color="red">信息渠道来源的权威性和可解释性</font></strong>。下面分别阐述这两点。</p><h5 id="The-authority-of-information"><a href="#The-authority-of-information" class="headerlink" title="The authority of information"></a>The authority of information</h5><p> 我们上网搜索<code>Git</code>，以下三张图展示了不同搜索引擎的搜索结果：</p><p><img src="https://ooo.0x0.ooo/2025/01/11/OE9RXx.png" alt="Google Search"></p><p><img src="https://ooo.0x0.ooo/2025/01/11/OE94xj.png" alt="Bing Search"></p><p><img src="https://ooo.0x0.ooo/2025/01/11/OE9DJp.png" alt="Baidu Search"></p><p>我们发现很多全新的名词，<strong>现在看不懂没有关系</strong>，但至少我们发现了一个网站，<a href="https://git-scm.com/">https://git-scm.com</a> ，这个网站在三个搜索引擎的页面都出现了，足以证明其重要性。</p><blockquote><p>搜索引擎的选择其实也有很多学问，笔者的默认搜索引擎和浏览器是<strong>Bing</strong>浏览器，有时也会用Google浏览器（这个有时候需要一些魔法，个人感觉在日常使用上Bing已经完全足够了）。<strong>非常不建议各位使用百度或者360等软件作为主力搜索引擎去使用</strong>，广告弹窗太多并且推荐系统很垃圾。就像在上面展示的，百度的首个推送竟然是广告，并且也没有像Bing或Google这样的首页摘要供用户快速查询。</p></blockquote><p>打开这个网站，我们发现了新世界。</p><p>这就是<strong>Git</strong>的官方网站，在这里的信息代表着<strong>最新颖最权威</strong>的信息！没有经过任何转述的过程。这也是我们后续学习的<strong>主战场之一</strong>。</p><p><img src="https://ooo.0x0.ooo/2025/01/11/OE9EBY.png" alt="Git"></p><p>细看这个网站，貌似我们能够回答第一个问题了，<strong>这个工具是什么？</strong><code>Git</code>的官网给出了最权威并且也是最准确的解答：</p><blockquote><p>Git is a <a href="https://git-scm.com/about/free-and-open-source">free and open source</a> <strong>distributed version control system</strong> designed to handle everything from small to very large projects with speed and efficiency.</p><p>Git is <a href="https://git-scm.com/doc">easy to learn</a> and has a <a href="https://git-scm.com/about/small-and-fast">tiny footprint with lightning fast performance</a>. It outclasses SCM tools like Subversion, CVS, Perforce, and ClearCase with features like <a href="https://git-scm.com/about/branching-and-merging">cheap local branching</a>, convenient <a href="https://git-scm.com/about/staging-area">staging areas</a>, and <a href="https://git-scm.com/about/distributed">multiple workflows</a>.</p><p>贴心的附上中文翻译，不过学好英语还是很重要的哇！</p><p>Git 是一个<a href="https://git-scm.com/about/free-and-open-source">免费且开源</a>的<strong>分布式版本控制系统</strong>，旨在以速度和效率处理从小型到超大型的各种项目。</p><p>Git <a href="https://git-scm.com/doc">易于学习</a>，并且具有<a href="https://git-scm.com/about/small-and-fast">极小的资源占用和闪电般的性能</a>。它通过诸如<a href="https://git-scm.com/about/branching-and-merging">廉价的本地分支</a>、便捷的<a href="https://git-scm.com/about/staging-area">暂存区域</a>和<a href="https://git-scm.com/about/distributed">多种工作流程</a>等特性，超越了 Subversion、CVS、Perforce 和 ClearCase 等 SCM 工具。</p></blockquote><div class="note note-success">            <p><strong>锦囊妙计①：重视官方网站（权威性）</strong></p>          </div><h5 id="The-interpretability-of-information"><a href="#The-interpretability-of-information" class="headerlink" title="The interpretability of information"></a>The interpretability of information</h5><p>这看着很酷，不是吗？毕竟我们找到了一个“宝藏网站”，也知道了后续我们要在哪里学习。但是，<strong>Git</strong>的官方网站算是世界上写的<strong>最好的官方文档之一了</strong>，实际上很多项目的官方文档并不具备很高的<strong>可读性</strong>。</p><p>比如，下面是C++的官方文档，当时真的是对我幼小的心灵造成了降维打击。像这样的官方文档就会更加注重<strong>全面性和严谨性</strong>，受众群体是准专业开发者而非入门的新手菜鸟。而对于菜鸟来说，这个网站更多应该起到一种<strong>References</strong>的作用。</p><p><img src="https://ooo.0x0.ooo/2025/01/11/OE90Mc.png" alt="C Plus Plus"></p><blockquote><p>程序员最讨厌的四件事：写注释、写文档、别人不写注释、别人不写文档。‌</p></blockquote><p>又比如，其实你并不了解上文的<strong>distributed version control system</strong>到底是啥意思？这其实是因为我们缺乏一种<strong>可读性且直观性的解释</strong>。而<strong>生成式AI模型</strong>可以给我们带来生动形象的解释（信息的可解释性）。顺带的，我们也可以解决我们在最开始问的第二个问题，<strong>这个工具是为了解决什么实际问题而存在的？</strong></p><p>在这里各位不需要为AI工具的使用而发愁，我推荐使用GPT，Claude（这俩需要魔法），国内推荐<strong>DeepSeek，豆包，文心一言，天工AI等</strong>。笔者目前使用<code>GPT+Cursor+DeepSeek</code>的组合。下文的实例都将使用DeepSeek作为示范AI：</p><div class="note note-primary">            <p><strong>ChatBox with DeepSeek</strong></p><p><strong>Me</strong>: 请用通俗的语言解释一下Git是什么</p><hr><p><strong>DeepSeek</strong>: Git 是一个版本控制系统，简单来说，它就像是一个“时光机”，帮你记录和管理文件的变化。</p><p>举个例子：假设你在写一篇文章，每次修改后，Git 都会帮你保存一个“快照”。这样，如果你改错了内容，或者想看看之前的样子，Git 可以轻松帮你找回之前的版本。</p><p>Git 还特别适合多人协作。比如你和朋友一起写代码，Git 可以让你们同时工作，最后再把各自的修改合并到一起，避免混乱。</p><p>总结一下，Git 的主要功能就是：</p><ol><li>记录文件的变化历史。</li><li>方便多人协作。</li><li>随时回退到之前的版本。</li></ol><p>它广泛用于软件开发，但也可以用来管理任何类型的文件。</p><hr><p><strong>Me</strong>: Git在实际应用中会解决什么样的问题？</p><hr><p><strong>DeepSeek</strong>: Git 在实际应用中主要解决以下几类问题：</p><ol><li><p><strong>版本管理</strong></p><ul><li><strong>问题</strong>：在开发过程中，文件会不断修改，可能会遇到改错代码、误删文件，或者想找回之前某个版本的情况。</li><li><strong>Git 的解决方案</strong>：Git 会记录每次文件的变化，你可以随时查看历史版本，甚至回退到之前的某个状态。</li></ul><p><strong>例子</strong>：你写了一段代码，后来改坏了，可以用 Git 轻松找回之前的正确版本。</p></li><li><p><strong>多人协作</strong></p><ul><li><strong>问题</strong>：多人同时修改同一个文件时，容易产生冲突，或者不知道谁改了哪里。</li><li><strong>Git 的解决方案</strong>：Git 允许每个人在自己的分支上工作，最后将修改合并到一起。如果有冲突，Git 会提示你解决。</li></ul><p><strong>例子</strong>：你和同事同时开发一个功能，Git 可以帮助你们合并代码，避免覆盖对方的工作。</p></li><li><p><strong>代码备份</strong></p><ul><li><strong>问题</strong>：代码只存在本地电脑上，如果电脑坏了或文件丢失，工作成果就没了。</li><li><strong>Git 的解决方案</strong>：Git 可以将代码上传到远程仓库（如 GitHub、GitLab），实现备份和共享。</li></ul><p><strong>例子</strong>：你可以把代码推送到 GitHub，这样即使电脑出问题，代码也不会丢失。</p></li><li><p><strong>分支管理</strong></p><ul><li><strong>问题</strong>：在开发新功能或修复 bug 时，直接修改主代码可能会影响正在运行的程序。</li><li><strong>Git 的解决方案</strong>：Git 支持创建分支，你可以在新分支上开发，完成后再合并到主分支。</li></ul><p><strong>例子</strong>：你想开发一个新功能，可以创建一个新分支，完成后测试无误再合并到主分支。</p></li><li><p><strong>追踪改动</strong></p><ul><li><strong>问题</strong>：修改代码后，很难记住具体改了哪些地方，为什么要改。</li><li><strong>Git 的解决方案</strong>：Git 会记录每次改动的具体内容，并且你可以为每次改动添加注释（commit message），方便以后查看。</li></ul><p><strong>例子</strong>：你可以通过 Git 查看某次改动的具体内容，了解为什么修改了某段代码。</p></li><li><p><strong>代码审查</strong></p><ul><li><strong>问题</strong>：多人协作时，如何确保代码质量？</li><li><strong>Git 的解决方案</strong>：通过 Git 的 Pull Request（PR）功能，其他人可以查看你的代码改动并提出建议。</li></ul><p><strong>例子</strong>：你完成一个功能后，发起 PR，同事可以检查代码并提出改进意见。</p></li></ol><p><strong>总结</strong></p><p>Git 主要解决了以下问题：</p><ul><li>版本丢失或混乱。</li><li>多人协作时的冲突。</li><li>代码备份和共享。</li><li>开发新功能时的风险隔离。</li><li>追踪改动和代码审查。</li></ul><p>无论是个人项目还是团队协作，Git 都是提高效率、降低风险的重要工具。</p><hr><p><strong>Me</strong>: Git的官网上解释的是distributed version control system，你能用通俗的语言解释一下吗</p><hr><p><strong>DeepSeek</strong>: 当然可以！Git 官网说它是一个 <strong>“分布式版本控制系统”</strong>，听起来有点复杂，但其实很简单。我们可以拆开来看：</p><ol><li><strong>版本控制系统</strong></li></ol><p>Git 是一个用来管理文件变化的工具。比如你写代码或文档，每次修改后，Git 都会帮你保存一个“快照”。这样，你可以随时查看之前的内容，或者回退到某个历史版本。</p><ol start="2"><li><strong>分布式</strong></li></ol><p>这是 Git 最特别的地方。传统的版本控制系统（比如 SVN）是 <strong>集中式</strong> 的，所有文件的历史版本都存放在一个中央服务器上。如果服务器坏了，大家就没法工作了。</p><p>而 Git 是 <strong>分布式</strong> 的，意思是：</p><ul><li>每个人电脑上都有一个完整的仓库（包括所有文件的历史记录）。</li><li>你不需要依赖中央服务器，可以在本地完成大部分操作（比如查看历史、创建分支、提交改动等）。</li><li>你可以随时和其他人的仓库同步，交换改动。</li></ul><p>举个例子：</p><p>假设你和朋友一起写代码：</p><ol><li>你用 Git 把整个项目（包括所有历史记录）复制到自己的电脑上。</li><li>你在本地修改代码，Git 帮你记录每次改动。</li><li>你朋友也在他的电脑上修改代码，Git 也帮他记录。</li><li>你们各自完成后，可以把改动同步到一起。</li></ol><p>即使没有网络，你也可以在本地工作，等有网了再同步。如果中央服务器坏了，你们每个人的电脑上都有完整的备份，不会丢失数据。</p><p>总结</p><p>“分布式版本控制系统” 就是：</p><ul><li><strong>版本控制</strong>：帮你记录文件的变化历史。</li><li><strong>分布式</strong>：每个人电脑上都有完整的仓库，不依赖中央服务器，更灵活、更安全。</li></ul><p>Git 的这种设计让它特别适合个人开发、团队协作，甚至是开源项目的全球协作（比如 Linux 内核开发）。</p>          </div><p>我在这里问了AI三个问题，<strong>他直接解决了我的所有问题！！！</strong>可谓是强大至极。我不仅知道了Git官网中的“分布式版本控制系统”是什么意思，还知道了Git在日常用途中经常使用在哪些场景中，Git能够解决哪些生活中的实际问题。</p><div class="note note-success">            <p><strong>锦囊妙计②：善用AI工具（可解释性）</strong></p><p>当你束手无策的时候，不妨和AI聊聊天，对于入门级别的工具教程而言，AI已经能够做的比大部分人类教程要好了。</p><div class="note note-danger">            <p>注意，不要产生对<strong>AI</strong>的过度依赖心理！AI的输出并不保证绝对的正确性，尤其是在涉及更深层次问题的时候。因此，<strong>极度不推荐</strong>完全借助AI的力量来学习工具！这往往会带来很严重的隐患，作为一个学习者的身份，你根本无法判断AI生成的内容到底是正确的还是胡说八道。相反，将AI作为工具辅助学习才是最为高效且安全的选择。</p>          </div>          </div><p>至此，以下三个问题的答案，已经如何找到以下三个问题答案的答案，已经被我们找到了：</p><ul><li>这个工具是什么？用一句话概括展现其本质的属性。<ul><li>分布式版本控制系统，记录文件变化历史。</li></ul></li><li>这个工具是为了解决什么实际问题而存在的？<ul><li>管理文件版本，避免丢失，支持多人协作。</li></ul></li><li>这个工具有什么用处？<ul><li>备份代码、回退版本、分支管理、团队协作。</li></ul></li></ul><div class="note note-info">            <p><strong>Period 1:</strong> 学习最基本的框架知识，经典三连问。</p><p><strong>学习时间</strong>：&lt;1h（熟练起来20分钟足矣）</p><p><strong>关键</strong>：</p><ul><li>把握官方网站和一些权威途径（权威性）</li><li>善于使用AI工具（可解释性）</li></ul>          </div><h3 id="Quick-Start-for-a-project"><a href="#Quick-Start-for-a-project" class="headerlink" title="Quick Start for a project"></a>Quick Start for a project</h3><ul><li><p>借助他人使用的轮子的力量</p></li><li><p>借助典型示例快速上手一个project</p></li><li><p><strong>最重要的部分</strong></p><p><span style="font-size: 18pt;"><strong><font  color="red">以实战项目为最好的教材，在实践中学习代码（知识）是怎么实现的</font></strong></span></p></li></ul><p>在掌握最基本的概念之后，我们需要<strong>使用这个工具</strong>，这也是一整套方法论中最关键的部分：<strong>实践永远放在第一位</strong>！</p><h4 id="Which-materials-to-choose"><a href="#Which-materials-to-choose" class="headerlink" title="Which materials to choose?"></a>Which materials to choose?</h4><p>最初的学习总是从<strong>模仿</strong>开始的，而一个<strong>从零开始</strong>的教程往往更加重要。</p><h3 id="From-imitating-to-modifying-and-enhancing"><a href="#From-imitating-to-modifying-and-enhancing" class="headerlink" title="From imitating to modifying and enhancing"></a>From imitating to modifying and enhancing</h3><ul><li>在精读完示例project后，可以尝试开始 <strong>模仿</strong></li><li><strong>模仿————修改————优化</strong></li><li>不断地发现问题，解决问题！</li></ul><h3 id="Diving-into-principles"><a href="#Diving-into-principles" class="headerlink" title="Diving into principles"></a>Diving into principles</h3><ul><li>在这个阶段，已经初步具备构建工程的基本能力，但仍需要进一步掌握<strong>底层原理和一些更高级更进阶的用法（自主性和创新性）</strong></li><li>可以在开源网站上学习他人的成果</li><li>尝试阅读官方文件或者一些底层文件</li><li>对底层原理的学习往往是枯燥的，<strong>对于工程实践来说初期永远是实践最重要，对于原理层面起到锦上添花的作用，目的在于为我们后续的个性化创新奠定基础。</strong></li></ul><h3 id="Occasional-Backtracking"><a href="#Occasional-Backtracking" class="headerlink" title="Occasional Backtracking"></a>Occasional Backtracking</h3><ul><li><strong>经典回读</strong>！！！</li><li>1-2-3-4往往是循环的过程，在哪一步都会受挫，理性分析，适当求助，疯狂拷打ChatGPT</li></ul><h2 id="Conclusion-and-Notice"><a href="#Conclusion-and-Notice" class="headerlink" title="Conclusion and Notice"></a>Conclusion and Notice</h2><ul><li>这一套方法论并不代表不重视<strong>基础原理</strong>，相反，如果你想要做出真正自己的原创，肯定还是需要熟练掌握底层原理（至少大部分）的。</li><li>先有<strong>Intuition</strong>，再有<strong>Implementation</strong>，最后再慢慢填补剩下的原理等层面，不断的产生新的感悟。</li><li><strong>不要怕重复训练</strong>，很多事情在做第二遍第三遍是收获的效果要远远高于第一遍。</li><li><strong>不要过度依赖AI</strong>，自身能力的捶打是需要自己不断实现的，参考 <a href="https://nmn.gl/blog/ai-and-learning">这一篇文章</a>。</li></ul><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p><a href="https://git-scm.com/docs">Git documentation</a></p><p style="text-align: center;">    <span style="font-size: 30pt;">        <strong>            <font  color="red">                Be a Life-long Learner            </font>        </strong>    </span></p>]]></content>
    
    
    <categories>
      
      <category>Efficient Tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tutorial</tag>
      
      <tag>Finished</tag>
      
      <tag>Methodologies</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Jotting-References-and-Encapsulation-in-OOP</title>
    <link href="/posts/Jotting-References-and-Encapsulation-in-OOP/"/>
    <url>/posts/Jotting-References-and-Encapsulation-in-OOP/</url>
    
    <content type="html"><![CDATA[<style>  html, body, .markdown-body {    font-family: Georgia, sans, serif;  }</style><h1 id="Jotting-References-and-Encapsulation-in-OOP"><a href="#Jotting-References-and-Encapsulation-in-OOP" class="headerlink" title="[Jotting] References and Encapsulation in OOP"></a>[Jotting] References and Encapsulation in OOP</h1><h2 id="About-Jotting"><a href="#About-Jotting" class="headerlink" title="About Jotting"></a>About Jotting</h2><div class="note note-primary">            <p>“Jotting” means quickly writing down short notes or ideas. It’s often used for informal, brief records, like reminders or thoughts.</p>          </div><p>在<strong>Jotting</strong>栏目中，我将以<strong>碎片化</strong>的方式记录我在学习过程中遇到的一个个小问题，他们之间具有独立性，各自是一个个小专题，但是<strong>有具有更深层次的共性</strong>。因此，本栏目的初衷就是在<strong>解决这一个个小专题的过程中，尝试提炼其最本质的“第一性原理”</strong>，进而有助于构建在宏观上的知识框架。</p><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>In this blog, we will start with the design of a <strong>vector</strong> class, exploring the implementation details of defining member functions as <strong>const references and non-const references</strong>, as well as their practical applications in <strong>operator overloading</strong>, <strong>setting friend functions</strong>, <strong>constructors</strong>, and more. On a deeper level, this article uses this example to discuss the trade-offs between the <strong>encapsulation philosophy and flexibility</strong> in OOP.</p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>在昨天的C++作业中，笔者做到了一道很经典的面向对象的设计题：<strong>设计向量类并实现对应的功能</strong>。下文贴出题目和已经通过测试样例的代码。</p><blockquote><p><strong>题目：</strong>本关任务：定义一个向量类MyVect，分量为整数，向量维数作为其数据成员，除了实现构造函数、析构函数、拷贝构造函数，还能够 </p><ul><li>重载加法：对应分量相加，假设总是维数相同的两个向量相加 </li><li>重载[]：取相应分量 </li><li>重载输入输出 </li><li>重载&#x3D;、&#x3D;&#x3D;、!&#x3D; </li><li>重载++、–：对所有分量做++和–</li><li>输出向量范数(L2范数) 若将向量赋值给一个double型数，则表示求其范数(L2范数) </li><li>能够知道程序目前存活的向量数 </li><li>输出向量维数</li></ul></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @Author: Xiyuan Yang   xiyuan_yang@outlook.com</span><br><span class="hljs-comment"> * @Date: 2024-11-11 21:10:22</span><br><span class="hljs-comment"> * @LastEditors: Xiyuan Yang   xiyuan_yang@outlook.com</span><br><span class="hljs-comment"> * @LastEditTime: 2024-12-30 14:56:27</span><br><span class="hljs-comment"> * @FilePath: \CODE_for_Vscode\C++_project\testcode_4.cpp</span><br><span class="hljs-comment"> * @Description: </span><br><span class="hljs-comment"> * Do you code and make progress today?</span><br><span class="hljs-comment"> * Copyright (c) 2024 by Xiyuan Yang, All Rights Reserved. </span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyVect</span>&#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> numbers;<br>    <span class="hljs-type">int</span> size;<br>    <span class="hljs-type">int</span> *array;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">MyVect</span>()&#123;<br>            numbers++;<br>        &#125;<br>        <span class="hljs-built_in">MyVect</span>(<span class="hljs-type">int</span> n):<span class="hljs-built_in">size</span>(n)&#123;<br>            array=<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[size];<br>            numbers++;<br>        &#125;<br>        <span class="hljs-built_in">MyVect</span>(<span class="hljs-type">const</span> MyVect&amp; x)&#123;<br>            size=x.size;<br>            array=<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[size];<br>            numbers++;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;<br>                array[i]=x.array[i];<br>            &#125;<br>        &#125;<br>        ~<span class="hljs-built_in">MyVect</span>()&#123;<br>            numbers--;<br>            <span class="hljs-keyword">delete</span>[] array;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getlength</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> size;&#125;<br>        <span class="hljs-function"><span class="hljs-type">int</span>* <span class="hljs-title">getarray</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<span class="hljs-keyword">return</span> array;&#125;<br>        <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">getnorm</span><span class="hljs-params">()</span></span>&#123;<br>            <span class="hljs-type">double</span> sum=<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;<br>                sum+=(array[i])*array[i];<br>            &#125;<br>            sum=<span class="hljs-built_in">sqrt</span>(sum);<br>            <span class="hljs-keyword">return</span> sum;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">getliving</span><span class="hljs-params">()</span></span>;<br>        <span class="hljs-type">int</span> <span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> x)&#123;<span class="hljs-keyword">return</span> array[x];&#125;<br>        MyVect&amp; <span class="hljs-keyword">operator</span>++()&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;<br>                array[i]++;<br>            &#125;<br>            <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>        &#125;<br>        MyVect <span class="hljs-keyword">operator</span>++(<span class="hljs-type">int</span> x)&#123;<br>            MyVect temp=*<span class="hljs-keyword">this</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;<br>                array[i]++;<br>            &#125;<br>            <span class="hljs-keyword">return</span> temp;<br>        &#125;<br>        MyVect <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> MyVect &amp;x);<br>        <span class="hljs-keyword">friend</span> istream&amp; <span class="hljs-keyword">operator</span>&gt;&gt;(istream&amp; is,MyVect&amp; x);<br>        <span class="hljs-keyword">friend</span> ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; os,<span class="hljs-type">const</span> MyVect&amp; x);<br>        <span class="hljs-keyword">friend</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(MyVect&amp;x1,MyVect&amp;x2);<br>        <span class="hljs-keyword">friend</span> MyVect <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> MyVect&amp;x1,<span class="hljs-type">const</span> MyVect&amp;x2);<br>        <span class="hljs-type">double</span> <span class="hljs-keyword">operator</span>-(<span class="hljs-type">double</span> minus)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">getnorm</span>()-minus;<br>        &#125;;<br>&#125;;<br><br><span class="hljs-type">int</span> MyVect::numbers=<span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">MyVect::getliving</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> numbers;<br>&#125;<br><br>istream&amp; <span class="hljs-keyword">operator</span>&gt;&gt;(istream&amp; is,MyVect&amp; x)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;x.size;i++)&#123;<br>        is&gt;&gt;x.array[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> is;<br>&#125;<br><br>ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; os,<span class="hljs-type">const</span> MyVect&amp; x)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;x.size;i++)&#123;<br>        os&lt;&lt;x.array[i];<br>        <span class="hljs-keyword">if</span>(i!=x.size<span class="hljs-number">-1</span>) os&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> os;<br>&#125;<br><br>MyVect <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> MyVect&amp;x1,<span class="hljs-type">const</span> MyVect&amp;x2)&#123;<br>    <span class="hljs-function">MyVect <span class="hljs-title">temp</span><span class="hljs-params">(x<span class="hljs-number">1.</span>size)</span></span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;x<span class="hljs-number">1.</span>size;i++)&#123;<br>        temp.array[i]=x<span class="hljs-number">1.</span>array[i]+x<span class="hljs-number">2.</span>array[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> temp;<br>&#125;<br><br><br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(MyVect&amp;x1,MyVect&amp;x2)&#123;<br>    <span class="hljs-keyword">if</span>(x<span class="hljs-number">1.</span>size!=x<span class="hljs-number">2.</span>size)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;x<span class="hljs-number">1.</span>size;i++)&#123;<br>        <span class="hljs-keyword">if</span>(x<span class="hljs-number">1.</span>array[i]!=x<span class="hljs-number">2.</span>array[i])&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br>MyVect MyVect::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> MyVect &amp;x)&#123;<br>            <span class="hljs-keyword">if</span>((<span class="hljs-keyword">this</span>)==&amp;x)&#123;<br>                <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">delete</span>[] array;<br>            size=x.size;<br>            array=<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[size];<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;<br>                array[i]=x.array[i];<br>            &#125;<br>            <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>        &#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-function">MyVect <span class="hljs-title">v1</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-type">double</span> x;<br>    cin &gt;&gt; v1;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Now v1 is: &quot;</span>&lt;&lt; v1 &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;The length of v1 is &quot;</span> &lt;&lt; v<span class="hljs-number">1.</span><span class="hljs-built_in">getlength</span>() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;The norm of v1 is &quot;</span> &lt;&lt; v<span class="hljs-number">1.</span><span class="hljs-built_in">getnorm</span>() &lt;&lt; endl;<br>    x = v1 - <span class="hljs-number">1.0</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;The norm of v1 minus 1 is &quot;</span> &lt;&lt; x &lt;&lt; endl;<br>    MyVect v2 = v1;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Now v2 is: &quot;</span> &lt;&lt; v2 &lt;&lt; endl;<br>    <span class="hljs-comment">//cout &lt;&lt; &quot;The number of vectors is: &quot; &lt;&lt; v1.getcount() &lt;&lt; endl;</span><br>    cout &lt;&lt; endl;<br>    &#123;<br>        <span class="hljs-function">MyVect <span class="hljs-title">v3</span><span class="hljs-params">(n)</span></span>;<br>        v3= v1 + v2;<br>        cout &lt;&lt; <span class="hljs-string">&quot;The result of v1+v2 is: &quot;</span> &lt;&lt; v3 &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">&quot;The 1st element of v3 is &quot;</span> &lt;&lt; v3[<span class="hljs-number">1</span>] &lt;&lt; endl;<br>        <span class="hljs-comment">//cout &lt;&lt; &quot;The number of vectors is: &quot; &lt;&lt; MyVect::getcount() &lt;&lt; endl;</span><br>    &#125;<br>    cout &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;The number of living vectors is: &quot;</span> &lt;&lt; v<span class="hljs-number">1.</span><span class="hljs-built_in">getliving</span>() &lt;&lt; endl;<br>    <span class="hljs-comment">//cout &lt;&lt; &quot;The number of total vector is: &quot; &lt;&lt; v1.getcount() &lt;&lt; endl;</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;The result of v1++ is: &quot;</span> &lt;&lt; v1++ &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;The result of v1==v2 is &quot;</span> &lt;&lt; (v1==v2) &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;The result of ++v2 is: &quot;</span> &lt;&lt; ++v2 &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;The result of v1==v2 is &quot;</span> &lt;&lt; (v1==v2) &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>具体的实现其实并不麻烦，只是代码的工程量很大。不过，笔者在重载++运算符的时候遇到了一些麻烦。</p><p>回顾**<a href="https://xiyuanyang-code.github.io/posts/Introduction-to-OOP/">笔者之前写的博客</a><strong>，这是</strong>重载++&#x2F;–运算符的方法**：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @Author: Xiyuan Yang   xiyuan_yang@outlook.com</span><br><span class="hljs-comment"> * @Date: 2024-11-11 21:10:21</span><br><span class="hljs-comment"> * @LastEditors: Xiyuan Yang   xiyuan_yang@outlook.com</span><br><span class="hljs-comment"> * @LastEditTime: 2024-12-30 14:04:15</span><br><span class="hljs-comment"> * @FilePath: \CODE_for_Vscode\C++_project\testcode_5.cpp</span><br><span class="hljs-comment"> * @Description: </span><br><span class="hljs-comment"> * Do you code and make progress today?</span><br><span class="hljs-comment"> * Copyright (c) 2024 by Xiyuan Yang, All Rights Reserved. </span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> value;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 构造函数</span><br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">int</span> v) : <span class="hljs-built_in">value</span>(v) &#123;&#125;<br><br>    <span class="hljs-comment">// 前缀 ++ 运算符重载</span><br>    MyClass&amp; <span class="hljs-keyword">operator</span>++() &#123;<br>        ++value;  <span class="hljs-comment">// 增加成员变量 value</span><br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;  <span class="hljs-comment">// 返回当前对象的引用</span><br>    &#125;<br><br>    <span class="hljs-comment">// 前缀 -- 运算符重载</span><br>    MyClass&amp; <span class="hljs-keyword">operator</span>--() &#123;<br>        --value;  <span class="hljs-comment">// 减少成员变量 value</span><br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;  <span class="hljs-comment">// 返回当前对象的引用</span><br>    &#125;<br><br>    <span class="hljs-comment">// 后缀 ++ 运算符重载</span><br>    MyClass <span class="hljs-keyword">operator</span>++(<span class="hljs-type">int</span>) &#123;<br>        MyClass temp = *<span class="hljs-keyword">this</span>;  <span class="hljs-comment">// 保存当前值</span><br>        ++value;  <span class="hljs-comment">// 增加成员变量 value</span><br>        <span class="hljs-keyword">return</span> temp;  <span class="hljs-comment">// 返回原对象</span><br>    &#125;<br><br>    <span class="hljs-comment">// 后缀 -- 运算符重载</span><br>    MyClass <span class="hljs-keyword">operator</span>--(<span class="hljs-type">int</span>) &#123;<br>        MyClass temp = *<span class="hljs-keyword">this</span>;  <span class="hljs-comment">// 保存当前值</span><br>        --value;  <span class="hljs-comment">// 减少成员变量 value</span><br>        <span class="hljs-keyword">return</span> temp;  <span class="hljs-comment">// 返回原对象</span><br>    &#125;<br><br>    <span class="hljs-comment">// 显示值</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Value: &quot;</span> &lt;&lt; value &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">MyClass <span class="hljs-title">obj1</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span>,<span class="hljs-title">obj2</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br>    cout&lt;&lt;<span class="hljs-string">&quot;++ in the front:&quot;</span>&lt;&lt;endl;<br>    (++obj1).<span class="hljs-built_in">display</span>();<br><br>    cout&lt;&lt;<span class="hljs-string">&quot;++ in the back:&quot;</span>&lt;&lt;endl;<br>    (obj2++).<span class="hljs-built_in">display</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">输出：</span><br><span class="hljs-comment">++ in the front:</span><br><span class="hljs-comment">Value: 11</span><br><span class="hljs-comment">++ in the back:</span><br><span class="hljs-comment">Value: 10</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>如果仔细比较<code>++/--</code>运算符的重载过程，我们会发现在函数定义的时候主要有以下几点的不同：</p><ul><li>后缀运算符重载的时候需要<code>(int)</code>作为一个参数列表，方便编译器区分。</li><li>后缀运算符返回的是一个**<code>MyClass</code>对象<strong>，而前缀运算符返回的是对一个</strong><code>MyClass</code>对象的引用**。</li></ul><p>下面我们来重点讨论第二条，即这篇博客的第一个重点内容：<strong>关于对象的引用。</strong></p><h2 id="The-References-of-an-object"><a href="#The-References-of-an-object" class="headerlink" title="The References of an object"></a>The References of an object</h2><p>为什么前缀和后缀运算符的<strong>返回值不相同</strong>？因为编译器实现这两种运算的操作不同。前缀运算是返回自增之后的</p><p>值，需要返回对对象的引用，这是为了支持<strong>链式操作</strong>和<strong>一致性</strong>。例如<code>(++(++obj));</code></p><p>那<strong>后置运算符</strong>呢？在我们重载的后置运算符中，我们先新建一个temp对象来储存原来对象的值，之后对对象做<strong>自增运算</strong>，然后返回temp对象的值，这样就实现了<strong>返回递增前对象的值</strong>。</p><p>所以，在使用<strong>后置自增运算符的过程中</strong>，我们实际上返回的是<strong>临时变量的值</strong>，因此<strong>不可以返回对对象的引用，因为对临时对象的引用会导致悬挂指针等严重的问题</strong>。（临时对象在传完值后就会被销毁，此时在对他进行引用操作是没有意义且极其危险的。）</p><p>如果读者还对这一部分有些疑惑的话，不妨看看下面的代码示例，以下的代码通过<strong>显式定义三种构造函数</strong>来监控临时对象的构造和析构。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @Author: Xiyuan Yang   xiyuan_yang@outlook.com</span><br><span class="hljs-comment"> * @Date: 2024-11-11 21:10:21</span><br><span class="hljs-comment"> * @LastEditors: Xiyuan Yang   xiyuan_yang@outlook.com</span><br><span class="hljs-comment"> * @LastEditTime: 2024-12-30 14:24:24</span><br><span class="hljs-comment"> * @FilePath: \CODE_for_Vscode\C++_project\testcode_5.cpp</span><br><span class="hljs-comment"> * @Description: </span><br><span class="hljs-comment"> * Do you code and make progress today?</span><br><span class="hljs-comment"> * Copyright (c) 2024 by Xiyuan Yang, All Rights Reserved. </span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> value;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 构造函数</span><br>    <span class="hljs-built_in">MyClass</span>()&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;Create a new object with default constructor&quot;</span>&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">int</span> v) : <span class="hljs-built_in">value</span>(v) &#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;Create a new object!&quot;</span>&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">const</span> MyClass&amp; x)&#123;<br>        value=x.value;<br>        cout&lt;&lt;<span class="hljs-string">&quot;Create a new object with copy constructor&quot;</span>&lt;&lt;endl;<br>    &#125;<br>    ~<span class="hljs-built_in">MyClass</span>()&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;The object destroyed&quot;</span>&lt;&lt;endl;<br>    &#125;<br><br>    <span class="hljs-comment">// 前缀 ++ 运算符重载</span><br>    MyClass&amp; <span class="hljs-keyword">operator</span>++() &#123;<br>        ++value;  <span class="hljs-comment">// 增加成员变量 value</span><br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;  <span class="hljs-comment">// 返回当前对象的引用</span><br>    &#125;<br><br>    <span class="hljs-comment">// 前缀 -- 运算符重载</span><br>    MyClass&amp; <span class="hljs-keyword">operator</span>--() &#123;<br>        --value;  <span class="hljs-comment">// 减少成员变量 value</span><br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;  <span class="hljs-comment">// 返回当前对象的引用</span><br>    &#125;<br><br>    <span class="hljs-comment">// 后缀 ++ 运算符重载</span><br>    MyClass <span class="hljs-keyword">operator</span>++(<span class="hljs-type">int</span>) &#123;<br>        MyClass temp = *<span class="hljs-keyword">this</span>;  <span class="hljs-comment">// 保存当前值</span><br>        ++value;  <span class="hljs-comment">// 增加成员变量 value</span><br>        <span class="hljs-keyword">return</span> temp;  <span class="hljs-comment">// 返回原对象</span><br>    &#125;<br><br>    <span class="hljs-comment">// 后缀 -- 运算符重载</span><br>    MyClass <span class="hljs-keyword">operator</span>--(<span class="hljs-type">int</span>) &#123;<br>        MyClass temp = *<span class="hljs-keyword">this</span>;  <span class="hljs-comment">// 保存当前值</span><br>        --value;  <span class="hljs-comment">// 减少成员变量 value</span><br>        <span class="hljs-keyword">return</span> temp;  <span class="hljs-comment">// 返回原对象</span><br>    &#125;<br><br>    <span class="hljs-comment">// 显示值</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Value: &quot;</span> &lt;&lt; value &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">MyClass <span class="hljs-title">obj3</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br>    obj<span class="hljs-number">3.</span><span class="hljs-built_in">display</span>();<br>    (obj3++).<span class="hljs-built_in">display</span>();<br>    ((obj3++)++).<span class="hljs-built_in">display</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">Create a new object!</span><br><span class="hljs-comment">Value: 10</span><br><span class="hljs-comment">Create a new object with copy constructor</span><br><span class="hljs-comment">Value: 10</span><br><span class="hljs-comment">The object destroyed</span><br><span class="hljs-comment">Create a new object with copy constructor</span><br><span class="hljs-comment">Create a new object with copy constructor</span><br><span class="hljs-comment">Value: 11</span><br><span class="hljs-comment">The object destroyed</span><br><span class="hljs-comment">The object destroyed</span><br><span class="hljs-comment">The object destroyed</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h3 id="Facing-the"><a href="#Facing-the" class="headerlink" title="Facing the &lt;&lt; operator"></a>Facing the <code>&lt;&lt;</code> operator</h3><p>因为临时变量对<strong>等待赋值运算符将值拷贝成功后再被销毁</strong>（如果涉及到指针对象，需要重载赋值运算符），因此仅仅在<strong>值</strong>的使用上，上文的代码能够相安无事。（输出结果的正确性也印证了这一点）。不过，只要我们对代码做一些小小的修改，我们就会发现很多有趣的bug（或者说是<strong>冲突</strong>）就出现了。</p><p>做什么修改呢？我们重载<strong>流输出运算符</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">friend</span> ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; os,MyClass&amp; x)&#123;<br>        os&lt;&lt;x.value;<br>        <span class="hljs-keyword">return</span> os;<br>    &#125;<br><span class="hljs-comment">//这是使用非 const引用</span><br></code></pre></td></tr></table></figure><p>接下来我们修改main函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">MyClass <span class="hljs-title">obj3</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br>    obj<span class="hljs-number">3.</span><span class="hljs-built_in">display</span>();<br>    (obj3++).<span class="hljs-built_in">display</span>();<br>    ((obj3++)++).<span class="hljs-built_in">display</span>();<br><br>    cout&lt;&lt;<span class="hljs-string">&quot;Now lets look at the obj4&quot;</span>&lt;&lt;endl;<br>    <span class="hljs-function">MyClass <span class="hljs-title">obj4</span><span class="hljs-params">(<span class="hljs-number">100</span>)</span></span>;<br>    cout&lt;&lt;<span class="hljs-string">&quot;Normal use &quot;</span>&lt;&lt;obj4&lt;&lt;endl;<br>    cout&lt;&lt;<span class="hljs-string">&quot;++ in the front &quot;</span>&lt;&lt;(++obj4)&lt;&lt;endl;<br>    <span class="hljs-comment">//cout&lt;&lt;&quot;++ in the back &quot;&lt;&lt;(obj4++)&lt;&lt;endl;</span><br>    <span class="hljs-comment">//上面这一行先注释掉，之后再讨论</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">Create a new object!</span><br><span class="hljs-comment">Value: 10</span><br><span class="hljs-comment">Create a new object with copy constructor</span><br><span class="hljs-comment">Value: 10</span><br><span class="hljs-comment">The object destroyed</span><br><span class="hljs-comment">Create a new object with copy constructor</span><br><span class="hljs-comment">Create a new object with copy constructor</span><br><span class="hljs-comment">Value: 11</span><br><span class="hljs-comment">The object destroyed</span><br><span class="hljs-comment">The object destroyed</span><br><span class="hljs-comment">Now lets look at the obj4</span><br><span class="hljs-comment">Create a new object!</span><br><span class="hljs-comment">Normal use 100</span><br><span class="hljs-comment">++ in the front 101</span><br><span class="hljs-comment">The object destroyed</span><br><span class="hljs-comment">The object destroyed</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>现在我们可以把<code>cout&lt;&lt;&quot;++ in the back &quot;&lt;&lt;(obj4++)&lt;&lt;endl;</code>这一行代码的注释删掉，<strong>不出意外的话，我们的代码出现了报错</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Bash">testcode_5.cpp:81:35: error: cannot <span class="hljs-built_in">bind</span> non-const lvalue reference of <span class="hljs-built_in">type</span> <span class="hljs-string">&#x27;MyClass&amp;&#x27;</span> to an rvalue of <span class="hljs-built_in">type</span> <span class="hljs-string">&#x27;MyClass&#x27;</span><br>     cout&lt;&lt;<span class="hljs-string">&quot;++ in the back &quot;</span>&lt;&lt;(obj4++)&lt;&lt;<span class="hljs-string">endl;</span><br><span class="hljs-string">                              ~~~~~^~~</span><br><span class="hljs-string">                              </span><br><span class="hljs-string">Translate:无法将类型为 MyClass&amp; 的非 const 左值引用绑定到类型为 MyClass 的右值。</span><br></code></pre></td></tr></table></figure><h3 id="Explanations"><a href="#Explanations" class="headerlink" title="Explanations"></a>Explanations</h3><p>仔细分析一下原因其实很简单：<strong>问题出现在后置++运算符的返回类型上</strong>。因为后置++运算符返回的是一个临时对象的值（<strong>MyClass 的右值</strong>），这与流输出运算符的重载参数列表（<strong>MyClass&amp; 的非 const 左值引用</strong>）不匹配。</p><p>这样就有冲突产生了，我们设计代码的初衷是希望对象能返回他在执行自增操作之前的值，如果我们修改++后置运算符的返回类型，会产生悬挂指针的严重问题：</p><p><img src="/posts/Jotting-References-and-Encapsulation-in-OOP/references.png" alt="Dangling pointer"></p><blockquote><p>引用找不到对应的内存地址，无法正常输出。</p></blockquote><p><strong>因此，解决这个问题的唯一途径就是修改流输出运算符的重载函数定义！</strong></p><h3 id="Use-of-const-references"><a href="#Use-of-const-references" class="headerlink" title="Use of const references"></a>Use of const references</h3><p>在这里，我们需要更改流输出运算符的引用类型：<strong>将非const引用更改为const引用</strong>。</p><p>因为<strong>const 引用有一个非常重要的特性</strong>：<strong>const 引用可以绑定右值</strong>。这是 C++ 中的一个重要特性，允许将临时对象（右值）传递给接受 <code>const</code> 引用的函数或参数。</p><p>在更改参数列表后，代码就可以正常的运行了！</p><p><strong>const vs non-const</strong></p><table><thead><tr><th align="left">特性</th><th align="left">const 引用</th><th align="left">非 const 引用</th></tr></thead><tbody><tr><td align="left"><strong>修改权限</strong></td><td align="left">不能修改对象</td><td align="left">可以修改对象</td></tr><tr><td align="left"><strong>绑定规则</strong></td><td align="left">可以绑定左值和右值</td><td align="left">只能绑定左值</td></tr><tr><td align="left"><strong>使用场景</strong></td><td align="left">只读访问，避免拷贝</td><td align="left">需要修改对象</td></tr><tr><td align="left"><strong>安全性</strong></td><td align="left">更安全，避免意外修改</td><td align="left">需要谨慎使用</td></tr><tr><td align="left"><strong>性能</strong></td><td align="left">可以优化右值处理</td><td align="left">无法直接优化右值处理</td></tr></tbody></table><div class="note note-info">            <p>笔者写到这里才发现自己的辅导书上在重载流输出运算符的时候本来就是使用const引用的 🤡💔。所以改了那么久的代码就是因为没有仔细看书。。。吃一堑长一智吧。。。</p>          </div><h2 id="Encapsulation-in-OOP"><a href="#Encapsulation-in-OOP" class="headerlink" title="Encapsulation in OOP"></a>Encapsulation in OOP</h2><p>写完上面的代码，读者的心中冒出了两个有关引用和封装的问题。</p><p><strong>Question1 <strong>回顾上面的代码，成员函数和友元函数可以</strong>直接修改引用类的私有数据成员</strong>，这样做是否有违OOP的<strong>封装</strong>的安全性精神？</p><p>封装的核心思想是<strong>隐藏对象的内部实现细节</strong>，只暴露必要的接口给外部使用。通过封装，可以确保对象的内部状态不会被外部代码随意修改，从而提高代码的安全性和可维护性。</p><p>身为<strong>成员函数</strong>或者<strong>友元函数</strong>，其本身就具有修改本对象的私有成员的权限，但是值得注意的是，这些函数在<strong>非const引用下具有访问甚至修改其他对象的私有成员的权限</strong>。</p><p>这是很危险的事情，因此，我们<strong>再次感受到了const引用的强大优势：在节省效率的同时保证了对象不被修改的安全性。</strong></p><p>因此，Question1 的问题确实是存在的，解决办法也非常的简单，将引用修改为const引用，只在需要修改的时候暴露必要的权限。同时，将修改的操作封装成函数也能一定程度上保证其安全性。</p><p><strong>Question 2</strong> 如果我希望任何外部代码都不能访问一个特地的私有成员（例如密钥），我该如何实现？</p><p><strong>这个问题比较复杂</strong>，具体而言需要使用<strong>嵌套类实现</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> value;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">PrivateValue</span>&#123;<br>        <span class="hljs-keyword">private</span>:<span class="hljs-type">int</span> privatevalue;<br>        <span class="hljs-keyword">public</span>:<br>            <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getprivatevalue</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>&#123;<span class="hljs-keyword">return</span> privatevalue;&#125;<br>            <span class="hljs-built_in">PrivateValue</span>(<span class="hljs-type">int</span> x):<span class="hljs-built_in">privatevalue</span>(x)&#123;&#125;<br>    &#125;;<br>    PrivateValue pri;<br>    <span class="hljs-comment">// 只有特定成员函数可以访问 privatevalue</span><br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">int</span> v, <span class="hljs-type">int</span> pv) : <span class="hljs-built_in">value</span>(v),<span class="hljs-built_in">pri</span>(pv)&#123;&#125;<br><br>    <span class="hljs-comment">// 公共接口</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getValue</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> pri.<span class="hljs-built_in">getprivatevalue</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>在这里，方法<code>int getprivatevalue() const&#123;return privatevalue;&#125;</code>成为了获得密钥的唯一途径，哪怕是成员函数，也不可以直接调用<code>pri.privatevalue</code>。</p><p><img src="/safety.png" alt="safety"></p><div class="note note-primary">            <p><strong>封装和安全性</strong>是OOP中非常重要的一个精神，在实现公用接口的同时隐藏数据成员和具体的函数代码，提高了用户使用的安全性和便捷性。但是，在本科C++的教学中，受困于<strong>题目</strong>的限制，这一点被大大忽略了。（笔者身边甚至有同学将所有的数据成员全部设置为public，这样少写很多函数也可以通过测试样例。）</p>          </div><p>例如在下面的类设计中，<code>privatevalue</code>作为密钥，<strong>哪怕是MyClass的成员函数都不可以调用其值</strong>，只能通过唯一的接口<code>int getprivatevalue() const</code>实现。</p><blockquote><p>这样有什么好处？好处时实现了安全性的<strong>层级分离</strong>。显然value的安全等级低于<code>privatevalue</code>，开发者放开<code>MyClass</code>的权限也不会影响到<code>PrivateValue</code>类。保证了高级安全数据的安全性。</p><p>例如，任何<code>MyClass</code>的成员函数都可以访问value的值，但是只有掌握password的成员函数才能通过接口访问<code>privatevalue</code>的值。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> value;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">PrivateValue</span>&#123;<br>        <span class="hljs-keyword">private</span>:<span class="hljs-type">int</span> privatevalue;<br>        <span class="hljs-keyword">public</span>:<br>            <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getprivatevalue</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>&#123;<br>                <span class="hljs-type">int</span> password;<br>                cout&lt;&lt;<span class="hljs-string">&quot;Please enter the password: &quot;</span>;<br>                cin&gt;&gt;password;<br>                <span class="hljs-keyword">if</span>(password==<span class="hljs-number">123456</span>)&#123;<br>                    <span class="hljs-keyword">return</span> privatevalue;<br>                &#125;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            &#125;<br>            <span class="hljs-built_in">PrivateValue</span>(<span class="hljs-type">int</span> x):<span class="hljs-built_in">privatevalue</span>(x)&#123;&#125;<br>    &#125;;<br>    PrivateValue pri;<br>    <span class="hljs-comment">// 只有特定成员函数可以访问 privatevalue</span><br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">int</span> v, <span class="hljs-type">int</span> pv) : <span class="hljs-built_in">value</span>(v),<span class="hljs-built_in">pri</span>(pv)&#123;&#125;<br><br>    <span class="hljs-comment">// 公共接口</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getValue</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> pri.<span class="hljs-built_in">getprivatevalue</span>();<br>    &#125;<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">MyClass <span class="hljs-title">obj1</span><span class="hljs-params">(<span class="hljs-number">23</span>,<span class="hljs-number">3456</span>)</span></span>;<br>    cout&lt;&lt;obj<span class="hljs-number">1.</span><span class="hljs-built_in">getValue</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><ul><li>多用const引用，多多益善。</li><li>对于没有访问权的变量使用<strong>嵌套类</strong>实现。</li></ul><blockquote><p>The END</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Code</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Finished</tag>
      
      <tag>C/C++</tag>
      
      <tag>OOP</tag>
      
      <tag>Jotting</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Input-and-Output-in-C-Plus-Plus</title>
    <link href="/posts/Input-and-Output-in-C-plus-plus/"/>
    <url>/posts/Input-and-Output-in-C-plus-plus/</url>
    
    <content type="html"><![CDATA[<style>  html, body, .markdown-body {    font-family: Georgia, sans, serif;  }</style><h1 id="Input-Output-and-Files-in-C"><a href="#Input-Output-and-Files-in-C" class="headerlink" title="Input, Output and Files in C++"></a>Input, Output and Files in C++</h1><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>This blog will focus on <strong>C++ stream-based input and output,</strong> including <strong>console-based, file-based, and string-based input and output</strong>. The blog will share some advanced techniques for custom input and output, including the use of the <strong>iomanip</strong> library, accessing <strong>ASCII files and binary files</strong>.</p><h2 id="Table-of-Contents"><a href="#Table-of-Contents" class="headerlink" title="Table of Contents"></a>Table of Contents</h2><ul><li><p><a href="#Introduction"><strong>Introductions</strong></a></p></li><li><p><a href="#Several-Basic-Concepts"><strong>Several Basic Concepts</strong></a></p></li><li><p><a href="#Console-based-input-and-output"><strong>Console-based input and output</strong></a></p></li></ul><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>在<strong>冯诺依曼体系结构</strong>中，计算机通过输入设备向电脑输入信息，经过运算后由输出设备输出。由此可见，输入输出是<strong>程序与外部进行数据通信的重要枢纽</strong>。在过往C++的学习中，我们已经掌握了一些有关输入输出的基本知识（<code>cin</code>和<code>cout</code>）。本章节将从更加底层的视角介绍C++中常见的三种输入输出：**基于控制台的输入输出类型<code>iostream</code>、基于文件的输入输出类型<code>fstream</code>和基于字符串的输入输出类型<code>sstream</code>**。</p><p><img src="/posts/Input-and-Output-in-C-plus-plus/fnym.png" alt="冯诺依曼体系结构"></p><h2 id="Several-Basic-Concepts"><a href="#Several-Basic-Concepts" class="headerlink" title="Several Basic Concepts"></a>Several Basic Concepts</h2><p>在正式开始我们的内容之前，我们需要做一些准备工作，下文将向读者介绍四个基本概念：<strong>流、控制台、缓冲区和IO标准库</strong>。</p><h3 id="Streams"><a href="#Streams" class="headerlink" title="Streams"></a>Streams</h3><p>在计算机编程中，<strong>流(Stream)<strong>是一种用于输入和输出（I&#x2F;O）操作的抽象。流可以看作是数据元素的序列，这些数据元素</strong>按时间顺序可供程序读取或写入</strong>，通常用于在程序与外部源（如文件、网络连接或控制台）之间传输数据。</p><p>具体到C++的输入输出中，C++的输入&#x2F;输出是以<strong>一连串字节流的方式</strong>进行的。在输入操作中，字节从<strong>设备（如键盘、磁盘）流向内存</strong>，称为<strong>输入流</strong>。在输出操作中，字节<strong>从内存流向设备（如显示器、打印机、磁盘等）</strong>，称为<strong>输出流</strong>。 C++同时提供“低层次”和“高层次”的输入&#x2F;输出。低层次的输入&#x2F;输出直接<strong>处理字节流中的一个个字节</strong>，把每个字节仅看成一个二进制比特串。高层次的输入&#x2F;输出可以将字节组合成有意义的单位，如<strong>整型数、浮点数及自定义类型的值进行操作</strong>。  </p><p>具体而言，高层次IO主要是基于<strong>流（Stream）</strong>的 I&#x2F;O，提供了更抽象、更易用的接口（<code>cin</code>和<code>cout</code>）。它隐藏了底层细节（如缓冲区管理、设备控制等）。而低层次IO基于<strong>系统调用</strong>或<strong>C 标准库函数</strong>的 I&#x2F;O，提供了更底层的控制，例如C语言中的<code>printf()</code>和<code>scanf()</code>函数。</p><table><thead><tr><th align="left">特性</th><th align="left">高层次 I&#x2F;O</th><th align="left">低层次 I&#x2F;O</th></tr></thead><tbody><tr><td align="left">抽象程度</td><td align="left">高（基于流）</td><td align="left">低（基于文件描述符或缓冲区）</td></tr><tr><td align="left">易用性</td><td align="left">高（简洁的接口，类型安全）</td><td align="left">低（需要手动管理资源）</td></tr><tr><td align="left">性能</td><td align="left">较低（有抽象层开销）</td><td align="left">较高（直接操作底层资源）</td></tr><tr><td align="left">控制粒度</td><td align="left">较粗（隐藏了底层细节）</td><td align="left">较细（可以精确控制 I&#x2F;O 细节）</td></tr><tr><td align="left">适用场景</td><td align="left">通用场景（如控制台、文件 I&#x2F;O）</td><td align="left">高性能场景或需要精细控制的场景</td></tr></tbody></table><h3 id="Console"><a href="#Console" class="headerlink" title="Console"></a>Console</h3><p><strong>控制台（Console）</strong>，也叫做<strong>命令行界面（CLI，Command Line Interface）</strong>或<strong>终端（Terminal）</strong>，是一个用于与计算机进行交互的文本界面。在控制台中，用户可以通过输入命令和接收计算机输出结果来与操作系统和应用程序进行交互。</p><p>控制台的基本概念：</p><ol><li><strong>文本交互界面</strong>： 控制台通常是一个纯文本的界面，没有图形元素，用户通过键盘输入命令，计算机通过文本输出反馈给用户。这与图形用户界面（GUI）相比，显得更加简洁、直接。</li><li><strong>命令输入和输出</strong>： 在控制台中，用户通过输入命令来执行各种任务，比如文件管理、程序启动、系统配置等。计算机则通过文本输出给出执行结果或提示信息。</li><li><strong>程序的交互式操作</strong>： 很多程序（尤其是开发工具、编译器、数据库等）都支持控制台交互，用户可以在控制台中输入指令，实时获取程序输出的结果。</li></ol><h3 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h3><p><strong>缓冲区（Buffer）</strong> 是计算机系统中的一块临时存储区域，通常用于存储数据，以便在数据处理过程中提高效率。缓冲区可以帮助程序减少频繁的I&#x2F;O操作（如磁盘读写、网络通信等），通过缓存数据来实现更高效的操作。</p><p>程序只能访问内存中的信息，而不能直接访问外部设备中的信息。当程序需要读取外部设备中的某个信息时，操作系统会将<strong>包含此信息的一批数据从外部设备读入内存，再从内存读入程序</strong>，此时发生了<strong>一次外部设备的访问</strong>。如果程序需要读取的数据已经在内存中，则不会发生外部设备的访问。输出也是如此。如果程序向外部设备输出一个信息，此信息被写在内存的某个地方，操作系统会定期将内存中的信息输出到外部设备。内存中存放这些数据的区域称为<strong>输入&#x2F;输出缓冲区</strong>。  </p><p><strong>缓冲区的工作原理：</strong></p><ol><li><strong>写缓冲区</strong>：当程序向文件或网络发送数据时，数据首先被写入缓冲区，<font color=red><strong>等缓冲区被填满或条件满足</strong></font>时，再一次性将数据写入目标设备。</li><li><strong>读缓冲区</strong>：当程序从文件或网络读取数据时，<font color=red><strong>数据首先被从目标设备加载到缓冲区，再从缓冲区读取数据到程序中</strong></font>。这样可以避免每次读取时都访问设备，提高读取速度。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 使用带缓冲的文件输入输出流</span><br>    <span class="hljs-function">std::ifstream <span class="hljs-title">inputFile</span><span class="hljs-params">(<span class="hljs-string">&quot;example.txt&quot;</span>)</span></span>;  <span class="hljs-comment">// 默认使用缓冲</span><br>    std::string line;<br><br>    <span class="hljs-keyword">if</span> (inputFile.<span class="hljs-built_in">is_open</span>()) &#123;<br>        <span class="hljs-keyword">while</span> (std::<span class="hljs-built_in">getline</span>(inputFile, line)) &#123;<br>            std::cout &lt;&lt; line &lt;&lt; std::endl;  <span class="hljs-comment">// 缓冲区中的数据一次性输出</span><br>        &#125;<br>        inputFile.<span class="hljs-built_in">close</span>();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;无法打开文件&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>std::ifstream</code> 默认使用缓冲区来读取文件内容。它首先从文件系统读取一些数据到缓冲区，然后一次性将这些数据提供给程序。</p><div class="note note-info">            <p>有关缓冲区的具体实现原理我们会稍后提及。（<strong>与输入输出类的实现有关</strong>）</p>          </div><h3 id="Standard-Library-for-IO"><a href="#Standard-Library-for-IO" class="headerlink" title="Standard Library for IO"></a>Standard Library for IO</h3><p>C++标准库中一个重要的组成部分就是IO流库，专门实现C++中的输入和输出。提供基于流的输入输出功能，包括控制台、文件和字符串的 I&#x2F;O。主要头文件：</p><ul><li><code>&lt;iostream&gt;</code>：标准输入输出流（如 <code>std::cin</code>、<code>std::cout</code>）。</li><li><code>&lt;fstream&gt;</code>：文件流（如 <code>std::ifstream</code>、<code>std::ofstream</code>）。</li><li><code>&lt;sstream&gt;</code>：字符串流（如 <code>std::istringstream</code>、<code>std::ostringstream</code>）。</li></ul><p><img src="/posts/Input-and-Output-in-C-plus-plus/iostream.png" alt="iostream"></p><table><thead><tr><th align="left">头文件</th><th align="left">功能描述</th><th align="left">主要类&#x2F;对象</th><th align="left">使用场景</th></tr></thead><tbody><tr><td align="left"><code>&lt;iostream&gt;</code></td><td align="left">提供标准输入输出功能，用于控制台 I&#x2F;O。</td><td align="left">- <code>std::cin</code>：标准输入流 -<code>std::cout</code>：标准输出流 - <code>std::cerr</code>：标准错误流 - <code>std::clog</code>：标准日志流</td><td align="left">控制台输入输出，如用户交互、调试信息输出等。</td></tr><tr><td align="left"><code>&lt;fstream&gt;</code></td><td align="left">提供文件输入输出功能，用于读写文件。</td><td align="left">- <code>std::ifstream</code>：文件输入流 - <code>std::ofstream</code>：文件输出流 - <code>std::fstream</code>：文件流</td><td align="left">文件读写操作，如读取配置文件、保存数据到文件等。</td></tr><tr><td align="left"><code>&lt;sstream&gt;</code></td><td align="left">提供字符串输入输出功能，用于将字符串作为流处理。</td><td align="left">- <code>std::istringstream</code>：字符串输入流 - <code>std::ostringstream</code>：字符串输出流 - <code>std::stringstream</code>：字符串流</td><td align="left">字符串格式化、解析，如将字符串转换为数字、将数据格式化为字符串等。</td></tr></tbody></table><h2 id="Console-based-input-and-output"><a href="#Console-based-input-and-output" class="headerlink" title="Console-based input and output"></a>Console-based input and output</h2><p>在<strong>运算符重载</strong>这一小节时，笔者曾经介绍了cin&#x2F;cout的真实面目是**<code>istream</code>类和<code>ostream</code>类的对象**。并讲解了如何重载流输入输出运算符。下面转载自己的部分博客内容，<a href="https://xiyuanyang-code.github.io/posts/Introduction-to-OOP/">原文点这里</a>。</p><div class="note note-info">            <h3 id="输入-输出运算符的重载"><a href="#输入-输出运算符的重载" class="headerlink" title="输入&#x2F;输出运算符的重载"></a>输入&#x2F;输出运算符的重载</h3><h4 id="重新认识运算符"><a href="#重新认识运算符" class="headerlink" title="重新认识&lt;&lt;和&gt;&gt;运算符"></a>重新认识<code>&lt;&lt;</code>和<code>&gt;&gt;</code>运算符</h4><p>在笔者的第一堂C++启蒙课上，笔者便体会到了<strong>流操作</strong>的精妙和便捷。（相比于<code>printf()</code>和<code>scanf()</code>的冗长语法）但是，当时笔者只是把<code>cin/cout</code>当做一个普通的函数来使用，并不知道其背后深层次的原理。下面，我们先来重新认识一下cin&#x2F;cout的真面目。</p><h5 id="istream和ostream"><a href="#istream和ostream" class="headerlink" title="istream和ostream"></a><code>istream</code>和<code>ostream</code></h5><p>在 C++ 中，<strong>流类（如 <code>std::istream</code> 和 <code>std::ostream</code>）是处理输入输出操作的核心类</strong>，它们为程序提供了与数据流进行交互的功能。这些类是 C++ 标准库的一部分，用于简化与文件、控制台、字符串等设备的交互。</p><ol><li><strong><code>std::istream</code> 类</strong></li></ol><p><code>std::istream</code> 类是用于处理输入操作的类，提供了从输入流中读取数据的功能。它是所有输入流类（如 <code>cin</code>）的基类。</p><ul><li><p><strong>构造函数</strong>：<code>std::istream</code> 的构造函数可以用来打开文件或初始化输入流。</p></li><li><p>成员函数</p><ul><li><code>operator&gt;&gt;</code>：流提取运算符，用于从流中提取数据。</li><li><code>get()</code>：用于读取一个字符或一行数据。</li><li><code>read()</code>：从流中读取特定数量的字符。</li><li><code>eof()</code>：检查是否到达文件结束标志。</li><li><code>fail()</code>：检查流是否进入失败状态。</li></ul></li></ul><ol start="2"><li><strong><code>std::ostream</code> 类</strong></li></ol><p><code>std::ostream</code> 类是用于处理输出操作的类，提供了将数据写入输出流的功能。它是所有输出流类（如 <code>cout</code>）的基类。</p><ul><li><p><strong>构造函数</strong>：<code>std::ostream</code> 的构造函数用于打开输出流或初始化输出流。</p></li><li><p>成员函数</p><ul><li><code>operator&lt;&lt;</code>：流插入运算符，用于将数据插入到流中。</li><li><code>put()</code>：用于向流中写入一个字符。</li><li><code>write()</code>：用于向流中写入特定数量的字符。</li><li><code>flush()</code>：强制输出缓冲区内容，确保数据立即写入流。</li><li><code>endl</code>：插入一个换行符并刷新输出流。</li></ul></li></ul><ol start="3"><li><strong>继承结构</strong></li></ol><p><code>std::istream</code> 和 <code>std::ostream</code> 类本身都继承自 <code>std::ios</code> 类，它们共享一些基本的输入输出功能。<code>std::ios</code> 类提供了管理流状态的功能，比如检查是否处于错误状态、是否已到达文件末尾等。</p><ul><li><strong><code>std::ios</code> 类</strong>：<code>std::ios</code> 是 <code>std::istream</code> 和 <code>std::ostream</code> 的基类，负责流的基本状态管理（如错误标志、格式控制等）。<ul><li><code>std::ios::good()</code>: 检查流是否处于良好状态。</li><li><code>std::ios::eof()</code>: 检查流是否到达文件末尾。</li><li><code>std::ios::fail()</code>: 检查流是否处于失败状态。</li></ul></li></ul><ol start="4"><li><strong>常见的派生类</strong></li></ol><ul><li>**<code>std::ifstream</code>**：<code>std::ifstream</code> 是 <code>std::istream</code> 的派生类，用于处理文件输入。它提供了从文件读取数据的功能。</li><li>**<code>std::ofstream</code>**：<code>std::ofstream</code> 是 <code>std::ostream</code> 的派生类，用于处理文件输出。它提供了将数据写入文件的功能。</li><li>**<code>std::stringstream</code>**：<code>std::stringstream</code> 是 <code>std::istream</code> 和 <code>std::ostream</code> 的派生类，允许在内存中处理字符串流。它既可以用于输入也可以用于输出。</li></ul><h5 id="cin和cout"><a href="#cin和cout" class="headerlink" title="cin和cout"></a><code>cin</code>和<code>cout</code></h5><p><code>cin</code> 和 <code>cout</code> 是 C++ 标准库中<strong>预定义的输入和输出流对象</strong>，它们是由流类（如 <code>istream</code> 和 <code>ostream</code>）创建的全局对象，用于进行数据的输入和输出。</p><ul><li><strong><code>cin</code>（标准输入流对象）</strong>：<code>cin</code> 是一个全局的输入流对象，属于 <code>std::istream</code> 类，通常用于从标准输入（如键盘）获取数据。</li><li><strong><code>cout</code>（标准输出流对象）</strong>：<code>cout</code> 是一个全局的输出流对象，属于 <code>std::ostream</code> 类，通常用于将数据输出到标准输出（如显示器）。</li></ul><div class="note note-danger">            <p><strong>是的，cin&#x2F;cout根本不是函数，而是对象！！！</strong></p>          </div><h5 id="运算符"><a href="#运算符" class="headerlink" title="&lt;&lt;和&gt;&gt;运算符"></a><code>&lt;&lt;</code>和<code>&gt;&gt;</code>运算符</h5><p>这些运算符实际上是被重载的，它们不是内置运算符，而是通过重载来定义流操作的行为。</p><ul><li>**流插入运算符 <code>&lt;&lt;</code>**：被 <code>std::ostream</code> 类重载，用于将数据插入到输出流中。当你写 <code>cout &lt;&lt; x;</code> 时，实际上是调用了 <code>std::ostream</code> 类的 <code>operator&lt;&lt;</code> 函数。</li><li>**流提取运算符 <code>&gt;&gt;</code>**：被 <code>std::istream</code> 类重载，用于从输入流中提取数据。当你写 <code>cin &gt;&gt; x;</code> 时，实际上是调用了 <code>std::istream</code> 类的 <code>operator&gt;&gt;</code> 函数。</li></ul><p>流插入运算符&lt;&lt;是一个二元运算符。例如，表达式 cout &lt;&lt; x 的运算符两侧分别是 cout 和 x， x 是一个整型变量， cout 是输出流类 <code>ostream</code> 的对象。 &lt;&lt;运算符将右边对象的值转换成文本形式插入左边的输出流对象， 执行结果是左边的输出流对象的引用。对于 cout &lt;&lt; x，运算结果为对象 cout。正因为&lt;&lt;运算的结果是左边对象的引用，所以允许执行 <code>cout &lt;&lt; x &lt;&lt; y</code> 等的操作。因为&lt;&lt;是左结合的，所以上述表达式先执行 <code>cout &lt;&lt; x</code>，执行的结果是对象 cout，然后执行 <code>cout &lt;&lt; y</code>。</p><h4 id="在自定义类中重载运算符"><a href="#在自定义类中重载运算符" class="headerlink" title="在自定义类中重载&lt;&lt;和&gt;&gt;运算符"></a>在自定义类中重载<code>&lt;&lt;</code>和<code>&gt;&gt;</code>运算符</h4><p>由于第一个参数是<code>ostream/istream</code> 类的对象，因此<strong>流插入运算符不能重载成成员函数，必须重载成全局函数，流输出运算符也是如此</strong>。</p><p>为什么？在 C++ 中，<strong>成员函数的第一个参数通常是隐式的 <code>this</code> 指针</strong>，指向当前对象。因此，成员函数可以通过 <code>this</code> 指针访问对象的成员变量和其他成员函数。也就是说，只有运算符的第一个参数是可以被<strong>this指针指向的，才能够被定义为类内的成员函数</strong>，否则必须被<strong>定义为友元函数</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> x, y;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 构造函数</span><br>    <span class="hljs-built_in">Point</span>(<span class="hljs-type">int</span> x = <span class="hljs-number">0</span>, <span class="hljs-type">int</span> y = <span class="hljs-number">0</span>) : <span class="hljs-built_in">x</span>(x), <span class="hljs-built_in">y</span>(y) &#123;&#125;<br><br>    <span class="hljs-comment">// 重载 &lt;&lt; 运算符</span><br>    <span class="hljs-keyword">friend</span> ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; os, <span class="hljs-type">const</span> Point&amp; p);<br>    <span class="hljs-comment">//参数中第一个对象是ostream类的对象（相当于cout）</span><br>&#125;;<br><br><span class="hljs-comment">// 重载 &lt;&lt; 运算符</span><br>ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; os, <span class="hljs-type">const</span> Point&amp; p) &#123;<br>    os &lt;&lt; <span class="hljs-string">&quot;(&quot;</span> &lt;&lt; p.x &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; p.y &lt;&lt; <span class="hljs-string">&quot;)&quot;</span>;<br>    <span class="hljs-keyword">return</span> os;  <span class="hljs-comment">// 返回 ostream 引用，以便链式调用</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">Point <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)</span></span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Point: &quot;</span> &lt;&lt; p &lt;&lt; endl;  <span class="hljs-comment">// 调用重载的 &lt;&lt; 运算符</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> x, y;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 构造函数</span><br>    <span class="hljs-built_in">Point</span>(<span class="hljs-type">int</span> x = <span class="hljs-number">0</span>, <span class="hljs-type">int</span> y = <span class="hljs-number">0</span>) : <span class="hljs-built_in">x</span>(x), <span class="hljs-built_in">y</span>(y) &#123;&#125;<br><br>    <span class="hljs-comment">// 重载 &gt;&gt; 运算符</span><br>    <span class="hljs-keyword">friend</span> istream&amp; <span class="hljs-keyword">operator</span>&gt;&gt;(istream&amp; is, Point&amp; p);<br>    <span class="hljs-comment">//参数中第一个对象是istream类的对象（相当于cin）</span><br>&#125;;<br><br><span class="hljs-comment">// 重载 &gt;&gt; 运算符</span><br>istream&amp; <span class="hljs-keyword">operator</span>&gt;&gt;(istream&amp; is, Point&amp; p) &#123;<br>    is &gt;&gt; p.x &gt;&gt; p.y;  <span class="hljs-comment">// 从输入流中读取数据到成员变量</span><br>    <span class="hljs-keyword">return</span> is;  <span class="hljs-comment">// 返回 istream 引用，以便链式调用</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">Point <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)</span></span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Enter coordinates for the point (x y): &quot;</span>;<br>    cin &gt;&gt; p;  <span class="hljs-comment">// 调用重载的 &gt;&gt; 运算符</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;You entered point: &quot;</span> &lt;&lt; p &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>相关注意点：</strong></p><ul><li>注意返回类型是对<code>istream</code>或<code>ostream</code>的引用。</li></ul>          </div><h3 id="iomanip"><a href="#iomanip" class="headerlink" title="iomanip"></a>iomanip</h3><p><code>iomanip</code> 是 C++ 标准库中的一个头文件，全称为 <strong>Input&#x2F;Output Manipulators</strong>（输入输出操纵器）。它提供了一系列用于<strong>格式化输入</strong>输出的工具函数，通常与 <code>iostream</code> 库（如 <code>cin</code> 和 <code>cout</code>）结合使用，以控制数据的显示方式。<strong>格式化输入&#x2F;输出</strong>是通过<strong>流操纵符</strong>或**<code>istream</code> 和 <code>ostream</code> 类的成员函数<strong>实现的。流操纵符是以一个流引用作为参数，并返回同一流引用的函数，因此它可以嵌入输入&#x2F;输出操作的链中。 <code>endl</code> 就是最常用的流操纵符。格式化输入&#x2F;输出的功能包括</strong>设置整型数的基数、设置浮点数的精度、设置和改变域宽、设置域的填充字符**等。  </p><p><code>iomanip</code> 中常用的函数包括：</p><ol><li><p><strong>设置字段宽度</strong><br><code>setw(n)</code>：设置下一个输出字段的宽度为 <code>n</code> 个字符。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cout &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">10</span>) &lt;&lt; <span class="hljs-string">&quot;Hello&quot;</span>; <span class="hljs-comment">// 输出 &quot;     Hello&quot;（前面有 5 个空格）</span><br></code></pre></td></tr></table></figure></li><li><p><strong>设置浮点数精度</strong><br><code>setprecision(n)</code>：设置浮点数输出的精度为 <code>n</code> 位。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cout &lt;&lt; <span class="hljs-built_in">setprecision</span>(<span class="hljs-number">3</span>) &lt;&lt; <span class="hljs-number">3.14159</span>; <span class="hljs-comment">// 输出 &quot;3.14&quot;</span><br>cout &lt;&lt; fixed &lt;&lt; <span class="hljs-built_in">setprecision</span>(<span class="hljs-number">3</span>) &lt;&lt; <span class="hljs-number">3.14159</span>; <span class="hljs-comment">//输出 &quot;3.142&quot;</span><br><br><span class="hljs-comment">// 你也可以写成 cout.precision(3);cout&lt;&lt;x;</span><br></code></pre></td></tr></table></figure><p>在默认模式下，<code>setprecision(n)</code> 控制的是<strong>有效数字位数</strong>，即从第一个非零数字开始计算的总位数。在 <code>fixed</code> 模式下，<code>setprecision(n)</code> 控制的是<strong>小数点后的位数</strong>。(<strong>是四舍五入</strong>)。在 <code>scientific</code> 模式下，<code>setprecision(n)</code> 控制的是<strong>小数点后的位数</strong>，但数字会以科学计数法显示。</p></li><li><p><strong>设置填充字符</strong><br><code>setfill(c)</code>：设置填充字符为 <code>c</code>，通常与 <code>setw</code> 一起使用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cout &lt;&lt; <span class="hljs-built_in">setfill</span>(<span class="hljs-string">&#x27;*&#x27;</span>) &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">10</span>) &lt;&lt; <span class="hljs-string">&quot;Hi&quot;</span>; <span class="hljs-comment">// 输出 &quot;********Hi&quot;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>控制布尔值输出格式</strong><br><code>boolalpha</code> &#x2F; <code>noboolalpha</code>：将布尔值输出为 <code>true</code>&#x2F;<code>false</code> 或 <code>1</code>&#x2F;<code>0</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cout &lt;&lt; boolalpha &lt;&lt; <span class="hljs-literal">true</span>; <span class="hljs-comment">// 输出 &quot;true&quot;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>控制数字的进制</strong><br><code>hex</code>、<code>dec</code>、<code>oct</code>：分别将数字输出为十六进制、十进制和八进制。</p><p>也可以使用<code>setbase()</code>进行格式化控制。（<strong>参数化的流操纵符</strong>）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cout &lt;&lt; hex &lt;&lt; <span class="hljs-number">255</span>; <span class="hljs-comment">// 输出 &quot;ff&quot;</span><br></code></pre></td></tr></table></figure></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iomanip&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">10</span>) &lt;&lt; <span class="hljs-built_in">setfill</span>(<span class="hljs-string">&#x27;-&#x27;</span>) &lt;&lt; <span class="hljs-string">&quot;Hello&quot;</span> &lt;&lt; endl; <span class="hljs-comment">// 输出 &quot;-----Hello&quot;</span><br>    cout &lt;&lt; <span class="hljs-built_in">setprecision</span>(<span class="hljs-number">4</span>) &lt;&lt; <span class="hljs-number">3.14159</span> &lt;&lt; endl;          <span class="hljs-comment">// 输出 &quot;3.142&quot;</span><br>    cout &lt;&lt; hex &lt;&lt; <span class="hljs-number">255</span> &lt;&lt; endl;                          <span class="hljs-comment">// 输出 &quot;ff&quot;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="6"><li><strong>自定义输出流操纵符</strong></li></ol><p>在 C++ 中，自定义流操纵符函数（Custom Stream Manipulators）允许你创建自己的流操作符，用于简化或扩展输入输出流的格式化操作。自定义流操纵符函数可以是一个无参数的函数，也可以是一个带参数的函数，它们通过操作流的内部状态或执行特定操作来实现自定义功能。</p><ol><li><strong>无参数的自定义流操纵符</strong></li></ol><p>无参数的自定义流操纵符是一个简单的函数，它接受一个流对象（<code>std::ostream&amp;</code> 或 <code>std::istream&amp;</code>）并返回该流对象。通常用于设置流的格式状态。</p><p><strong>示例：实现一个自定义操纵符，将输出流的颜色设置为红色（假设终端支持 ANSI 颜色代码）：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 自定义操纵符函数：设置为红色</span><br><span class="hljs-function">ostream&amp; <span class="hljs-title">red</span><span class="hljs-params">(ostream&amp; os)</span> </span>&#123;<br>    os &lt;&lt; <span class="hljs-string">&quot;\033[31m&quot;</span>; <span class="hljs-comment">// ANSI 颜色代码：红色</span><br>    <span class="hljs-keyword">return</span> os;<br>&#125;<br><br><span class="hljs-comment">// 自定义操纵符函数：恢复默认颜色</span><br><span class="hljs-function">ostream&amp; <span class="hljs-title">reset</span><span class="hljs-params">(ostream&amp; os)</span> </span>&#123;<br>    os &lt;&lt; <span class="hljs-string">&quot;\033[0m&quot;</span>; <span class="hljs-comment">// ANSI 重置代码</span><br>    <span class="hljs-keyword">return</span> os;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cout &lt;&lt; red &lt;&lt; <span class="hljs-string">&quot;This text is red!&quot;</span> &lt;&lt;endl&lt;&lt; reset &lt;&lt; <span class="hljs-string">&quot; This text is back to default.&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li><strong>带参数的自定义流操纵符</strong></li></ol><p>带参数的自定义流操纵符需要借助一个辅助类来实现。通过重载 <code>operator&lt;&lt;</code> 或 <code>operator&gt;&gt;</code>，可以传递参数并执行更复杂的操作。</p><p><strong>示例：实现一个自定义操纵符，重复输出指定次数的字符串：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 辅助类</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">RepeatManipulator</span> &#123;<br>    <span class="hljs-type">int</span> count;<br>    <span class="hljs-type">const</span> string&amp; str;<br><br>    <span class="hljs-built_in">RepeatManipulator</span>(<span class="hljs-type">int</span> n, <span class="hljs-type">const</span> string&amp; s) : <span class="hljs-built_in">count</span>(n), <span class="hljs-built_in">str</span>(s) &#123;&#125;<br>&#125;;<br><br><span class="hljs-comment">// 重载 operator&lt;&lt;</span><br>ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; os, <span class="hljs-type">const</span> RepeatManipulator&amp; manip) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; manip.count; ++i) &#123;<br>        os &lt;&lt; manip.str;<br>    &#125;<br>    <span class="hljs-keyword">return</span> os;<br>&#125;<br><br><span class="hljs-comment">// 自定义操纵符函数</span><br><span class="hljs-function">RepeatManipulator <span class="hljs-title">repeat</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">const</span> string&amp; s)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">RepeatManipulator</span>(n, s);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-built_in">repeat</span>(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;Hello! &quot;</span>) &lt;&lt; endl; <span class="hljs-comment">// 输出 &quot;Hello! Hello! Hello! &quot;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><ol start="3"><li><strong>结合 <code>iomanip</code> 使用</strong></li></ol><p>自定义流操纵符可以与 <code>iomanip</code> 中的标准操纵符结合使用，以实现更强大的功能。</p><p><strong>示例：实现一个自定义操纵符，将浮点数输出为百分比格式：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iomanip&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 自定义操纵符函数</span><br><span class="hljs-function">ostream&amp; <span class="hljs-title">percent</span><span class="hljs-params">(ostream&amp; os)</span> </span>&#123;<br>    os &lt;&lt; fixed &lt;&lt; <span class="hljs-built_in">setprecision</span>(<span class="hljs-number">2</span>) &lt;&lt; <span class="hljs-string">&#x27;*&#x27;</span>; <span class="hljs-comment">// 设置格式并添加百分号</span><br>    <span class="hljs-keyword">return</span> os;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">double</span> num = <span class="hljs-number">0.753</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Percentage: &quot;</span> &lt;&lt; num * <span class="hljs-number">100</span> &lt;&lt; percent &lt;&lt; endl; <span class="hljs-comment">// 输出 &quot;Percentage: 75.30%&quot;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><ol start="4"><li><strong>自定义输入流操纵符</strong></li></ol><p>自定义流操纵符也可以用于输入流（<code>std::istream</code>），用于解析或处理输入数据。</p><p><strong>示例：实现一个自定义操纵符，跳过输入流中的逗号：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 自定义操纵符函数</span><br><span class="hljs-function">istream&amp; <span class="hljs-title">skipComma</span><span class="hljs-params">(istream&amp; is)</span> </span>&#123;<br>    <span class="hljs-type">char</span> c;<br>    is &gt;&gt; c; <span class="hljs-comment">// 读取一个字符</span><br>    <span class="hljs-keyword">if</span> (c != <span class="hljs-string">&#x27;,&#x27;</span>) &#123;<br>        is.<span class="hljs-built_in">putback</span>(c); <span class="hljs-comment">// 如果不是逗号，放回流中</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> is;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> a, b;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Enter two numbers separated by a comma: &quot;</span>;<br>    cin &gt;&gt; a &gt;&gt; skipComma &gt;&gt; b;<br>    cout &lt;&lt; <span class="hljs-string">&quot;You entered: &quot;</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; and &quot;</span> &lt;&lt; b &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>自定义流操作符是C++输入输出的利器。</strong>强烈推荐大家上手实现自己的流操作符！</p></blockquote><h2 id="File-based-input-and-output"><a href="#File-based-input-and-output" class="headerlink" title="File-based input and output"></a>File-based input and output</h2><h3 id="Preliminaries"><a href="#Preliminaries" class="headerlink" title="Preliminaries"></a>Preliminaries</h3><p>在我们之前所遇到的程序中，程序的输入都指的是<strong>键盘的手动输入</strong>，这种输入方式灵活便捷但具有局限性。（例如我编写了一个程序需要统计公司所有员工的考勤记录，如果把所有数据全部手敲进终端中无疑是费时费力的。）因此，<strong>文件的输入输出</strong>在某些情况下相比于控制台的输入输出有着得天独厚的优越性。</p><p>为了展示文件输入输出的强大之处，先向笔者展示以下的程序：</p><p><img src="/posts/Input-and-Output-in-C-plus-plus/Bash.png" alt="File-based input and output"></p><blockquote><p>上图的命令行使用Bash语言，感兴趣的读者可自行学习，笔者这里使用的是GitBash（Powershell就是💩）</p></blockquote><ul><li><code>cat</code> 展示文件的内容</li><li><code>g++ testfile1.cpp =o main </code>编译<code>testfile1.cpp</code>文件，生成<code>main.exe</code>的可执行文件</li><li><code>./main.exe</code> 运行<code>main.exe</code></li><li><code>./main.exe &lt;1.txt &gt;2.txt</code><ul><li><strong>Bash语言的输入重定向和输出重定向</strong>：将<code>1.txt</code>的文件内容当做输入输入进<code>main.exe</code>中，然后将程序的输出流向<code>2.txt</code></li></ul></li></ul><p>根据结果不难发现，<code>1.txt</code>作为输入内容，成功被程序所执行并且<strong>成功将执行的结果导入到<code>2.txt</code><strong>中。</strong>泰裤辣！</strong></p><h3 id="Files-Streams-and-EOF"><a href="#Files-Streams-and-EOF" class="headerlink" title="Files, Streams, and EOF"></a>Files, Streams, and EOF</h3><h4 id="EOF"><a href="#EOF" class="headerlink" title="EOF"></a>EOF</h4><p>C++的文件没有记录的概念，它把文件看成字节序列，即由一个个字节顺序组成，每一个文件以<strong>文件结束符（ End Of File， EOF）</strong>结束，这种文件称为<strong>流式文件</strong>。我们可以将 C++的文件看成一个字符串。只不过这个字符串不是存放在内存中的，而是存放在外存中；不是用<code>&#39;\0&#39;</code>结束的，而是用 EOF 结束。</p><h4 id="Files"><a href="#Files" class="headerlink" title="Files"></a>Files</h4><p>根据不同的读写方式，<strong>文件</strong>在C++中具体被分类为<strong>ASCII文件</strong>和<strong>二进制文件</strong>。<strong>ASCII文件</strong>是指使用 ASCII 编码存储文本的文件，用来存储纯文本数据。而<strong>二进制文件</strong>储存的是<strong>数据在内存中的表示</strong>。例如我们常见的可执行文件<code>.exe</code>就是一种常见的二进制文件。</p><h4 id="Streams-1"><a href="#Streams-1" class="headerlink" title="Streams"></a>Streams</h4><p>和<code>iostream</code>类似，在数据传输过程中，文件也可以被看做是<strong>一种输入输出流</strong>。当应用程序从文件中读取数据时，将文件与一个<strong>输入文件流对象</strong> <code>ifstream</code> 相关联（<strong>这一步叫做打开文件</strong>）。当应用程序将数据写入一个文件时，将文件与一个<strong>输出文件流对象</strong> <code>ofstream</code> 相关联（<strong>这一步叫做关闭文件</strong>）。如果既要输入又要输出，则与<strong>输入&#x2F;输出文件流对象</strong> <code>fstream</code> 相关联。  文件被关闭后，该文件流对象可以与其他文件相关联。</p><p>在操作上，<code>fstream</code>是<code>iostream</code>的派生类，因此并无较大的差异。</p><h3 id="Using-fstream-for-ASCII"><a href="#Using-fstream-for-ASCII" class="headerlink" title="Using fstream for ASCII"></a>Using <code>fstream</code> for ASCII</h3><p>下面的代码给出了使用<code>fstream</code>的若干基本用法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span> <span class="hljs-comment">// 包含文件流库</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span>  <span class="hljs-comment">// 包含字符串库</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 1. 打开文件</span><br>    <span class="hljs-comment">// 使用 fstream 对象，可以同时支持读写操作</span><br>    fstream file;<br><br>    <span class="hljs-comment">// 打开文件 &quot;example.txt&quot;，模式为：</span><br>    <span class="hljs-comment">// ios::out - 写入模式（如果文件不存在则创建）</span><br>    <span class="hljs-comment">// ios::in  - 读取模式</span><br>    <span class="hljs-comment">// ios::trunc - 如果文件存在，清空文件内容</span><br>    file.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;example.txt&quot;</span>, ios::out | ios::in | ios::trunc);<br><br>    <span class="hljs-comment">// 检查文件是否成功打开</span><br>    <span class="hljs-keyword">if</span> (!file.<span class="hljs-built_in">is_open</span>()) &#123;<br>        cerr &lt;&lt; <span class="hljs-string">&quot;Error: Failed to open file!&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <span class="hljs-comment">// 返回错误码</span><br>    &#125;<br><br>    <span class="hljs-comment">// 2. 写入数据到文件</span><br>    string dataToWrite = <span class="hljs-string">&quot;Hello, this is a line of text written to the file.\n&quot;</span>;<br>    file &lt;&lt; dataToWrite; <span class="hljs-comment">// 使用流插入运算符写入数据</span><br>    file &lt;&lt; <span class="hljs-string">&quot;Another line of text.\n&quot;</span>;<br><br>    <span class="hljs-comment">// 3. 读取文件内容</span><br>    <span class="hljs-comment">// 将文件指针移动到文件开头</span><br>    file.<span class="hljs-built_in">seekg</span>(<span class="hljs-number">0</span>, ios::beg);<br><br>    string line;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Reading from file:\n&quot;</span>;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">getline</span>(file, line)) &#123; <span class="hljs-comment">// 逐行读取文件内容</span><br>        cout &lt;&lt; line &lt;&lt; endl;     <span class="hljs-comment">// 输出到控制台</span><br>    &#125;<br><br>    <span class="hljs-comment">// 4. 关闭文件</span><br>    file.<span class="hljs-built_in">close</span>();<br><br>    <span class="hljs-comment">// 5. 重新打开文件以追加数据</span><br>    file.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;example.txt&quot;</span>, ios::out | ios::app); <span class="hljs-comment">// ios::app 表示追加模式</span><br>    <span class="hljs-keyword">if</span> (!file.<span class="hljs-built_in">is_open</span>()) &#123;<br>        cerr &lt;&lt; <span class="hljs-string">&quot;Error: Failed to reopen file for appending!&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 追加数据</span><br>    file &lt;&lt; <span class="hljs-string">&quot;This line is appended to the file.\n&quot;</span>;<br><br>    <span class="hljs-comment">// 6. 再次读取文件内容</span><br>    file.<span class="hljs-built_in">close</span>();<br>    file.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;example.txt&quot;</span>, ios::in); <span class="hljs-comment">// 以只读模式打开文件</span><br>    <span class="hljs-keyword">if</span> (!file.<span class="hljs-built_in">is_open</span>()) &#123;<br>        cerr &lt;&lt; <span class="hljs-string">&quot;Error: Failed to reopen file for reading!&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;\nReading after appending:\n&quot;</span>;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">getline</span>(file, line)) &#123; <span class="hljs-comment">// 逐行读取文件内容</span><br>        cout &lt;&lt; line &lt;&lt; endl;     <span class="hljs-comment">// 输出到控制台</span><br>    &#125;<br><br>    <span class="hljs-comment">// 7. 关闭文件</span><br>    file.<span class="hljs-built_in">close</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-primary">            <p><strong>代码的相关要点解释</strong></p><h4 id="定义文件流对象"><a href="#定义文件流对象" class="headerlink" title="定义文件流对象"></a><strong>定义文件流对象</strong></h4><p><code>fstream file</code>将<strong>文件流对象</strong>和输入的数据流绑定。</p><h4 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h4><p>定义好文件流对象后，就可以使用文件流对象的<code>open()</code>成员函数实现<strong>打开文件</strong>的操作。下面是<code>open()</code>成员函数的参数列表：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">open</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* filename, ios_base::openmode mode = ios_base::in | ios_base::out)</span></span>;<br></code></pre></td></tr></table></figure><p>不难发现<code>open()</code>函数有两个参数，第一个参数接受C语言风格的字符串，第二个参数是**<code>ios_base::openmode</code>**。<code>ios_base::openmode</code> 是 C++ 标准库中定义的一个枚举类型，用于指定文件流的打开模式。它是 <code>std::ios_base</code> 类的成员类型，通常通过 <code>std::ios</code> 命名空间来访问（例如 <code>std::ios::in</code>）。<code>ios_base::openmode</code> 的主要作用是控制文件流的打开方式，例如是读取、写入、追加还是二进制模式等。这些模式可以通过位运算符 <code>|</code> 组合使用。</p><table><thead><tr><th align="left">模式</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>std::ios::in</code></td><td align="left">以读取模式打开文件。如果文件不存在，打开失败。</td></tr><tr><td align="left"><code>std::ios::out</code></td><td align="left">以写入模式打开文件。如果文件不存在，会创建文件；如果文件存在，默认覆盖内容。</td></tr><tr><td align="left"><code>std::ios::app</code></td><td align="left">以追加模式打开文件。所有写入操作都在文件末尾进行，不会覆盖原有内容。</td></tr><tr><td align="left"><code>std::ios::ate</code></td><td align="left">打开文件后，将文件指针定位到文件末尾。</td></tr><tr><td align="left"><code>std::ios::trunc</code></td><td align="left">如果文件存在，清空文件内容（截断文件）。</td></tr><tr><td align="left"><code>std::ios::binary</code></td><td align="left">以二进制模式打开文件（默认是文本模式）。</td></tr></tbody></table><p>因此，上文中<code>file.open(&quot;example.txt&quot;, ios::out | ios::in | ios::trunc);</code>的意思就是：打开<code>example.txt</code>文件，可读可写且截断文件。由默认参数可知，<code>fstream</code>类的对象默认可读也可写。</p><div class="note note-danger">            <p>在实际的应用中，程序员为了保证安全性，会<strong>实现ifstream和ofstream</strong>的分离。在<code>ifstream</code>的情况下，就不可以使用<code>out</code>模式了，反过来也同样如此。</p>          </div><h4 id="检查文件"><a href="#检查文件" class="headerlink" title="检查文件"></a>检查文件</h4><p><strong>在复杂程序中</strong>，加入适当的<strong>检查点</strong>是非常好的习惯，这也有利于我们检查代码是否有一些隐式的错误。例如在这里，我们需要<strong>检查文件是否被成功打开并且被读取</strong>。<code>file.is_open()</code>就是这样一个函数，返回一个布尔值。<code>cerr &lt;&lt; &quot;Error: Failed to open file!&quot; &lt;&lt; endl;</code> 这行代码的作用是向标准错误流（<code>cerr</code>）输出一条错误信息，表示文件打开失败。此时程序会直接结束。</p><h4 id="流输入和流输出运算符"><a href="#流输入和流输出运算符" class="headerlink" title="流输入和流输出运算符"></a>流输入和流输出运算符</h4><p><code>file &lt;&lt; dataToWrite;</code> 这行代码的作用是将数据（<code>dataToWrite</code>）写入到文件流（<code>file</code>）中。它是 C++ 中流插入运算符（<code>&lt;&lt;</code>）的典型用法，用于将数据<strong>输出</strong>到文件。</p><blockquote><p>用法和<code>cout</code>没什么区别</p></blockquote><p>同理，使用<code>&gt;&gt;</code>运算符，可以将<strong>数据输入到文件</strong>中。</p><h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><ul><li>和<code>cin/cout</code>一样，文件的输入输出流也是<strong>忽略空白字符的！</strong>如果有必要也可以向上文的程序一样使用<code>getline()</code>。</li><li>ASCII文件也可以写入各种数字和字符串。</li></ul>          </div><h3 id="Access-to-binary-files"><a href="#Access-to-binary-files" class="headerlink" title="Access to binary files"></a>Access to binary files</h3><p>在二进制文件中，所有的文件输入和读取都是以<strong>字节</strong>为基本单位，这与ASCII的读取有很大的不同。（<strong>ASCII文件可以读取各种类型，包括整型和浮点型</strong>）</p><p>由于在内存中，<code>char</code>类型的数据都只占1个字节，因此，在<strong>二进制文件</strong>中，输入输出都需要<strong>强制转换为char类型指针</strong>后进行操作。这一点会在后面的代码示例中做进一步解释。</p><h4 id="打开二进制文件"><a href="#打开二进制文件" class="headerlink" title="打开二进制文件"></a>打开二进制文件</h4><p>对于二进制文件，<code>fstream</code> 提供了 <code>read</code> 和 <code>write</code> 方法，用于直接读写二进制数据。</p><p>使用 <code>fstream</code> 打开二进制文件时，需要指定文件模式为 <code>ios::binary</code>。<strong>使用方式和ASCII文件没有区别</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 打开二进制文件用于写入</span><br>    <span class="hljs-function">fstream <span class="hljs-title">file</span><span class="hljs-params">(<span class="hljs-string">&quot;data.bin&quot;</span>, ios::out | ios::binary)</span></span>;<br><br>    <span class="hljs-keyword">if</span> (!file) &#123;<br>        cerr &lt;&lt; <span class="hljs-string">&quot;文件打开失败！&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 文件操作...</span><br><br>    file.<span class="hljs-built_in">close</span>(); <span class="hljs-comment">// 关闭文件</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="写入二进制数据"><a href="#写入二进制数据" class="headerlink" title="写入二进制数据"></a><strong>写入二进制数据</strong></h4><p>使用 <code>write</code> 方法将二进制数据写入文件。<code>write</code> 方法的原型为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">ostream&amp; <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* buffer, streamsize size)</span></span>;<br></code></pre></td></tr></table></figure><ul><li><code>buffer</code>：指向要写入的数据的指针。</li><li><code>size</code>：要写入的字节数。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">fstream <span class="hljs-title">file</span><span class="hljs-params">(<span class="hljs-string">&quot;data.bin&quot;</span>, ios::out | ios::binary)</span></span>;<br>    <span class="hljs-keyword">if</span> (!file) &#123;<br>        cerr &lt;&lt; <span class="hljs-string">&quot;文件打开失败！&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span> data[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>    file.<span class="hljs-built_in">write</span>(<span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">char</span>*&gt;(data), <span class="hljs-built_in">sizeof</span>(data)); <span class="hljs-comment">// 写入二进制数据</span><br><br>    file.<span class="hljs-built_in">close</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>reinterpret_cast</code> 是 C++ 中的一种强制类型转换操作符。它可以将任意类型的指针转换为另一种类型的指针，而不改变指针指向的实际数据。它通常用于低级别的内存操作，例如将 <code>int*</code> 转换为 <code>char*</code>。在这里， <code>data</code> 的指针类型被转换为 <code>char*</code> 类型，以便可以按字节访问数据。</p><h4 id="读取二进制数据"><a href="#读取二进制数据" class="headerlink" title="读取二进制数据"></a><strong>读取二进制数据</strong></h4><p>使用 <code>read</code> 方法从二进制文件中读取数据。<code>read</code> 方法的原型为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">istream&amp; <span class="hljs-title">read</span><span class="hljs-params">(<span class="hljs-type">char</span>* buffer, streamsize size)</span></span>;<br></code></pre></td></tr></table></figure><ul><li><code>buffer</code>：指向存储读取数据的缓冲区的指针。</li><li><code>size</code>：要读取的字节数。</li></ul><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">fstream <span class="hljs-title">file</span><span class="hljs-params">(<span class="hljs-string">&quot;data.bin&quot;</span>, ios::in | ios::binary)</span></span>;<br>    <span class="hljs-keyword">if</span> (!file) &#123;<br>        cerr &lt;&lt; <span class="hljs-string">&quot;文件打开失败！&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span> data[<span class="hljs-number">5</span>];<br>    file.<span class="hljs-built_in">read</span>(<span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">char</span>*&gt;(data), <span class="hljs-built_in">sizeof</span>(data)); <span class="hljs-comment">// 读取二进制数据</span><br><br>    <span class="hljs-comment">// 输出读取的数据</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; ++i) &#123;<br>        cout &lt;&lt; data[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout &lt;&lt; endl;<br><br>    file.<span class="hljs-built_in">close</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="File-Pointer"><a href="#File-Pointer" class="headerlink" title="File Pointer"></a>File Pointer</h3><p>在上文的两种访问方式中，无论是对ASCII文件的访问还是对二进制文件的访问，都是<strong>顺序访问</strong>，即扫描一遍文件进行写入或输出等操作。但是，在实际应用中，我们需要更加灵活且高效的文件访问操作：例如<strong>只扫描文件的特定部分</strong>或者<strong>自定义扫描文件的顺序</strong>。换句话，我们需要程序能够自主控制<strong>操作位置的移动</strong>。因此，我们需要<strong>文件指针</strong>。</p><p><strong>文件指针</strong>是用于标识文件中当前位置的一个标记，它指示了下一个读取或写入操作将从文件的哪个位置开始。文件指针的概念在文件操作中非常重要，尤其是在<strong>随机访问文件</strong>时。</p><p>在 C++ 中，文件指针的操作主要通过以下函数实现：</p><ol><li><strong>移动文件指针</strong></li></ol><ul><li><p><code>seekg</code>：用于输入流，移动读取指针。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">istream&amp; <span class="hljs-title">seekg</span> <span class="hljs-params">(streampos pos)</span></span>; <span class="hljs-comment">// 移动到绝对位置</span><br><span class="hljs-function">istream&amp; <span class="hljs-title">seekg</span> <span class="hljs-params">(streamoff off, ios_base::seekdir way)</span></span>; <span class="hljs-comment">// 移动到相对位置</span><br></code></pre></td></tr></table></figure></li><li><p><code>seekp</code>：用于输出流，移动写入指针。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">ostream&amp; <span class="hljs-title">seekp</span> <span class="hljs-params">(streampos pos)</span></span>; <span class="hljs-comment">// 移动到绝对位置</span><br><span class="hljs-function">ostream&amp; <span class="hljs-title">seekp</span> <span class="hljs-params">(streamoff off, ios_base::seekdir way)</span></span>; <span class="hljs-comment">// 移动到相对位置</span><br></code></pre></td></tr></table></figure></li></ul><ol start="2"><li><strong>获取文件指针位置</strong></li></ol><ul><li><p><code>tellg</code>：用于输入流，返回当前读取指针的位置。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">streampos <span class="hljs-title">tellg</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure></li><li><p><code>tellp</code>：用于输出流，返回当前写入指针的位置。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">streampos <span class="hljs-title">tellp</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure></li></ul><blockquote><p><code>streampos</code> 是 C++ 标准库中用于表示<strong>流位置</strong>的数据类型。它通常用于标识文件流（如 <code>ifstream</code>、<code>ofstream</code> 等）中的位置，例如文件指针的位置。<code>streampos</code> 是一个与平台相关的类型，通常是一个整数类型（如 <code>long</code> 或 <code>long long</code>），用于表示从文件开头到某个位置的字节偏移量。</p></blockquote><h4 id="seekg和seekp"><a href="#seekg和seekp" class="headerlink" title="seekg和seekp"></a><code>seekg</code>和<code>seekp</code></h4><p>使用 <code>seekg</code> 和 <code>seekp</code> 可以移动文件指针，分别用于读取和写入操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">file.<span class="hljs-built_in">seekg</span>(<span class="hljs-number">0</span>, ios::beg); <span class="hljs-comment">// 将读取指针移动到文件开头</span><br>file.<span class="hljs-built_in">seekp</span>(<span class="hljs-number">0</span>, ios::end); <span class="hljs-comment">// 将写入指针移动到文件末尾</span><br></code></pre></td></tr></table></figure><div class="note note-info">            <p><code>seekg</code> 和 <code>seekp</code> 是 C++ 中用于文件流定位的成员函数，分别用于输入流和输出流。它们允许你在文件中移动读取或写入的位置。</p><p><code>seekg</code> 用于输入流（如 <code>ifstream</code>），用于设置文件读取位置。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">istream&amp; <span class="hljs-title">seekg</span> <span class="hljs-params">(streampos pos)</span></span>;<br><span class="hljs-function">istream&amp; <span class="hljs-title">seekg</span> <span class="hljs-params">(streamoff off, ios_base::seekdir way)</span></span>;<br></code></pre></td></tr></table></figure><ul><li><code>pos</code>：绝对位置，表示从文件开头到该位置的字节数。</li><li><code>off</code>：偏移量，表示相对于 <code>way</code> 的字节数。</li><li><code>way</code>：基准位置，可以是以下值之一：<ul><li><code>ios_base::beg</code>：文件开头。</li><li><code>ios_base::cur</code>：当前位置。</li><li><code>ios_base::end</code>：文件末尾。</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::ifstream <span class="hljs-title">file</span><span class="hljs-params">(<span class="hljs-string">&quot;example.txt&quot;</span>, std::ios::in | std::ios::binary)</span></span>;<br>    <span class="hljs-keyword">if</span> (file) &#123;<br>        file.<span class="hljs-built_in">seekg</span>(<span class="hljs-number">10</span>, std::ios::beg); <span class="hljs-comment">// 从文件开头移动10个字节</span><br>        <span class="hljs-type">char</span> buffer[<span class="hljs-number">20</span>];<br>        file.<span class="hljs-built_in">read</span>(buffer, <span class="hljs-number">20</span>); <span class="hljs-comment">// 读取20个字节</span><br>        std::cout.<span class="hljs-built_in">write</span>(buffer, <span class="hljs-number">20</span>);<br>        file.<span class="hljs-built_in">close</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>seekp</code> 用于输出流（如 <code>ofstream</code>），用于设置文件写入位置。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">ostream&amp; <span class="hljs-title">seekp</span> <span class="hljs-params">(streampos pos)</span></span>;<br><span class="hljs-function">ostream&amp; <span class="hljs-title">seekp</span> <span class="hljs-params">(streamoff off, ios_base::seekdir way)</span></span>;<br></code></pre></td></tr></table></figure><ul><li><code>pos</code>：绝对位置，表示从文件开头到该位置的字节数。</li><li><code>off</code>：偏移量，表示相对于 <code>way</code> 的字节数。</li><li><code>way</code>：基准位置，可以是以下值之一：<ul><li><code>ios_base::beg</code>：文件开头。</li><li><code>ios_base::cur</code>：当前位置。</li><li><code>ios_base::end</code>：文件末尾。</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::ofstream <span class="hljs-title">file</span><span class="hljs-params">(<span class="hljs-string">&quot;example.txt&quot;</span>, std::ios::out | std::ios::binary)</span></span>;<br>    <span class="hljs-keyword">if</span> (file) &#123;<br>        file.<span class="hljs-built_in">seekp</span>(<span class="hljs-number">10</span>, std::ios::beg); <span class="hljs-comment">// 从文件开头移动10个字节</span><br>        file.<span class="hljs-built_in">write</span>(<span class="hljs-string">&quot;Hello, World!&quot;</span>, <span class="hljs-number">13</span>); <span class="hljs-comment">// 写入13个字节</span><br>        file.<span class="hljs-built_in">close</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>          </div><h4 id="tellg和tellp"><a href="#tellg和tellp" class="headerlink" title="tellg和tellp"></a><code>tellg</code>和<code>tellp</code></h4><p><code>tellp</code> 和 <code>tellg</code> 是 C++ 中用于文件流位置操作的成员函数，分别用于输出流和输入流。它们的作用是返回当前文件指针的位置（以字节为单位）。</p><p><code>tellg</code> 用于输入流（如 <code>ifstream</code>），返回当前读取位置。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">streampos <span class="hljs-title">tellg</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><ul><li>返回一个 <code>streampos</code> 类型的值，表示当前读取位置（从文件开头的字节偏移量）。</li><li>如果失败，返回 <code>-1</code>。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::ifstream <span class="hljs-title">file</span><span class="hljs-params">(<span class="hljs-string">&quot;example.txt&quot;</span>, std::ios::in | std::ios::binary)</span></span>;<br>    <span class="hljs-keyword">if</span> (file) &#123;<br>        file.<span class="hljs-built_in">seekg</span>(<span class="hljs-number">10</span>, std::ios::beg); <span class="hljs-comment">// 移动读取位置到第10字节</span><br>        std::streampos pos = file.<span class="hljs-built_in">tellg</span>(); <span class="hljs-comment">// 获取当前读取位置</span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Current read position: &quot;</span> &lt;&lt; pos &lt;&lt; std::endl;<br>        file.<span class="hljs-built_in">close</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>tellp</code> 用于输出流（如 <code>ofstream</code>），返回当前写入位置。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">streampos <span class="hljs-title">tellp</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><ul><li>返回一个 <code>streampos</code> 类型的值，表示当前写入位置（从文件开头的字节偏移量）。</li><li>如果失败，返回 <code>-1</code>。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::ofstream <span class="hljs-title">file</span><span class="hljs-params">(<span class="hljs-string">&quot;example.txt&quot;</span>, std::ios::out | std::ios::binary)</span></span>;<br>    <span class="hljs-keyword">if</span> (file) &#123;<br>        file.<span class="hljs-built_in">seekp</span>(<span class="hljs-number">20</span>, std::ios::beg); <span class="hljs-comment">// 移动写入位置到第20字节</span><br>        std::streampos pos = file.<span class="hljs-built_in">tellp</span>(); <span class="hljs-comment">// 获取当前写入位置</span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Current write position: &quot;</span> &lt;&lt; pos &lt;&lt; std::endl;<br>        file.<span class="hljs-built_in">close</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="综合示例"><a href="#综合示例" class="headerlink" title="综合示例"></a>综合示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 写入数据到文件</span><br>    <span class="hljs-function">std::ofstream <span class="hljs-title">outFile</span><span class="hljs-params">(<span class="hljs-string">&quot;example.txt&quot;</span>, std::ios::out | std::ios::binary)</span></span>;<br>    <span class="hljs-keyword">if</span> (outFile) &#123;<br>        outFile &lt;&lt; <span class="hljs-string">&quot;Hello, World!&quot;</span>; <span class="hljs-comment">// 写入字符串</span><br>        std::streampos writePos = outFile.<span class="hljs-built_in">tellp</span>(); <span class="hljs-comment">// 获取当前写入位置</span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Write position after writing: &quot;</span> &lt;&lt; writePos &lt;&lt; std::endl;<br>        outFile.<span class="hljs-built_in">close</span>();<br>    &#125;<br><br>    <span class="hljs-comment">// 读取数据从文件</span><br>    <span class="hljs-function">std::ifstream <span class="hljs-title">inFile</span><span class="hljs-params">(<span class="hljs-string">&quot;example.txt&quot;</span>, std::ios::in | std::ios::binary)</span></span>;<br>    <span class="hljs-keyword">if</span> (inFile) &#123;<br>        inFile.<span class="hljs-built_in">seekg</span>(<span class="hljs-number">0</span>, std::ios::end); <span class="hljs-comment">// 移动读取位置到文件末尾</span><br>        std::streampos endPos = inFile.<span class="hljs-built_in">tellg</span>(); <span class="hljs-comment">// 获取文件大小</span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;File size: &quot;</span> &lt;&lt; endPos &lt;&lt; <span class="hljs-string">&quot; bytes&quot;</span> &lt;&lt; std::endl;<br><br>        inFile.<span class="hljs-built_in">seekg</span>(<span class="hljs-number">0</span>, std::ios::beg); <span class="hljs-comment">// 移动读取位置到文件开头</span><br>        <span class="hljs-type">char</span> buffer[<span class="hljs-number">100</span>];<br>        inFile.<span class="hljs-built_in">read</span>(buffer, endPos); <span class="hljs-comment">// 读取整个文件</span><br>        buffer[endPos] = <span class="hljs-string">&#x27;\0&#x27;</span>; <span class="hljs-comment">// 添加字符串结束符</span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;File content: &quot;</span> &lt;&lt; buffer &lt;&lt; std::endl;<br>        inFile.<span class="hljs-built_in">close</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Stream-based-files"><a href="#Stream-based-files" class="headerlink" title="Stream-based files"></a>Stream-based files</h3><p>这一部分的内容笔者将会单独拉出来更新一期，敬请期待。</p><h2 id="String-based-input-and-output"><a href="#String-based-input-and-output" class="headerlink" title="String-based input and output"></a>String-based input and output</h2><p>在 C++ 编程中，处理字符串和数字之间的转换是一项常见的任务。</p><p><code>sstream</code> 是 C++ 标准库中的一个组件，它提供了一种方便的方式来处理字符串流（可以像处理流一样处理字符串）。<code>&lt;sstream&gt;</code> 允许你将字符串当作输入&#x2F;输出流来使用，这使得从字符串中读取数据或将数据写入字符串变得非常简单。</p><h3 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h3><p><code>sstream</code>是 C++ 标准库中的一个命名空间，它包含了几个类，用于处理字符串流，这些类包括：</p><ul><li><code>istringstream</code>：用于从字符串中读取数据。</li><li><code>ostringstream</code>：用于将数据写入字符串。</li><li><code>stringstream</code>：是<code>istringstream</code>和<code>ostringstream</code>的组合，可以同时进行读取和写入操作。</li></ul><h3 id="Grammar"><a href="#Grammar" class="headerlink" title="Grammar"></a>Grammar</h3><p>使用<code>sstream</code>的基本语法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sstream&gt;</span></span><br><br><span class="hljs-comment">// 使用istringstream</span><br><span class="hljs-function">std::istringstream <span class="hljs-title">iss</span><span class="hljs-params">(<span class="hljs-string">&quot;some data&quot;</span>)</span></span>;<br><br><span class="hljs-comment">// 使用ostringstream</span><br>std::ostringstream oss;<br><br><span class="hljs-comment">// 使用stringstream</span><br>std::stringstream ss;<br></code></pre></td></tr></table></figure><h4 id="从字符串读取数据"><a href="#从字符串读取数据" class="headerlink" title="从字符串读取数据"></a>从字符串读取数据</h4><p>下面是一个使用 <code>istringstream</code> 从字符串中读取整数和浮点数的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sstream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  std::string data = <span class="hljs-string">&quot;10 20.5&quot;</span>;<br>  <span class="hljs-function">std::istringstream <span class="hljs-title">iss</span><span class="hljs-params">(data)</span></span>;<br><br>  <span class="hljs-type">int</span> i;<br>  <span class="hljs-type">double</span> d;<br><br>  iss &gt;&gt; i &gt;&gt; d;<br><br>  std::cout &lt;&lt; <span class="hljs-string">&quot;Integer: &quot;</span> &lt;&lt; i &lt;&lt; std::endl;<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;Double: &quot;</span> &lt;&lt; d &lt;&lt; std::endl;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>输出结果：</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Integer</span>: <span class="hljs-number">10</span><br><span class="hljs-attribute">Double</span>: <span class="hljs-number">20</span>.<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><h4 id="向字符串写入数据"><a href="#向字符串写入数据" class="headerlink" title="向字符串写入数据"></a>向字符串写入数据</h4><p>下面是一个使用 <code>ostringstream</code> 将数据写入字符串的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sstream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  std::ostringstream oss;<br>  <span class="hljs-type">int</span> i = <span class="hljs-number">100</span>;<br>  <span class="hljs-type">double</span> d = <span class="hljs-number">200.5</span>;<br><br>  oss &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; d;<br><br>  std::string result = oss.<span class="hljs-built_in">str</span>();<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;Resulting string: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>输出结果：</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Resulting</span> string: <span class="hljs-number">100</span> <span class="hljs-number">200</span>.<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><h4 id="使用stringstream进行读写操作"><a href="#使用stringstream进行读写操作" class="headerlink" title="使用stringstream进行读写操作"></a>使用stringstream进行读写操作</h4><p>下面是一个使用 <code>stringstream</code> 同时进行读取和写入操作的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sstream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  std::string data = <span class="hljs-string">&quot;30 40.5&quot;</span>;<br>  <span class="hljs-function">std::stringstream <span class="hljs-title">ss</span><span class="hljs-params">(data)</span></span>;<br><br>  <span class="hljs-type">int</span> i;<br>  <span class="hljs-type">double</span> d;<br><br>  <span class="hljs-comment">// 从stringstream读取数据</span><br>  ss &gt;&gt; i &gt;&gt; d;<br><br>  std::cout &lt;&lt; <span class="hljs-string">&quot;Read Integer: &quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;, Double: &quot;</span> &lt;&lt; d &lt;&lt; std::endl;<br><br>  <span class="hljs-comment">// 向stringstream写入数据</span><br>  ss.<span class="hljs-built_in">str</span>(<span class="hljs-string">&quot;&quot;</span>); <span class="hljs-comment">// 清空stringstream</span><br>  ss &lt;&lt; <span class="hljs-string">&quot;New data: &quot;</span> &lt;&lt; <span class="hljs-number">50</span> &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; <span class="hljs-number">60.7</span>;<br><br>  std::string newData = ss.<span class="hljs-built_in">str</span>();<br>  <span class="hljs-comment">//使用str()来实现字符串的写入。</span><br>  std::cout &lt;&lt; <span class="hljs-string">&quot;New data string: &quot;</span> &lt;&lt; newData &lt;&lt; std::endl;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>输出结果：</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Read</span> Integer: <span class="hljs-number">30</span>, Double: <span class="hljs-number">40</span>.<span class="hljs-number">5</span><br><span class="hljs-attribute">New</span> data string: New data: <span class="hljs-number">50</span> <span class="hljs-number">60</span>.<span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><p>例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    stringstream input;<br>    input&lt;&lt;<span class="hljs-string">&quot;hello world&quot;</span>;<br>    string a,b;<br>    input&gt;&gt;a&gt;&gt;b;<br>    cout&lt;&lt;a&lt;&lt;endl;<br>    cout&lt;&lt;b&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="字符串中的str"><a href="#字符串中的str" class="headerlink" title="字符串中的str()"></a>字符串中的<code>str()</code></h3><p><code>std::stringstream</code> 类提供了一个名为 <code>str</code> 的成员函数，用于<strong>获取和设置流中的字符串内容</strong>。这个函数有两个重载版本，一个是无参的，用于获取流中的字符串内容；另一个是带一个 <code>std::string</code> 参数的，用于设置流中的字符串内容。</p><h5 id="获取字符串内容"><a href="#获取字符串内容" class="headerlink" title="获取字符串内容"></a>获取字符串内容</h5><p>当你调用无参的 <code>str</code> 函数时，它会返回一个 <code>std::string</code>，包含当前流中的所有内容。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sstream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::stringstream ss;<br>    ss &lt;&lt; <span class="hljs-string">&quot;Hello, &quot;</span> &lt;&lt; <span class="hljs-string">&quot;world!&quot;</span>;<br>    std::string result = ss.<span class="hljs-built_in">str</span>(); <span class="hljs-comment">// 获取流中的内容</span><br>    std::cout &lt;&lt; result &lt;&lt; std::endl; <span class="hljs-comment">// 输出: Hello, world!</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="设置字符串内容"><a href="#设置字符串内容" class="headerlink" title="设置字符串内容"></a>设置字符串内容</h5><p>当你调用带 <code>std::string</code> 参数的 <code>str</code> 函数时，它会设置流的内容为指定的字符串，并清除之前的内容。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sstream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::stringstream ss;<br>    ss &lt;&lt; <span class="hljs-string">&quot;Initial content.&quot;</span>;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Before: &quot;</span> &lt;&lt; ss.<span class="hljs-built_in">str</span>() &lt;&lt; std::endl; <span class="hljs-comment">// 输出: Before: Initial content.</span><br><br>    ss.<span class="hljs-built_in">str</span>(<span class="hljs-string">&quot;New content.&quot;</span>); <span class="hljs-comment">// 设置新的内容</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;After: &quot;</span> &lt;&lt; ss.<span class="hljs-built_in">str</span>() &lt;&lt; std::endl; <span class="hljs-comment">// 输出: After: New content.</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="结合使用-str-和-clear-方法"><a href="#结合使用-str-和-clear-方法" class="headerlink" title="结合使用 str 和 clear 方法"></a>结合使用 <code>str</code> 和 <code>clear</code> 方法</h5><p>在重用 <code>std::stringstream</code> 对象时，通常会结合使用 <code>str</code> 方法和 <code>clear</code> 方法。<code>str</code> 方法用于设置新的字符串内容，而 <code>clear</code> 方法用于重置流的状态（例如，清除错误标志）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sstream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::stringstream ss;<br>    ss &lt;&lt; <span class="hljs-string">&quot;123 456&quot;</span>;<br>    <span class="hljs-type">int</span> a, b;<br>    ss &gt;&gt; a &gt;&gt; b;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;a: &quot;</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot;, b: &quot;</span> &lt;&lt; b &lt;&lt; std::endl; <span class="hljs-comment">// 输出: a: 123, b: 456</span><br><br>    ss.<span class="hljs-built_in">clear</span>(); <span class="hljs-comment">// 重置流的状态</span><br>    <span class="hljs-comment">//重置流的状态意味着清除流的状态标志（如错误标志、结束标志等），但并不改变流的内部缓冲区的内容。换句话说，重置状态让流恢复到一个干净的状态，但原有数据仍然保留。</span><br>    ss.<span class="hljs-built_in">str</span>(<span class="hljs-string">&quot;&quot;</span>); <span class="hljs-comment">// 清空流的内容</span><br><br>    ss &lt;&lt; <span class="hljs-string">&quot;789 1011&quot;</span>;<br>    ss &gt;&gt; a &gt;&gt; b;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;a: &quot;</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot;, b: &quot;</span> &lt;&lt; b &lt;&lt; std::endl; <span class="hljs-comment">// 输出: a: 789, b: 1011</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ul><li><code>str()</code>：无参版本用于获取流中的字符串内容。</li><li><code>str(const std::string &amp;s)</code>：带参数版本用于设置流中的字符串内容，并清除之前的内容。</li></ul><p>通过使用 <code>str</code> 方法，你可以方便地获取和设置 <code>std::stringstream</code> 对象中的字符串内容，从而实现灵活的字符串操作。</p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><ul><li>基于控制台的输入输出</li><li>基于文件的输入输出</li><li>基于字符串的输入输出</li></ul><blockquote><p>这一块的知识确实是有一点冗杂的<del>学会cin&#x2F;cout其实就可以解决大部分的输入输出问题了。建议本章节可以在实践中学习，效果更佳</del></p></blockquote><div class="note note-info">            <p><strong>至此，笔者有关C++语法专题的所有内容全部更新完成啦！！！完结撒花！！！</strong></p><p>梳理一下大概更新了些啥：</p><ul><li>面向对象编程——C++ Primer Plus专题<ul><li><a href="https://xiyuanyang-code.github.io/posts/Introduction-to-OOP/">OOP入门</a></li><li><a href="https://xiyuanyang-code.github.io/posts/Dynamic-Memory-and-Classes/">类和动态内存分配</a></li><li><a href="https://xiyuanyang-code.github.io/posts/Class-Inheritance/">类的继承</a></li><li><a href="https://xiyuanyang-code.github.io/posts/Code-Reuse-in-OOP/">代码重用和高阶技巧</a></li></ul></li><li><a href="https://xiyuanyang-code.github.io/posts/Linked-List-Implementation-Based-on-Structs/">基于结构体的链表实现代码</a></li><li><a href="https://xiyuanyang-code.github.io/posts/Exception-Handling-in-C-plus-plus/">C++中的异常处理</a></li><li><a href="https://xiyuanyang-code.github.io/posts/Pointers-Arrays-and-Functions/">数组——指针——函数</a></li><li><a href="https://xiyuanyang-code.github.io/posts/Input-and-Output-in-C-plus-plus/">C++中的输入输出</a></li></ul><p><strong>后续，笔者将会把更新的重点放在数据结构和算法以及Python语法和专业基础课上，敬请期待~</strong></p>          </div><blockquote><p>THE END</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Code</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tutorial</tag>
      
      <tag>Finished</tag>
      
      <tag>C/C++</tag>
      
      <tag>IO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DataStructure-Stack</title>
    <link href="/posts/DataStructure-Stack/"/>
    <url>/posts/DataStructure-Stack/</url>
    
    <content type="html"><![CDATA[<style>  html, body, .markdown-body {    font-family: Georgia, sans, serif;  }</style><h1 id="数据结构——栈"><a href="#数据结构——栈" class="headerlink" title="数据结构——栈"></a>数据结构——栈</h1><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><h2 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h2><p><strong>栈（Stack）</strong>是一种特殊的线性表，在这种线性表中，<strong>插入和删除运算限制在表的某一端进行</strong>。<strong>进行插入和删除 的一段叫栈顶</strong>，另一端称为<strong>栈底</strong>。</p><p><strong>栈</strong>的最重要的性质是**后进先出(Last in, first out LIFO)**，即位于栈顶的元素相当于叠叠乐中最上面的人，最后入栈但最后出栈。</p><p><img src="https://www.hello-algo.com/chapter_stack_and_queue/stack.assets/stack_operations.png" alt="栈的先入后出规则 Hello 算法"></p><p><strong>栈的基本计算如下：</strong></p><ul><li>创建一个栈</li><li>进栈 <code>push()</code></li><li>出栈 <code>pop()</code></li><li>读取栈顶元素但不弹出 <code>top()</code></li><li>判断栈空 <code>isEmpty()</code></li></ul><h2 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h2><p>首先实现栈的抽象类：</p><blockquote><p>由于线性表的抽象类设置了许多纯虚函数，并且栈的许多操作实现和一般的线性表差异较大。因此此处无法直接继承线性表的抽象基类。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ElementType&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Stack</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Stack</span>() &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">const</span> ElementType&amp; element)</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> ElementType <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> ElementType <span class="hljs-title">top</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//同样设置为纯虚函数</span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="栈的顺序实现（类似于数组）"><a href="#栈的顺序实现（类似于数组）" class="headerlink" title="栈的顺序实现（类似于数组）"></a>栈的顺序实现（类似于数组）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Exception.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Stack.h&quot;</span></span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ElementType&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SequentialStack</span> : <span class="hljs-keyword">public</span> Stack&lt;ElementType&gt;<br>&#123;<br><span class="hljs-keyword">private</span>:<br>    ElementType* elementData;<br>    <span class="hljs-comment">//存储栈元素的数组名</span><br>    <span class="hljs-type">int</span> topPosition, totalCapacity;<br>    <span class="hljs-comment">//栈顶序列和总容量</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">expand</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">SequentialStack</span>(<span class="hljs-type">int</span> size = <span class="hljs-number">10</span>);<br>    ~<span class="hljs-built_in">SequentialStack</span>();<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">const</span> ElementType&amp; element)</span></span>;<br>    <span class="hljs-function">ElementType <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function">ElementType <span class="hljs-title">top</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ElementType&gt;<br><span class="hljs-type">void</span> SequentialStack&lt;ElementType&gt;::<span class="hljs-built_in">expand</span>()<br>    <span class="hljs-comment">//私有成员函数</span><br>&#123;<br>    ElementType* TempData = elementData;<br>    totalCapacity *= <span class="hljs-number">2</span>;<span class="hljs-comment">//将栈的容量扩大两倍</span><br>    elementData = <span class="hljs-keyword">new</span> ElementType[totalCapacity];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= topPosition; i++)<br>        elementData[i] = TempData[i];<br>    <span class="hljs-keyword">delete</span>[] TempData;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ElementType&gt;<br>SequentialStack&lt;ElementType&gt;::<span class="hljs-built_in">SequentialStack</span>(<span class="hljs-type">int</span> size)<span class="hljs-comment">//构造函数</span><br>&#123;<br>    elementData = <span class="hljs-keyword">new</span> ElementType[size];<br>    totalCapacity = size;<br>    topPosition = <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ElementType&gt;<br>SequentialStack&lt;ElementType&gt;::~<span class="hljs-built_in">SequentialStack</span>()<span class="hljs-comment">//destructor</span><br>&#123;<br>    <span class="hljs-keyword">delete</span>[] elementData;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ElementType&gt;<br><span class="hljs-type">bool</span> SequentialStack&lt;ElementType&gt;::<span class="hljs-built_in">empty</span>() <span class="hljs-type">const</span><br>&#123;<br>    <span class="hljs-keyword">return</span> topPosition == <span class="hljs-number">-1</span>;<br>    <span class="hljs-comment">//清空栈顶，将栈顶序列设置为特殊的-1</span><br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ElementType&gt;<br><span class="hljs-type">void</span> SequentialStack&lt;ElementType&gt;::<span class="hljs-built_in">push</span>(<span class="hljs-type">const</span> ElementType&amp; element)<br>&#123;<br>    <span class="hljs-keyword">if</span> (topPosition == totalCapacity - <span class="hljs-number">1</span>)<br>        <span class="hljs-built_in">expand</span>();<br>    <span class="hljs-comment">//说明已经存储不下了</span><br>    elementData[++topPosition] = element;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ElementType&gt;<br>ElementType SequentialStack&lt;ElementType&gt;::<span class="hljs-built_in">pop</span>()<br>&#123;<br>    <span class="hljs-keyword">if</span> (topPosition == <span class="hljs-number">-1</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-built_in">EmptyContainer</span>(<span class="hljs-string">&quot;Error: Stack is already empty&quot;</span>);<br>    <span class="hljs-keyword">return</span> elementData[topPosition--];<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ElementType&gt;<br>ElementType SequentialStack&lt;ElementType&gt;::<span class="hljs-built_in">top</span>() <span class="hljs-type">const</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (topPosition == <span class="hljs-number">-1</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-built_in">EmptyContainer</span>(<span class="hljs-string">&quot;Error: Stack is already empty&quot;</span>);<br>    <span class="hljs-keyword">return</span> elementData[topPosition];<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ElementType&gt;<br><span class="hljs-type">void</span> SequentialStack&lt;ElementType&gt;::<span class="hljs-built_in">clear</span>()<br>&#123;<br>    topPosition = <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><code>topPosition</code>代表栈当前的栈顶序列，如果现在栈有3个元素，这栈顶序列为2。空栈的栈顶序列为-1。</p></blockquote><p>顺序<strong>栈的运算复杂度非常低</strong>：除了进栈操作需要扩充的特殊情况（即调用<code>expand()</code>函数），其余运算的时间复杂度均为<code>O(1)</code>。</p><h3 id="栈的链接实现"><a href="#栈的链接实现" class="headerlink" title="栈的链接实现"></a>栈的链接实现</h3><p>在栈的链接实现中，栈顶元素就相当于是<strong>头结点</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Exception.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Stack.h&quot;</span></span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ElementType&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkedStack</span> : <span class="hljs-keyword">public</span> Stack&lt;ElementType&gt;<br>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">StackNode</span><br>        <span class="hljs-comment">//和链表一样定义节点</span><br>    &#123;<br>        ElementType data;<br>        StackNode* next;<br>        <span class="hljs-built_in">StackNode</span>() : <span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br>        <span class="hljs-built_in">StackNode</span>(<span class="hljs-type">const</span> ElementType&amp; _data, StackNode* _next = <span class="hljs-literal">nullptr</span>) : <span class="hljs-built_in">data</span>(_data), <span class="hljs-built_in">next</span>(_next) &#123;&#125;<br>        ~<span class="hljs-built_in">StackNode</span>() &#123;&#125;<br>    &#125;;<br>    StackNode* head;<br>    <span class="hljs-comment">//需要维护一个指针始终指向头结点</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">LinkedStack</span>();<br>    ~<span class="hljs-built_in">LinkedStack</span>();<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">const</span> ElementType&amp; element)</span></span>;<br>    <span class="hljs-function">ElementType <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function">ElementType <span class="hljs-title">top</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ElementType&gt;<br>LinkedStack&lt;ElementType&gt;::<span class="hljs-built_in">LinkedStack</span>()<br>&#123;<br>    head = <span class="hljs-literal">nullptr</span>;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ElementType&gt;<br>LinkedStack&lt;ElementType&gt;::~<span class="hljs-built_in">LinkedStack</span>()<br>&#123;<br>    <span class="hljs-built_in">clear</span>();<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ElementType&gt;<br><span class="hljs-type">bool</span> LinkedStack&lt;ElementType&gt;::<span class="hljs-built_in">empty</span>() <span class="hljs-type">const</span><br>&#123;<br>    <span class="hljs-keyword">return</span> head == <span class="hljs-literal">nullptr</span>;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ElementType&gt;<br><span class="hljs-type">void</span> LinkedStack&lt;ElementType&gt;::<span class="hljs-built_in">push</span>(<span class="hljs-type">const</span> ElementType&amp; element)<br>&#123;<br>    head = <span class="hljs-keyword">new</span> <span class="hljs-built_in">StackNode</span>(element, head);<br>    <span class="hljs-comment">//从右向左读，使用构造函数创建了一个临时变量，值为element，指向的节点是当前head的地址。</span><br>    <span class="hljs-comment">//现在将它对head进行赋值，则head指向的地址发生改变(指向现在新的栈顶元素)，而原来的栈顶元素变成了head-&gt;next所指向的</span><br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ElementType&gt;<br>ElementType LinkedStack&lt;ElementType&gt;::<span class="hljs-built_in">pop</span>()<br>&#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">nullptr</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-built_in">EmptyContainer</span>(<span class="hljs-string">&quot;Error: Stack is already empty&quot;</span>);<br>    StackNode* temp = head;<br>    ElementType value = temp-&gt;data;<br>    head = head-&gt;next;<br>    <span class="hljs-comment">//此时head指向的下一个节点成为新的栈顶元素</span><br>    <span class="hljs-keyword">delete</span> temp;<br>    <span class="hljs-keyword">return</span> value;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ElementType&gt;<br>ElementType LinkedStack&lt;ElementType&gt;::<span class="hljs-built_in">top</span>() <span class="hljs-type">const</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">nullptr</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-built_in">EmptyContainer</span>(<span class="hljs-string">&quot;Error: Stack is already empty&quot;</span>);<br>    <span class="hljs-keyword">return</span> head-&gt;data;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ElementType&gt;<br><span class="hljs-type">void</span> LinkedStack&lt;ElementType&gt;::<span class="hljs-built_in">clear</span>()<br>&#123;<br>    StackNode* temp;<br>    <span class="hljs-keyword">while</span> (head != <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        temp = head;<br>        head = head-&gt;next;<br>        <span class="hljs-keyword">delete</span> temp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>栈的链接实现</strong>在效率上优于栈的顺序实现，因为<strong>不用扩容</strong>，不用维护<code>topPosition</code>。</p><h2 id="Stack-in-STL"><a href="#Stack-in-STL" class="headerlink" title="Stack in STL"></a>Stack in STL</h2><p>STL中的栈有四个基本运算：</p><ul><li><code>push</code>（进栈）</li><li><code>pop</code>（出栈）</li><li><code>top</code>（返回首元素）</li><li><code>empty</code>（检查栈是否为空）</li></ul><p>以下是一个实例代码，展示了栈的若干基本操作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 创建一个整数栈</span><br>    std::stack&lt;<span class="hljs-type">int</span>&gt; s;<br><br>    <span class="hljs-comment">// 压入元素</span><br>    s.<span class="hljs-built_in">push</span>(<span class="hljs-number">10</span>);<br>    s.<span class="hljs-built_in">push</span>(<span class="hljs-number">20</span>);<br>    s.<span class="hljs-built_in">push</span>(<span class="hljs-number">30</span>);<br><br>    <span class="hljs-comment">// 获取栈顶元素</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;栈顶元素: &quot;</span> &lt;&lt; s.<span class="hljs-built_in">top</span>() &lt;&lt; std::endl;  <span class="hljs-comment">// 输出 30</span><br><br>    <span class="hljs-comment">// 弹出栈顶元素</span><br>    s.<span class="hljs-built_in">pop</span>();<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;弹出后栈顶元素: &quot;</span> &lt;&lt; s.<span class="hljs-built_in">top</span>() &lt;&lt; std::endl;  <span class="hljs-comment">// 输出 20</span><br><br>    <span class="hljs-comment">// 栈是否为空</span><br>    <span class="hljs-keyword">if</span> (!s.<span class="hljs-built_in">empty</span>()) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;栈不为空，元素个数: &quot;</span> &lt;&lt; s.<span class="hljs-built_in">size</span>() &lt;&lt; std::endl;  <span class="hljs-comment">// 输出 2</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>stack</code> 默认使用 <code>deque</code> 作为底层容器，但也可以通过模板参数指定其他容器，如 <code>vector</code> 或 <code>list</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">std::stack&lt;<span class="hljs-type">int</span>, std::vector&lt;<span class="hljs-type">int</span>&gt;&gt; s;  <span class="hljs-comment">// 使用 vector 作为底层容器</span><br>std::stack&lt;<span class="hljs-type">int</span>, std::list&lt;<span class="hljs-type">int</span>&gt;&gt; s;    <span class="hljs-comment">// 使用 list 作为底层容器（链接栈的实现）</span><br></code></pre></td></tr></table></figure><blockquote><p><code>deque</code>（双端队列）是 C++ 标准库中提供的一个容器，它可以在两端高效地插入或删除元素。它的名字 <code>deque</code> 是 “double-ended queue” 的缩写，表示它支持在队列的两端进行操作。我们在下一讲介绍队列的时候会详细介绍<code>deque</code>的用法。</p></blockquote><h2 id="Application"><a href="#Application" class="headerlink" title="Application"></a>Application</h2><h3 id="Recursive-cleaning"><a href="#Recursive-cleaning" class="headerlink" title="Recursive cleaning"></a>Recursive cleaning</h3><h4 id="Recursion"><a href="#Recursion" class="headerlink" title="Recursion"></a>Recursion</h4><p>我们常常使用<strong>递归</strong>（函数嵌套函数）的方法解决问题，但是，递归会消耗<strong>大量的时间和空间复杂度。</strong>为什么？下面我们先来详细地从内存视角解释一下递归的产生机理。</p><p>在内存管理中，所谓的“栈”内存（stack memory）就是<strong>栈</strong>的操作模式相似，按照一定的规则进行分配和回收。栈内存（stack memory）主要用于<strong>存储局部变量、函数参数、函数调用的返回地址</strong>等数据。它的分配和回收非常迅速，通常是由操作系统自动管理的。栈内存的特点如下：</p><ul><li><strong>后进先出（LIFO）</strong>：栈内存的分配和回收遵循“后进先出”的规则，最近压入栈的数据会最先被弹出，这与栈数据结构的操作模式一致。</li><li><strong>自动管理</strong>：栈内存的分配和释放由系统自动管理，通常是函数的调用和返回过程中，栈帧（stack frame）的创建和销毁。</li><li><strong>空间有限</strong>：栈的大小通常是固定的，超过限制时会发生栈溢出（stack overflow）。</li></ul><p><img src="/posts/DataStructure-Stack/Recursion.png" alt="Recursion"></p><p>我们先来看一种比较特殊的情况，<strong>函数的嵌套调用</strong>。在<code>main</code>函数中，函数调用<code>max</code>函数，在<code>max</code>函数中，函数调用<code>p</code>函数，形成了函数调用的一种<strong>三层嵌套</strong>。上文讲过，<strong>函数体内部的局部变量</strong>通常是存储在栈内存上的。这些局部变量在函数调用时被创建，并在函数返回时自动销毁（具体的过程如上图右侧所演示）。也就是说，当函数嵌套的层数变多时，系统执行这一个过程所需的<strong>最大栈内存</strong>会不断递增。</p><p>回到递归的例子，当递归层数增多时，在<strong>栈内存</strong>上的<strong>栈帧空间</strong>会不断变大（因为上一级的函数没有返回对应的值，函数的调用没有结束，所有栈内存上会一直保留着函数的上下文）。<strong>这会带来极大的内存消耗！！！</strong></p><blockquote><p>目前一些编译器对<strong>尾递归</strong>优化可以不保留上下文，但是对于没有尾递归的情况（例如回溯算法），则栈内存的低效使用是<strong>递归</strong>不得不面对的问题。</p></blockquote><p><img src="https://www.hello-algo.com/chapter_computational_complexity/iteration_and_recursion.assets/recursion_sum_depth.png" alt="递归调用深度 Hello 算法"></p><h4 id="Using-Stack-instead-of-Recursion"><a href="#Using-Stack-instead-of-Recursion" class="headerlink" title="Using Stack instead of Recursion"></a>Using Stack instead of Recursion</h4><p>下面看一个程序实例：我们需要打印正整数的值：</p><blockquote><p>没事找事做的程序（乐）</p></blockquote><p>如果使用递归函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(num&lt;<span class="hljs-number">10</span>)&#123;<br>        cout&lt;&lt;num;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-built_in">print</span>(num/<span class="hljs-number">10</span>);  <span class="hljs-comment">//Recursion</span><br>        cout&lt;&lt;num%<span class="hljs-number">10</span>;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> N;cin&gt;&gt;N;<br>    <span class="hljs-built_in">print</span>(N);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个递归实现本身较为简单，但是当递归深度较大时，该算法对<strong>栈内存的利用率</strong>非常低，例如，系统会在栈内存上分配<strong>栈帧</strong>，即为每一层函数存储局部变量、函数参数、返回地址等信息。但是，我们只希望存储一个值！</p><p>因此，我们可以<strong>从内存的视角优化递归算法</strong>。使用栈消除递归就是程序员<strong>自己模拟函数的调用</strong>，自己维护一个<strong>栈</strong>来存储目标值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> num)</span></span>&#123;<br>    stack&lt;<span class="hljs-type">int</span>&gt; s;<br>    <span class="hljs-type">int</span> tmp;<br>    <span class="hljs-type">int</span> maxsize=<span class="hljs-number">0</span>;<br>    s.<span class="hljs-built_in">push</span>(num);<br>    maxsize++;<br>    <span class="hljs-keyword">while</span>(!s.<span class="hljs-built_in">empty</span>())&#123;<br>        <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">top</span>()&gt;<span class="hljs-number">9</span>)&#123;<br>            tmp=s.<span class="hljs-built_in">top</span>();<br>            s.<span class="hljs-built_in">pop</span>();<br>            s.<span class="hljs-built_in">push</span>(tmp%<span class="hljs-number">10</span>);<br>            s.<span class="hljs-built_in">push</span>(tmp/<span class="hljs-number">10</span>);<br>            maxsize=<span class="hljs-built_in">max</span>(maxsize,<span class="hljs-built_in">int</span>(s.<span class="hljs-built_in">size</span>()));<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            cout&lt;&lt;s.<span class="hljs-built_in">top</span>();<br>            s.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;endl&lt;&lt;<span class="hljs-string">&quot;The maxsize of the stack: &quot;</span>&lt;&lt;maxsize&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> N;cin&gt;&gt;N;<br>    <span class="hljs-built_in">print</span>(N);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-number">1234567</span><br><span class="hljs-number">1234567</span><br>The maxsize of the stack: <span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><p><strong>从内存视角来比较两者的差异：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span></span>&#123;<br>    cout&lt;&lt;&amp;num&lt;&lt;endl;<br>    <span class="hljs-keyword">if</span>(num&lt;<span class="hljs-number">10</span>)&#123;<br>        cout&lt;&lt;num;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-built_in">print</span>(num/<span class="hljs-number">10</span>);<br>        cout&lt;&lt;num%<span class="hljs-number">10</span>;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> N;cin&gt;&gt;N;<br>    <span class="hljs-built_in">print</span>(N);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-number">1234567</span><br><span class="hljs-number">0</span>x61fdf0<br><span class="hljs-number">0</span>x61fdc0<br><span class="hljs-number">0</span>x61fd90<br><span class="hljs-number">0</span>x61fd60<br><span class="hljs-number">0</span>x61fd30<br><span class="hljs-number">0</span>x61fd00<br><span class="hljs-number">0</span>x61fcd0<br><span class="hljs-number">1234567</span><br></code></pre></td></tr></table></figure><p>可以看出，<strong>函数的递归深度为7</strong>，<strong>自定义的栈的内存最大值也为7</strong>。但是在函数调用时，仅函数调用就用了288bytes，而栈的内存仅仅只是224bytes。（估算）</p><blockquote><p>虽然相差只是几个字节的差距，但是<strong>一旦递归深度变大且数据类型本身所占内存数变多</strong>，这个开销将会大大的增长。</p></blockquote><h3 id="括号配对"><a href="#括号配对" class="headerlink" title="括号配对"></a>括号配对</h3><p>在敲代码的过程中，相信大家都会遇到过<strong>括号太多或者括号不匹配</strong>的情况。编译器需要检查<strong>括号匹配</strong>的情况，并在发现异常时及时地报错。但是，括号具有多种类型：<code>()``[]``&#123;&#125;</code>，并且有些相互匹配的括号之间的间隔非常遥远。我们能够仅在<strong>一次扫描的过程中</strong>完成对括号配对的检查？</p><p>下面为了方便，我们将<code>([&#123;</code>称为开括号，将<code>)]&#125;</code>称为闭括号。</p><p>这个问题使用<strong>栈</strong>，可以很高效地解决。基本思路是：<strong>遇到闭括号时，将与最近遇到的且尚未被匹配的开括号进行匹配。</strong></p><blockquote><p>“<strong>最近遇到的</strong>的括号”和<strong>栈</strong>的LIFO特性不谋而合！</p></blockquote><p>确定基本算法的思想后，我们来细分到每一个步骤的实现：</p><div class="note note-primary">            <ul><li>创建一个栈来维护括号的存储。（更具体来说：<strong>维护开括号的存储</strong>）</li><li>如果读取到一个开括号，进栈。<ul><li>因为<strong>匹配工作是依据闭括号来进行的，所以开括号进栈的时候不需要额外的操作。</strong></li></ul></li><li>如果读取到一个闭括号，则与栈顶的开括号进行匹配。（位于栈顶的开括号就是最近遇到的且尚未被匹配的开括号）<ul><li>如果匹配成功，那么这一对括号匹配成功，将开括号弹出栈。</li><li><strong>如果匹配失败，说明无法匹配。（例如<code>[{(}]</code>)，直接<code>return false</code>。</strong></li><li>如果此时栈已空，则说明不匹配。（闭括号的数量多于开括号的数量）</li></ul></li><li>完成所有的扫描后，若栈非空，则说明开括号的数量多于闭括号的数量。匹配失败。</li></ul>          </div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">judgethemarkers</span><span class="hljs-params">(string s)</span></span>&#123;<br>    stack&lt;<span class="hljs-type">char</span>&gt; themarker;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> ch:s)&#123;<br>        <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;(&#x27;</span>||ch==<span class="hljs-string">&#x27;[&#x27;</span>||ch==<span class="hljs-string">&#x27;&#123;&#x27;</span>)&#123;<br>            themarker.<span class="hljs-built_in">push</span>(ch);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">if</span>(themarker.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-type">char</span> check=themarker.<span class="hljs-built_in">top</span>();<br>            <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;]&#x27;</span>&amp;&amp;check==<span class="hljs-string">&#x27;[&#x27;</span>) themarker.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;)&#x27;</span>&amp;&amp;check==<span class="hljs-string">&#x27;(&#x27;</span>) themarker.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;&#125;&#x27;</span>&amp;&amp;check==<span class="hljs-string">&#x27;&#123;&#x27;</span>) themarker.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(!themarker.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    string s;<br>    cin&gt;&gt;s;<br>    cout&lt;&lt;(<span class="hljs-built_in">judgethemarkers</span>(s)?<span class="hljs-string">&quot;Successful&quot;</span>:<span class="hljs-string">&quot;Unsuccessful&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>至此，栈的扫描功能已经完全实现，但是还有很多细节需要被优化：</p><ul><li>当括号出现在<strong>字符串，字符常量，注释</strong>中时，我们不希望括号被统计。</li><li>实现更高级的功能，例如定位到具体哪个位置的括号匹配出现问题。</li></ul><p>为此，我们实现一个更加复杂的<code>balance</code>类，作为一个检查文件中代码括号匹配的工具。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span>  <span class="hljs-comment">// for file input handling</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">balance</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>    ifstream fin;      <span class="hljs-comment">// File stream to be checked</span><br>    <span class="hljs-type">int</span> currentLine;   <span class="hljs-comment">// Current line being processed</span><br>    <span class="hljs-type">int</span> Errors;        <span class="hljs-comment">// Count of errors found</span><br><br>    <span class="hljs-comment">// Structure representing a symbol and its line number</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Symbol</span> &#123;<br>        <span class="hljs-type">char</span> Token;     <span class="hljs-comment">// Character token (e.g., braces, parentheses)</span><br>        <span class="hljs-type">int</span> TheLine;    <span class="hljs-comment">// Line number where the token is found</span><br>    &#125;;<br><br>    <span class="hljs-comment">// Enum for comment types</span><br>    <span class="hljs-keyword">enum</span> <span class="hljs-title class_">CommentType</span> &#123;<br>        SlashSlash,     <span class="hljs-comment">// C++ style comment (//)</span><br>        SlashStar       <span class="hljs-comment">// C style comment (/* */)</span><br>    &#125;;<br><br>    <span class="hljs-comment">// Utility functions for CheckBalance</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">CheckMatch</span><span class="hljs-params">(<span class="hljs-type">char</span> Symb1, <span class="hljs-type">char</span> Symb2, <span class="hljs-type">int</span> Line1, <span class="hljs-type">int</span> Line2)</span></span>; <span class="hljs-comment">// Check if two symbols match (e.g., &#x27;(&#x27; and &#x27;)&#x27;)</span><br>    <span class="hljs-function"><span class="hljs-type">char</span> <span class="hljs-title">GetNextSymbol</span><span class="hljs-params">()</span></span>;          <span class="hljs-comment">// Get the next valid symbol from the input</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PutBackChar</span><span class="hljs-params">(<span class="hljs-type">char</span> ch)</span></span>;     <span class="hljs-comment">// Push back a character to the input stream</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SkipComment</span><span class="hljs-params">(<span class="hljs-keyword">enum</span> CommentType type)</span></span>; <span class="hljs-comment">// Skip over comments (C or C++ style)</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SkipQuote</span><span class="hljs-params">(<span class="hljs-type">char</span> type)</span></span>;     <span class="hljs-comment">// Skip over quoted strings or characters</span><br>    <span class="hljs-function"><span class="hljs-type">char</span> <span class="hljs-title">NextChar</span><span class="hljs-params">()</span></span>;               <span class="hljs-comment">// Get the next character from the input file</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// Constructor: Opens the file for checking</span><br>    <span class="hljs-built_in">balance</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s);<br><br>    <span class="hljs-comment">// Check if the brackets/parentheses in the file are balanced</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">CheckBalance</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">noFile</span>&#123;&#125;;<span class="hljs-comment">//for the exception</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>除了构造函数之外，公有函数只有<code>CheckBalance</code>，其他工具函数全部为私有函数的形式，用户不需要直接调用。（<strong>对用户而言只提供唯一的接口，对程序员而言将不同的子功能在内部封装。</strong>）</p><blockquote><p>具体功能的实现比较复杂，敬请期待后续的更新~</p></blockquote><h3 id="简单的计算器"><a href="#简单的计算器" class="headerlink" title="简单的计算器"></a>简单的计算器</h3><p><strong>中缀表达式</strong>：算术表达式总是出现在两个操作数之间。例如<code>5*(7-2*3)+8/2</code>。</p><p>我们似乎总是能够一样看出中缀表达式的运算结果，真的吗？</p><p>不妨来看下面的中缀表达式：<code>( ( ( 3 + 5 * ( 2 - 8 ) ) / ( sin(45) + 2^3 ) ) * ( log(100, 10) - sqrt(16) ) + max(1, 2, 3) % 4 ) ^ 2 + abs( -10 ) * factorial(3) - ( min(5, 10, 15) + ceil(4.3) ) / floor(2.9)</code>。</p><p>这个时候或许就有点吃力了，为什么？<strong>因为中缀表达式的运算优先级往往并不总是从左向右</strong>：</p><ul><li>有时候我们需要提前运算括号里面的内容</li><li>没有括号是不同的运算符也有不同的运算优先级。</li></ul><p>对于计算机而言，这个任务或许更加的艰巨——计算机无法识别输入顺序和计算顺序之间的差别。</p><p>于是，我们希望改写<strong>中缀表达式</strong>，并将其转化为<strong>后缀表达式（逆波兰表达式）</strong>，后缀表达式将运算符放在运算数之后，并且运算顺序和阅读顺序保持一致。</p><p>例如，中缀表达式<code>5*(7-2*3)+8/2</code>转化为后缀表达式为<code>5 7 2 3 * - * 8 2 / +</code>，计算机在阅读后缀表达式时，只需要<strong>从左往右不断输入，遇到运算符，则取之前的两个运算数做乘法，并将运算结果代替该子表达式</strong>。</p><div class="note note-primary">            <p>对于上面的例子，后缀表达式的运算结果如下：</p><p>步骤 1：初始化</p><ul><li>栈：<code>[]</code></li><li>输入：<code>5 7 2 3 * - * 8 2 / +</code></li></ul><p>步骤 2：处理数字 <code>5</code></p><ul><li>将 <code>5</code> 压入栈。</li><li>栈：<code>[5]</code></li><li>输入：<code>7 2 3 * - * 8 2 / +</code></li></ul><p>步骤 3：处理数字 <code>7</code></p><ul><li>将 <code>7</code> 压入栈。</li><li>栈：<code>[5, 7]</code></li><li>输入：<code>2 3 * - * 8 2 / +</code></li></ul><p>步骤 4：处理数字 <code>2</code></p><ul><li>将 <code>2</code> 压入栈。</li><li>栈：<code>[5, 7, 2]</code></li><li>输入：<code>3 * - * 8 2 / +</code></li></ul><p>步骤 5：处理数字 <code>3</code></p><ul><li>将 <code>3</code> 压入栈。</li><li>栈：<code>[5, 7, 2, 3]</code></li><li>输入：<code>* - * 8 2 / +</code></li></ul><p>步骤 6：处理运算符 <code>*</code></p><ul><li>弹出栈顶的两个数字：<code>3</code> 和 <code>2</code>。</li><li>计算：<code>2 * 3 = 6</code>。</li><li>将结果 <code>6</code> 压入栈。</li><li>栈：<code>[5, 7, 6]</code></li><li>输入：<code>- * 8 2 / +</code></li></ul><p>步骤 7：处理运算符 <code>-</code></p><ul><li>弹出栈顶的两个数字：<code>6</code> 和 <code>7</code>。</li><li>计算：<code>7 - 6 = 1</code>。</li><li>将结果 <code>1</code> 压入栈。</li><li>栈：<code>[5, 1]</code></li><li>输入：<code>* 8 2 / +</code></li></ul><p>步骤 8：处理运算符 <code>*</code></p><ul><li>弹出栈顶的两个数字：<code>1</code> 和 <code>5</code>。</li><li>计算：<code>5 * 1 = 5</code>。</li><li>将结果 <code>5</code> 压入栈。</li><li>栈：<code>[5]</code></li><li>输入：<code>8 2 / +</code></li></ul><p>步骤 9：处理数字 <code>8</code></p><ul><li>将 <code>8</code> 压入栈。</li><li>栈：<code>[5, 8]</code></li><li>输入：<code>2 / +</code></li></ul><p>步骤 10：处理数字 <code>2</code></p><ul><li>将 <code>2</code> 压入栈。</li><li>栈：<code>[5, 8, 2]</code></li><li>输入：<code>/ +</code></li></ul><p>步骤 11：处理运算符 <code>/</code></p><ul><li>弹出栈顶的两个数字：<code>2</code> 和 <code>8</code>。</li><li>计算：<code>8 / 2 = 4</code>。</li><li>将结果 <code>4</code> 压入栈。</li><li>栈：<code>[5, 4]</code></li><li>输入：<code>+</code></li></ul><p>步骤 12：处理运算符 <code>+</code></p><ul><li>弹出栈顶的两个数字：<code>4</code> 和 <code>5</code>。</li><li>计算：<code>5 + 4 = 9</code>。</li><li>将结果 <code>9</code> 压入栈。</li><li>栈：<code>[9]</code></li><li>输入：<code>（空）</code></li></ul>          </div><p>到这里，我们已经找到了实现简单计算器的基本思路：</p><ul><li>等待用户输入一个字符串（中缀表达式），并检查合法性。</li><li><strong>将中缀表达式转化为后缀表达式</strong>。</li><li><strong>对后缀表达式处理，得到最终的运算结果</strong>。</li></ul><p>如何实现<strong>中缀转后缀</strong>？在这里比较示例中的中缀表达式和后缀表达式：中缀表达式<code>5*(7-2*3)+8/2</code>转化为后缀表达式为<code>5 7 2 3 * - * 8 2 / +</code>，我们发现：</p><ul><li>对于运算数而言，运算数之间的顺序保持不变</li><li>运算符之间的相对位置发生了变化<ul><li>如何改变？依据<strong>运算符的优先级</strong></li></ul></li></ul><p>在这里我们只实现四种运算：加减、乘除、乘方、括号，其优先级递增。对于相同优先级的情况，加减和乘除运算符合<strong>左结合</strong>规律，乘方优先级符合<strong>右结合</strong>规律。根据这个规律， 我们来分析<code>5*(7-2*3)+8/2</code>的运算过程。首先进行的运算是<code>2*3</code>，因此后缀表达式中一定有一个部分是<code>2 3 *</code>,接下来执行运算<code>7-6</code>,其中6是第一步运算生成的操作数，因此这一部分可以被扩写为<code>7 2 3 * -</code>，以此类推，可以写出最后的后缀表达式。</p><p>总结规律，我们发现，我们总是先<strong>人为地找到中缀表达式的优先运算的部分，然后不断在字符串的两端扩写后缀表达式。</strong>关键的部分，我们应该如何让计算机确定<strong>哪个部分是优先运算的部分？</strong></p><p>为了解决这个问题，我们不妨模拟计算机，计算机会<strong>按照顺序读入表达式的运算数和运算符</strong>，如果读入运算数，就在输出的字符串后直接添加。（因为运算数不会改变运算顺序，运算符才是重点！）如果读入运算符，我们<strong>需要维护一个栈来控制进出顺序</strong>。</p><div class="note note-primary">            <p><strong>使用栈</strong>的核心原因是<strong>控制运算符输入顺序和输出顺序不同</strong>。</p>          </div><p>在读入运算符的时候，因为不确定其是否能直接做运算（<code>5*(7-2*3)+8/2</code>读到减号后，无法确定是否要执行7-2，因为2的右边还有一个未知的运算符，无法确定优先级），因此<strong>运算符需要进栈</strong>。</p><p>如何确定运算符的出栈顺序？一条普适规律：<strong>如果存在栈内运算符的优先级高于或等于新进栈的运算符的优先级（乘方右结合除外）</strong>，那么说明这些运算符会先于这个新进栈的运算符被运算，因此需要按顺序全部出栈。</p><blockquote><p>出栈顺序就代表着运算符的<strong>实际被运算顺序</strong>！</p></blockquote><p>对于括号而言，<strong>由于括号并不会出现在后缀表达式中</strong>，因此，括号只是起到了一个隔离的作用，相当于开闭括号之间是一个小的表达式。</p><p>综上所述，我们可以归纳<strong>中缀转后缀</strong>的运算法则：</p><ul><li>运算数：立即输出</li><li>开括号：进栈</li><li>闭括号：不进栈，同时不断清栈直到遇到第一个开括号，把这个开括号出栈</li><li>乘方：进栈（<strong>乘方运算是右结合，且运算的优先级最高，所以读入乘方肯定无法确定是否要运算，且栈内也不会有运算符的优先级高于乘方</strong>）</li><li>乘除：进栈且退栈直到遇到加，减或左括号</li><li>加减：先进栈，再退栈直到栈为空或遇到左括号</li><li>读入结束后清栈</li></ul><p>这就是中缀转后缀的基本操作，后续的实现就很简单了：按顺序扫描后缀表达式（<strong>后缀表达式本质上也用一个栈来维护</strong>）至此，我们便完成了<strong>简单计算器</strong>的算法原理的构思。</p><p>不过这还没有完，因为使用的都是栈，因此<strong>这两步本质上可以进行合并</strong>，即维护<strong>运算数栈</strong>和<strong>运算符栈</strong>，在实现中缀转后缀的过程中，一旦运算符栈弹出一个运算符，运算数栈立刻弹出<strong>两个运算数</strong>，并且将运算后的运算数重新入栈。</p><p>接下来就是漫长的Coding过程，以下是实现简单计算器功能的<code>Cauculate</code>类：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cctype&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Calculate</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    string expression;  <span class="hljs-comment">// 存储用户输入的表达式</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check_if_available</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">// 检查表达式是否合法</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Calculate</span>(string input_ = <span class="hljs-string">&quot;No input&quot;</span>) : <span class="hljs-built_in">expression</span>(input_) &#123;<br>        <span class="hljs-comment">// 删除空白字符</span><br>        expression.<span class="hljs-built_in">erase</span>(std::<span class="hljs-built_in">remove_if</span>(expression.<span class="hljs-built_in">begin</span>(), expression.<span class="hljs-built_in">end</span>(), ::isspace), expression.<span class="hljs-built_in">end</span>());<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">calculate_result</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">// 计算表达式的结果</span><br>&#125;;<br><br><span class="hljs-comment">// 检查字符是否是运算符</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">check_op</span><span class="hljs-params">(<span class="hljs-type">char</span> ch)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> ch == <span class="hljs-string">&#x27;+&#x27;</span> || ch == <span class="hljs-string">&#x27;-&#x27;</span> || ch == <span class="hljs-string">&#x27;*&#x27;</span> || ch == <span class="hljs-string">&#x27;/&#x27;</span> || ch == <span class="hljs-string">&#x27;^&#x27;</span>;<br>&#125;<br><br><span class="hljs-comment">// 检查字符是否是括号</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">check_Parentheses</span><span class="hljs-params">(<span class="hljs-type">char</span> ch)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> ch == <span class="hljs-string">&#x27;(&#x27;</span> || ch == <span class="hljs-string">&#x27;)&#x27;</span>;<br>&#125;<br><br><span class="hljs-comment">// 根据运算符计算两个操作数的结果</span><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">cal</span><span class="hljs-params">(<span class="hljs-type">char</span> op, <span class="hljs-type">double</span> a, <span class="hljs-type">double</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">switch</span> (op) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>: <span class="hljs-keyword">return</span> a + b;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span>: <span class="hljs-keyword">return</span> a - b;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span>: <span class="hljs-keyword">return</span> a * b;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/&#x27;</span>: <span class="hljs-keyword">return</span> a / b;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;^&#x27;</span>: <span class="hljs-keyword">return</span> <span class="hljs-built_in">pow</span>(a, b);<br>        <span class="hljs-keyword">default</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">// 默认返回 0</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 执行栈操作：弹出运算符和操作数，计算结果并压入栈中</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Stack_operation</span><span class="hljs-params">(stack&lt;<span class="hljs-type">double</span>&gt;&amp; numstack, stack&lt;<span class="hljs-type">char</span>&gt;&amp; opstack)</span> </span>&#123;<br>    <span class="hljs-type">char</span> op = opstack.<span class="hljs-built_in">top</span>();  <span class="hljs-comment">// 弹出栈顶运算符</span><br>    opstack.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-type">double</span> num1 = numstack.<span class="hljs-built_in">top</span>(); numstack.<span class="hljs-built_in">pop</span>();  <span class="hljs-comment">// 弹出第一个操作数</span><br>    <span class="hljs-type">double</span> num2 = numstack.<span class="hljs-built_in">top</span>(); numstack.<span class="hljs-built_in">pop</span>();  <span class="hljs-comment">// 弹出第二个操作数</span><br>    numstack.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">cal</span>(op, num2, num1));  <span class="hljs-comment">// 计算结果并压入栈中</span><br>&#125;<br><br><span class="hljs-comment">// 检查表达式是否合法</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Calculate::check_if_available</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (expression == <span class="hljs-string">&quot;No input&quot;</span>) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Please input a string!&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span> size = expression.<span class="hljs-built_in">length</span>();<br>    stack&lt;<span class="hljs-type">char</span>&gt; parentheses;  <span class="hljs-comment">// 用于检查括号匹配</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>        <span class="hljs-type">char</span> ch = expression[i];<br><br>        <span class="hljs-comment">// 检查括号</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check_Parentheses</span>(ch)) &#123;<br>            <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                parentheses.<span class="hljs-built_in">push</span>(<span class="hljs-string">&#x27;(&#x27;</span>);  <span class="hljs-comment">// 左括号入栈</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (parentheses.<span class="hljs-built_in">empty</span>() || parentheses.<span class="hljs-built_in">top</span>() != <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                    cout &lt;&lt; <span class="hljs-string">&quot;Parentheses match fault!&quot;</span> &lt;&lt; endl;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>                parentheses.<span class="hljs-built_in">pop</span>();  <span class="hljs-comment">// 右括号匹配成功，弹出左括号</span><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 检查运算符</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check_op</span>(ch)) &#123;<br>            <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span> || i == size - <span class="hljs-number">1</span>) &#123;<br>                cout &lt;&lt; <span class="hljs-string">&quot;Operation Error!&quot;</span> &lt;&lt; endl;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br><br>            <span class="hljs-type">char</span> prev = expression[i - <span class="hljs-number">1</span>];  <span class="hljs-comment">// 运算符前一个字符</span><br>            <span class="hljs-type">char</span> next = expression[i + <span class="hljs-number">1</span>];  <span class="hljs-comment">// 运算符后一个字符</span><br>            <span class="hljs-keyword">if</span> (!((<span class="hljs-built_in">isdigit</span>(prev) || prev == <span class="hljs-string">&#x27;)&#x27;</span>) &amp;&amp; (<span class="hljs-built_in">isdigit</span>(next) || next == <span class="hljs-string">&#x27;(&#x27;</span>))) &#123;<br>                cout &lt;&lt; <span class="hljs-string">&quot;Operation Error!&quot;</span> &lt;&lt; endl;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 检查非法字符</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isdigit</span>(ch) &amp;&amp; ch != <span class="hljs-string">&#x27;.&#x27;</span>) &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;INVALID LETTERS&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 检查括号是否全部匹配</span><br>    <span class="hljs-keyword">if</span> (!parentheses.<span class="hljs-built_in">empty</span>()) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Parentheses match fault!&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">// 计算表达式的结果</span><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">Calculate::calculate_result</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">check_if_available</span>()) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Wrong!&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    stack&lt;<span class="hljs-type">char</span>&gt; opstack;  <span class="hljs-comment">// 运算符栈</span><br>    stack&lt;<span class="hljs-type">double</span>&gt; numstack;  <span class="hljs-comment">// 操作数栈</span><br>    <span class="hljs-type">int</span> size = expression.<span class="hljs-built_in">length</span>();<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>        <span class="hljs-type">char</span> ch = expression[i];<br><br>        <span class="hljs-comment">// 处理数字和小数点</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isdigit</span>(ch) || ch == <span class="hljs-string">&#x27;.&#x27;</span>) &#123;<br>            stringstream ss;<br>            <span class="hljs-keyword">while</span> (i &lt; size &amp;&amp; (<span class="hljs-built_in">isdigit</span>(expression[i]) || expression[i] == <span class="hljs-string">&#x27;.&#x27;</span>)) &#123;<br>                ss &lt;&lt; expression[i++];  <span class="hljs-comment">// 将数字和小数点拼接到字符串流中</span><br>            &#125;<br>            i--;  <span class="hljs-comment">// 回退一步，因为外层循环会再增加一次 i</span><br>            <span class="hljs-type">double</span> num;<br>            ss &gt;&gt; num;  <span class="hljs-comment">// 将字符串流转换为浮点数</span><br>            numstack.<span class="hljs-built_in">push</span>(num);  <span class="hljs-comment">// 将数字压入操作数栈</span><br>        &#125;<br><br>        <span class="hljs-comment">// 处理运算符和括号</span><br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">switch</span> (ch) &#123;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;(&#x27;</span>:<br>                    opstack.<span class="hljs-built_in">push</span>(ch);  <span class="hljs-comment">// 左括号直接入栈</span><br>                    <span class="hljs-keyword">break</span>;<br><br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;)&#x27;</span>:<br>                    <span class="hljs-comment">// 弹出栈顶运算符并计算，直到遇到左括号</span><br>                    <span class="hljs-keyword">while</span> (!opstack.<span class="hljs-built_in">empty</span>() &amp;&amp; opstack.<span class="hljs-built_in">top</span>() != <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                        <span class="hljs-built_in">Stack_operation</span>(numstack, opstack);<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (!opstack.<span class="hljs-built_in">empty</span>() &amp;&amp; opstack.<span class="hljs-built_in">top</span>() == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                        opstack.<span class="hljs-built_in">pop</span>();  <span class="hljs-comment">// 弹出左括号</span><br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        cout &lt;&lt; <span class="hljs-string">&quot;Parentheses match fault!&quot;</span> &lt;&lt; endl;<br>                        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>                    &#125;<br>                    <span class="hljs-keyword">break</span>;<br><br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;^&#x27;</span>:<br>                    <span class="hljs-comment">// 乘方运算符优先级最高，直接入栈</span><br>                    opstack.<span class="hljs-built_in">push</span>(ch);<br>                    <span class="hljs-keyword">break</span>;<br><br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span>:<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/&#x27;</span>:<br>                    <span class="hljs-comment">// 处理乘法和除法运算符</span><br>                    <span class="hljs-keyword">while</span> (!opstack.<span class="hljs-built_in">empty</span>() &amp;&amp; opstack.<span class="hljs-built_in">top</span>() != <span class="hljs-string">&#x27;(&#x27;</span> &amp;&amp;<br>                        (opstack.<span class="hljs-built_in">top</span>() == <span class="hljs-string">&#x27;^&#x27;</span> || opstack.<span class="hljs-built_in">top</span>() == <span class="hljs-string">&#x27;*&#x27;</span> || opstack.<span class="hljs-built_in">top</span>() == <span class="hljs-string">&#x27;/&#x27;</span>)) &#123;<br>                        <span class="hljs-built_in">Stack_operation</span>(numstack, opstack);<br>                    &#125;<br>                    opstack.<span class="hljs-built_in">push</span>(ch);  <span class="hljs-comment">// 当前运算符入栈</span><br>                    <span class="hljs-keyword">break</span>;<br><br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>:<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span>:<br>                    <span class="hljs-comment">// 处理加法和减法运算符</span><br>                    <span class="hljs-keyword">while</span> (!opstack.<span class="hljs-built_in">empty</span>() &amp;&amp; opstack.<span class="hljs-built_in">top</span>() != <span class="hljs-string">&#x27;(&#x27;</span> &amp;&amp;<br>                        (opstack.<span class="hljs-built_in">top</span>() == <span class="hljs-string">&#x27;^&#x27;</span> || opstack.<span class="hljs-built_in">top</span>() == <span class="hljs-string">&#x27;*&#x27;</span> || opstack.<span class="hljs-built_in">top</span>() == <span class="hljs-string">&#x27;/&#x27;</span> ||<br>                            opstack.<span class="hljs-built_in">top</span>() == <span class="hljs-string">&#x27;+&#x27;</span> || opstack.<span class="hljs-built_in">top</span>() == <span class="hljs-string">&#x27;-&#x27;</span>)) &#123;<br>                        <span class="hljs-built_in">Stack_operation</span>(numstack, opstack);<br>                    &#125;<br>                    opstack.<span class="hljs-built_in">push</span>(ch);  <span class="hljs-comment">// 当前运算符入栈</span><br>                    <span class="hljs-keyword">break</span>;<br><br>                <span class="hljs-keyword">default</span>:<br>                    <span class="hljs-comment">// 非法字符（已经在 check_if_available 中检查过，这里不会执行）</span><br>                    <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 清空栈中剩余的运算符</span><br>    <span class="hljs-keyword">while</span> (!opstack.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-built_in">Stack_operation</span>(numstack, opstack);<br>    &#125;<br><br>    <span class="hljs-comment">// 返回最终结果</span><br>    <span class="hljs-keyword">return</span> numstack.<span class="hljs-built_in">top</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    string inputstr;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Enter the expression (or &#x27;q&#x27; to quit): &quot;</span> &lt;&lt; endl;<br>        <span class="hljs-built_in">getline</span>(cin, inputstr);<br>        <span class="hljs-keyword">if</span> (inputstr == <span class="hljs-string">&quot;q&quot;</span>) <span class="hljs-keyword">break</span>;<br>        <span class="hljs-function">Calculate <span class="hljs-title">test</span><span class="hljs-params">(inputstr)</span></span>;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Result: &quot;</span> &lt;&lt; test.<span class="hljs-built_in">calculate_result</span>() &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tutorial</tag>
      
      <tag>Finished</tag>
      
      <tag>Data Structure</tag>
      
      <tag>C/C++</tag>
      
      <tag>Stack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DataStructure-LinearList</title>
    <link href="/posts/DataStructure-LinearList/"/>
    <url>/posts/DataStructure-LinearList/</url>
    
    <content type="html"><![CDATA[<style>  html, body, .markdown-body {    font-family: Georgia, sans, serif;  }</style><h1 id="Data-Structure-Linear-List"><a href="#Data-Structure-Linear-List" class="headerlink" title="Data Structure: Linear List"></a>Data Structure: Linear List</h1><p><a href="https://blog.csdn.net/weixin_73616913/article/details/130185228">封面图片出处</a></p><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>This article introduces the basic data structure of linear tables, including their sequential and linked implementations. At the same time, this paper gives the definitions of the abstract base class of linear tables and the header files and member functions of the derived classes of two linear tables, and finally introduces the linear tables in STL.</p><p>接下来，我们来看数据结构中第一种数据结构，也是最简单的一种数据结构——<strong>线性结构</strong></p><div class="note note-primary">            <p><strong>前置知识回顾</strong></p><p><strong>数据结构：建模——求解（基于数据结构的算法）</strong></p><ul><li>数据元素的存储：内置类型和结构体类型</li><li>数据关系的<strong>存储</strong>：<ul><li>顺序</li><li>链接</li><li>散列</li><li>索引</li></ul></li></ul>          </div><h2 id="线性结构"><a href="#线性结构" class="headerlink" title="线性结构"></a>线性结构</h2><p>特点：一对一，有序</p><blockquote><p>Definition：<strong>具有相同特征的节点构成的有序序列</strong></p></blockquote><p>首节点，尾节点，前继节点，后继结点</p><p><strong>分类</strong>：</p><ul><li>线性表（相对位置）</li><li>时间有序表（时间先后）<ul><li>栈（3）</li><li>队列（4）</li></ul></li><li>频率有序表（频率先后）</li><li>排序表（关键字值 Key）<ul><li>排序</li></ul></li></ul><h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><p><strong>仅有节点的相互位置</strong>来确定节点的关系。0,1,2,3,4,5…，n-1,n</p><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><ul><li>创建线性表</li><li>清除线性表</li><li>求长度</li><li>插入节点，删除节点，搜索节点：O（N）</li><li>扩充数组<ul><li>申请一个更大规模的动态数组</li><li>将原数组的内容拷贝到新的动态数组上</li><li>delete掉原来的数组</li><li>将新数组作为新的存储区</li></ul></li><li>索引</li><li>按序遍历访问</li></ul><h3 id="线性表的实现"><a href="#线性表的实现" class="headerlink" title="线性表的实现"></a>线性表的实现</h3><h4 id="顺序实现（数组）"><a href="#顺序实现（数组）" class="headerlink" title="顺序实现（数组）"></a>顺序实现（数组）</h4><p><img src="https://www.hello-algo.com/chapter_array_and_linkedlist/array.assets/array_definition.png" alt="数组定义与存储方式"></p><p><strong>使用物理位置的邻接关系表示逻辑的邻接关系</strong></p><p>优点：</p><ul><li>无需增加额外的存储空间</li><li>方便访问表中的任意节点</li></ul><p>缺点：<strong>插入和删除的操作效率低，空间浪费</strong></p><ul><li>指向线性表元素类型的指针</li><li>数组规模（最大的元素个数）</li><li>数组中的元素个数</li></ul><h4 id="链接实现（链表-）"><a href="#链接实现（链表-）" class="headerlink" title="链接实现（链表 ）"></a>链接实现（链表 ）</h4><p><img src="https://www.hello-algo.com/chapter_array_and_linkedlist/linked_list.assets/linkedlist_definition.png" alt="链表定义与存储方式"></p><ul><li>单链表，双链表，循环链表</li><li><strong>头结点</strong>：保证不用对首元素进行特殊讨论</li></ul><h2 id="线性表的类的实现"><a href="#线性表的类的实现" class="headerlink" title="线性表的类的实现"></a>线性表的类的实现</h2><ul><li>线性表的抽象类</li><li><strong>顺序表类</strong></li><li><strong>链接表类</strong></li></ul><blockquote><p>小tips：为了方便管理，以下的类实现都会使用<strong>动态内存分配</strong>到<strong>堆</strong>上，但实际上，堆的内存更容易碎片化，效率没有栈高</p></blockquote><h3 id="线性表的抽象类"><a href="#线性表的抽象类" class="headerlink" title="线性表的抽象类"></a>线性表的抽象类</h3><p><strong>类模板</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ElementType&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">List</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">List</span>() &#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">length</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">const</span> ElementType&amp; element)</span> </span>= <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> </span>= <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">const</span> ElementType&amp; element)</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> ElementType <span class="hljs-title">fetch</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">traverse</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><div class="note note-primary">            <p>有关线性表抽象基类的若干说明：</p><ul><li><code>=0</code>代表在<strong>抽象基类</strong>中函数在基类中不实现，只在派生类中实现。（这也符合抽象基类的设计原理）<ul><li><code>=0</code>代表这是所有派生类的共同特征，但是在不同的派生类中又有各自不同的实现方式</li></ul></li><li><code>const</code>代表不可以修改<strong>数据成员</strong></li><li>在抽象基类中并未定义数据成员，因为不同的线性表的实现方式中，节点的定义是不同的：<ul><li>在顺序表类中，节点就是直接的数据存储</li><li>在链接表类中，节点还需要包括指针（前驱指针和后继指针）</li></ul></li></ul>          </div><h3 id="顺序表类"><a href="#顺序表类" class="headerlink" title="顺序表类"></a>顺序表类</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Exception.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;List.h&quot;</span></span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ElementType&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SequentialList</span> : <span class="hljs-keyword">public</span> List&lt;ElementType&gt;<br>&#123;<br><span class="hljs-keyword">private</span>:<br>ElementType* elementData;<br><span class="hljs-type">int</span> currentLength, totalCapacity;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">expand</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">SequentialList</span>(<span class="hljs-type">int</span> size = <span class="hljs-number">10</span>);<br>~<span class="hljs-built_in">SequentialList</span>();<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">length</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">capacity</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">const</span> ElementType&amp; element)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">const</span> ElementType&amp; element)</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-function">ElementType <span class="hljs-title">fetch</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traverse</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-function">ElementType <span class="hljs-title">back</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">append</span><span class="hljs-params">(<span class="hljs-type">const</span> ElementType&amp; element)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">cancel</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">resize</span><span class="hljs-params">(<span class="hljs-type">int</span> size)</span></span>;<br>ElementType&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> index);<br>ElementType&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> index) <span class="hljs-type">const</span>;<br>&#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ElementType&gt;<br><span class="hljs-comment">//expand the list for a larger memory</span><br><span class="hljs-type">void</span> SequentialList&lt;ElementType&gt;::<span class="hljs-built_in">expand</span>()<br>&#123;<br>ElementType* tempData = elementData;<br>totalCapacity *= <span class="hljs-number">2</span>;<br>elementData = <span class="hljs-keyword">new</span> ElementType[totalCapacity];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; currentLength; i++)<br>elementData[i] = tempData[i];<br><span class="hljs-keyword">delete</span>[] tempData;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ElementType&gt;<br><span class="hljs-comment">//constructor function</span><br>SequentialList&lt;ElementType&gt;::<span class="hljs-built_in">SequentialList</span>(<span class="hljs-type">int</span> size)<br>&#123;<br>currentLength = <span class="hljs-number">0</span>;<br>totalCapacity = size;<br>elementData = <span class="hljs-keyword">new</span> ElementType[size];<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ElementType&gt;<br><span class="hljs-comment">//destructor function</span><br>SequentialList&lt;ElementType&gt;::~<span class="hljs-built_in">SequentialList</span>()<br>&#123;<br><span class="hljs-keyword">delete</span>[] elementData;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ElementType&gt;<br><span class="hljs-comment">//clear the list</span><br><span class="hljs-type">void</span> SequentialList&lt;ElementType&gt;::<span class="hljs-built_in">clear</span>()<br>&#123;<br>currentLength = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ElementType&gt;<br><span class="hljs-comment">//the const means the function cannot modify the value of the statics of the object</span><br><span class="hljs-type">int</span> SequentialList&lt;ElementType&gt;::<span class="hljs-built_in">length</span>() <span class="hljs-type">const</span><br>&#123;<br><span class="hljs-keyword">return</span> currentLength;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ElementType&gt;<br><span class="hljs-type">int</span> SequentialList&lt;ElementType&gt;::<span class="hljs-built_in">capacity</span>() <span class="hljs-type">const</span><br>&#123;<br><span class="hljs-keyword">return</span> totalCapacity;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ElementType&gt;<br><span class="hljs-comment">//insert the value on a certain index</span><br><span class="hljs-type">void</span> SequentialList&lt;ElementType&gt;::<span class="hljs-built_in">insert</span>(<span class="hljs-type">int</span> index, <span class="hljs-type">const</span> ElementType&amp; element)<br>&#123;<br><span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt; currentLength)<span class="hljs-comment">//the index is INVALID</span><br><span class="hljs-keyword">throw</span> <span class="hljs-built_in">IndexExceed</span>();<br><span class="hljs-keyword">if</span> (currentLength == totalCapacity)<br><span class="hljs-built_in">expand</span>();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = currentLength; i &gt; index; i--)<br>elementData[i] = elementData[i - <span class="hljs-number">1</span>];<br>    <span class="hljs-comment">//move each element backwards</span><br>elementData[index] = element;<br>currentLength++;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ElementType&gt;<br><span class="hljs-comment">//delete the element on a certain index</span><br><span class="hljs-type">void</span> SequentialList&lt;ElementType&gt;::<span class="hljs-built_in">remove</span>(<span class="hljs-type">int</span> index)<br>&#123;<br><span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt;= currentLength)<br><span class="hljs-keyword">throw</span> <span class="hljs-built_in">IndexExceed</span>();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = index; i &lt; currentLength - <span class="hljs-number">1</span>; i++)<br>elementData[i] = elementData[i + <span class="hljs-number">1</span>];<br>currentLength--;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ElementType&gt;<br><span class="hljs-type">int</span> SequentialList&lt;ElementType&gt;::<span class="hljs-built_in">find</span>(<span class="hljs-type">const</span> ElementType&amp; element) <span class="hljs-type">const</span><br>&#123;<br><span class="hljs-type">int</span> i;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; currentLength &amp;&amp; elementData[i] != element; i++)<br>;<br>    <span class="hljs-comment">//the loop end if the tarverse ends or the target element has been found</span><br><span class="hljs-keyword">if</span> (i == currentLength)<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> i;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ElementType&gt;<br>ElementType SequentialList&lt;ElementType&gt;::<span class="hljs-built_in">fetch</span>(<span class="hljs-type">int</span> index) <span class="hljs-type">const</span><br>&#123;<br><span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt;= currentLength)<br><span class="hljs-keyword">throw</span> <span class="hljs-built_in">IndexExceed</span>();<br><span class="hljs-keyword">return</span> elementData[index];<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ElementType&gt;<br><span class="hljs-type">void</span> SequentialList&lt;ElementType&gt;::<span class="hljs-built_in">traverse</span>() <span class="hljs-type">const</span><br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; currentLength; i++)<br>std::cout &lt;&lt; elementData[i] &lt;&lt; <span class="hljs-string">&quot;\t&quot;</span>;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ElementType&gt;<br>ElementType SequentialList&lt;ElementType&gt;::<span class="hljs-built_in">back</span>()<br>    <span class="hljs-comment">//return the last element</span><br>&#123;<br><span class="hljs-keyword">return</span> elementData[currentLength - <span class="hljs-number">1</span>];<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ElementType&gt;<br><span class="hljs-type">void</span> SequentialList&lt;ElementType&gt;::<span class="hljs-built_in">append</span>(<span class="hljs-type">const</span> ElementType&amp; element)<br>&#123;<br><span class="hljs-built_in">insert</span>(currentLength, element);<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ElementType&gt;<br><span class="hljs-type">void</span> SequentialList&lt;ElementType&gt;::<span class="hljs-built_in">cancel</span>()<br>&#123;<br><span class="hljs-built_in">remove</span>(currentLength - <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ElementType&gt;<br><span class="hljs-type">void</span> SequentialList&lt;ElementType&gt;::<span class="hljs-built_in">resize</span>(<span class="hljs-type">int</span> size)<br>&#123;<br><span class="hljs-keyword">if</span> (size &lt;= totalCapacity)<br><span class="hljs-keyword">throw</span> <span class="hljs-built_in">InvalidModify</span>();<br>ElementType* tempData = elementData;<br>totalCapacity = size;<br>elementData = <span class="hljs-keyword">new</span> ElementType[totalCapacity];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; currentLength; i++)<br>elementData[i] = tempData[i];<br><span class="hljs-keyword">delete</span>[] tempData;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ElementType&gt;<br>ElementType&amp; SequentialList&lt;ElementType&gt;::<span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> index)<br>&#123;<br><span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt;= currentLength)<br><span class="hljs-keyword">throw</span> <span class="hljs-built_in">IndexExceed</span>();<br><span class="hljs-keyword">return</span> elementData[index];<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ElementType&gt;<br>ElementType&amp; SequentialList&lt;ElementType&gt;::<span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> index) <span class="hljs-type">const</span><br>    <span class="hljs-comment">//Operator Overloading with const</span><br>&#123;<br><span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt;= currentLength)<br><span class="hljs-keyword">throw</span> <span class="hljs-built_in">IndexExceed</span>();<br><span class="hljs-keyword">return</span> elementData[index];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="单链表类"><a href="#单链表类" class="headerlink" title="单链表类"></a>单链表类</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Exception.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;List.h&quot;</span></span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ElementType&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SingleLinkedList</span> : <span class="hljs-keyword">public</span> List&lt;ElementType&gt;<br>&#123;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ListNode</span><br>&#123;<br>ElementType data;<br>ListNode* next;<br><span class="hljs-built_in">ListNode</span>() : <span class="hljs-built_in">data</span>(), <span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br><span class="hljs-built_in">ListNode</span>(<span class="hljs-type">const</span> ElementType&amp; _data, ListNode* _next = <span class="hljs-literal">nullptr</span>) : <span class="hljs-built_in">data</span>(_data), <span class="hljs-built_in">next</span>(_next) &#123;&#125;<br>        <span class="hljs-comment">//constructor</span><br>~<span class="hljs-built_in">ListNode</span>() &#123;&#125;<br>        <span class="hljs-comment">//destructor</span><br>&#125;;<br>ListNode* head;<br><span class="hljs-type">int</span> currentLength;<br><span class="hljs-function">ListNode* <span class="hljs-title">place</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> <span class="hljs-type">const</span></span>;<br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">SingleLinkedList</span>();<br>~<span class="hljs-built_in">SingleLinkedList</span>();<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">length</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">const</span> ElementType&amp; element)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">const</span> ElementType&amp; element)</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-function">ElementType <span class="hljs-title">fetch</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traverse</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">append</span><span class="hljs-params">(<span class="hljs-type">const</span> ElementType&amp; element)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">erase</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span></span>;<br>&#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ElementType&gt;<br><span class="hljs-keyword">typename</span> SingleLinkedList&lt;ElementType&gt;::ListNode* SingleLinkedList&lt;ElementType&gt;::<span class="hljs-built_in">place</span>(<span class="hljs-type">int</span> index) <span class="hljs-type">const</span><br>&#123;<br>ListNode* p = head;<br><span class="hljs-keyword">while</span> (index &gt;= <span class="hljs-number">0</span>)<br>&#123;<br>index--;<br>p = p-&gt;next;<br>&#125;<br><span class="hljs-keyword">return</span> p;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ElementType&gt;<br>SingleLinkedList&lt;ElementType&gt;::<span class="hljs-built_in">SingleLinkedList</span>()<br>&#123;<br>head = <span class="hljs-keyword">new</span> ListNode;<br>currentLength = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ElementType&gt;<br>SingleLinkedList&lt;ElementType&gt;::~<span class="hljs-built_in">SingleLinkedList</span>()<br>&#123;<br><span class="hljs-built_in">clear</span>();<br><span class="hljs-keyword">delete</span> head;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ElementType&gt;<br><span class="hljs-type">void</span> SingleLinkedList&lt;ElementType&gt;::<span class="hljs-built_in">clear</span>()<br>&#123;<br>ListNode* p = head-&gt;next, * q;<br>head-&gt;next = <span class="hljs-literal">nullptr</span>;<br><span class="hljs-keyword">while</span> (p != <span class="hljs-literal">nullptr</span>)<br>&#123;<br>q = p-&gt;next;<br><span class="hljs-keyword">delete</span> p;<br>p = q;<br>&#125;<br>currentLength = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ElementType&gt;<br><span class="hljs-type">int</span> SingleLinkedList&lt;ElementType&gt;::<span class="hljs-built_in">length</span>() <span class="hljs-type">const</span><br>&#123;<br><span class="hljs-keyword">return</span> currentLength;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ElementType&gt;<br><span class="hljs-type">void</span> SingleLinkedList&lt;ElementType&gt;::<span class="hljs-built_in">insert</span>(<span class="hljs-type">int</span> index, <span class="hljs-type">const</span> ElementType&amp; element)<br>&#123;<br><span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt; currentLength)<br><span class="hljs-keyword">throw</span> <span class="hljs-built_in">IndexExceed</span>();<br>ListNode* p = <span class="hljs-built_in">place</span>(index - <span class="hljs-number">1</span>);<br>p-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(element, p-&gt;next);<br>currentLength++;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ElementType&gt;<br><span class="hljs-type">void</span> SingleLinkedList&lt;ElementType&gt;::<span class="hljs-built_in">remove</span>(<span class="hljs-type">int</span> index)<br>&#123;<br><span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt;= currentLength)<br><span class="hljs-keyword">throw</span> <span class="hljs-built_in">IndexExceed</span>();<br>ListNode* p = <span class="hljs-built_in">place</span>(index - <span class="hljs-number">1</span>), * q = p-&gt;next;<br>p-&gt;next = q-&gt;next;<br><span class="hljs-keyword">delete</span> q;<br>currentLength--;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ElementType&gt;<br><span class="hljs-type">int</span> SingleLinkedList&lt;ElementType&gt;::<span class="hljs-built_in">find</span>(<span class="hljs-type">const</span> ElementType&amp; element) <span class="hljs-type">const</span><br>&#123;<br>ListNode* p = head-&gt;next;<br><span class="hljs-type">int</span> index = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (p != <span class="hljs-literal">nullptr</span> &amp;&amp; p-&gt;data != element)<br>&#123;<br>p = p-&gt;next;<br>index++;<br>&#125;<br><span class="hljs-keyword">if</span> (p == <span class="hljs-literal">nullptr</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> index;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ElementType&gt;<br>ElementType SingleLinkedList&lt;ElementType&gt;::<span class="hljs-built_in">fetch</span>(<span class="hljs-type">int</span> index) <span class="hljs-type">const</span><br>&#123;<br><span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt;= currentLength)<br><span class="hljs-keyword">throw</span> <span class="hljs-built_in">IndexExceed</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">place</span>(index)-&gt;data;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ElementType&gt;<br><span class="hljs-type">void</span> SingleLinkedList&lt;ElementType&gt;::<span class="hljs-built_in">traverse</span>() <span class="hljs-type">const</span><br>&#123;<br>ListNode* p = head-&gt;next;<br><span class="hljs-keyword">while</span> (p != <span class="hljs-literal">nullptr</span>)<br>&#123;<br>std::cout &lt;&lt; p-&gt;data &lt;&lt; <span class="hljs-string">&quot;\t&quot;</span>;<br>p = p-&gt;next;<br>&#125;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ElementType&gt;<br><span class="hljs-type">void</span> SingleLinkedList&lt;ElementType&gt;::<span class="hljs-built_in">append</span>(<span class="hljs-type">const</span> ElementType&amp; element)<br>&#123;<br><span class="hljs-built_in">insert</span>(currentLength, element);<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ElementType&gt;<br><span class="hljs-type">void</span> SingleLinkedList&lt;ElementType&gt;::<span class="hljs-built_in">erase</span>(<span class="hljs-type">int</span> index)<br>&#123;<br><span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt;= currentLength)<br><span class="hljs-keyword">throw</span> <span class="hljs-built_in">IndexExceed</span>();<br>ListNode* p = <span class="hljs-built_in">place</span>(index - <span class="hljs-number">1</span>), * q = p-&gt;next;<br>ElementType target = q-&gt;data;<br>p-&gt;next = q-&gt;next;<br><span class="hljs-keyword">delete</span> q;<br><span class="hljs-type">int</span> count = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (p = head; p-&gt;next != <span class="hljs-literal">nullptr</span>;)<br>&#123;<br><span class="hljs-keyword">if</span> (p-&gt;next-&gt;data == target)<br>&#123;<br>q = p-&gt;next;<br>p-&gt;next = q-&gt;next;<br><span class="hljs-keyword">delete</span> q;<br>count++;<br>&#125;<br><span class="hljs-keyword">else</span><br>p = p-&gt;next;<br>&#125;<br>currentLength -= count;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="STL：Standard-Template-Library"><a href="#STL：Standard-Template-Library" class="headerlink" title="STL：Standard Template Library"></a>STL：Standard Template Library</h2><p><strong>泛型思想</strong>：</p><ul><li>把算法和数据类型分离：<strong>模版函数</strong></li><li>把算法和容器分离：<strong>STL和迭代器</strong></li><li>把容器和数据类型分离：<strong>模板类</strong></li></ul><p>容器，迭代器，算法</p><p><strong>迭代器</strong>：为每一种容器定义的表示其元素相对位置的类型，迭代器对象相当于指向容器中指向对象的指针，他将容器中对象的位置信息封装了起来。<strong>从使用者的角度而言，可以把迭代器当作一种抽象的指针。</strong></p><p>每个容器提供两种迭代器，<code>const</code>和非<code>const</code></p><div class="note note-info">            <p><strong>补充知识点：迭代器中重载的常见运算符</strong></p><p>在 C++ 中，迭代器通常会重载一组运算符，以便像指针一样使用它们。这些运算符使得迭代器能够在容器中进行遍历、索引以及修改数据。具体来说，常见的迭代器会重载以下运算符：</p><ol><li><strong>解引用运算符 <code>\*</code></strong></li></ol><ul><li><p><strong>作用</strong>：访问迭代器当前指向的元素。</p></li><li><p>示例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;<span class="hljs-type">int</span>&gt; v = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br><span class="hljs-keyword">auto</span> it = v.<span class="hljs-built_in">begin</span>();<br>std::cout &lt;&lt; *it;  <span class="hljs-comment">// 输出 1，指向第一个元素</span><br></code></pre></td></tr></table></figure></li></ul><ol start="2"><li><strong>箭头运算符 <code>-&gt;</code></strong></li></ol><ul><li><p><strong>作用</strong>：通过迭代器访问指向对象的成员（适用于指向对象的迭代器，如 <code>std::map</code>、<code>std::unordered_map</code> 等）。</p></li><li><p>示例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; v = &#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;&#125;;<br><span class="hljs-keyword">auto</span> it = v.<span class="hljs-built_in">begin</span>();<br>std::cout &lt;&lt; it-&gt;first &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; it-&gt;second;  <span class="hljs-comment">// 输出 1, 2</span><br></code></pre></td></tr></table></figure></li></ul><ol start="3"><li><strong>前置递增运算符 <code>++</code></strong></li></ol><ul><li><p><strong>作用</strong>：将迭代器向前移动一个位置，指向容器中的下一个元素。</p></li><li><p>示例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;<span class="hljs-type">int</span>&gt; v = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br><span class="hljs-keyword">auto</span> it = v.<span class="hljs-built_in">begin</span>();<br>++it;  <span class="hljs-comment">// 将迭代器移动到第二个元素</span><br>std::cout &lt;&lt; *it;  <span class="hljs-comment">// 输出 2</span><br></code></pre></td></tr></table></figure></li></ul><ol start="4"><li><strong>后置递增运算符 <code>++</code></strong></li></ol><ul><li><p><strong>作用</strong>：与前置递增运算符类似，但它会返回移动前的迭代器，通常用于赋值操作中。</p></li><li><p>示例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;<span class="hljs-type">int</span>&gt; v = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br><span class="hljs-keyword">auto</span> it = v.<span class="hljs-built_in">begin</span>();<br><span class="hljs-keyword">auto</span> it_copy = it++;  <span class="hljs-comment">// it_copy 是移动前的迭代器，it 会向前移动</span><br>std::cout &lt;&lt; *it_copy;  <span class="hljs-comment">// 输出 1</span><br>std::cout &lt;&lt; *it;       <span class="hljs-comment">// 输出 2</span><br></code></pre></td></tr></table></figure></li></ul><ol start="5"><li><strong>前置递减运算符 <code>--</code></strong></li></ol><ul><li><p><strong>作用</strong>：将迭代器向后移动一个位置，指向容器中的前一个元素。</p></li><li><p>示例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;<span class="hljs-type">int</span>&gt; v = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br><span class="hljs-keyword">auto</span> it = v.<span class="hljs-built_in">end</span>();<br>--it;  <span class="hljs-comment">// 将迭代器移动到最后一个元素</span><br>std::cout &lt;&lt; *it;  <span class="hljs-comment">// 输出 4</span><br></code></pre></td></tr></table></figure></li></ul><ol start="6"><li><strong>后置递减运算符 <code>--</code></strong></li></ol><ul><li><p><strong>作用</strong>：与前置递减运算符类似，但它会返回移动前的迭代器。</p></li><li><p>示例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;<span class="hljs-type">int</span>&gt; v = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br><span class="hljs-keyword">auto</span> it = v.<span class="hljs-built_in">end</span>();<br><span class="hljs-keyword">auto</span> it_copy = it--;  <span class="hljs-comment">// it_copy 是移动前的迭代器，it 会向后移动</span><br>std::cout &lt;&lt; *it_copy;  <span class="hljs-comment">// 输出 4</span><br>std::cout &lt;&lt; *it;       <span class="hljs-comment">// 输出 3</span><br></code></pre></td></tr></table></figure></li></ul><ol start="7"><li><strong>比较运算符 <code>==</code> 和 <code>!=</code></strong></li></ol><ul><li><p><strong>作用</strong>：比较两个迭代器是否相等。对于容器中的元素，迭代器 <code>==</code> 表示它们指向同一个位置，<code>!=</code> 表示它们指向不同的位置。</p></li><li><p>示例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;<span class="hljs-type">int</span>&gt; v = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br><span class="hljs-keyword">auto</span> it1 = v.<span class="hljs-built_in">begin</span>();<br><span class="hljs-keyword">auto</span> it2 = v.<span class="hljs-built_in">begin</span>();<br><span class="hljs-keyword">auto</span> it3 = v.<span class="hljs-built_in">end</span>();<br><br>std::cout &lt;&lt; (it1 == it2);  <span class="hljs-comment">// 输出 1 (true)</span><br>std::cout &lt;&lt; (it1 != it3);  <span class="hljs-comment">// 输出 1 (true)</span><br></code></pre></td></tr></table></figure></li></ul><ol start="8"><li><strong>加法运算符 <code>+</code>（某些迭代器）</strong></li></ol><ul><li><p><strong>作用</strong>：允许迭代器跳过多个元素，通常返回一个新的迭代器。</p></li><li><p>示例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;<span class="hljs-type">int</span>&gt; v = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br><span class="hljs-keyword">auto</span> it = v.<span class="hljs-built_in">begin</span>();<br>it = it + <span class="hljs-number">2</span>;  <span class="hljs-comment">// 跳过两个元素，指向第三个元素</span><br>std::cout &lt;&lt; *it;  <span class="hljs-comment">// 输出 3</span><br></code></pre></td></tr></table></figure></li></ul><ol start="9"><li><strong>减法运算符 <code>-</code>（某些迭代器）</strong></li></ol><ul><li><p><strong>作用</strong>：允许迭代器向回跳过多个元素。</p></li><li><p>示例</p><p>（对于随机访问迭代器，如 <code>std::vector</code>）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;<span class="hljs-type">int</span>&gt; v = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br><span class="hljs-keyword">auto</span> it = v.<span class="hljs-built_in">end</span>();<br>it = it - <span class="hljs-number">2</span>;  <span class="hljs-comment">// 向回跳过两个元素，指向第三个元素</span><br>std::cout &lt;&lt; *it;  <span class="hljs-comment">// 输出 3</span><br></code></pre></td></tr></table></figure></li></ul><ol start="10"><li><strong>加法赋值运算符 <code>+=</code> 和 减法赋值运算符 <code>-=</code></strong></li></ol><ul><li><p><strong>作用</strong>：使迭代器向前或向后移动指定的步数。</p></li><li><p>示例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;<span class="hljs-type">int</span>&gt; v = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br><span class="hljs-keyword">auto</span> it = v.<span class="hljs-built_in">begin</span>();<br>it += <span class="hljs-number">2</span>;  <span class="hljs-comment">// 向前移动两个位置，指向第三个元素</span><br>std::cout &lt;&lt; *it;  <span class="hljs-comment">// 输出 3</span><br>it -= <span class="hljs-number">1</span>;  <span class="hljs-comment">// 向后移动一个位置</span><br>std::cout &lt;&lt; *it;  <span class="hljs-comment">// 输出 2</span><br></code></pre></td></tr></table></figure></li></ul><ol start="11"><li><strong>下标运算符 <code>[]</code>（适用于随机访问迭代器）</strong></li></ol><ul><li><p><strong>作用</strong>：通过下标访问迭代器当前所指向的元素。</p></li><li><p>示例</p><p>（对于随机访问迭代器，如 <code>std::vector</code>）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;<span class="hljs-type">int</span>&gt; v = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br><span class="hljs-keyword">auto</span> it = v.<span class="hljs-built_in">begin</span>();<br>std::cout &lt;&lt; it[<span class="hljs-number">2</span>];  <span class="hljs-comment">// 输出 3</span><br></code></pre></td></tr></table></figure></li></ul><p><strong>注意：8,9,10,11一般适用于随机访问迭代器（支持任意位置的跳跃访问和直接跳转，因此可以实现高效的前后移动），对应的容器有线性容器，如 <code>std::vector</code>、<code>std::deque</code>、<code>std::array</code> 和 <code>std::string</code><strong>，而</strong><code>std::set</code></strong> 和 **<code>std::map</code>**（以及它们的 <code>unordered</code> 版本），这些容器的迭代器也不支持随机访问，因为它们通常是基于树或哈希表的结构。</p>          </div><h3 id="STL中的线性表"><a href="#STL中的线性表" class="headerlink" title="STL中的线性表"></a>STL中的线性表</h3><p>在 C++ 标准库中，<code>std::vector</code> 和 <code>std::list</code> 是两个常用的容器类，它们分别代表动态数组和双向链表。虽然它们都实现了 <code>std::container</code> 的接口，但它们的内部结构和适用场景不同，因此提供的库函数也有所不同。</p><h4 id="1-std-vector-类的常见库函数"><a href="#1-std-vector-类的常见库函数" class="headerlink" title="1. std::vector 类的常见库函数"></a>1. <code>std::vector</code> 类的常见库函数</h4><p><code>std::vector</code> 是一个动态数组容器，支持随机访问。它非常适合用来存储需要频繁随机访问的数据。常见的成员函数包括：</p><h5 id="1-1-构造函数和赋值操作"><a href="#1-1-构造函数和赋值操作" class="headerlink" title="1.1 构造函数和赋值操作"></a>1.1 构造函数和赋值操作</h5><ul><li>**<code>vector()</code>**：默认构造函数，创建一个空的 <code>vector</code>。</li><li>**<code>vector(n)</code>**：构造一个包含 <code>n</code> 个默认值的 <code>vector</code>。</li><li>**<code>vector(n, value)</code>**：构造一个包含 <code>n</code> 个值为 <code>value</code> 的 <code>vector</code>。</li><li>**<code>vector(begin, end)</code>**：使用范围 <code>[begin, end)</code> 的元素来构造 <code>vector</code>。</li><li>**<code>operator=</code>**：赋值操作符，用于将一个 <code>vector</code> 赋值给另一个。</li></ul><h5 id="1-2-元素访问"><a href="#1-2-元素访问" class="headerlink" title="1.2 元素访问"></a>1.2 元素访问</h5><ul><li>**<code>operator[]</code>**：通过下标访问元素。</li><li>**<code>at()</code>**：通过下标访问元素，但会进行边界检查。</li><li>**<code>front()</code>**：返回第一个元素。</li><li>**<code>back()</code>**：返回最后一个元素。</li><li>**<code>data()</code>**：返回指向第一个元素的指针。</li></ul><h5 id="1-3-容量操作"><a href="#1-3-容量操作" class="headerlink" title="1.3 容量操作"></a>1.3 容量操作</h5><ul><li>**<code>size()</code>**：返回 <code>vector</code> 中元素的个数。</li><li>**<code>capacity()</code>**：返回 <code>vector</code> 的容量（即 <code>vector</code> 可以存储的最大元素个数，不一定等于 <code>size()</code>）。</li><li>**<code>empty()</code>**：检查 <code>vector</code> 是否为空。</li><li>**<code>reserve()</code>**：预留至少可以容纳 <code>n</code> 个元素的空间。</li><li>**<code>shrink_to_fit()</code>**：请求减少 <code>vector</code> 的容量，使其尽可能接近 <code>size()</code>，但不保证立即生效。</li></ul><h5 id="1-4-修改操作"><a href="#1-4-修改操作" class="headerlink" title="1.4 修改操作"></a>1.4 修改操作</h5><ul><li>**<code>push_back()</code>**：在 <code>vector</code> 的末尾添加元素。</li><li>**<code>pop_back()</code>**：删除 <code>vector</code> 中的最后一个元素。</li><li>**<code>insert()</code>**：在指定位置插入元素。</li><li>**<code>erase()</code>**：删除指定位置的元素。</li><li>**<code>clear()</code>**：删除 <code>vector</code> 中的所有元素。</li></ul><h5 id="1-5-迭代器和算法"><a href="#1-5-迭代器和算法" class="headerlink" title="1.5 迭代器和算法"></a>1.5 迭代器和算法</h5><ul><li>**<code>begin()</code>**：返回指向 <code>vector</code> 第一个元素的迭代器。</li><li>**<code>end()</code>**：返回指向 <code>vector</code> 末尾元素之后位置的迭代器。</li><li>**<code>rbegin()</code>**：返回指向 <code>vector</code> 最后一个元素的反向迭代器。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; v = &#123;<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>&#125;;<br><br>    <span class="hljs-comment">// 使用反向迭代器进行遍历</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = v.<span class="hljs-built_in">rbegin</span>(); it != v.<span class="hljs-built_in">rend</span>(); ++it) &#123;<br>        std::cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <span class="hljs-comment">// 输出: 50 40 30 20 10</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li>**<code>rend()</code>**：返回指向 <code>vector</code> 第一个元素之前的反向迭代器。</li></ul><h5 id="1-6-其他操作"><a href="#1-6-其他操作" class="headerlink" title="1.6 其他操作"></a>1.6 其他操作</h5><ul><li>**<code>swap()</code>**：交换两个 <code>vector</code> 的内容。</li><li>**<code>resize()</code>**：改变 <code>vector</code> 的大小，如果新大小大于当前大小，新增的元素会用默认值初始化。</li><li>**<code>emplace_back()</code>**：在 <code>vector</code> 末尾构造一个元素。</li><li>**<code>emplace()</code>**：在指定位置构造一个元素。</li></ul><h3 id="2-std-list-类的常见库函数"><a href="#2-std-list-类的常见库函数" class="headerlink" title="2. std::list 类的常见库函数"></a>2. <code>std::list</code> 类的常见库函数</h3><p><code>std::list</code> 是一个双向链表容器，适合用来执行大量的插入和删除操作。由于是链表结构，<code>std::list</code> 不支持随机访问，只能进行顺序访问。常见的成员函数包括：</p><h5 id="2-1-构造函数和赋值操作"><a href="#2-1-构造函数和赋值操作" class="headerlink" title="2.1 构造函数和赋值操作"></a>2.1 构造函数和赋值操作</h5><ul><li>**<code>list()</code>**：默认构造函数，创建一个空的 <code>list</code>。</li><li>**<code>list(n)</code>**：构造一个包含 <code>n</code> 个默认值的 <code>list</code>。</li><li>**<code>list(n, value)</code>**：构造一个包含 <code>n</code> 个值为 <code>value</code> 的 <code>list</code>。</li><li>**<code>list(begin, end)</code>**：使用范围 <code>[begin, end)</code> 的元素来构造 <code>list</code>。</li><li>**<code>operator=</code>**：赋值操作符，用于将一个 <code>list</code> 赋值给另一个。</li></ul><h5 id="2-2-元素访问"><a href="#2-2-元素访问" class="headerlink" title="2.2 元素访问"></a>2.2 元素访问</h5><ul><li>**<code>front()</code>**：返回 <code>list</code> 中的第一个元素。</li><li>**<code>back()</code>**：返回 <code>list</code> 中的最后一个元素。</li></ul><h5 id="2-3-容量操作"><a href="#2-3-容量操作" class="headerlink" title="2.3 容量操作"></a>2.3 容量操作</h5><ul><li>**<code>size()</code>**：返回 <code>list</code> 中元素的个数。</li><li>**<code>empty()</code>**：检查 <code>list</code> 是否为空。</li></ul><h5 id="2-4-修改操作"><a href="#2-4-修改操作" class="headerlink" title="2.4 修改操作"></a>2.4 修改操作</h5><ul><li>**<code>push_front()</code>**：将元素添加到 <code>list</code> 的前面。</li><li>**<code>push_back()</code>**：将元素添加到 <code>list</code> 的末尾。</li><li>**<code>pop_front()</code>**：删除 <code>list</code> 中的第一个元素。</li><li>**<code>pop_back()</code>**：删除 <code>list</code> 中的最后一个元素。</li><li>**<code>insert()</code>**：在指定位置插入一个元素。</li><li>**<code>erase()</code>**：删除指定位置的元素。</li><li>**<code>remove()</code>**：删除所有等于指定值的元素。</li><li>**<code>clear()</code>**：删除 <code>list</code> 中的所有元素。</li></ul><h5 id="2-5-迭代器和算法"><a href="#2-5-迭代器和算法" class="headerlink" title="2.5 迭代器和算法"></a>2.5 迭代器和算法</h5><ul><li>**<code>begin()</code>**：返回指向 <code>list</code> 第一个元素的迭代器。</li><li>**<code>end()</code>**：返回指向 <code>list</code> 末尾元素之后位置的迭代器。</li><li>**<code>rbegin()</code>**：返回指向 <code>list</code> 最后一个元素的反向迭代器。</li><li>**<code>rend()</code>**：返回指向 <code>list</code> 第一个元素之前的反向迭代器。</li></ul><h5 id="2-6-其他操作"><a href="#2-6-其他操作" class="headerlink" title="2.6 其他操作"></a>2.6 其他操作</h5><ul><li>**<code>swap()</code>**：交换两个 <code>list</code> 的内容。</li><li>**<code>resize()</code>**：改变 <code>list</code> 的大小。如果新大小大于当前大小，新增的元素会使用默认值初始化。</li><li>**<code>unique()</code>**：删除 <code>list</code> 中相邻的重复元素。</li></ul><h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h3><table><thead><tr><th>操作</th><th><code>std::vector</code></th><th><code>std::list</code></th></tr></thead><tbody><tr><td><strong>构造函数</strong></td><td><code>vector()</code>, <code>vector(n)</code>, <code>vector(n, value)</code></td><td><code>list()</code>, <code>list(n)</code>, <code>list(n, value)</code></td></tr><tr><td><strong>访问元素</strong></td><td><code>operator[]</code>, <code>at()</code>, <code>front()</code>, <code>back()</code></td><td><code>front()</code>, <code>back()</code></td></tr><tr><td><strong>容量操作</strong></td><td><code>size()</code>, <code>capacity()</code>, <code>reserve()</code>, <code>shrink_to_fit()</code></td><td><code>size()</code>, <code>empty()</code></td></tr><tr><td><strong>修改操作</strong></td><td><code>push_back()</code>, <code>pop_back()</code>, <code>insert()</code>, <code>erase()</code>, <code>clear()</code></td><td><code>push_front()</code>, <code>push_back()</code>, <code>pop_front()</code>, <code>pop_back()</code>, <code>insert()</code>, <code>erase()</code>, <code>clear()</code></td></tr><tr><td><strong>迭代器操作</strong></td><td><code>begin()</code>, <code>end()</code>, <code>rbegin()</code>, <code>rend()</code></td><td><code>begin()</code>, <code>end()</code>, <code>rbegin()</code>, <code>rend()</code></td></tr><tr><td><strong>其他操作</strong></td><td><code>resize()</code>, <code>swap()</code>, <code>emplace_back()</code>, <code>emplace()</code></td><td><code>swap()</code>, <code>resize()</code>, <code>unique()</code>, <code>remove()</code></td></tr></tbody></table><ul><li><strong><code>std::vector</code></strong> 适合频繁的随机访问操作和需要动态扩展大小的场景，但在插入或删除操作上可能效率较低。</li><li><strong><code>std::list</code></strong> 适合需要频繁插入和删除操作的场景，尤其是在容器中间的位置，虽然其访问速度较慢。</li></ul><p>选择使用哪个容器，取决于应用场景的需求：如果需要高效的随机访问，使用 <code>std::vector</code>；如果需要频繁地在容器中间插入和删除元素，使用 <code>std::list</code>。</p><div class="note note-info">            <p><strong>补充知识：内存和缓存：从硬件视角看数据结构的选择</strong></p><blockquote><p>以下内容整理自《Hello 算法》</p></blockquote><p>首先抛出观点：<strong>物理结构在很大程度上决定了程序对内存和缓存的使用效率。</strong></p><ul><li>计算机存储设备</li></ul><p>计算机中包括三种类型的存储设备：硬盘（hard disk）、内存（random-access memory, RAM）、缓存（cache memory）。表 4-2 展示了它们在计算机系统中的不同角色和性能特点。</p><p><a href="https://www.hello-algo.com/chapter_array_and_linkedlist/ram_and_cache/">表 4-2  计算机的存储设备</a></p><table><thead><tr><th align="left"></th><th align="left">硬盘</th><th align="left">内存</th><th align="left">缓存</th></tr></thead><tbody><tr><td align="left">用途</td><td align="left">长期存储数据，包括操作系统、程序、文件等</td><td align="left"><strong>临时存储当前运行的程序和正在处理的数据</strong></td><td align="left"><strong>存储经常访问的数据和指令，减少 CPU 访问内存的次数</strong></td></tr><tr><td align="left">易失性</td><td align="left">断电后数据不会丢失</td><td align="left">断电后数据会丢失</td><td align="left">断电后数据会丢失</td></tr><tr><td align="left">容量</td><td align="left">较大，TB 级别</td><td align="left">较小，GB 级别</td><td align="left">非常小，MB 级别</td></tr><tr><td align="left">速度</td><td align="left">较慢，几百到几千 MB&#x2F;s</td><td align="left">较快，几十 GB&#x2F;s</td><td align="left">非常快，几十到几百 GB&#x2F;s</td></tr><tr><td align="left">价格</td><td align="left">较便宜，几毛到几元 &#x2F; GB</td><td align="left">较贵，几十到几百元 &#x2F; GB</td><td align="left">非常贵，随 CPU 打包计价</td></tr></tbody></table><p><img src="https://www.hello-algo.com/chapter_array_and_linkedlist/ram_and_cache.assets/storage_pyramid.png" alt="计算机存储系统 Hello算法"></p><p><strong>计算机的存储层次结构体现了在速度，容量和成本三者之间的精妙平衡</strong>。</p><ul><li>数据结构的<strong>内存效率</strong></li></ul><p>在上文我们已经比较过数组和链表在内存角度的优缺点：</p><ol><li>数组元素在内存上排列紧密，但是需要一整块内存进行存储。查找效率高但插入，删除效率低。</li><li>链表元素在内存上分散排布，但需要额外储存指针的值。插入、删除效率高但遍历效率低。<ul><li><strong>链表</strong>还有一个比较大的弊端：如果在链表中频繁的插入和删除，会导致<strong>内存的碎片化</strong>，是内存的使用效率降低。</li></ul></li></ol><ul><li>数据结构的<strong>缓存效率</strong>（Additional）</li></ul><p>缓存虽然在空间容量上远小于内存，但它比内存快得多，在程序执行速度上起着至关重要的作用。由于缓存的容量有限，只能存储一小部分频繁访问的数据，因此当 CPU 尝试访问的数据不在缓存中时，就会发生缓存未命中（cache miss），此时 CPU 不得不从速度较慢的内存中加载所需数据。</p><p>显然，<strong>“缓存未命中”越少，CPU 读写数据的效率就越高</strong>，程序性能也就越好。我们将 CPU 从缓存中成功获取数据的比例称为缓存命中率（cache hit rate），这个指标通常用来衡量缓存效率。</p><p>实际上，<strong>数组和链表对缓存的利用效率是不同的</strong>，主要体现在以下几个方面。</p><ul><li><strong>占用空间</strong>：链表元素比数组元素占用空间更多，导致缓存中容纳的有效数据量更少。</li><li><strong>缓存行</strong>：链表数据分散在内存各处，而缓存是“按行加载”的，因此加载到无效数据的比例更高。</li><li><strong>预取机制</strong>：数组比链表的数据访问模式更具“可预测性”，即系统更容易猜出即将被加载的数据。</li><li><strong>空间局部性</strong>：数组被存储在集中的内存空间中，因此被加载数据附近的数据更有可能即将被访问。</li></ul><p>总体而言，<strong>数组具有更高的缓存命中率，因此它在操作效率上通常优于链表</strong>。这使得在解决算法问题时，基于数组实现的数据结构往往更受欢迎。</p>          </div><h2 id="线性表的应用"><a href="#线性表的应用" class="headerlink" title="线性表的应用"></a>线性表的应用</h2><h3 id="大整数处理"><a href="#大整数处理" class="headerlink" title="大整数处理"></a>大整数处理</h3><h3 id="多项式求和"><a href="#多项式求和" class="headerlink" title="多项式求和"></a>多项式求和</h3><h3 id="约瑟夫环问题"><a href="#约瑟夫环问题" class="headerlink" title="约瑟夫环问题"></a>约瑟夫环问题</h3><h3 id="动态内存管理"><a href="#动态内存管理" class="headerlink" title="动态内存管理"></a>动态内存管理</h3>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tutorial</tag>
      
      <tag>Finished</tag>
      
      <tag>Data Structure</tag>
      
      <tag>C/C++</tag>
      
      <tag>Linear List</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DataStructure-Tutorial</title>
    <link href="/posts/DataStructure-Tutorial/"/>
    <url>/posts/DataStructure-Tutorial/</url>
    
    <content type="html"><![CDATA[<style>  html, body, .markdown-body {    font-family: Georgia, sans, serif;  }</style><h1 id="Data-Structure-Tutorial"><a href="#Data-Structure-Tutorial" class="headerlink" title="Data Structure Tutorial"></a>Data Structure Tutorial</h1><p>在本文将要系统梳理之后笔者将要学习的数据结构的内容，这是笔者<strong>遇到的第一门难度较大且较为重要的专业课程</strong>，将成为笔者2025年的更新重点之一。</p><h2 id="Before-Reading"><a href="#Before-Reading" class="headerlink" title="Before Reading"></a>Before Reading</h2><p>在阅读这一系列博客之前，你需要掌握以下知识：</p><ul><li>C++的基本语法（Necessary！）<ul><li><strong>面向过程</strong></li><li><strong>面向对象</strong></li></ul></li><li>Python的基本语法（Optional）</li><li>掌握一些基本的关于算法的基础知识<ul><li>递归算法</li><li>迭代算法</li><li><strong>STL的一些基本知识</strong>（会使用一些基本的接口）</li></ul></li></ul><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li>入门教材：<a href="https://www.hello-algo.com/">Hello 算法</a><ul><li>非常经典且优质的一本教材，有在线学习的网站，并且开源了书中所有代码示例。</li><li>内容相对较少，但是都是基础中的基础，非常适合新手的快速入门，<strong>在一轮过后再深入学习一些更深入的知识</strong>。</li></ul></li><li>主力教材：<strong>《数据结构：思想与实现》——翁慧玉，俞勇</strong><ul><li>经典教材！</li><li>但是教材的难度较大，是笔者下学期上课的教材，也会作为更新的重点。</li></ul></li><li>其他参考教材：<ul><li>图解算法（<strong>可视化做的很好</strong>）</li><li><strong>《大话数据结构》</strong></li><li><strong>《数据结构和算法分析——C语言描述》</strong></li></ul></li></ul><blockquote><p><strong>注：示例代码主要都以C++或者Python代码给出。</strong></p></blockquote><h2 id="What’s-have-been-updated"><a href="#What’s-have-been-updated" class="headerlink" title="What’s have been updated"></a>What’s have been updated</h2><ul><li>导论（在本篇发表之前已经更新）<ul><li>数据结构和算法</li><li>算法的时间复杂度，空间复杂度</li></ul></li><li>线性结构<ul><li>线性表<ul><li>线性表的顺序实现（数组）</li><li>线性表的链接实现（链表）</li></ul></li><li>栈</li><li>队列</li><li>字符串</li></ul></li><li>树状结构<ul><li>二叉树</li><li>哈夫曼树</li><li>优先级队列</li></ul></li><li>集合结构<ul><li>集合与静态查找表</li><li>动态查找表<ul><li>二叉查找树</li><li>AVL树</li><li>红黑树</li><li>AA树</li><li>伸展树</li><li>散列表（哈希表）</li></ul></li><li><strong>算法应用：排序</strong><ul><li>插入排序</li><li>选择排序</li><li>交换排序</li><li>归并排序</li><li>基数排序</li><li>外部查找和排序<ul><li>B树</li><li>B+树</li></ul></li></ul></li></ul></li><li>图状结构<ul><li>图</li><li>最小生成树</li><li><strong>算法应用问题：最短路径问题</strong></li></ul></li><li>算法设计基础<ul><li>枚举法</li><li>贪婪法</li><li>分治法</li><li>动态规划</li><li>回溯法</li><li>随机算法</li></ul></li></ul><h1 id="Introduction-to-Data-structure"><a href="#Introduction-to-Data-structure" class="headerlink" title="Introduction to Data structure"></a>Introduction to Data structure</h1><h2 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h2><ul><li>A set of elements</li><li>with specific relations</li><li>the same type of data</li><li><strong>Logic relations and operations</strong></li></ul><p>Data structure, in essence, represents the <strong>abstract simulation of logic relations of different objects</strong>.</p><ul><li><strong>Set relations</strong> (集合结构)</li><li><strong>Linear relations 1-1</strong> (线性结构)</li><li><strong>Tree relations</strong> (节点一对多，树形结构)</li><li><strong>Graph relations</strong> (节点多对多，图结构)</li></ul><p>The difference between these structures lie in different aspects. For instance, the time and space efficiency for <strong>traverse, insert or other basic operations of elements</strong>.</p><p>Operations are of great importance for data structure!</p><h2 id="Physical-Structure"><a href="#Physical-Structure" class="headerlink" title="Physical Structure"></a>Physical Structure</h2><p>如图 3-3 所示，<strong>物理结构反映了数据在计算机内存中的存储方式</strong>，可分为连续空间存储（数组）和分散空间存储（链表）。物理结构从底层决定了数据的访问、更新、增删等操作方法，两种物理结构在时间效率和空间效率方面呈现出互补的特点。</p><p><img src="https://www.hello-algo.com/chapter_data_structure/classification_of_data_structure.assets/classification_phisical_structure.png" alt="连续空间存储与分散空间存储"></p><p>连续空间存储（数组）</p><ul><li><strong>定义</strong>：连续空间存储是指数据元素在内存中连续排列，数组是这种存储方式的典型代表。</li><li><strong>优点</strong>：<ul><li><strong>快速访问</strong>：由于数组元素是连续存储的，可以通过索引直接访问任意元素，时间复杂度为 O(1)。</li><li><strong>空间局部性</strong>：连续存储有助于缓存命中率，因为访问一个元素后，后续访问相邻元素时，可能已经在缓存中。</li></ul></li><li><strong>缺点</strong>：<ul><li><strong>插入和删除操作效率低</strong>：在数组中插入或删除元素通常需要移动其他元素以保持数据的连续性，时间复杂度为 <em>O</em>(<em>n</em>)。</li><li><strong>固定大小</strong>：数组的大小在创建时确定，扩展数组的大小需要重新分配内存并复制数据。</li></ul></li></ul><p>分散空间存储（链表）</p><ul><li><strong>定义</strong>：分散空间存储是指数据元素在内存中不必连续排列，链表是这种存储方式的典型代表。</li><li><strong>优点</strong>：<ul><li><strong>动态大小</strong>：链表可以方便地进行动态内存分配，允许在运行时灵活地增加或减少元素。</li><li><strong>高效插入和删除</strong>：在链表中，插入和删除元素只需调整指针，而不需要移动其他元素，时间复杂度为 <em>O</em>(1)（在已知位置的情况下）。</li></ul></li><li><strong>缺点</strong>：<ul><li><strong>访问速度慢</strong>：由于链表元素存储在非连续的内存位置，访问某个特定元素需要从头遍历链表，时间复杂度为 <em>O</em>(<em>n</em>)。</li><li><strong>额外空间开销</strong>：链表需要额外的存储空间来存储指针（如前驱和后继指针），这增加了内存使用量。</li></ul></li></ul><p>互补特点</p><ul><li><strong>数组</strong>适合需要频繁随机访问的场景，如需要快速读取大量数据但不经常修改数据的情况。</li><li><strong>链表</strong>适合需要频繁插入和删除操作的场景，如实现动态数据结构（例如队列、栈）时。</li></ul><p>值得说明的是，<strong>所有数据结构都是基于数组、链表或二者的组合实现的</strong>。例如，栈和队列既可以使用数组实现，也可以使用链表实现；而哈希表的实现可能同时包含数组和链表。</p><ul><li><strong>基于数组可实现</strong>：栈、队列、哈希表、树、堆、图、矩阵、张量（维度 ≥3 的数组）等。</li><li><strong>基于链表可实现</strong>：栈、队列、哈希表、树、堆、图等。</li></ul><p>​    哈希表底层是数组，而为了解决哈希冲突，我们可能会使用“链式地址”（后续“哈希冲突”章节会讲）：数组中每个桶指向一个链表，当链表长度超过一定阈值时，又可能被转化为树（通常为红黑树）。</p><p>​    从存储的角度来看，哈希表的底层是数组，其中每一个桶槽位可能包含一个值，也可能包含一个链表或一棵树。因此，哈希表可能同时包含线性数据结构（数组、链表）和非线性数据结构（树）。</p><h2 id="Storage"><a href="#Storage" class="headerlink" title="Storage"></a>Storage</h2><ul><li>Sequential Storage</li><li>Linked Storage</li></ul><p><strong>The two mostly used basic storage implementation of all data-structures.</strong></p><ul><li>Hash storage（散列存储&#x2F;哈希存储）<ul><li>Especially for set structures</li><li><strong>Ideal</strong>: All nodes lies in a continuous space uniformly.<ul><li><strong>Hash collision</strong> and Hash functions</li></ul></li></ul></li><li>Index Storage （索引存储）<ul><li>All nodes will be placed in a sequential order.</li><li><strong>An index place to show relations of different nodes.</strong></li></ul></li></ul><h1 id="Introduction-to-Algorithm"><a href="#Introduction-to-Algorithm" class="headerlink" title="Introduction to Algorithm"></a>Introduction to Algorithm</h1><p>My personal lecture notes of <a href="https://www.hello-algo.com/en/">https://www.hello-algo.com/en/</a></p><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><ul><li>迭代与递归</li><li>时间复杂度</li><li>空间复杂度</li><li>数据结构的物理结构</li></ul><h2 id="Algorithm-and-complexity"><a href="#Algorithm-and-complexity" class="headerlink" title="Algorithm and complexity"></a>Algorithm and complexity</h2><p>​    由于实际测试具有较大的局限性，因此我们可以考虑仅通过一些计算来评估算法的效率。这种估算方法被称为渐近复杂度分析（asymptotic complexity analysis），简称复杂度分析。</p><p>​    复杂度分析能够体现算法运行所需的时间和空间资源与输入数据大小之间的关系。<strong>它描述了随着输入数据大小的增加，算法执行所需时间和空间的增长趋势</strong>。这个定义有些拗口，我们可以将其分为三个重点来理解。</p><ul><li>“<strong>时间和空间资源</strong>”分别对应时间复杂度（time complexity）和空间复杂度（space complexity）。</li><li>“随着输入数据大小的增加”意味着复杂度反映了算法运行效率与输入数据体量之间的关系。</li><li>“<strong>时间和空间的增长趋势</strong>”表示复杂度分析关注的不是运行时间或占用空间的具体值，而是时间或空间增长的“快慢”。（<strong>一种趋势！</strong>）</li></ul><h3 id="Iteration-and-Recursion"><a href="#Iteration-and-Recursion" class="headerlink" title="Iteration and Recursion"></a>Iteration and Recursion</h3><p><strong>迭代：自下而上，小问题积累成大问题</strong></p><p><strong>递归：自上而下，大问题拆解成小问题</strong></p><p>程序实现重复代码块执行的两种方式：</p><ul><li><p>迭代（for循环，while循环）</p></li><li><p>递归</p></li></ul><p>​    递归（recursion）是一种算法策略，通过函数调用自身来解决问题。它主要包含两个阶段。</p><ol><li><strong>递</strong>：程序不断深入地调用自身，通常传入更小或更简化的参数，直到达到“终止条件”。</li><li><strong>归</strong>：触发“终止条件”后，程序从最深层的递归函数开始逐层返回，汇聚每一层的结果。</li></ol><p>​    而从实现的角度看，递归代码主要包含三个要素。</p><ol><li><strong>终止条件</strong>：用于决定什么时候由“递”转“归”。</li><li><strong>递归调用</strong>：对应“递”，函数调用自身，通常输入更小或更简化的参数。</li><li><strong>返回结果</strong>：对应“归”，将当前递归层级的结果返回至上一层。</li></ol><p><strong>有关递归的时间问题和空间问题</strong></p><p>​    递归函数每次调用自身时，系统都会为新开启的函数分配内存，以存储局部变量、调用地址和其他信息等。这将导致两方面的结果。</p><ul><li><p>函数的上下文数据都存储在称为“<strong>栈帧空间</strong>”的内存区域中，直至函数返回后才会被释放。因此，<strong>递归通常比迭代更加耗费内存空间</strong>。（需要控制递归深度，否则过深的递归会导致栈的溢出错误）</p></li><li><p><strong>有关栈帧空间</strong>：</p></li><li><p>栈帧空间是指在程序执行过程中，为每个函数调用分配的一块内存区域，用于存储该函数的局部变量、参数、返回地址以及其他控制信息。每次函数被调用时，都会在调用栈上创建一个新的栈帧，这个栈帧的生命周期与函数的执行周期相同。</p><ol><li><strong>返回地址</strong>：当函数调用完成后，程序需要知道从哪里继续执行，因此返回地址会被压入栈帧中。</li><li><strong>参数</strong>：函数调用时传递给被调用函数的参数也会存储在栈帧中。</li><li><strong>局部变量</strong>：函数内部定义的局部变量会占用栈帧空间。</li><li><strong>控制信息</strong>：包括指向上一个栈帧的指针（帧指针），用于维护调用链。</li></ol><p>  <strong>栈帧的工作机制</strong></p><ul><li><strong>入栈</strong>：当一个函数被调用时，首先将参数和返回地址压入栈中，然后分配空间给局部变量，形成新的栈帧。</li><li><strong>出栈</strong>：当函数执行完毕时，局部变量和参数的空间被释放，返回地址被弹出，程序控制流转回调用该函数的位置。</li></ul><p>  <strong>栈帧的优点</strong></p><ul><li><strong>自动管理</strong>：栈帧由系统自动管理，无需手动分配和释放内存。</li><li><strong>高效性</strong>：由于栈的后进先出特性，内存分配和释放速度非常快。</li></ul></li><li><p>递归调用函数会产生额外的开销。<strong>因此递归通常比循环的时间效率更低</strong>。</p></li><li><p><strong>使用尾递归</strong>可以优化递归的效率（系统无需保存函数上一级的上下文）</p></li></ul><p><strong>有关递归树</strong></p><p>我们在函数内递归调用了两个函数，<strong>这意味着从一个调用产生了两个调用分支</strong>。如图 2-6 所示，这样不断递归调用下去，最终将产生一棵层数为 n 的递归树（recursion tree）。</p><p><img src="https://www.hello-algo.com/chapter_computational_complexity/iteration_and_recursion.assets/recursion_tree.png" alt="斐波那契数列的递归树"></p><blockquote><p>这种递归树可以达到指数阶的时间复杂度。</p></blockquote><p><strong>一定要理解递归的核心思想：分治！</strong></p><p>从本质上看，递归体现了“将问题分解为更小子问题”的思维范式，这种分治策略至关重要。</p><ul><li>从算法角度看，<strong>搜索、排序、回溯、分治、动态规划</strong>等许多重要算法策略直接或间接地应用了这种思维方式。</li><li>从数据结构角度看，<strong>递归天然适合处理链表、树和图的相关问题</strong>，因为它们非常适合用分治思想进行分析。</li></ul><p><strong>迭代和递归的本质与内在联系</strong></p><p>以上述递归函数为例，求和操作在递归的“归”阶段进行。这意味着<strong>最初被调用的函数实际上是最后完成其求和操作</strong>的，<strong>这种工作机制与栈的“先入后出”原则异曲同工</strong>。</p><p>事实上，“<strong>调用栈</strong>”和“<strong>栈帧空间</strong>”这类递归术语已经暗示了递归与栈之间的密切关系。</p><ol><li><strong>递</strong>：当函数被调用时，系统会在“调用栈”上为该函数分配新的栈帧，用于<strong>存储函数的局部变量、参数、返回地址</strong>等数据。</li><li><strong>归</strong>：当函数完成执行并返回时，对应的栈帧会被从“调用栈”上移除，恢复之前函数的执行环境。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">for_loop_recur</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;使用迭代模拟递归&quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 使用一个显式的栈来模拟系统调用栈</span><br>    stack = []<br>    res = <span class="hljs-number">0</span><br>    <span class="hljs-comment"># 递：递归调用</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>):<br>        <span class="hljs-comment"># 通过“入栈操作”模拟“递”</span><br>        stack.append(i)<br>    <span class="hljs-comment"># 归：返回结果</span><br>    <span class="hljs-keyword">while</span> stack:<br>        <span class="hljs-comment"># 通过“出栈操作”模拟“归”</span><br>        res += stack.pop()<br>    <span class="hljs-comment"># res = 1+2+3+...+n</span><br>    <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h3 id="Time-complexity"><a href="#Time-complexity" class="headerlink" title="Time complexity"></a>Time complexity</h3><ul><li><strong>常数</strong>时间复杂度</li><li><strong>线性</strong>时间复杂度</li><li><strong>平方</strong>时间复杂度</li><li><strong>指数阶</strong>时间复杂度<ul><li>递归树的一分为二</li></ul></li><li><strong>对数阶</strong>时间复杂度<ul><li>每轮缩减到一半</li><li>也会出现在递归树中（经典例题：快速幂计算）</li></ul></li><li><strong>线性对数阶</strong>时间复杂度（<code>O(nlogn)</code>）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">linear_log_recur</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;线性对数阶&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">if</span> n &lt;= <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    <span class="hljs-comment"># 一分为二，子问题的规模减小一半</span><br>    count = linear_log_recur(n // <span class="hljs-number">2</span>) + linear_log_recur(n // <span class="hljs-number">2</span>)<br>    <span class="hljs-comment"># 与C++不同，//表示地板出发（整数截断）</span><br>    <span class="hljs-comment"># 当前子问题包含 n 个操作</span><br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>        count += <span class="hljs-number">1</span><br>    <span class="hljs-comment"># 代表当前需要执行的n次操作</span><br>    <span class="hljs-keyword">return</span> count<br></code></pre></td></tr></table></figure><p><img src="https://www.hello-algo.com/chapter_computational_complexity/time_complexity.assets/time_complexity_logarithmic_linear.png" alt="线性对数阶的时间复杂度"></p><ul><li><strong>阶乘阶</strong>时间复杂度</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">factorial_recur</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;阶乘阶（递归实现）&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    count = <span class="hljs-number">0</span><br>    <span class="hljs-comment"># 从 1 个分裂出 n 个</span><br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>        count += factorial_recur(n - <span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> count<br></code></pre></td></tr></table></figure><p><img src="https://www.hello-algo.com/chapter_computational_complexity/time_complexity.assets/time_complexity_factorial.png" alt="阶乘阶的时间复杂度"></p><p>时间复杂度的分类：</p><ul><li>最差时间复杂度</li><li>最佳时间复杂度</li></ul><blockquote><p>以上两个时间复杂度均与数据的分布存在联系，具有偶然性</p></blockquote><ul><li>平均时间复杂度</li></ul><blockquote><p><strong>The essence of time complexity</strong> lies in not considering the specific runtime function, but rather focusing only on the order of the runtime function. This is because, when the data size is large, the highest-order term of the time function dominates the overall trend.</p></blockquote><h4 id="Symbolic-representation-of-time-complexity"><a href="#Symbolic-representation-of-time-complexity" class="headerlink" title="Symbolic representation of time complexity"></a>Symbolic representation of time complexity</h4><p>时间复杂度的符号表示法主要有三种：<code>O</code>、<code>Ω</code> 和 <code>Θ</code>，它们分别表示算法在不同情况下的性能表现。</p><ol><li><strong>大 O 表示法 (O(f(n)))</strong>：<ul><li>描述：表示算法在<strong>最坏情况下的时间复杂度</strong>。</li><li>用途：用于描述算法的上界，即算法的执行时间不会超过某个函数的增长速度。</li><li>示例：如果一个算法的时间复杂度是 (O(n^2))，意味着在最坏情况下，算法的执行时间最多是输入规模的平方。</li></ul></li><li><strong>大 Ω 表示法 (Ω(f(n)))</strong>：<ul><li>描述：表示算法在<strong>最好情况下的时间复杂度</strong>。</li><li>用途：用于描述算法的下界，即算法的执行时间至少是某个函数的增长速度。</li><li>示例：如果一个算法的时间复杂度是 (Ω(n))，意味着在最好情况下，算法的执行时间至少是输入规模的线性增长。</li></ul></li><li><strong>大 Θ 表示法 (Θ(f(n)))</strong>：<ul><li>描述：表示算法在<strong>平均情况下的时间复杂度</strong>。</li><li>用途：用于描述算法的确界，即算法的执行时间既不会超过某个函数的上界，也不会低于某个函数的下界。</li><li>示例：如果一个算法的时间复杂度是 (Θ(n \log n))，意味着在所有情况下，算法的执行时间大致是输入规模的 (n \log n) 级别。</li><li><strong>Explanation in Maths</strong>: exits c1, c2 and N0, when N &gt; N0, c1*F(N) &lt;&#x3D; T(n) &lt;&#x3D; c2*F(N)</li></ul></li><li><strong>小o表示法</strong>:<ul><li>T(N) 是 Ω(F(N)) and T(N) 不是 Θ(F(N))</li></ul></li></ol><h3 id="Space-complexity"><a href="#Space-complexity" class="headerlink" title="Space complexity"></a>Space complexity</h3><p>算法在运行过程中使用的内存空间主要包括以下几种。</p><ul><li><strong>输入空间</strong>：用于存储算法的输入数据。</li><li><strong>暂存空间</strong>：用于存储算法在运行过程中的变量、对象、函数上下文等数据。</li><li><strong>输出空间</strong>：用于存储算法的输出数据。</li></ul><p>一般情况下，空间复杂度的统计范围是“<strong>暂存空间”加上“输出空间”</strong>。</p><p>暂存空间可以进一步划分为三个部分。</p><ul><li><strong>暂存数据</strong>：用于保存算法运行过程中的各种常量、变量、对象等。</li><li><strong>栈帧空间</strong>：用于保存调用函数的上下文数据。系统在每次调用函数时都会在栈顶部创建一个栈帧，函数返回后，栈帧空间会被释放。</li><li><strong>指令空间</strong>：用于保存编译后的程序指令，在实际统计中通常忽略不计。</li></ul><p>在分析一段程序的空间复杂度时，<strong>我们通常统计暂存数据、栈帧空间和输出数据三部分</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;类&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, x: <span class="hljs-built_in">int</span></span>):<br>        <span class="hljs-variable language_">self</span>.val: <span class="hljs-built_in">int</span> = x              <span class="hljs-comment"># 节点值</span><br>        <span class="hljs-variable language_">self</span>.<span class="hljs-built_in">next</span>: Node | <span class="hljs-literal">None</span> = <span class="hljs-literal">None</span>  <span class="hljs-comment"># 指向下一节点的引用</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">function</span>() -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;函数&quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 执行某些操作...</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">algorithm</span>(<span class="hljs-params">n</span>) -&gt; <span class="hljs-built_in">int</span>:  <span class="hljs-comment"># 输入数据</span><br>    A = <span class="hljs-number">0</span>                 <span class="hljs-comment"># 暂存数据（常量，一般用大写字母表示）</span><br>    b = <span class="hljs-number">0</span>                 <span class="hljs-comment"># 暂存数据（变量）</span><br>    node = Node(<span class="hljs-number">0</span>)        <span class="hljs-comment"># 暂存数据（对象）</span><br>    c = function()        <span class="hljs-comment"># 栈帧空间（调用函数）</span><br>    <span class="hljs-keyword">return</span> A + b + c      <span class="hljs-comment"># 输出数据</span><br></code></pre></td></tr></table></figure><p>​    而与时间复杂度不同的是，<strong>我们通常只关注最差空间复杂度</strong>。这是因为内存空间是一项硬性要求，我们必须确保在所有输入数据下都有足够的内存空间预留。</p><ul><li>以最差输入数据为准</li><li>以算法运行的<strong>峰值内存</strong>（注意不是累积量）为准</li></ul><p>一些常见的空间复杂度：</p><ul><li><p>常数阶空间复杂度</p><ul><li>在循环中初始化变量或调用函数而占用的内存，在进入下一循环后就会被释放，因此不会累积占用空间，空间复杂度还是<code>O(1)</code>。</li></ul></li><li><p>线性阶空间复杂度</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">linear</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span></span>):<br>    <span class="hljs-string">&quot;&quot;&quot;线性阶&quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 长度为 n 的列表占用 O(n) 空间</span><br>    nums = [<span class="hljs-number">0</span>] * n<br>    <span class="hljs-comment"># 长度为 n 的哈希表占用 O(n) 空间</span><br>    hmap = <span class="hljs-built_in">dict</span>[<span class="hljs-built_in">int</span>, <span class="hljs-built_in">str</span>]()<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>        hmap[i] = <span class="hljs-built_in">str</span>(i)<br></code></pre></td></tr></table></figure>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">linear_recur</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span></span>):<br>    <span class="hljs-string">&quot;&quot;&quot;线性阶（递归实现）&quot;&quot;&quot;</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;递归 n =&quot;</span>, n)<br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span><br>    linear_recur(n - <span class="hljs-number">1</span>)<br>    <span class="hljs-comment"># 在达到最深的递归深度的时候，会有n个变量n（涉及到局部变量）</span><br></code></pre></td></tr></table></figure></li><li><p>平方阶空间复杂度</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">quadratic</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span></span>):<br>    <span class="hljs-string">&quot;&quot;&quot;平方阶&quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 二维列表占用 O(n^2) 空间</span><br>    num_matrix = [[<span class="hljs-number">0</span>] * n <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br></code></pre></td></tr></table></figure><ul><li><p><code>num_matrix</code>：这是一个变量名，用于存储生成的二维矩阵。</p><p>  <code>[[0] * n for _ in range(n)]</code>：这是一个列表生成式，用于创建一个包含 <code>n</code> 个子列表的列表，每个子列表包含 <code>n</code> 个元素。</p><ul><li><code>[0] * n</code>：这一部分创建一个包含 <code>n</code> 个 <code>0</code> 的列表。例如，如果 <code>n</code> 是 <code>3</code>，则生成 <code>[0, 0, 0]</code>。</li><li><code>for _ in range(n)</code>：这一部分用于重复创建上述的子列表 <code>n</code> 次。<code>_</code> 是一个惯用的变量名，表示循环变量在循环体内未被使用。</li></ul>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">quadratic_recur</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;平方阶（递归实现）&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">if</span> n &lt;= <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    <span class="hljs-comment"># 数组 nums 长度为 n, n-1, ..., 2, 1</span><br>    nums = [<span class="hljs-number">0</span>] * n<br>    <span class="hljs-keyword">return</span> quadratic_recur(n - <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure></li></ul></li><li><p>指数阶空间复杂度（二叉树）</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">build_tree</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span></span>) -&gt; TreeNode | <span class="hljs-literal">None</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;指数阶（建立满二叉树）&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>    root = TreeNode(<span class="hljs-number">0</span>)<br>    root.left = build_tree(n - <span class="hljs-number">1</span>)<br>    root.right = build_tree(n - <span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> root<br></code></pre></td></tr></table></figure><p>  <img src="https://www.hello-algo.com/chapter_computational_complexity/space_complexity.assets/space_complexity_exponential.png" alt="满二叉树产生的指数阶空间复杂度"></p></li><li><p>对数阶空间复杂度</p></li></ul><p>对数阶空间复杂度（(O(\log n))）在算法中并不如其他复杂度（如常数、线性、平方等）常见，因为对数阶通常与递归深度相关联。以下是一些可能具有对数阶空间复杂度的常见算法和场景：</p><ol><li><p><strong>递归算法</strong>：</p><ul><li><strong>二分查找</strong>：在递归实现中，二分查找的空间复杂度是 (O(\log n))，因为递归调用栈的深度是对数级别的。</li><li><strong>快速排序</strong>：在最优情况下（即每次分区都能将数组均匀分割），快速排序的递归深度是 (O(\log n))，因此空间复杂度也是 (O(\log n))。</li><li><strong>归并排序</strong>：尽管归并排序的时间复杂度是 (O(n \log n))，其递归实现的空间复杂度可以是 (O(\log n))（不包括用于存储结果的额外数组）。</li></ul><h3 id="快速排序（Quick-Sort）"><a href="#快速排序（Quick-Sort）" class="headerlink" title="快速排序（Quick Sort）"></a>快速排序（Quick Sort）</h3><p> 快速排序是一种分而治之的排序算法。它的基本思想是选择一个基准元素（pivot），然后将数组分成两个子数组，一个包含所有小于基准元素的元素，另一个包含所有大于基准元素的元素，然后递归地对这两个子数组进行排序。</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">quick_sort</span>(<span class="hljs-params">arr</span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(arr) &lt;= <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span> arr<br>    <span class="hljs-keyword">else</span>:<br>        pivot = arr[<span class="hljs-built_in">len</span>(arr) // <span class="hljs-number">2</span>]<br>        left = [x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> arr <span class="hljs-keyword">if</span> x &lt; pivot]<br>        middle = [x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> arr <span class="hljs-keyword">if</span> x == pivot]<br>        right = [x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> arr <span class="hljs-keyword">if</span> x &gt; pivot]<br>        <span class="hljs-keyword">return</span> quick_sort(left) + middle + quick_sort(right)<br><br><span class="hljs-comment"># 示例使用</span><br>arr = [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">10</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Original array:&quot;</span>, arr)<br>sorted_arr = quick_sort(arr)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Sorted array:&quot;</span>, sorted_arr)<br></code></pre></td></tr></table></figure><h3 id="归并排序（Merge-Sort）"><a href="#归并排序（Merge-Sort）" class="headerlink" title="归并排序（Merge Sort）"></a>归并排序（Merge Sort）</h3><p> 归并排序也是一种分而治之的排序算法。它的基本思想是将数组分成两个子数组，对这两个子数组分别进行排序，然后将排序后的子数组合并成一个有序的数组。</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">merge_sort</span>(<span class="hljs-params">arr</span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(arr) &lt;= <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span> arr<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">merge</span>(<span class="hljs-params">left, right</span>):<br>        result = []<br>        i = j = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> i &lt; <span class="hljs-built_in">len</span>(left) <span class="hljs-keyword">and</span> j &lt; <span class="hljs-built_in">len</span>(right):<br>            <span class="hljs-keyword">if</span> left[i] &lt; right[j]:<br>                result.append(left[i])<br>                i += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                result.append(right[j])<br>                j += <span class="hljs-number">1</span><br>        result.extend(left[i:])<br>        result.extend(right[j:])<br>        <span class="hljs-keyword">return</span> result<br><br>    mid = <span class="hljs-built_in">len</span>(arr) // <span class="hljs-number">2</span><br>    left = merge_sort(arr[:mid])<br>    right = merge_sort(arr[mid:])<br>    <span class="hljs-keyword">return</span> merge(left, right)<br><br><span class="hljs-comment"># 示例使用</span><br>arr = [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">10</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Original array:&quot;</span>, arr)<br>sorted_arr = merge_sort(arr)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Sorted array:&quot;</span>, sorted_arr)<br></code></pre></td></tr></table></figure><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><ul><li><p><strong>快速排序</strong>：</p><ul><li>选择一个基准元素（pivot）。</li><li>将数组分成三个部分：小于基准的部分、等于基准的部分和大于基准的部分。</li><li>递归地对小于基准和大于基准的部分进行排序。</li><li>合并结果。</li></ul></li><li><p><strong>归并排序</strong>：</p><ul><li>将数组分成两半。</li><li>递归地对每一半进行排序。</li><li>合并两个排序后的子数组。</li></ul></li></ul><p> 这两种排序算法都是经典的分而治之算法，具有较好的性能和广泛的应用。</p></li><li><p><strong>平衡树的数据结构</strong>：</p><ul><li><strong>平衡二叉搜索树（如 AVL 树、红黑树）</strong>：这些数据结构在执行插入、删除和查找操作时的递归深度通常是 (O(\log n))，因此在某些实现中，可能会有 (O(\log n)) 的空间复杂度，主要用于递归调用栈。</li></ul></li><li><p><strong>迭代算法</strong>：</p><ul><li>某些迭代算法在实现中可能会使用一个栈来模拟递归，从而使得其空间复杂度为 (O(\log n))。例如，某些树遍历算法在深度优先搜索时可能使用栈来存储路径信息。</li></ul></li></ol><p>需要注意的是，空间复杂度为 (O(\log n)) 的算法通常涉及递归调用或需要存储某些对数数量的信息。这种复杂度通常与算法的递归深度或树结构的高度相关。</p><p><strong>循环与递归在空间复杂度上的差异</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">function</span>() -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-comment"># 执行某些操作</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">loop</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span></span>):<br>    <span class="hljs-string">&quot;&quot;&quot;循环的空间复杂度为 O(1)&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>        function()<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">recur</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span></span>):<br>    <span class="hljs-string">&quot;&quot;&quot;递归的空间复杂度为 O(n)&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span><br>    <span class="hljs-keyword">return</span> recur(n - <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>函数 <code>loop()</code> 和 <code>recur()</code> 的时间复杂度都为 O(n) ，但空间复杂度不同。</p><ul><li>函数 <code>loop()</code> 在循环中调用了 n 次 <code>function()</code> ，每轮中的 <code>function()</code> 都返回并释放了栈帧空间，因此空间复杂度仍为 O(1) 。</li><li>递归函数 <code>recur()</code> 在运行过程中会同时存在 n 个未返回的 <code>recur()</code> ，从而占用 O(n) 的栈帧空间。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tutorial</tag>
      
      <tag>Finished</tag>
      
      <tag>Data Structure</tag>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CMake-Tutorial-Episode2</title>
    <link href="/posts/CMake-tutorial-episode2/"/>
    <url>/posts/CMake-tutorial-episode2/</url>
    
    <content type="html"><![CDATA[<style>  html, body, .markdown-body {    font-family: Georgia, sans, serif;  }</style><h1 id="CMake-编译多文件-C-程序：项目指南"><a href="#CMake-编译多文件-C-程序：项目指南" class="headerlink" title="CMake 编译多文件 C++ 程序：项目指南"></a>CMake 编译多文件 C++ 程序：项目指南</h1><p>本指南将帮助你使用 CMake 构建一个包含多个 <code>.cpp</code> 文件的 C++ 项目。我们将逐步介绍如何配置 <code>CMakeLists.txt</code> 文件，以及如何管理项目中的源文件和头文件。</p><hr><h3 id="1-项目结构"><a href="#1-项目结构" class="headerlink" title="1. 项目结构"></a>1. 项目结构</h3><p>假设我们有以下项目结构：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cmake">/<span class="hljs-keyword">project</span><br>  ├── CMakeLists.txt      <span class="hljs-comment"># 项目根目录的 CMake 配置文件</span><br>  ├── src/                <span class="hljs-comment"># 源代码文件夹</span><br>  │   ├── main.cpp        <span class="hljs-comment"># 主程序文件</span><br>  │   ├── foo.cpp         <span class="hljs-comment"># 其他源文件</span><br>  │   └── bar.cpp         <span class="hljs-comment"># 其他源文件</span><br>  ├── <span class="hljs-keyword">include</span>/            <span class="hljs-comment"># 头文件文件夹</span><br>  │   ├── foo.h           <span class="hljs-comment"># foo 的头文件</span><br>  │   └── bar.h           <span class="hljs-comment"># bar 的头文件</span><br>  └── CMakeLists.txt      <span class="hljs-comment"># src 子目录中的 CMake 配置文件</span><br></code></pre></td></tr></table></figure><h3 id="2-创建-CMake-配置文件"><a href="#2-创建-CMake-配置文件" class="headerlink" title="2. 创建 CMake 配置文件"></a>2. 创建 CMake 配置文件</h3><h4 id="2-1-根目录的-CMakeLists-txt"><a href="#2-1-根目录的-CMakeLists-txt" class="headerlink" title="2.1 根目录的 CMakeLists.txt"></a>2.1 根目录的 <code>CMakeLists.txt</code></h4><p>在项目的根目录下创建一个 <code>CMakeLists.txt</code> 文件，配置全局设置和添加子目录。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># 设置 CMake 最低版本要求</span><br><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.10</span>)<br><br><span class="hljs-comment"># 设置项目名称</span><br><span class="hljs-keyword">project</span>(MyMultiFileProject)<br><br><span class="hljs-comment"># 设置 C++ 标准</span><br><span class="hljs-keyword">set</span>(CMAKE_CXX_STANDARD <span class="hljs-number">11</span>)<br><br><span class="hljs-comment"># 添加 src 目录作为子目录</span><br><span class="hljs-keyword">add_subdirectory</span>(src)<br></code></pre></td></tr></table></figure><h4 id="2-2-src-CMakeLists-txt"><a href="#2-2-src-CMakeLists-txt" class="headerlink" title="2.2 src/CMakeLists.txt"></a>2.2 <code>src/CMakeLists.txt</code></h4><p>在 <code>src/</code> 目录下创建另一个 <code>CMakeLists.txt</code> 文件，用于配置源文件的编译规则。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># 查找 src 目录及其子目录中的所有 .cpp 文件</span><br><span class="hljs-keyword">file</span>(GLOB_RECURSE SOURCES <span class="hljs-string">&quot;*.cpp&quot;</span>)<br><br><span class="hljs-comment"># 创建可执行文件</span><br><span class="hljs-keyword">add_executable</span>(MyExecutable <span class="hljs-variable">$&#123;SOURCES&#125;</span>)<br><br><span class="hljs-comment"># 设置头文件搜索路径</span><br><span class="hljs-keyword">target_include_directories</span>(MyExecutable PRIVATE ../<span class="hljs-keyword">include</span>)<br></code></pre></td></tr></table></figure><ul><li><code>file(GLOB_RECURSE ...)</code>：递归查找 <code>src/</code> 目录及其子目录下的所有 <code>.cpp</code> 文件。</li><li><code>add_executable(MyExecutable $&#123;SOURCES&#125;)</code>：将所有 <code>.cpp</code> 文件编译成一个可执行文件 <code>MyExecutable</code>。</li><li><code>target_include_directories(MyExecutable PRIVATE ../include)</code>：设置 <code>MyExecutable</code> 可执行文件的头文件搜索路径，指向项目的 <code>include/</code> 目录。</li></ul><h3 id="3-自动查找源文件"><a href="#3-自动查找源文件" class="headerlink" title="3. 自动查找源文件"></a>3. 自动查找源文件</h3><p>如果源文件数量较多，手动列出每个源文件可能比较麻烦。可以使用 <code>file(GLOB ...)</code> 或 <code>file(GLOB_RECURSE ...)</code> 自动查找 <code>.cpp</code> 文件。</p><h4 id="3-1-查找当前目录下的-cpp-文件"><a href="#3-1-查找当前目录下的-cpp-文件" class="headerlink" title="3.1 查找当前目录下的 .cpp 文件"></a>3.1 查找当前目录下的 <code>.cpp</code> 文件</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">file</span>(GLOB SOURCES <span class="hljs-string">&quot;*.cpp&quot;</span>)<br></code></pre></td></tr></table></figure><p><code>file(GLOB ...)</code> 会查找当前目录下所有 <code>.cpp</code> 文件，并将它们添加到 <code>SOURCES</code> 变量中。</p><h4 id="3-2-查找子目录中的-cpp-文件"><a href="#3-2-查找子目录中的-cpp-文件" class="headerlink" title="3.2 查找子目录中的 .cpp 文件"></a>3.2 查找子目录中的 <code>.cpp</code> 文件</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">file</span>(GLOB_RECURSE SOURCES <span class="hljs-string">&quot;*.cpp&quot;</span>)<br></code></pre></td></tr></table></figure><p><code>file(GLOB_RECURSE ...)</code> 会递归地查找指定目录及其所有子目录中的 <code>.cpp</code> 文件。</p><h3 id="4-构建和编译"><a href="#4-构建和编译" class="headerlink" title="4. 构建和编译"></a>4. 构建和编译</h3><h4 id="4-1-生成构建目录"><a href="#4-1-生成构建目录" class="headerlink" title="4.1 生成构建目录"></a>4.1 生成构建目录</h4><p>在项目根目录下创建一个 <code>build</code> 目录，并进入该目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> build<br><span class="hljs-built_in">cd</span> build<br></code></pre></td></tr></table></figure><h4 id="4-2-运行-CMake-配置"><a href="#4-2-运行-CMake-配置" class="headerlink" title="4.2 运行 CMake 配置"></a>4.2 运行 CMake 配置</h4><p>在 <code>build</code> 目录中运行 CMake，指定项目的根目录作为源目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cmake ..<br></code></pre></td></tr></table></figure><p>这将配置项目并生成适合你平台的构建系统。</p><h4 id="4-3-编译项目"><a href="#4-3-编译项目" class="headerlink" title="4.3 编译项目"></a>4.3 编译项目</h4><p>使用 CMake 生成的构建系统来编译项目。如果你使用 Makefiles，可以运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">make<br></code></pre></td></tr></table></figure><p>如果使用其他构建系统（如 Visual Studio），可以直接在 IDE 中进行编译。</p><h4 id="4-4-运行程序"><a href="#4-4-运行程序" class="headerlink" title="4.4 运行程序"></a>4.4 运行程序</h4><p>编译完成后，你可以在 <code>build</code> 目录中找到生成的可执行文件 <code>MyExecutable</code>，然后运行它：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./MyExecutable<br></code></pre></td></tr></table></figure><h3 id="5-处理大型项目结构"><a href="#5-处理大型项目结构" class="headerlink" title="5. 处理大型项目结构"></a>5. 处理大型项目结构</h3><p>对于大型项目，你可能会将源文件和头文件拆分成多个子目录。在这种情况下，可以使用 <code>add_subdirectory()</code> 将各个子目录包含进来，每个子目录都可以有自己的 <code>CMakeLists.txt</code> 文件。</p><h4 id="示例：子目录结构"><a href="#示例：子目录结构" class="headerlink" title="示例：子目录结构"></a>示例：子目录结构</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs stylus">/project<br>  ├── CMakeLists<span class="hljs-selector-class">.txt</span><br>  ├── <span class="hljs-attribute">src</span>/<br>  │   ├── CMakeLists<span class="hljs-selector-class">.txt</span><br>  │   ├── <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.cpp</span><br>  │   ├── foo<span class="hljs-selector-class">.cpp</span><br>  │   └── bar<span class="hljs-selector-class">.cpp</span><br>  └── include/<br>      ├── foo<span class="hljs-selector-class">.h</span><br>      └── bar.h<br></code></pre></td></tr></table></figure><p>根目录的 <code>CMakeLists.txt</code> 文件：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.10</span>)<br><br><span class="hljs-keyword">project</span>(MyMultiFileProject)<br><br><span class="hljs-keyword">set</span>(CMAKE_CXX_STANDARD <span class="hljs-number">11</span>)<br><br><span class="hljs-comment"># 添加 src 子目录</span><br><span class="hljs-keyword">add_subdirectory</span>(src)<br></code></pre></td></tr></table></figure><p><code>src/CMakeLists.txt</code> 文件：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># 查找 src 目录及其子目录中的所有 .cpp 文件</span><br><span class="hljs-keyword">file</span>(GLOB_RECURSE SOURCES <span class="hljs-string">&quot;*.cpp&quot;</span>)<br><br><span class="hljs-comment"># 创建可执行文件</span><br><span class="hljs-keyword">add_executable</span>(MyExecutable <span class="hljs-variable">$&#123;SOURCES&#125;</span>)<br><br><span class="hljs-comment"># 设置头文件搜索路径</span><br><span class="hljs-keyword">target_include_directories</span>(MyExecutable PRIVATE ../<span class="hljs-keyword">include</span>)<br></code></pre></td></tr></table></figure><h3 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h3><p>通过以上步骤，你可以使用 CMake 管理多源文件的 C++ 项目：</p><ol><li>在项目根目录创建一个 <code>CMakeLists.txt</code> 文件，配置全局项目设置。</li><li>在 <code>src/</code> 目录创建子目录的 <code>CMakeLists.txt</code> 文件，自动查找 <code>.cpp</code> 文件。</li><li>使用 <code>file(GLOB ...)</code> 或 <code>file(GLOB_RECURSE ...)</code> 自动查找源文件。</li><li>配置头文件搜索路径，确保程序能找到必要的头文件。</li><li>使用 <code>cmake</code> 和 <code>make</code> 命令构建项目，并生成可执行文件。</li></ol><p>这样，你就能高效地管理和构建多个源文件的 C++ 项目，同时也能确保项目结构清晰，易于扩展和维护。</p>]]></content>
    
    
    <categories>
      
      <category>Efficient Tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tutorial</tag>
      
      <tag>Finished</tag>
      
      <tag>CMake</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CMake-Tutorial1</title>
    <link href="/posts/CMake-tutorial1/"/>
    <url>/posts/CMake-tutorial1/</url>
    
    <content type="html"><![CDATA[<style>  html, body, .markdown-body {    font-family: Georgia, sans, serif;  }</style><h1 id="CMake-tutorial-episode1"><a href="#CMake-tutorial-episode1" class="headerlink" title="CMake-tutorial-episode1"></a>CMake-tutorial-episode1</h1><h2 id="Building-a-cpp-project"><a href="#Building-a-cpp-project" class="headerlink" title="Building a cpp project"></a>Building a cpp project</h2><p>在之前的C++程序中，绝大部分都是以<strong>单个Cpp文件</strong>呈现的。具体到编译器，编译器对源代码（<strong>Cpp</strong>文件）进行编译，生成中间目标文件（**.obj**），再由链接器将中间目标文件与一些会使用到的库文件链接在一起，最终形成一个可执行文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Bash">g++ your_file_name.cpp -o your_executable_name.exe<br>./your_executable_name.exe<br></code></pre></td></tr></table></figure><blockquote><p>上面两行代码是在Bash（命令行）中编译C++程序的命令行代码。</p></blockquote><p>但是，随着程序体量的膨胀，我们越来越难把所有的函数放在一个cpp文件中，这样对后续代码的修改，调试等工作都增添了负担。因此，<strong>模块化开发</strong>是C++中必不可少的一个部分！</p><h3 id="模块化开发"><a href="#模块化开发" class="headerlink" title="模块化开发"></a>模块化开发</h3><p>模块化是一种将复杂系统分解为可更好管理的模块的方式</p><ul><li>模块化开发就是封装实现细节，提供模块使用接口，模块彼此之间互不影响，每个模块实现某一特定的功能</li><li>最大化代码重用，以最少的模块、零部件，更快速地满足个性化需求</li><li>原则：<strong>模块内紧耦合，模块间松耦合</strong></li></ul><p>在C++的模块化开发中，主要有两层含义：</p><ul><li>功能模块化</li><li>代码模块化</li></ul><p>对于功能模块化，<strong>程序可以拆解成若干个子功能</strong>（例如在一个学生成绩的统计表中，可以拆解为：修改、查找、排序等子功能），将每个子功能的代码实现在不同的文件中。</p><p>对于代码模块化，<strong>是指对于每一个具体的子功能</strong>，其内部有若干个自定义的函数实现，我们需要将<strong>函数的声明、函数的定义、函数的调用</strong>三者分离开来，分别放在不同的头文件或者源代码文件中。</p><h3 id="Usage："><a href="#Usage：" class="headerlink" title="Usage："></a>Usage：</h3><h4 id="①全局变量或者枚举定义"><a href="#①全局变量或者枚举定义" class="headerlink" title="①全局变量或者枚举定义"></a>①全局变量或者枚举定义</h4><p>这个部分往往是所有子功能都会使用到的，我们首先进行定义。</p><div class="note note-danger">            <p><strong>注意：谨慎使用全局变量！！！在多文件开发中，全局变量可以被任何一个文件中的任何一个函数调用并且修改！！！安全性低并且会产生很多奇怪的错误！</strong></p><p>可以在文件中使用<strong>静态全局变量</strong>，这样可以让其他文件中的函数无法使用该变量。</p><p>因此，在这个文件中，笔者推荐只定义一些枚举变量或者变量的别名，宏定义等。</p>          </div><h4 id="②子功能模块的实现"><a href="#②子功能模块的实现" class="headerlink" title="②子功能模块的实现"></a>②子功能模块的实现</h4><p>这个部分主要要解决两件事：<strong>函数的声明和函数的定义</strong>。函数的声明在<strong>头文件(.h)<strong>中实现，而函数的定义在</strong>源代码文件(.cpp)<strong>中实现，一般来说，我们要求</strong>在一个子模块就只有这两个文件，并且要求同名。</strong></p><blockquote><p>例如，一个子模块实现“输出”的子功能，内涵各种各样包含输出的函数，这头文件可以定义为<code>Output.h</code>，源代码文件可以定义为<code>Output.cpp</code>。</p></blockquote><div class="note note-info">            <p><strong>为什么要把函数的声明和调用分离开来？</strong></p><p>如果读者看过笔者对《C++ Primer Plus》的更新的话，会发现其书中面向对象编程的所有程序都是<strong>严格将函数定义，函数声明和函数的调用分离开来</strong>，这样做确实会更麻烦，但会有如下的好处：</p><ol><li><p><strong>提高代码组织性</strong></p><ul><li><p><strong>函数声明</strong>（通常在头文件中）提供了函数的接口信息，包括函数名称、参数类型和返回类型。这让其他模块可以知道如何调用该函数，但不需要了解函数的实现细节。</p></li><li><p><strong>函数定义</strong>（通常在源文件中）包含了函数的具体实现，能够避免暴露内部细节。这样其他模块只需要知道函数的声明，而不需要关心其具体实现。</p></li></ul></li><li><p><strong>加速编译过程</strong></p><ul><li><p>如果将函数声明和定义都放在同一个文件中，每次编译时都需要重新编译实现部分，而声明通常是一个接口的约定，不会发生变化。将声明和定义分离后，头文件（声明部分）可以被多个源文件共享，而源文件（定义部分）则可以独立进行编译，减少编译时间。</p></li><li><p>修改一个函数的实现时，只有源文件需要重新编译，其他依赖该函数声明的源文件不需要重新编译，提升了代码的编译效率。</p></li></ul></li><li><p><strong>代码重用</strong></p><ul><li>分离声明和定义后，可以方便地将函数声明放入一个公共的头文件，供其他项目或模块复用，而实现部分可以放在不同的源文件中。这样，开发者可以重用已有的函数实现而不需要重复编写相同的代码。</li></ul></li><li><p><strong>增强封装性</strong></p><ul><li>把函数声明放在头文件中，定义放在源文件中，可以隐藏函数的实现细节，提供更强的封装性。这样可以避免函数的实现细节泄漏给调用者，确保模块的内聚性和独立性。</li></ul></li><li><p><strong>避免重复定义</strong></p><ul><li>如果函数声明和定义混合在一个文件中，并且这个文件被多个源文件包含，那么就可能导致函数的重复定义错误。将声明和定义分离后，使用 <code>#ifndef</code>、<code>#define</code> 等预处理指令来防止头文件被多次包含，从而避免这种错误。</li></ul></li><li><p><strong>接口与实现分离</strong></p><ul><li>分离函数声明和定义符合“接口与实现分离”的设计原则。这样可以让调用者关注函数的功能（通过接口）而不需要关注具体的实现细节，提高模块的独立性和灵活性。如果接口发生改变，函数实现可以保持不变，反之亦然。</li></ul></li></ol>          </div><p><strong>注意使用预编译命令，防止同一个头文件被重复定义。</strong></p><p><img src="/posts/CMake-tutorial1/multicompiling.png" alt="Several Optional Structures"></p><p>上图是三种可选的源代码放置方式。在接下来的讨论中，我们将默认选择第三种。（也是相对最复杂的一种）</p><h2 id="What-is-CMake"><a href="#What-is-CMake" class="headerlink" title="What is CMake"></a>What is CMake</h2><p>上文我们了解了C++的<strong>模块化开发</strong>的核心思想，但是有一个问题亟需被解决：</p><p><strong>如何让编译器编译那么多的文件并最后生成一个可执行文件？</strong></p><p>第一种方法是手动输入各种命令行，让程序按照顺序一个一个被编译，最后main函数被编译，生成一个可执行文件。但这种方法无疑是及其繁琐的，因为每一次编译都需要程序员手动输入，大大降低了开发的效率。</p><p>一种可行的方法就是自己写一个<strong>脚本文件</strong>，让程序<strong>自动化</strong>地按顺序编译对应的头文件和源代码文件。但是还有另外一个问题，你不想<strong>每写一个新的程序就重新先写一遍脚本</strong>，同时你希望你的脚本能够在<strong>全平台运行（Linux，Windows，macOS）</strong>。</p><p>在这样的背景下，<strong>CMake</strong>诞生了。</p><p>CMake 是个一个开源的跨平台自动化建构系统，用来管理软件建置的程序，并不依赖于某特定编译器，并可支持多层目录、多个应用程序与多个函数库。</p><p>CMake 通过使用简单的配置文件 CMakeLists.txt，自动生成不同平台的构建文件（如 Makefile、Ninja 构建文件、Visual Studio 工程文件等），简化了项目的编译和构建过程。</p><p>CMake 本身不是构建工具，而是生成构建系统的工具，它生成的构建系统可以使用不同的编译器和工具链。</p><h2 id="The-Basic-Usage-of-CMake"><a href="#The-Basic-Usage-of-CMake" class="headerlink" title="The Basic Usage of CMake"></a>The Basic Usage of CMake</h2><p><a href="https://blog.csdn.net/weiwei9363/article/details/109290252">推荐一篇写的很好的博客</a></p><p>接下来，我们以 <strong>IDE CLion</strong>为例，介绍在<strong>CLion</strong>中如何使用CMake构建工程文件。</p><blockquote><p>CLion的使用可自行查询，是一款非常好用的C++开发工具。</p></blockquote><p>在打开一个新项目的时候（C++ Executable），你应该会得到如下的界面：</p><p><img src="/posts/CMake-tutorial1/1.png" alt="Opening a new project"></p><p>我们会发现系统自动生成了一个CMakeList.txt的文本文件，<strong>这就是上文提到的自动化编译的脚本</strong>。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs makefile">cmake_minimum_required(VERSION 3.30)<br><br>project(untitled)<br><br>set(CMAKE_CXX_STANDARD 20)<br><br>add_executable(untitled main.cpp)<br><br></code></pre></td></tr></table></figure><p>接下来我们来逐行解释这四行代码：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile">cmake_minimum_required(VERSION 3.30)<br></code></pre></td></tr></table></figure><p>规定了CMake的最低版本，这里CLion自动生成，无需修改。</p><blockquote><p>如果你是直接安装了CMake，则需要自己创建一个文本文件并将内容输入，还是有一点工作量的，建议新手先使用CLion熟悉CMake的基本操作。</p></blockquote><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile">project(untitled)<br></code></pre></td></tr></table></figure><p>这行代码定义了 CMake 项目的名称。在这个例子中，项目名是 <code>untitled</code>。<code>project()</code> 命令是用来初始化 CMake 项目，并为后续的构建设置一些基本的项目属性（如名称、版本等）</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile">set(CMAKE_CXX_STANDARD 20)<br></code></pre></td></tr></table></figure><p>这行代码设置了 C++ 编译标准。在这个例子中，<code>CMAKE_CXX_STANDARD 20</code> 表示将 C++ 标准设为 C++20。CMake 会确保编译器使用符合 C++20 标准的特性和语法来编译源代码。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile">add_executable(untitled main.cpp)<br></code></pre></td></tr></table></figure><p>这行代码创建了一个可执行文件。<code>add_executable()</code> 命令告诉 CMake 将源文件（此处是 <code>main.cpp</code>）编译并链接成一个可执行文件。可执行文件的名称是 <code>untitled</code>，即编译后生成的程序文件名将是 <code>untitled</code>。</p><p>在点击CLion的<code>Build</code>后，找到文件夹的根目录，在文件夹<code>cmake-build-debug</code>中应该会生成一个可执行文件，说明程序已经编译完成。</p>]]></content>
    
    
    <categories>
      
      <category>Efficient Tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tutorial</tag>
      
      <tag>CMake</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Pointers-Arrays-and-Functions</title>
    <link href="/posts/Pointers-Arrays-and-Functions/"/>
    <url>/posts/Pointers-Arrays-and-Functions/</url>
    
    <content type="html"><![CDATA[<style>  html, body, .markdown-body {    font-family: Georgia, sans, serif;  }</style><h1 id="函数、数组和指针"><a href="#函数、数组和指针" class="headerlink" title="函数、数组和指针"></a>函数、数组和指针</h1><p>封面来源：<a href="https://knowyourmeme.com/photos/2214241-two-soyjaks-pointing">Pointers</a></p><blockquote><p>对不起真的太好笑了哈哈哈哈哈哈</p></blockquote><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>在C++中，函数，数组和指针是三个非常重要的概念，他们是C++实现许多高级功能（例如STL，OOP）的基石。同时，这三者之间又有着密不可分的联系。本文将主要从<strong>指针</strong>的角度出发，深入探究<strong>内存</strong>的本质，并在此基础之上探寻一些指针的高级功能。</p><blockquote><p>In C++, functions, arrays, and pointers are three essential concepts that serve as the cornerstone for implementing many advanced features, such as the Standard Template Library (STL) and Object-Oriented Programming (OOP). At the same time, these three elements are intricately interconnected. This article will primarily focus on <strong>pointers</strong>, delving deep into the essence of <strong>memory</strong> and, based on this foundation, exploring some advanced functionalities of pointers.</p></blockquote><h2 id="Before-the-article-begins"><a href="#Before-the-article-begins" class="headerlink" title="Before the article begins"></a>Before the article begins</h2><p>在文章开始前，请务必确保你已经掌握了<strong>指针，数组，函数三者分别的基本用法和一些初步的内存管理的知识</strong>。本文对相关基础代码不再过多赘述。</p><h2 id="Table-of-Contents"><a href="#Table-of-Contents" class="headerlink" title="Table of Contents"></a>Table of Contents</h2><ul><li>Pointers and Memories</li><li>Types of Pointers matters</li><li>Array of an Pointer and Pointer of an array</li><li>Rvalue</li><li>parameters in the main function</li><li>Lambda expression</li><li>Smart Pointer</li></ul><h2 id="Pointers-and-Memories"><a href="#Pointers-and-Memories" class="headerlink" title="Pointers and Memories"></a>Pointers and Memories</h2><p>在这一节，我们将从内存的视角重新认识指针。</p><p><strong>内存是什么？</strong>通俗来说，内存就是计算机<strong>存储数据的地方</strong>（这个定义非常的不严谨，甚至是一派胡言。但是这篇文章不会涉及硬件的太多知识，大家只要认识到这一步就行了）。第二个问题，<strong>如何存储数据？</strong>我们知道，数据存储的最小单元是<strong>位（bit）</strong>，代表一个二进制位。因此，我们会把内存进行<strong>编码</strong>，每一个bit都会拿到自己的编号，代表自己的具体位置。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> a=<span class="hljs-number">100</span>;<br>    <span class="hljs-type">int</span> *p=&amp;a;<br>    cout&lt;&lt;p;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//输出结果：0x61fe14(变量a的值，变量a的内存块第一个bit的编号，指针p所储存的值)</span><br></code></pre></td></tr></table></figure><blockquote><p>内存的硬件知识有兴趣的可以看这篇 <a href="https://blog.csdn.net/hellojoy/article/details/102933809">博客</a>，讲的比较清楚。</p></blockquote><p>接下来，回到指针。指针存储了一个<strong>变量</strong>的<strong>地址（内存）</strong>，这是指针的功能。但是，指针本身其实<strong>也是一种变量</strong>，在内存中有相对应的地址。一般来说，在64位的系统上，指针在内存中占<strong>8个字节（64bit）</strong>，在大小上和<code>unsigned long long</code>类型是一样的。（不过指针的值是十六进制的存储方式）</p><div class="note note-success">            <p><strong>因此，指针也是一种数据类型！和int，double，char等等一样，在内存中占一定空间，并且储存对应的值。（只不过指针储存的值就是内存的编号罢了）</strong></p>          </div><h2 id="Types-of-pointers-matters"><a href="#Types-of-pointers-matters" class="headerlink" title="Types of pointers matters"></a>Types of pointers matters</h2><p>指针有着<strong>解引用</strong>的操作，这是如何实现的？</p><p>我们来看下面的代码示范：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> num=<span class="hljs-number">4758843763784</span>;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span>* p1=&amp;num;<br>    <span class="hljs-type">int</span>* p2=(<span class="hljs-type">int</span>*)p1;<br>    <span class="hljs-type">double</span>* p3=(<span class="hljs-type">double</span>*)p1;<br>    <span class="hljs-type">char</span>* p4=(<span class="hljs-type">char</span>*)p2;<br>    <span class="hljs-type">float</span>* p5=(<span class="hljs-type">float</span>*)p1;<br>    <span class="hljs-comment">//对指针进行强制类型转换</span><br>    cout&lt;&lt;<span class="hljs-string">&quot;the size of each pointers:&quot;</span>&lt;&lt;endl;<br>    cout&lt;&lt;<span class="hljs-built_in">sizeof</span>(p1)&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;<span class="hljs-built_in">sizeof</span>(p2)&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;<span class="hljs-built_in">sizeof</span>(p3)&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;<span class="hljs-built_in">sizeof</span>(p4)&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;<span class="hljs-built_in">sizeof</span>(p5)&lt;&lt;endl;<br>    cout&lt;&lt;<span class="hljs-string">&quot;The memory:&quot;</span>&lt;&lt;endl;<br>    cout&lt;&lt;p1&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;p2&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;p3&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;(<span class="hljs-type">void</span>*)p4&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;p5&lt;&lt;endl;<br>    <span class="hljs-comment">//强制类型转换字符指针，否则会输出实际字符的值。</span><br>    cout&lt;&lt;<span class="hljs-string">&quot;Dereferencing Various Pointers&quot;</span>&lt;&lt;endl;<br>    cout&lt;&lt;*p1&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;*p2&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;*p3&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;*p4&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;*p5&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">the</span> size of each pointers:<br><span class="hljs-attribute">8</span> <span class="hljs-number">8</span> <span class="hljs-number">8</span> <span class="hljs-number">8</span> <span class="hljs-number">8</span><br><span class="hljs-attribute">The</span> memory:<br><span class="hljs-attribute">0x61fdf0</span> <span class="hljs-number">0</span>x61fdf0 <span class="hljs-number">0</span>x61fdf0 <span class="hljs-number">0</span>x61fdf0 <span class="hljs-number">0</span>x61fdf0<br><span class="hljs-attribute">Dereferencing</span> Various Pointers<br><span class="hljs-attribute">4758843763784</span> <span class="hljs-number">19999816</span> <span class="hljs-number">2</span>.<span class="hljs-number">35118</span>e-<span class="hljs-number">311</span> H <span class="hljs-number">3</span>.<span class="hljs-number">25415</span>e-<span class="hljs-number">38</span><br></code></pre></td></tr></table></figure><p>这个代码告诉了我们以下几点：</p><ul><li>指针在内存中存储的大小和<strong>指针指向数据类型的大小无关</strong>。（这一点很重要，稍后会解释）</li><li><strong>指向不同数据类型的指针，对于同一块内存解引用所得到的是完全不同的值</strong>！</li></ul><p>换句话说，指针的类型不会改变指针在内存中的存储和指针的值，只会影响指针在<strong>解引用时</strong>对内存的解释（即如何将0&#x2F;1的比特位转换成有效数据）。</p><p>因此，<strong>Types of pointers matters！</strong>实际上，如果不进行强制类型的转换，编译器面对不匹配的指针类型的时候也会报错。</p><p>以上两个章节是对指针和内存一些基础知识的回顾，接下来，我们将介绍<strong>数组，指针和函数</strong>三者在C++中一些高级的操作。</p><h2 id="Advanced-Technique-1-Array-of-pointers-and-Pointer-to-an-array"><a href="#Advanced-Technique-1-Array-of-pointers-and-Pointer-to-an-array" class="headerlink" title="Advanced Technique 1  Array of pointers and Pointer to an array"></a>Advanced Technique 1  Array of pointers and Pointer to an array</h2><p><strong>Definition</strong></p><p>数组指针：数组指针是<strong>指向数组的指针</strong>。</p><p>指针数组：是一个数组，数组的每个元素都是<strong>指针</strong>。</p><p>定义还是非常直白的，<strong>数组指针是指针，指针数组是数组。</strong></p><p><strong>Usage</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">int</span> (*ptr)[size];<br><span class="hljs-comment">//声明一个数组指针</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> *ptr[size];<br><span class="hljs-comment">//声明一个指针数组</span><br></code></pre></td></tr></table></figure><div class="note note-warning">            <p>在 C++ 中，<code>*</code> 运算符用于声明指针，而 <code>[]</code> 运算符用于声明数组。因为<strong>运算符的优先级不同</strong>（<code>[]</code> 运算符的优先级高于<code>*</code> 运算符），直接写 <code>*ptr[size]</code> 会让编译器理解为声明一个数组 <code>ptr</code>，每个元素是一个指向 <code>type</code> 的指针，而不是声明一个指向数组的指针。</p>          </div><p><strong>使用方法</strong></p><p>如果是数组指针：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> arr[<span class="hljs-number">3</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>    <span class="hljs-built_in">int</span> (*ptr)[<span class="hljs-number">3</span>] = &amp;arr;  <span class="hljs-comment">// ptr 是指向包含 3 个整数的数组的指针</span><br><br>    <span class="hljs-comment">// 访问数组元素</span><br>    std::cout &lt;&lt; (*ptr)[<span class="hljs-number">0</span>] &lt;&lt; std::endl;  <span class="hljs-comment">// 输出 1</span><br>    std::cout &lt;&lt; (*ptr)[<span class="hljs-number">1</span>] &lt;&lt; std::endl;  <span class="hljs-comment">// 输出 2</span><br>    std::cout &lt;&lt; (*ptr)[<span class="hljs-number">2</span>] &lt;&lt; std::endl;  <span class="hljs-comment">// 输出 3</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>ptr</code> 是指向一个包含 3 个整数的数组的指针。可以通过 <code>(*ptr)[i]</code> 的方式来访问数组元素。</p><p>如果是指针数组：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">1</span>, b = <span class="hljs-number">2</span>, c = <span class="hljs-number">3</span>;<br>    <span class="hljs-type">int</span> *ptr[<span class="hljs-number">3</span>];  <span class="hljs-comment">// ptr 是一个指针数组，包含 3 个指向整数的指针</span><br><br>    ptr[<span class="hljs-number">0</span>] = &amp;a;<br>    ptr[<span class="hljs-number">1</span>] = &amp;b;<br>    ptr[<span class="hljs-number">2</span>] = &amp;c;<br><br>    <span class="hljs-comment">// 访问数组元素</span><br>    std::cout &lt;&lt; *ptr[<span class="hljs-number">0</span>] &lt;&lt; std::endl;  <span class="hljs-comment">// 输出 1</span><br>    std::cout &lt;&lt; *ptr[<span class="hljs-number">1</span>] &lt;&lt; std::endl;  <span class="hljs-comment">// 输出 2</span><br>    std::cout &lt;&lt; *ptr[<span class="hljs-number">2</span>] &lt;&lt; std::endl;  <span class="hljs-comment">// 输出 3</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>ptr</code> 是一个包含 3 个指针的数组，每个指针指向不同的整数变量。通过 <code>*ptr[i]</code> 可以访问指针所指向的值。</p><p><strong>Applications</strong></p><p><strong>数组指针和指针数组都可以用来操作二维数组</strong>。</p><p>假设你有一个二维数组 <code>arr[3][4]</code>，它有 3 行 4 列，你可以通过以下两种方式来使用指针来访问它。</p><p>使用数组指针：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">int</span> (*ptr)[<span class="hljs-number">4</span>] = arr;  <span class="hljs-comment">// ptr 是指向数组中每一行的指针</span><br></code></pre></td></tr></table></figure><p>在这种情况下，<code>ptr</code> 是指向数组中每一行的指针。你可以通过 <code>ptr[i]</code> 来访问第 <code>i</code> 行的数据。</p><p>使用指针数组：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> *ptr[<span class="hljs-number">3</span>];  <span class="hljs-comment">// ptr 是一个指针数组，包含 3 个指向整数的指针</span><br>ptr[<span class="hljs-number">0</span>] = arr[<span class="hljs-number">0</span>];  <span class="hljs-comment">// ptr[0] 指向 arr 的第一行</span><br>ptr[<span class="hljs-number">1</span>] = arr[<span class="hljs-number">1</span>];  <span class="hljs-comment">// ptr[1] 指向 arr 的第二行</span><br>ptr[<span class="hljs-number">2</span>] = arr[<span class="hljs-number">2</span>];  <span class="hljs-comment">// ptr[2] 指向 arr 的第三行</span><br></code></pre></td></tr></table></figure><p>在这种情况下，<code>ptr</code> 是一个数组，每个元素都是一个指向数组行的指针。你可以通过 <code>ptr[i][j]</code> 来访问数组中的元素。</p><div class="note note-warning">            <p><strong>使用二级指针不可以直接指向一个二维数组！（因为类型并不匹配）</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> ** testptr=<span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-type">int</span> a[<span class="hljs-number">5</span>][<span class="hljs-number">5</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br>    testptr=a;  <span class="hljs-comment">//INVALID!</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">会报错：</span><br><span class="hljs-comment">testcode_1.cpp: In function &#x27;int main()&#x27;:</span><br><span class="hljs-comment">testcode_1.cpp:40:13: error: cannot convert &#x27;int [5][5]&#x27; to &#x27;int**&#x27; in assignment</span><br><span class="hljs-comment">     testptr=a;</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> ** testptr=<span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-built_in">int</span> (*testptr2)[<span class="hljs-number">5</span>]=<span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-type">int</span> a[<span class="hljs-number">5</span>][<span class="hljs-number">5</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br>    testptr2=a;<br>    cout&lt;&lt;*testptr2&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;**testptr2;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">程序可以正常运行：</span><br><span class="hljs-comment">输出结果：0x61fd90 0</span><br><span class="hljs-comment">解释：*testptr2代表数组指针的首元素的值，是一个指向int的指针，再解引用一次才得到a[0][0]的值。</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>但是可以使用<strong>动态内存分配</strong>的方式，也可以让一个二级指针与二维数组相关联。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> rows = <span class="hljs-number">3</span>;<br>    <span class="hljs-type">int</span> cols = <span class="hljs-number">4</span>;<br><br>    <span class="hljs-comment">// 使用 new 动态分配二维数组</span><br>    <span class="hljs-type">int</span> **arr = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>*[rows];  <span class="hljs-comment">// 创建一个指针数组，每个元素指向一行</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; rows; i++) &#123;<br>        arr[i] = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[cols];  <span class="hljs-comment">// 每一行分配 cols 个 int</span><br>    &#125;<br><br>    <span class="hljs-comment">// 给二维数组赋值</span><br>    arr[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    arr[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">2</span>;<br>    arr[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>] = <span class="hljs-number">3</span>;<br>    arr[<span class="hljs-number">0</span>][<span class="hljs-number">3</span>] = <span class="hljs-number">4</span>;<br><br>    arr[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">5</span>;<br>    arr[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">6</span>;<br>    arr[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>] = <span class="hljs-number">7</span>;<br>    arr[<span class="hljs-number">1</span>][<span class="hljs-number">3</span>] = <span class="hljs-number">8</span>;<br><br>    arr[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">9</span>;<br>    arr[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">10</span>;<br>    arr[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>] = <span class="hljs-number">11</span>;<br>    arr[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>] = <span class="hljs-number">12</span>;<br><br>    <span class="hljs-comment">// 使用二级指针访问元素</span><br>    std::cout &lt;&lt; arr[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] &lt;&lt; std::endl;  <span class="hljs-comment">// 输出 1</span><br>    std::cout &lt;&lt; arr[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>] &lt;&lt; std::endl;  <span class="hljs-comment">// 输出 7</span><br>    std::cout &lt;&lt; arr[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>] &lt;&lt; std::endl;  <span class="hljs-comment">// 输出 12</span><br><br>    <span class="hljs-comment">// 释放内存</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; rows; i++) &#123;<br>        <span class="hljs-keyword">delete</span>[] arr[i];  <span class="hljs-comment">// 释放每行的内存</span><br>    &#125;<br>    <span class="hljs-keyword">delete</span>[] arr;  <span class="hljs-comment">// 释放指针数组</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>          </div><h2 id="Advanced-Technique-2-Rvalue"><a href="#Advanced-Technique-2-Rvalue" class="headerlink" title="Advanced Technique 2 Rvalue"></a>Advanced Technique 2 Rvalue</h2><p><strong>左值（Lvalue）</strong>：可以表示一个对象的内存位置，并且可以获取其地址。通常是变量、对象或数组元素。</p><p><strong>右值（Rvalue）</strong>：通常是临时对象、字面值或表达式的结果。右值不能获取地址，代表的是一个不再需要的值。</p><p>例如在<code>x=y+z</code>这个表达式中，x,y,z都是变量（左值），在内存中有对应的空间，可以进行取址运算，但是编译器会先计算<code>y+z</code>的值（<strong>这是一个表达式是右值</strong>），将这个值赋给x后，y+z的结果就消失了。</p><p>C++3 中引用类型的变量只能是左值，除非声明的是 const 的引用，因而称之为左值引用。而C++11 引入了右值引用。右值引用以<code>&amp;&amp;</code>来表示，它的初值只能是一个将要被销毁的对象。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> x = <span class="hljs-number">10</span>; <br><span class="hljs-type">int</span> &amp;&amp;y = x + <span class="hljs-number">9</span>; <br><span class="hljs-type">int</span> &amp;&amp;z = <span class="hljs-number">8</span> * <span class="hljs-number">9</span> % <span class="hljs-number">4</span>;<br></code></pre></td></tr></table></figure><p>由于<strong>右值引用只能绑定到临时对象</strong>，即该对象将要被销毁，这意味着<strong>右值引用的变量可以接管所引用的对象的资源</strong>。定义 y 和 z 时都没有分配空间，而是接管了存储右边表达式计算结果的临时变量的空间。 y 接管了存放 x+9 结果值的临时变量的空间。 z 接管了存放 8 * 9 % 4 结果值的临时变量的空间。 </p><blockquote><p>右值引用相当于给一个即将要消亡的值续了一口命让他一直存在。</p></blockquote><p>通过右值引用，C++ 能够实现<strong>移动语义</strong>，即当对象的资源不再需要时，可以直接将资源“移动”到另一个对象中，而不是进行昂贵的拷贝操作。例如，<code>std::vector</code>和<code>std::string</code>等容器类会利用右值引用来避免不必要的内存分配和数据复制。</p><p><strong>移动语义的核心思想是避免不必要的拷贝</strong>。例如，当我们将一个临时对象传递给容器时，容器可以通过移动构造而不是拷贝构造来获取该对象的资源。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LargeObject</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span>* data;<br>    <br>    <span class="hljs-built_in">LargeObject</span>(<span class="hljs-type">int</span> value) : <span class="hljs-built_in">data</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(value)) &#123;&#125;<br>    ~<span class="hljs-built_in">LargeObject</span>() &#123; <span class="hljs-keyword">delete</span> data; &#125;<br>    <br>    <span class="hljs-comment">// 移动构造函数</span><br>    <span class="hljs-built_in">LargeObject</span>(LargeObject&amp;&amp; other) <span class="hljs-keyword">noexcept</span> : <span class="hljs-built_in">data</span>(other.data) &#123;<br>        other.data = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 移动赋值运算符</span><br>    LargeObject&amp; <span class="hljs-keyword">operator</span>=(LargeObject&amp;&amp; other) <span class="hljs-keyword">noexcept</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;other) &#123;<br>            <span class="hljs-keyword">delete</span> data;<br>            data = other.data;<br>            other.data = <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    vector&lt;LargeObject&gt; vec;<br>    vec.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">LargeObject</span>(<span class="hljs-number">42</span>));  <span class="hljs-comment">// 移动构造而非拷贝构造</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><p>简单来说，赋值构造函数是将对象的所有值拷贝一份赋给一个新的对象（无论是浅拷贝还是深拷贝），如果我只是希望实现值的移动，我还需要将原来的对象删除，这样的效率十分低下。有了移动语义（移动构造函数），我们便可以实现<strong>不拷贝直接实现值的转移</strong>。</p></blockquote><div class="note note-primary">            <h3 id="const引用和右值引用的区别"><a href="#const引用和右值引用的区别" class="headerlink" title="const引用和右值引用的区别"></a><code>const</code>引用和右值引用的区别</h3><p><strong>什么是 <code>const</code> 引用？</strong></p><p><code>const</code> 引用是一种引用类型，它允许<strong>你通过引用来访问对象，但不允许修改对象的值</strong>。通过 <code>const</code> 引用，你可以<strong>避免复制对象，同时确保引用的对象不会被修改</strong>。这通常用于传递大对象或需要确保数据不被修改的场合。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> Type&amp; ref = object;<br></code></pre></td></tr></table></figure><p>这里的 <code>const Type&amp;</code> 表示一个常量引用，<code>object</code> 可以是左值或右值。</p><blockquote><p><code>const</code>引用经常出现在函数参数的传递过程中，即保证了<strong>高效</strong>，又保证了安全性。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printValue</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; value)</span> </span>&#123;<br>    std::cout &lt;&lt; value &lt;&lt; std::endl;  <span class="hljs-comment">// 不能修改 value，因为它是 const 引用</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">10</span>;<br>    <span class="hljs-built_in">printValue</span>(x);  <span class="hljs-comment">// 传递左值</span><br>    <span class="hljs-built_in">printValue</span>(<span class="hljs-number">20</span>); <span class="hljs-comment">// 传递右值</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong><code>const</code> 引用与右值引用的区别：</strong></p><ol><li><strong><code>const</code> 引用</strong>：</li></ol><ul><li><strong>允许绑定左值和右值</strong>：<code>const</code> 引用可以<strong>绑定到左值或右值。对于右值，它的作用是将其延长生命周期，保证在函数中可以安全地使用。</strong>当我们希望通过引用传递一个右值并延长其生命周期时。通过 <code>const</code> 引用绑定到右值，可以避免不必要的拷贝，同时又不会修改该对象。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">processConstRef</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; vec)</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Size of vector (const ref): &quot;</span> &lt;&lt; vec.<span class="hljs-built_in">size</span>() &lt;&lt; std::endl;<br>    <span class="hljs-comment">// vec.push_back(4); // 错误！不能修改 const 引用绑定的对象</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 创建一个右值（临时对象）</span><br>    <span class="hljs-built_in">processConstRef</span>(std::vector&lt;<span class="hljs-type">int</span>&gt;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;);  <span class="hljs-comment">// 这里传递的是一个右值</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">输出：Size of vector (const ref): 3</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p><code>std::vector&lt;int&gt;{1, 2, 3}</code> 是一个 <strong>右值</strong>，它是一个临时对象。我们通过 <code>const std::vector&lt;int&gt;&amp;</code> 将右值传递给 <code>processConstRef</code> 函数，<code>const</code> 确保了我们在函数内部不能修改这个对象。在 <code>processConstRef</code> 中，<code>vec</code> 是一个 <strong><code>const</code> 引用</strong>，它绑定到这个临时对象上，并延长了这个临时对象的生命周期。这样，直到 <code>processConstRef</code> 函数结束，右值才会被销毁。</p><blockquote><p>如果删除const关键词，会有报错：<code>cannot bind non-const lvalue reference of type &#39;std::vector&lt;int&gt;&amp;&#39; to an rvalue of type &#39;std::vector&lt;int&gt;&#39;</code></p></blockquote><ol start="2"><li><strong>右值引用（<code>Type&amp;&amp;</code>）</strong>：</li></ol><ul><li><strong>只能绑定到右值</strong>：右值引用是 C++11 引入的，它主要用于“移动语义”，只能绑定到右值（例如临时对象、函数返回值等）。</li><li><strong>允许移动资源</strong>：右值引用允许转移对象的资源，避免不必要的复制（例如通过 <code>std::move</code>），提高性能。</li><li><strong>可以修改原对象</strong>：通过右值引用，我们可以修改被移动的对象（例如，置为空）。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">processConstRef</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; vec)</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Size of vector (const ref): &quot;</span> &lt;&lt; vec.<span class="hljs-built_in">size</span>() &lt;&lt; std::endl;<br>    <span class="hljs-comment">// vec.push_back(4); // 错误！不能修改 const 引用绑定的对象</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">processRvalueRef</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt;&amp;&amp; vec)</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Size of vector (rvalue ref): &quot;</span> &lt;&lt; vec.<span class="hljs-built_in">size</span>() &lt;&lt; std::endl;<br>    vec.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">4</span>);  <span class="hljs-comment">// 可以修改 vec，因为它是右值引用</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; vec1 = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br><br>    <span class="hljs-comment">// 使用 const 引用</span><br>    <span class="hljs-built_in">processConstRef</span>(vec1);  <span class="hljs-comment">// 传递左值</span><br><br>    <span class="hljs-comment">// 使用右值引用</span><br>    <span class="hljs-built_in">processRvalueRef</span>(std::<span class="hljs-built_in">move</span>(vec1));  <span class="hljs-comment">// 传递右值，vec1 资源被“移动”</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;vec1 size after move: &quot;</span> &lt;&lt; vec<span class="hljs-number">1.</span><span class="hljs-built_in">size</span>() &lt;&lt; std::endl;  <span class="hljs-comment">// vec1 现在为空</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">Size of vector (const ref): 3</span><br><span class="hljs-comment">Size of vector (rvalue ref): 3</span><br><span class="hljs-comment">vec1 size after move: 0</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><ol><li><strong><code>const&amp;</code> 引用</strong>：<code>processConstRef</code> 函数使用了 <code>const</code> 引用，它可以接收左值或右值，但无法修改 <code>vec</code> 的内容。</li><li><strong>右值引用（<code>&amp;&amp;</code>）</strong>：<code>processRvalueRef</code> 函数使用了右值引用，它只能接收右值，并且**可以修改 <code>vec</code>**（在本例中就是将数据“移动”到 <code>processRvalueRef</code>，并且通过 <code>push_back</code> 添加数据）。</li></ol><p><strong>总结一下，const引用和右值引用都可以绑定到右值上，但是两者的具体功能是不一样的：const引用重点在<code>const</code>上，而右值引用主要在移动语义等方面提供了更高的效率（避免了不必要的复制过程）。</strong></p>          </div><h2 id="Advanced-Technique-3-parameters-in-the-main-function"><a href="#Advanced-Technique-3-parameters-in-the-main-function" class="headerlink" title="Advanced Technique 3 parameters in the main function"></a>Advanced Technique 3 parameters in the main function</h2><p>在我们之前写的C++程序中，main函数是<strong>没有参数且返回值为0</strong>的，程序能够正常退出。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cout&lt;&lt;<span class="hljs-string">&quot;Hello world&quot;</span>&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-comment">//如果更改为return 1,那么程序仍能运行，但是会显示异常退出。</span><br></code></pre></td></tr></table></figure><p><strong>带参数的 <code>main</code> 函数</strong>：它接受命令行参数，允许程序在启动时接收外部输入。这种形式在处理用户输入或命令行参数时非常有用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span> </span>&#123;<br>    <span class="hljs-comment">// 程序代码</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><ol><li>**<code>argc</code>**：<code>argc</code> 是 <strong>argument count</strong>（参数计数）的缩写，表示传递给程序的命令行参数的个数。它的值至少为 1，因为程序名称本身也算作一个参数。</li><li>**<code>argv</code>**：<code>argv</code> 是 <strong>argument vector</strong>（参数向量）的缩写，它是一个指向字符指针数组的指针，数组的每个元素都是一个命令行参数（字符串）。<code>argv[0]</code> 通常是程序的名称，<code>argv[1]</code>、<code>argv[2]</code> 等依次是传递给程序的其他参数。</li></ol><p>例如下面的程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;程序名称: &quot;</span> &lt;&lt; argv[<span class="hljs-number">0</span>] &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;传递的参数个数: &quot;</span> &lt;&lt; argc - <span class="hljs-number">1</span> &lt;&lt; endl;  <span class="hljs-comment">// 不算程序名称</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;传递的参数: &quot;</span>;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; argc; ++i) &#123;  <span class="hljs-comment">// 从1开始，跳过程序名称</span><br>        cout &lt;&lt; argv[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li>**<code>argv[0]</code>**：程序名称，通常是执行程序时给出的文件名（例如 <code>&quot;./my_program&quot;</code>）。</li><li>**<code>argv[1]</code>、<code>argv[2]</code>**：这些是用户传递给程序的额外命令行参数。</li><li>**<code>argc</code>**：命令行参数的个数。对于上述程序，<code>argc</code> 至少为 1，因为 <code>argv[0]</code> 是程序名称。</li></ul><p><strong>编译与运行</strong>：</p><p>假设程序的文件名为 <code>program.cpp</code>，你可以按以下方式编译和运行它：</p><ol><li><p>编译程序：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">g++ program.cpp -o program<br></code></pre></td></tr></table></figure></li><li><p>运行程序，并传递一些命令行参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./program arg1 arg2 arg3<br></code></pre></td></tr></table></figure><p>输出将是：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">程序名称: ./program</span><br><span class="hljs-section">传递的参数个数: 3</span><br><span class="hljs-section">传递的参数: arg1 arg2 arg3</span><br></code></pre></td></tr></table></figure></li></ol><blockquote><p>在一些第三方库的使用中，带参数的main函数是非常强大的。</p></blockquote><h2 id="Advanced-Technique-4-Function-Pointer"><a href="#Advanced-Technique-4-Function-Pointer" class="headerlink" title="Advanced Technique 4 Function Pointer"></a>Advanced Technique 4 Function Pointer</h2><div class="note note-info">            <p><strong>问题引入：函数在内存中有自己的地址？</strong></p><p><strong>函数在内存中是有地址的</strong>。每个函数在程序加载到内存时，都会被分配一个唯一的内存地址，通常这个地址是指向函数代码开始位置的地址。在 C++ 中，我们可以通过<strong>函数指针</strong>来获取这个地址，从而间接地访问和调用函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myFunction</span><span class="hljs-params">()</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Hello, this is myFunction!&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cout &lt;&lt; (<span class="hljs-type">void</span>*)myFunction &lt;&lt; endl;  <span class="hljs-comment">// 输出函数的地址</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>函数名</strong>和数组名类似，代表了函数在内存中的地址。</p><blockquote><p>这里用到<code>(void*)</code>进行指针的强制类型转换，因为函数指针在cout中会被隐式转换成布尔值（即输出1）。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myFunction</span><span class="hljs-params">()</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Hello, this is myFunction!&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 获取函数的地址，并将其赋给一个函数指针</span><br>    <span class="hljs-built_in">void</span> (*funcPtr)() = myFunction;<br><br>    <span class="hljs-comment">// 通过函数指针调用函数</span><br>    <span class="hljs-built_in">funcPtr</span>();  <span class="hljs-comment">// 等同于 myFunction()</span><br>    <br>    <span class="hljs-comment">// 输出函数的内存地址</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;Function address: &quot;</span> &lt;&lt; (<span class="hljs-type">void</span>*)funcPtr &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">输出：</span><br><span class="hljs-comment">Hello, this is myFunction!</span><br><span class="hljs-comment">Function address: 0x401550</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>在上面的例子中，<code>funcPtr</code> 是一个指向 <code>myFunction</code> 函数的指针。<code>funcPtr</code> 存储了 <code>myFunction</code> 函数的内存地址。通过这个指针，我们可以调用函数。</p><ul><li><strong>函数名</strong>本身在 C++ 中是一个<strong>常量指针</strong>，指向函数的内存地址。例如，<code>myFunction</code> 就代表了 <code>myFunction</code> 函数的地址。</li><li>通过 <code>(void*)funcPtr</code> 可以将函数指针转为 <code>void*</code> 类型，进而打印出函数的内存地址。</li></ul>          </div><p>在 C++ 中，<strong>函数指针</strong>（Function Pointer）是一个指向函数的指针变量，类似于指向普通数据类型的指针。通过函数指针，我们可以动态地调用函数，而不需要直接调用它们的名称。函数指针在实现回调机制、事件驱动编程、以及某些设计模式（如策略模式）时非常有用。</p><ol><li><strong>函数指针的声明</strong></li></ol><p>函数指针的声明需要指定函数的返回类型、参数类型以及指针本身的类型。声明的形式与函数的声明很相似，关键在于指针的符号 <code>*</code> 和 <code>&amp;</code> 的使用。</p><p>假设有一个返回 <code>int</code> 类型，参数为 <code>int</code> 和 <code>float</code> 的函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">my_function</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">float</span>)</span></span>;<br></code></pre></td></tr></table></figure><p>那么，指向该函数的函数指针应该这样声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">int</span> (*func_ptr)(<span class="hljs-type">int</span>, <span class="hljs-type">float</span>);<br></code></pre></td></tr></table></figure><ul><li><code>int (*func_ptr)(int, float)</code>：表示 <code>func_ptr</code> 是一个指向函数的指针，函数的返回类型是 <code>int</code>，参数类型是 <code>int</code> 和 <code>float</code>。</li><li><code>(*func_ptr)</code> 表示 <code>func_ptr</code> 是一个指针，指向的内容是一个函数。</li></ul><ol start="2"><li><strong>函数指针的初始化</strong></li></ol><p>函数指针可以通过将它指向某个具体的函数来初始化。你可以将函数名赋给函数指针，因为函数名本身就是指向函数的指针。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">my_function</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">float</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">int</span> (*func_ptr)(<span class="hljs-type">int</span>, <span class="hljs-type">float</span>);  <span class="hljs-comment">// 函数指针声明</span><br>    func_ptr = my_function;       <span class="hljs-comment">// 初始化指针，指向 my_function</span><br><br>    <span class="hljs-comment">// 通过函数指针调用函数</span><br>    <span class="hljs-type">int</span> result = <span class="hljs-built_in">func_ptr</span>(<span class="hljs-number">5</span>, <span class="hljs-number">3.2</span>); <span class="hljs-comment">// 等价于 my_function(5, 3.2)</span><br>    std::cout &lt;&lt; result &lt;&lt; std::endl;  <span class="hljs-comment">// 输出 8</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的代码中，<code>func_ptr</code> 是一个指向 <code>my_function</code> 函数的指针。通过 <code>func_ptr</code> 调用函数，功能与直接调用 <code>my_function</code> 一样。</p><ol start="3"><li><strong>通过函数指针调用函数</strong></li></ol><p>一旦函数指针被正确初始化，你可以使用该指针来调用函数。通过 <code>*</code> 解引用函数指针，然后传递参数来调用目标函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">int</span> (*func_ptr)(<span class="hljs-type">int</span>, <span class="hljs-type">float</span>);  <span class="hljs-comment">// 函数指针声明</span><br>func_ptr = my_function;       <span class="hljs-comment">// 函数指针初始化</span><br><br><span class="hljs-comment">// 使用函数指针调用函数</span><br><span class="hljs-type">int</span> result = (*func_ptr)(<span class="hljs-number">10</span>, <span class="hljs-number">5.5</span>);  <span class="hljs-comment">// 等同于 my_function(10, 5.5)</span><br>std::cout &lt;&lt; <span class="hljs-string">&quot;Result: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;<br></code></pre></td></tr></table></figure><p>你也可以直接用 <code>func_ptr(10, 5.5)</code> 来调用函数，因为 <code>func_ptr</code> 本身就代表了一个函数。</p><ol start="4"><li><strong>函数指针数组</strong></li></ol><p>你可以创建一个指向多个函数的数组。这样的数组允许你根据索引动态选择不同的函数进行调用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123; <span class="hljs-keyword">return</span> a + b; &#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">subtract</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123; <span class="hljs-keyword">return</span> a - b; &#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">multiply</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123; <span class="hljs-keyword">return</span> a * b; &#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 创建函数指针数组，数组元素是指向函数的指针</span><br>    <span class="hljs-built_in">int</span> (*operations[<span class="hljs-number">3</span>])(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>) = &#123;add, subtract, multiply&#125;;<br><br>    <span class="hljs-comment">// 动态调用不同的操作</span><br>    <span class="hljs-type">int</span> x = <span class="hljs-number">5</span>, y = <span class="hljs-number">3</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Add: &quot;</span> &lt;&lt; operations[<span class="hljs-number">0</span>](x, y) &lt;&lt; endl;        <span class="hljs-comment">// add(5, 3)</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;Subtract: &quot;</span> &lt;&lt; operations[<span class="hljs-number">1</span>](x, y) &lt;&lt; endl;   <span class="hljs-comment">// subtract(5, 3)</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;Multiply: &quot;</span> &lt;&lt; operations[<span class="hljs-number">2</span>](x, y) &lt;&lt; endl;   <span class="hljs-comment">// multiply(5, 3)</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>operations</code> 是一个函数指针数组，其中每个元素都指向一个函数。你可以使用数组的索引来选择要调用的函数。</p><blockquote><p>可以用于菜单选择。</p></blockquote><div class="note note-warning">            <p>注意，函数指针数组要求<strong>数组中的每一个函数的返回值和特征表都要相同！</strong></p><ul><li>例如，如果修改add函数为<code>int add(int a, double b) { return a + b; }</code>，会产生报错：<code>invalid conversion from &#39;int (*)(int, double)&#39; to &#39;int (*)(int, int)&#39; [-fpermissive]</code></li><li>修改<code>int add(int a) { return a; }</code>，会产生报错：<code>invalid conversion from &#39;int (*)(int)&#39; to &#39;int (*)(int, int)&#39; [-fpermissive]</code></li><li>修改<code>double add(int a ,int b) { return a+b; }</code>，会产生报错：<code>invalid conversion from &#39;double (*)(int, int)&#39; to &#39;int (*)(int, int)&#39; [-fpermissive]</code><ul><li>你当然可以用指针的<strong>强制类型转换</strong>来实现这一点，但是这又会带来更大的隐患。</li></ul></li></ul>          </div><ol start="5"><li><strong>作为函数参数的函数指针</strong></li></ol><p>函数指针常常作为参数传递给其他函数，允许在运行时选择不同的函数进行调用。这是一种典型的<strong>回调机制</strong>。</p><p>示例：<strong>回调函数</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 定义一个函数类型</span><br><span class="hljs-keyword">using</span> FuncPtr = <span class="hljs-built_in">void</span>(*)(<span class="hljs-type">int</span>);  <span class="hljs-comment">// 函数指针类型，指向接受 int 参数并返回 void 的函数</span><br><br><span class="hljs-comment">// 函数 1</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print_square</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Square: &quot;</span> &lt;&lt; x * x &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">// 函数 2</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print_cube</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Cube: &quot;</span> &lt;&lt; x * x * x &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">// 一个函数，它接受一个函数指针作为参数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">process_number</span><span class="hljs-params">(<span class="hljs-type">int</span> num, FuncPtr callback)</span> </span>&#123;<br>    <span class="hljs-built_in">callback</span>(num);  <span class="hljs-comment">// 调用回调函数</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> num = <span class="hljs-number">5</span>;<br>    <br>    <span class="hljs-comment">// 使用不同的回调函数</span><br>    <span class="hljs-built_in">process_number</span>(num, print_square);  <span class="hljs-comment">// 调用 print_square</span><br>    <span class="hljs-built_in">process_number</span>(num, print_cube);    <span class="hljs-comment">// 调用 print_cube</span><br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>process_number</code> 函数接收一个函数指针 <code>callback</code>，它指向一个接受 <code>int</code> 参数并返回 <code>void</code> 的函数。你可以传递不同的函数来处理同一个数字，这样就实现了动态的行为。</p><p>举个实际的例子：<strong>函数指针和冒泡排序</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(T a[],<span class="hljs-type">int</span> size,<span class="hljs-type">bool</span>(*f)(T,T))</span> </span>&#123;<br>    <span class="hljs-type">bool</span> flag;<br>    <span class="hljs-type">int</span> i,j;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;size;++i) &#123;<br>        flag=<span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;size-i<span class="hljs-number">-1</span>;++j) &#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">f</span>(a[j],a[j<span class="hljs-number">+1</span>])) &#123;<br>                T temp=a[j];<br>                a[j]=a[j<span class="hljs-number">+1</span>];<br>                a[j<span class="hljs-number">+1</span>]=temp;<br>                flag=<span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(!flag)<span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">increaseInt</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<span class="hljs-keyword">return</span> x&gt;y;&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">decreaseInt</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<span class="hljs-keyword">return</span> x&lt;y;&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">increaseString</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* x,<span class="hljs-type">const</span> <span class="hljs-type">char</span>* y)</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">strcmp</span>(x,y)&gt;<span class="hljs-number">0</span>;&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">decreaseString</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* x,<span class="hljs-type">const</span> <span class="hljs-type">char</span>* y)</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">strcmp</span>(x,y)&lt;<span class="hljs-number">0</span>;&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> a[]=&#123;<span class="hljs-number">92</span>,<span class="hljs-number">73</span>,<span class="hljs-number">36</span>,<span class="hljs-number">63</span>,<span class="hljs-number">13</span>&#125;;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>*b[]=&#123;<span class="hljs-string">&quot;hsc&quot;</span>,<span class="hljs-string">&quot;cbs&quot;</span>,<span class="hljs-string">&quot;abx&quot;</span>,<span class="hljs-string">&quot;bcj&quot;</span>&#125;;<br>    <span class="hljs-comment">//cout&lt;&lt;strcmp(b[1],b[2]);</span><br>    <span class="hljs-built_in">sort</span>&lt;<span class="hljs-type">int</span>&gt;(a,<span class="hljs-number">5</span>,increaseInt);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++) cout&lt;&lt;a[i]&lt;&lt;<span class="hljs-string">&quot;\t&quot;</span>;<br>    cout&lt;&lt;endl;<br>    <span class="hljs-built_in">sort</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">char</span>*&gt;(b,<span class="hljs-number">4</span>,decreaseString);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++) cout&lt;&lt;b[i]&lt;&lt;<span class="hljs-string">&quot;\t&quot;</span>;<br>    cout&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">输出结果:</span><br><span class="hljs-comment">13      36      63      73      92</span><br><span class="hljs-comment">hsc     cbs     bcj     abx</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p><code>bool(*f)(T,T))</code>就是函数指针作为函数参数的用法（<strong>回调函数</strong>）。类似于<code>sort</code>函数的<code>compare</code>函数一样，在冒泡排序算法中，搭配不同的<code>bool(*f)(T,T))</code>可以实现自定义的排序顺序。</p><ol start="6"><li><strong>函数指针和 <code>const</code> 修饰符</strong></li></ol><p>如果你想确保函数指针指向的函数不被修改，可以使用 <code>const</code> 修饰符。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123; <span class="hljs-keyword">return</span> a + b; &#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">subtract</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123; <span class="hljs-keyword">return</span> a - b; &#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 定义一个常量函数指针，指向不修改函数的函数</span><br>    <span class="hljs-built_in">int</span> (*<span class="hljs-type">const</span> func_ptr)(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>) = add;<br>    <br>    <span class="hljs-comment">// func_ptr = subtract;  // 错误，不能改变指针的值</span><br>    <span class="hljs-type">int</span> result = <span class="hljs-built_in">func_ptr</span>(<span class="hljs-number">10</span>, <span class="hljs-number">5</span>);  <span class="hljs-comment">// 正确，调用 add</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;Result: &quot;</span> &lt;&lt; result &lt;&lt; endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这里，<code>func_ptr</code> 是一个常量函数指针，意味着它一旦指向 <code>add</code> 函数，就不能再改变指向其他函数。</p><h2 id="Advanced-Technique-5-Lambda-expression"><a href="#Advanced-Technique-5-Lambda-expression" class="headerlink" title="Advanced Technique 5 Lambda expression"></a>Advanced Technique 5 Lambda expression</h2><p>C++ 中的 <strong>Lambda 表达式</strong> 是一种轻量级的匿名函数，它允许在代码中定义和使用一个函数对象，而不需要事先为其命名。Lambda 表达式使得 C++ 代码更加简洁和灵活，特别是在需要临时传递函数作为参数时非常有用。</p><p>C++11 引入了 Lambda 表达式，基本语法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">[捕获列表](参数列表) -&gt; 返回类型 &#123; 函数体 &#125;<br></code></pre></td></tr></table></figure><p>其中各部分的含义如下：</p><ul><li><strong>捕获列表</strong>（Capture list）：指定 Lambda 表达式访问外部变量的方式。捕获列表允许 Lambda 表达式“捕获”<strong>外部作用域中的变量</strong>，并可以在函数体内使用这些变量。</li><li><strong>参数列表</strong>（Parameter list）：指定 Lambda 表达式的输入参数，类似于普通函数的参数。</li><li><strong>返回类型</strong>（Return type）：指定 Lambda 表达式的返回类型，可以省略，编译器会根据返回值推导类型。</li><li><strong>函数体</strong>（Function body）：Lambda 表达式的实际代码，包含执行的语句。</li></ul><ol><li><strong>捕获列表（Capture List）</strong></li></ol><p>捕获列表定义了 Lambda 表达式如何访问外部作用域的变量。捕获方式有以下几种：</p><ul><li><p>按值捕获：捕获外部变量的副本</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">[x] &#123; std::cout &lt;&lt; x; &#125;  <span class="hljs-comment">// 捕获 x 的副本</span><br></code></pre></td></tr></table></figure></li><li><p>按引用捕获：捕获外部变量的引用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">[&amp;x] &#123; x = <span class="hljs-number">10</span>; &#125;  <span class="hljs-comment">// 捕获 x 的引用，允许修改 x</span><br></code></pre></td></tr></table></figure></li><li><p>捕获所有变量按值：捕获所有外部变量的副本</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">[=] &#123; std::cout &lt;&lt; x &lt;&lt; y; &#125;  <span class="hljs-comment">// 捕获所有外部变量的副本</span><br></code></pre></td></tr></table></figure></li><li><p>捕获所有变量按引用：捕获所有外部变量的引用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">[&amp;] &#123; x = <span class="hljs-number">10</span>; y = <span class="hljs-number">20</span>; &#125;  <span class="hljs-comment">// 捕获所有外部变量的引用</span><br></code></pre></td></tr></table></figure></li><li><p>按值和引用混合捕获：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">[=, &amp;x] &#123; x = <span class="hljs-number">10</span>; &#125;  <span class="hljs-comment">// 捕获所有外部变量按值，x 按引用</span><br></code></pre></td></tr></table></figure></li></ul><ol start="2"><li><strong>参数列表</strong></li></ol><p>Lambda 表达式的参数列表与普通函数类似，可以定义输入参数。如果没有参数，参数列表可以省略。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">[]() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Hello, World!&quot;</span> &lt;&lt; std::endl; &#125;<br></code></pre></td></tr></table></figure><ol start="3"><li><strong>返回类型</strong></li></ol><p><strong>Lambda 表达式的返回类型通常可以省略</strong>，编译器会根据函数体中的返回语句推导出返回类型。如果需要显式指定返回类型，可以使用 <code>-&gt;</code> 语法。</p><blockquote><p>这怎么那么像python的语法？？？</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> lambda = []() -&gt; <span class="hljs-type">int</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>; &#125;;<br>std::cout &lt;&lt; <span class="hljs-built_in">lambda</span>() &lt;&lt; std::endl;  <span class="hljs-comment">// 输出 42</span><br></code></pre></td></tr></table></figure><ol start="4"><li><strong>Lambda 表达式的实际例子</strong></li></ol><ul><li>按值捕获</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">auto</span> lambda = [x]() &#123; cout &lt;&lt; <span class="hljs-string">&quot;x = &quot;</span> &lt;&lt; x &lt;&lt; endl; &#125;;<br>    <span class="hljs-built_in">lambda</span>();  <span class="hljs-comment">// 输出: x = 5</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的 Lambda 捕获了变量 <code>x</code> 的值，并输出它。</p><ul><li>按引用捕获</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">auto</span> lambda = [&amp;x]() &#123; x = <span class="hljs-number">10</span>; &#125;;  <span class="hljs-comment">// 捕获 x 的引用</span><br>    <span class="hljs-built_in">lambda</span>();<br>    cout &lt;&lt; <span class="hljs-string">&quot;x = &quot;</span> &lt;&lt; x &lt;&lt; endl;  <span class="hljs-comment">// 输出: x = 10</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码通过按引用捕获，Lambda 表达式能够修改外部变量 <code>x</code>。</p><ul><li>带参数的 Lambda</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> add = [](<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b) &#123; <span class="hljs-keyword">return</span> a + b; &#125;;<br>    cout &lt;&lt; <span class="hljs-built_in">add</span>(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>) &lt;&lt; endl;  <span class="hljs-comment">// 输出: 8</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这是一个带有两个整型参数的 Lambda 表达式，用于计算两个数的和。</p><ol start="5"><li><strong>Lambda 表达式的高级用法</strong></li></ol><ul><li>Lambda <strong>表达式作为参数</strong></li></ul><p>Lambda 表达式常用于 STL 算法中作为参数，尤其是像 <code>std::sort</code> 这样的函数，它允许你提供自定义的排序规则。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; vec = &#123;<span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>&#125;;<br>    <br>    <span class="hljs-comment">// 使用 Lambda 表达式自定义排序规则</span><br>    <span class="hljs-built_in">sort</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b) &#123; <span class="hljs-keyword">return</span> a &gt; b; &#125;);<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> val : vec) &#123;<br>        cout &lt;&lt; val &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <span class="hljs-comment">// 输出: 5 4 3 2 1</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，Lambda 表达式 <code>[ ]</code> 用于指定排序的比较规则。</p><ul><li><strong>使用 <code>mutable</code> 修改捕获变量</strong></li></ul><p>默认情况下，捕获的变量在 Lambda 中是 <strong>常量</strong>，不能修改。如果你需要在 Lambda 内部修改捕获的变量，可以使用 <code>mutable</code> 关键字。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">auto</span> lambda = [x]() <span class="hljs-keyword">mutable</span> &#123; x = <span class="hljs-number">10</span>; cout &lt;&lt; <span class="hljs-string">&quot;x inside lambda: &quot;</span> &lt;&lt; x &lt;&lt; endl; &#125;;<br>    <span class="hljs-built_in">lambda</span>();<br>    cout &lt;&lt; <span class="hljs-string">&quot;x outside lambda: &quot;</span> &lt;&lt; x &lt;&lt; endl;  <span class="hljs-comment">// 输出: x outside lambda: 5</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用 <code>mutable</code> 后，捕获的变量 <code>x</code> 在 Lambda 内部变成可修改的副本，但是外部的 <code>x</code> 不会受到影响。</p><ul><li><strong>返回 Lambda 表达式</strong></li></ul><p><strong>Lambda 表达式也可以返回 Lambda</strong>。例如，返回一个根据输入参数变化的 Lambda：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">createAdder</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> [x](<span class="hljs-type">int</span> y) &#123; <span class="hljs-keyword">return</span> x + y; &#125;;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> add5 = <span class="hljs-built_in">createAdder</span>(<span class="hljs-number">5</span>);<br>    <span class="hljs-comment">//在这里add5是一个函数指针，相当于createAdder的返回值，可以继续进行操作。</span><br>    cout &lt;&lt; <span class="hljs-built_in">add5</span>(<span class="hljs-number">10</span>) &lt;&lt; endl;  <span class="hljs-comment">// 输出: 15</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>createAdder</code> 返回一个 Lambda 表达式，它会将传入的 <code>x</code> 与每次调用时传入的 <code>y</code> 相加。</p><ol start="6"><li><strong>总结</strong></li></ol><ul><li><strong>Lambda 表达式</strong> 是 C++ 中一种轻量级的匿名函数，可以捕获外部变量并在局部上下文中使用。</li><li>捕获方式有按值捕获、按引用捕获、按值或按引用混合捕获等。</li><li>Lambda 表达式可以带有参数和返回类型，可以通过 <code>mutable</code> 关键字修改捕获的外部变量。</li><li>Lambda 表达式常用于 STL 算法、回调函数、事件处理等场景，提供了更高的灵活性和代码简洁性。</li></ul><h2 id="Advanced-Technique-6-Smart-Pointer"><a href="#Advanced-Technique-6-Smart-Pointer" class="headerlink" title="Advanced Technique 6 Smart Pointer"></a>Advanced Technique 6 Smart Pointer</h2><p>在之前的学习过程中我们知道，使用<code>new</code>命令动态分配内存，需要手动<code>delete</code>来释放分配在<strong>堆</strong>的内存，否则会发生严重的内存泄漏，导致程序崩溃。在C++98中，**引入了<code>auto_ptr</code>，来自动实现内存回收的功能（所以被称作智能指针）。但是，在C++11的新标准中，<code>auto_ptr</code>被摒弃，取而代之的是三种新的智能指针：<code>unique_ptr</code>,<code>shared_ptr</code>,<code>weak_ptr</code>**。</p><h3 id="为什么需要智能指针"><a href="#为什么需要智能指针" class="headerlink" title="为什么需要智能指针"></a>为什么需要智能指针</h3><p>​我们希望智能指针能够在程序终止时<strong>自动回收为指针所分配的内存而非手动删除</strong>，看下面的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cassert&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">testfunction</span><span class="hljs-params">(string &amp;str,<span class="hljs-type">int</span> n)</span></span>&#123;<br>    str=<span class="hljs-string">&quot;Hello world&quot;</span>;<br>    string *pd=<span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>(str);<br>    <span class="hljs-built_in">assert</span>(n==<span class="hljs-number">0</span>);<br>    pd=&amp;str;<br>    cout&lt;&lt;pd&lt;&lt;endl;<br>    cout&lt;&lt;*pd&lt;&lt;endl;<br>    cout&lt;&lt;&amp;str&lt;&lt;endl&lt;&lt;str&lt;&lt;endl;<br>    <span class="hljs-keyword">delete</span> pd;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    string str;<br>    <span class="hljs-built_in">testfunction</span>(str,<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-number">0x61fd20</span><br>Hello world<br><span class="hljs-number">0x61fd20</span><br>Hello world<br></code></pre></td></tr></table></figure><p>​我们不难发现<strong>手动删除内存是一件效率十分低下的事情！</strong>，如果我没有正确的通过<code>assert</code>断言，我就不会执行<code>delete</code>语句实现内存的回收。因此，<strong>我们希望pd指针有着更强大的功能——在程序终止时自动回收</strong>。如何在类中实现对象的回收与销毁？<strong>析构函数！</strong></p><blockquote><p><code>auto_ptr</code>的类定义(确实是有析构函数的！)</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Tp&gt;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">auto_ptr</span><br>    &#123;<br>    <span class="hljs-keyword">private</span>:<br>      _Tp* _M_ptr;<br>        <span class="hljs-comment">//声明了一个私有成员变量 _M_ptr，它是一个指向模板类型 _Tp 的指针，用于存储 auto_ptr 管理的对象的地址</span><br>    <span class="hljs-keyword">public</span>:<br>      <span class="hljs-comment">/// The pointed-to type.</span><br>      <span class="hljs-keyword">typedef</span> _Tp element_type;<br>      <span class="hljs-comment">//定义了一个类型别名 element_type，它是 _Tp 的同义词，用于表示 auto_ptr 所管理的对象类型。</span><br>      <span class="hljs-function"><span class="hljs-keyword">explicit</span></span><br><span class="hljs-function">      <span class="hljs-title">auto_ptr</span><span class="hljs-params">(element_type* __p = <span class="hljs-number">0</span>)</span> <span class="hljs-title">throw</span><span class="hljs-params">()</span> : _M_ptr(__p) &#123;</span> &#125;<br>      <span class="hljs-comment">/*</span><br><span class="hljs-comment">        这是 auto_ptr 的构造函数：</span><br><span class="hljs-comment">          explicit 关键字意味着这个构造函数不能用于隐式类型转换。</span><br><span class="hljs-comment">          构造函数接受一个指向 element_type 类型的指针  __p 作为参数，默认值为 0（即 NULL）。</span><br><span class="hljs-comment">          throw() 表示这个构造函数不会抛出异常（在C++98中，异常规范已弃用）。</span><br><span class="hljs-comment">          构造函数体通过初始化列表将传入的指针赋值给 _M_ptr</span><br><span class="hljs-comment">          </span><br><span class="hljs-comment">      */</span><br>      ~<span class="hljs-built_in">auto_ptr</span>() &#123; <span class="hljs-keyword">delete</span> _M_ptr; &#125;<br>        <span class="hljs-comment">//当 auto_ptr 对象被销毁时，析构函数被调用。</span><br>        <span class="hljs-comment">//它使用 delete 来释放 _M_ptr 所指向的内存，从而自动管理资源。</span><br>      <span class="hljs-comment">//other members.............</span><br>    &#125;;<br></code></pre></td></tr></table></figure><h3 id="auto-ptr"><a href="#auto-ptr" class="headerlink" title="auto_ptr"></a><code>auto_ptr</code></h3><p>​这就是<code>auto_ptr</code>的基本思想，<strong>通过析构函数在指针结束其生命周期的时候自动释放内存</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">auto_ptr&lt;<span class="hljs-type">double</span>&gt; <span class="hljs-title">pd</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">double</span>)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>智能指针和普通的动态内存分配在使用上还有哪些差异？</strong>请看下面的两组程序的对比：在程序中实现了相同的<code>MyClass</code>类，包含数据成员<code>value</code>以及对应的构造函数，析构函数和<code>showMessage()</code>函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs Cpp"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span>  <span class="hljs-comment">// 引入 auto_ptr 需要的头文件</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>    <span class="hljs-type">int</span> value;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">int</span> n):<span class="hljs-built_in">value</span>(n)&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;MyClass constructor&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    ~<span class="hljs-built_in">MyClass</span>() &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;MyClass destructor&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showMessage</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Hello from MyClass!&quot;</span> &lt;&lt; std::endl;<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;The value is&quot;</span>&lt;&lt;value&lt;&lt;std::endl;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demonotAutoPtr</span><span class="hljs-params">()</span> </span>&#123;<br>    MyClass* ptr1=<span class="hljs-keyword">new</span> <span class="hljs-built_in">MyClass</span>(<span class="hljs-number">4</span>);<br>    ptr1-&gt;<span class="hljs-built_in">showMessage</span>();<br>    MyClass *ptr2;<br>    ptr2=ptr1;<br>    ptr2-&gt;<span class="hljs-built_in">showMessage</span>();<br>    ptr1-&gt;<span class="hljs-built_in">showMessage</span>();<br>    <span class="hljs-keyword">delete</span> ptr1;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">demonotAutoPtr</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">MyClass constructor</span><br><span class="hljs-comment">Hello from MyClass!</span><br><span class="hljs-comment">The value is4</span><br><span class="hljs-comment">Hello from MyClass!</span><br><span class="hljs-comment">The value is4</span><br><span class="hljs-comment">Hello from MyClass!</span><br><span class="hljs-comment">The value is4</span><br><span class="hljs-comment">MyClass destructor</span><br><span class="hljs-comment">(这里程序正常运行并且正常退出)</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span>  <span class="hljs-comment">// 引入 auto_ptr 需要的头文件</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>    <span class="hljs-type">int</span> value;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">int</span> n):<span class="hljs-built_in">value</span>(n)&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;MyClass constructor&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    ~<span class="hljs-built_in">MyClass</span>() &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;MyClass destructor&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showMessage</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Hello from MyClass!&quot;</span> &lt;&lt; std::endl;<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;The value is&quot;</span>&lt;&lt;value&lt;&lt;std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demoAutoPtr</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 创建一个 auto_ptr，并初始化为指向动态分配的 MyClass 对象</span><br>    <span class="hljs-function">std::auto_ptr&lt;MyClass&gt; <span class="hljs-title">ptr1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> MyClass(<span class="hljs-number">4</span>))</span></span>;<br>    ptr1-&gt;<span class="hljs-built_in">showMessage</span>();  <span class="hljs-comment">// 使用 auto_ptr 指向的对象</span><br><br>    <span class="hljs-comment">// 将 ptr1 转移给 ptr2，这样 ptr1 变为空，ptr2 拥有 MyClass 的所有权</span><br>    std::auto_ptr&lt;MyClass&gt; ptr2 = ptr1;<br>    <span class="hljs-comment">// 此时 ptr1 不再持有对象，只有 ptr2 拥有 MyClass 对象</span><br>    ptr2-&gt;<span class="hljs-built_in">showMessage</span>();<br>    ptr1-&gt;<span class="hljs-built_in">showMessage</span>();<br>    <span class="hljs-comment">// ptr2 会在超出作用域时自动销毁，并调用 MyClass 的析构函数</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">demoAutoPtr</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">MyClass constructor</span><br><span class="hljs-comment">Hello from MyClass!</span><br><span class="hljs-comment">The value is 4</span><br><span class="hljs-comment">Hello from MyClass!</span><br><span class="hljs-comment">The value is 4</span><br><span class="hljs-comment">Hello from MyClass!</span><br><span class="hljs-comment">The value is</span><br><span class="hljs-comment">(最后程序会异常退出)</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>通过对比可以发现，两者唯一的不同是在函数<code>demoAutoPtr()</code>中一个使用<strong>动态内存</strong>，另一个使用<strong>智能指针</strong>。两者实现的操作都是一样的，创建<code>ptr1</code>后将<code>ptr1</code>的值转移给<code>ptr2</code>。但是程序在最后调用<code>ptr1-&gt;showMessage();</code>这条语句的时候出现了差异：<strong>基于动态内存实现的指针保留的原来的value值，但是基于智能指针实现的指针在此处value值丢失了，导致程序的异常终止。</strong></p><p>在 <code>auto_ptr</code> 的赋值操作中，资源的所有权被转移给了目标 <code>auto_ptr</code>，而源 <code>auto_ptr</code> 被置为空。具体来说，这种行为是通过以下方式实现的：</p><ol><li>当你将一个 <code>auto_ptr</code> 赋值给另一个 <code>auto_ptr</code> 时，源对象的指针会被转移到目标对象，而源对象的指针则被置为 <code>nullptr</code>。这种行为是通过“<strong>转移所有权</strong>”来避免多次删除相同的资源。</li><li>这种转移的目的是确保动态分配的内存在程序结束时被释放，但是如果没有进行所有权转移，可能会发生<strong>双重删除</strong>的错误。</li></ol><p>因此，我们可以发现，在智能指针的使用上，仅仅依靠<code>auto_ptr</code>似乎是不够的：上文的<strong>转移所有权</strong>的特性确实能够避免内存泄漏的问题出现，但是我们有时也需要进行<strong>指针拷贝</strong>的操作。实际上，在C++的新标准中，**<code>auto_ptr</code>已经被弃用**，主要有以下原因：</p><ol><li><p><strong>不安全的转移语义</strong>： <code>auto_ptr</code> 在赋值或传递给另一个 <code>auto_ptr</code> 时，进行的是“<strong>浅拷贝</strong>”，即将指针转移到另一个 <code>auto_ptr</code>，并将原来的 <code>auto_ptr</code> 设置为 <code>nullptr</code>。这种行为会导致潜在的资源管理问题，尤其是多个 <code>auto_ptr</code> 管理同一内存时，容易发生重复释放内存。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">auto_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">10</span>))</span></span>;<br>auto_ptr&lt;<span class="hljs-type">int</span>&gt; p2 = p1;  <span class="hljs-comment">// 现在 p1 为空，p2 拥有该内存</span><br>std::cout &lt;&lt; *p2 &lt;&lt; std::endl;  <span class="hljs-comment">// p2 仍然有效，但 p1 不再持有该内存</span><br></code></pre></td></tr></table></figure></li><li><p><strong>不一致的所有权语义</strong>： <code>auto_ptr</code> 的所有权语义比较模糊。它使得传递和返回指针时，所有权的转移比较不直观，容易造成内存管理的混乱。</p></li><li><p><strong>不支持移动语义</strong>： <code>auto_ptr</code> 不支持现代 C++ 中引入的“移动语义”。C++11 引入了 <code>std::move</code> 和 <code>std::unique_ptr</code>，使得可以安全高效地转移所有权，而无需担心意外的复制和删除。</p></li></ol><h3 id="other-smart-pointers"><a href="#other-smart-pointers" class="headerlink" title="other smart pointers"></a>other smart pointers</h3><p>现代 C++ 中有<strong>三种常见的智能指针</strong>，它们分别是：</p><ol><li><strong><code>std::unique_ptr</code><strong>：用于表示</strong>独占所有权</strong>。每个 <code>unique_ptr</code> 只能有一个所有者，当它超出作用域时会自动释放资源。</li><li><strong><code>std::shared_ptr</code><strong>：用于表示</strong>共享所有权</strong>。多个 <code>shared_ptr</code> 可以共享同一块资源，当所有指向该资源的 <code>shared_ptr</code> 都被销毁时，资源才会被释放。</li><li>**<code>std::weak_ptr</code>**：用于表示对某个资源的“非拥有”引用。它不会影响资源的生命周期，但可以用来观察 <code>shared_ptr</code> 所管理的对象，避免循环引用。</li></ol><blockquote><p>智能指针的关键在于对<strong>内存地址的所有权</strong>进行自动管理。</p></blockquote><h4 id="1-std-unique-ptr"><a href="#1-std-unique-ptr" class="headerlink" title="1. std::unique_ptr"></a>1. <strong><code>std::unique_ptr</code></strong></h4><p><code>std::unique_ptr</code> 是 C++11 引入的，适用于确保资源的独占所有权。<strong>一个 <code>unique_ptr</code> 不能被复制，只能被移动</strong>。</p><div class="note note-info">            <p><strong>就相当于原来的<code>auto_ptr</code>一样。</strong></p>          </div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyClass</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;MyClass constructor&quot;</span> &lt;&lt; std::endl; &#125;<br>    ~<span class="hljs-built_in">MyClass</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;MyClass destructor&quot;</span> &lt;&lt; std::endl; &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showMessage</span><span class="hljs-params">()</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Hello from MyClass!&quot;</span> &lt;&lt; std::endl; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demoUniquePtr</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 创建一个 unique_ptr，指向 MyClass 对象</span><br>    std::unique_ptr&lt;MyClass&gt; ptr1 = std::<span class="hljs-built_in">make_unique</span>&lt;MyClass&gt;();<br>    ptr1-&gt;<span class="hljs-built_in">showMessage</span>();<br><br>    <span class="hljs-comment">// 转移所有权</span><br>    std::unique_ptr&lt;MyClass&gt; ptr2 = std::<span class="hljs-built_in">move</span>(ptr1);  <span class="hljs-comment">// 这里发生了所有权的转移</span><br>    <span class="hljs-keyword">if</span> (!ptr1) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;ptr1 is now empty (nullptr)&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    ptr2-&gt;<span class="hljs-built_in">showMessage</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">demoUniquePtr</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs delphi">MyClass <span class="hljs-function"><span class="hljs-keyword">constructor</span></span><br><span class="hljs-function"><span class="hljs-title">Hello</span> <span class="hljs-title">from</span> <span class="hljs-title">MyClass</span>!</span><br><span class="hljs-function"><span class="hljs-title">ptr1</span> <span class="hljs-title">is</span> <span class="hljs-title">now</span> <span class="hljs-title">empty</span> <span class="hljs-params">(nullptr)</span></span><br><span class="hljs-function"><span class="hljs-title">Hello</span> <span class="hljs-title">from</span> <span class="hljs-title">MyClass</span>!</span><br><span class="hljs-function"><span class="hljs-title">MyClass</span> <span class="hljs-title">destructor</span></span><br></code></pre></td></tr></table></figure><h4 id="2-std-shared-ptr"><a href="#2-std-shared-ptr" class="headerlink" title="2. std::shared_ptr"></a>2. <strong><code>std::shared_ptr</code></strong></h4><p><code>std::shared_ptr</code> 是 C++11 引入的，用于表示共享所有权。<strong>多个 <code>shared_ptr</code> 可以同时管理一个资源</strong>，资源只有在所有 <code>shared_ptr</code> 被销毁时才会释放。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>    <span class="hljs-type">int</span> value;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">int</span> n):<span class="hljs-built_in">value</span>(n) &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;MyClass constructor&quot;</span> &lt;&lt; std::endl; &#125;<br>    ~<span class="hljs-built_in">MyClass</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;MyClass destructor&quot;</span> &lt;&lt; std::endl; &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showMessage</span><span class="hljs-params">()</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Hello from MyClass!&quot;</span> &lt;&lt; std::endl; &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showValue</span><span class="hljs-params">()</span></span>&#123; std::cout&lt;&lt;<span class="hljs-string">&quot;the value: &quot;</span>&lt;&lt;value&lt;&lt;std::endl;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modifyValue</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123; value=n;&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demoSharedPtr</span><span class="hljs-params">()</span> </span>&#123;<br>    std::shared_ptr&lt;MyClass&gt; ptr1 = std::<span class="hljs-built_in">make_shared</span>&lt;MyClass&gt;(<span class="hljs-number">4</span>);<br>    ptr1-&gt;<span class="hljs-built_in">showMessage</span>();<br><br>    <span class="hljs-comment">// 创建第二个 shared_ptr，指向同一资源</span><br>    std::shared_ptr&lt;MyClass&gt; ptr2 = ptr1;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Use count: &quot;</span> &lt;&lt; ptr<span class="hljs-number">1.</span><span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl;  <span class="hljs-comment">// 输出共享计数</span><br><br>    ptr1-&gt;<span class="hljs-built_in">showValue</span>();<br>    ptr2-&gt;<span class="hljs-built_in">showValue</span>();<br>    <br>    ptr1-&gt;<span class="hljs-built_in">modifyValue</span>(<span class="hljs-number">3</span>);<br>    ptr2-&gt;<span class="hljs-built_in">showValue</span>();<br><br>    ptr2-&gt;<span class="hljs-built_in">modifyValue</span>(<span class="hljs-number">2</span>);<br>    ptr1-&gt;<span class="hljs-built_in">showValue</span>();<br>    <span class="hljs-comment">// ptr2 和 ptr1 都指向同一对象，资源不会被释放直到两个都超出作用域</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">demoSharedPtr</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs powershell">MyClass constructor<br>Hello from MyClass!<br>Use count: <span class="hljs-number">2</span><br>the value: <span class="hljs-number">4</span><br>the value: <span class="hljs-number">4</span><br>the value: <span class="hljs-number">3</span><br>the value: <span class="hljs-number">2</span><br>MyClass destructor<br></code></pre></td></tr></table></figure><h4 id="3-std-weak-ptr"><a href="#3-std-weak-ptr" class="headerlink" title="3. std::weak_ptr"></a>3. <strong><code>std::weak_ptr</code></strong></h4><p><code>std::weak_ptr</code> 是 C++11 引入的，通常与 <code>shared_ptr</code> 配合使用，用来观察由 <code>shared_ptr</code> 管理的对象。<code>weak_ptr</code> 不增加对象的引用计数，因此<strong>它不会影响对象的生命周期</strong>。</p><blockquote><p>在某些场景下，<code>shared_ptr</code> 之间可能会相互引用，导致引用计数永远不为零，从而导致内存泄漏。这时可以使用 <code>weak_ptr</code> 来避免这种循环引用的问题。</p></blockquote><p>想象你有一个 <code>shared_ptr</code> 管理的对象 <code>A</code>，同时，你有另一个对象 <code>B</code>，它想引用 <code>A</code>，但不想干扰 <code>A</code> 的生命周期。你就可以用 <code>weak_ptr</code> 来观察 <code>A</code> 是否存在。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span>  <span class="hljs-comment">// 引入 shared_ptr 和 weak_ptr</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyClass</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;MyClass constructor&quot;</span> &lt;&lt; std::endl; &#125;<br>    ~<span class="hljs-built_in">MyClass</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;MyClass destructor&quot;</span> &lt;&lt; std::endl; &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showMessage</span><span class="hljs-params">()</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Hello from MyClass!&quot;</span> &lt;&lt; std::endl; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demoWeakPtr</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 创建一个 shared_ptr，指向 MyClass 对象</span><br>    std::shared_ptr&lt;MyClass&gt; ptr1 = std::<span class="hljs-built_in">make_shared</span>&lt;MyClass&gt;();<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Use count before weak_ptr: &quot;</span> &lt;&lt; ptr<span class="hljs-number">1.</span><span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 创建一个 weak_ptr，指向同一个对象，但不增加引用计数</span><br>    std::weak_ptr&lt;MyClass&gt; weakPtr = ptr1;<br><br>    <span class="hljs-comment">// 使用 weak_ptr 时，我们需要“锁定”它，检查它是否仍然有效</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">auto</span> sharedPtr = weakPtr.<span class="hljs-built_in">lock</span>()) &#123;  <span class="hljs-comment">// lock() 方法返回一个 shared_ptr，如果对象仍然存在</span><br>        sharedPtr-&gt;<span class="hljs-built_in">showMessage</span>();  <span class="hljs-comment">// 如果 weak_ptr 指向的对象仍然存在，就可以使用它</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Object is no longer available&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-comment">// 释放 ptr1，MyClass 对象的引用计数变为 0，对象会被销毁</span><br>    ptr<span class="hljs-number">1.</span><span class="hljs-built_in">reset</span>();  <span class="hljs-comment">// 释放 ptr1 指向的对象</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Use count after reset: &quot;</span> &lt;&lt; weakPtr.<span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 尝试再次锁定 weak_ptr</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">auto</span> sharedPtr = weakPtr.<span class="hljs-built_in">lock</span>()) &#123;<br>        sharedPtr-&gt;<span class="hljs-built_in">showMessage</span>();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Object is no longer available&quot;</span> &lt;&lt; std::endl;  <span class="hljs-comment">// 此时对象已经被销毁</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">demoWeakPtr</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs delphi">MyClass <span class="hljs-function"><span class="hljs-keyword">constructor</span></span><br><span class="hljs-function"><span class="hljs-title">Use</span> <span class="hljs-title">count</span> <span class="hljs-title">before</span> <span class="hljs-title">weak_ptr</span>:</span> <span class="hljs-number">1</span><br>Hello from MyClass!<br>Use count after reset: <span class="hljs-number">0</span><br><span class="hljs-keyword">Object</span> <span class="hljs-keyword">is</span> no longer available<br>MyClass <span class="hljs-function"><span class="hljs-keyword">destructor</span></span><br></code></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>**<code>std::unique_ptr</code>**：表示独占所有权，只能转移所有权，不支持拷贝。常用于资源的独占管理。</li><li>**<code>std::shared_ptr</code>**：表示共享所有权，多个 <code>shared_ptr</code> 可以共同拥有一个资源，直到最后一个 <code>shared_ptr</code> 被销毁，资源才会被释放。</li><li>**<code>std::weak_ptr</code>**：不增加引用计数，仅用于观察由 <code>shared_ptr</code> 管理的对象，防止出现循环引用的问题。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Code</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tutorial</tag>
      
      <tag>Finished</tag>
      
      <tag>C/C++</tag>
      
      <tag>pointers</tag>
      
      <tag>functions</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Exception-Handling-in-C-Plus-Plus</title>
    <link href="/posts/Exception-Handling-in-C-plus-plus/"/>
    <url>/posts/Exception-Handling-in-C-plus-plus/</url>
    
    <content type="html"><![CDATA[<style>  html, body, .markdown-body {    font-family: Georgia, sans, serif;  }</style><h1 id="C-Primer-Plus-Tutorial-15"><a href="#C-Primer-Plus-Tutorial-15" class="headerlink" title="C++ Primer Plus Tutorial-15"></a>C++ Primer Plus Tutorial-15</h1><center><p style="color: red;"><b><font size=6.5>Chapter 15 Exception Handling</font></b></p></center><center><p style="color: red;"><b><font size=6.5>C++中的异常处理</font></b></p></center><p>【写在前面的话】</p><p><a href="https://xiyuanyang-code.github.io/posts/C-Primer-Plus-tutorial/">C++ Primer Plus Tutorial</a></p><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><blockquote><p>在原书的15.1节介绍了友元类函数的高阶用法，包括其他友元关系和共同友元。</p><p>在原书的15.2节介绍了嵌套类的高级用法。</p><p>对于刚刚入门C++的本科生而言，这两部分内容笔者在此不展开叙述。下面，我们将重点放在C++的一个功能强大的模块，也是“++”的部分——<strong>C++的异常处理机制</strong>。</p></blockquote><p>This article mainly introduces the exception handling mechanism introduced in C++, which includes <code>throw</code> (throwing exceptions), <code>try</code> (exception handling), and <code>catch</code> (catching exceptions), as well as some advanced techniques for exception handling.</p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>在程序设计中，有时会遇到<strong>程序异常终止</strong>的情景，例如用户进行了非法输入导致数据无法正常读取，尝试打开一个不可用的文件，对内存管理不当（申请过多的内存，内存泄漏）等等。而C++中的异常处理（Exception Handling）提供了一种机制，使程序在运行时能够<strong>优雅</strong>地处理错误。通过异常处理，程序可以检测并响应不同类型的运行时错误，而<strong>无需中断正常的程序流程</strong>。C++中的异常处理包括三个基本部分：<strong>throw</strong>、<strong>try</strong> 和 <strong>catch</strong>。</p><blockquote><p>何为<strong>优雅</strong>？异常处理使程序能够在遇到错误时跳转到适当的错误处理代码，程序的控制流不会直接终止而是转移到专门用来处理异常的地方。但是如果不使用异常处理，程序会直接崩溃或者挂起。</p></blockquote><p>请看下面的示例程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> a=<span class="hljs-number">2</span>;<br>    <span class="hljs-type">int</span> b[]=&#123;<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> num:b)&#123;<br>        cout&lt;&lt;<span class="hljs-built_in">double</span>(a)/num&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出示例：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">0</span>.<span class="hljs-number">4</span><br><span class="hljs-attribute">0</span>.<span class="hljs-number">5</span><br><span class="hljs-attribute">0</span>.<span class="hljs-number">666667</span><br><span class="hljs-attribute">1</span><br><span class="hljs-attribute">2</span><br><span class="hljs-attribute">inf</span><br></code></pre></td></tr></table></figure><p>程序在num的值（分母）为0是输出了<code>inf</code>，这是一个表示无穷大的特殊浮点数值。</p><p>幸运的是，在此处程序不会异常终止，但是一旦<code>inf</code>会被用在后续的复杂的程序计算中，便会产生非常严重的后果，也为后续的Debug过程增加了负担。因此，我们不得不引入一种<strong>异常处理的机制</strong>，来专门用来处理给种各样的异常情况，使我们的程序更加的鲁棒。</p><h2 id="If-No-Exception-Handling？"><a href="#If-No-Exception-Handling？" class="headerlink" title="If No Exception Handling？"></a>If No Exception Handling？</h2><p>接下来我们来介绍两种<strong>不需要使用异常处理机制的方法来终止程序</strong>。</p><h3 id="Abort"><a href="#Abort" class="headerlink" title="Abort"></a>Abort</h3><p><code>abort()</code> 函数是 C&#x2F;C++ 中用于终止程序执行的一个标准库函数。它通常用于程序遇到严重错误时，强制终止程序并产生异常的退出状态。该函数会立即停止程序的执行，并且不会进行任何清理操作（如调用析构函数或执行 <code>atexit()</code> 注册的函数等）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span>  <span class="hljs-comment">// 包含 abort 函数</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Program started.&quot;</span> &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 由于某种条件不满足，调用 abort 终止程序</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;An error occurred, aborting program.&quot;</span> &lt;&lt; std::endl;<br>    <span class="hljs-built_in">abort</span>();  <span class="hljs-comment">// 强制终止程序</span><br><br>    <span class="hljs-comment">// 这行代码不会被执行</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;This will not be printed.&quot;</span> &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>严格来说，这并不能能算一种异常处理的机制，毕竟没有人想通过<strong>强制退出</strong>的方法终止自己的程序。（而且这会带来非常多的隐患，例如<strong>动态分配的内存没有被清除等</strong>）</p><p><img src="/posts/Exception-Handling-in-C-plus-plus/abort.png" alt="在IDE中，这仍被视为程序的异常退出"></p><h3 id="使用函数的返回值"><a href="#使用函数的返回值" class="headerlink" title="使用函数的返回值"></a>使用函数的返回值</h3><p>一种比异常终止更灵活的方法是，使用函数的返回值来指出问题。例如， <code>ostream</code> 类的 get（ void）成员通常返回下一个输入字符的 ASCII 码，但到达文件尾时，将返回特殊值 EOF。对 hmean( )来说，这种方法不管用。任何数值都是有效的返回值，因此不存在可用于指出问题的特殊值。在这种情况下，可使用指针参数或引用参数来将值返回给调用程序，并使用函数的返回值来指出成功还是失败。<strong>istream 族重载&gt;&gt;运算符使用了这种技术的变体。通过告知调用程序是成功了还是失败了</strong>，使得程序可以采取除异常终止程序之外的其他措施。程序清单 15.8 是一个采用这种方式的示例，它将 hmean( )的返回值重新定义为 bool，让返回值指出成功了还是失败了，另外还给该函数增加了第三个参数，用于提供答案。  </p><blockquote><p>通俗来说，在流输入的时候，如果进行非法输入会直接告知调用程序是否调用成功，这也就是为什么我们可以使用<code>while(cin&gt;&gt;a)</code>的结构。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//error2.cpp -- returning an error code</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cfloat&gt;</span>  <span class="hljs-comment">// (or float.h) for DBL_MAX</span></span><br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hmean</span><span class="hljs-params">(<span class="hljs-type">double</span> a, <span class="hljs-type">double</span> b, <span class="hljs-type">double</span> * ans)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">double</span> x, y, z;<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Enter two numbers: &quot;</span>;<br>    <span class="hljs-keyword">while</span> (std::cin &gt;&gt; x &gt;&gt; y)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">hmean</span>(x,y,&amp;z))<br>            <span class="hljs-comment">//这里将函数的返回值设置为布尔值，用来判断条件是否成立，而将运算的结果通过指针的方式储存。</span><br>            std::cout &lt;&lt; <span class="hljs-string">&quot;Harmonic mean of &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; and &quot;</span> &lt;&lt; y<br>                &lt;&lt; <span class="hljs-string">&quot; is &quot;</span> &lt;&lt; z &lt;&lt; std::endl;<br>        <span class="hljs-keyword">else</span><br>            std::cout &lt;&lt; <span class="hljs-string">&quot;One value should not be the negative &quot;</span><br>                &lt;&lt; <span class="hljs-string">&quot;of the other - try again.\n&quot;</span>;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Enter next set of numbers &lt;q to quit&gt;: &quot;</span>;<br>    &#125;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Bye!\n&quot;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hmean</span><span class="hljs-params">(<span class="hljs-type">double</span> a, <span class="hljs-type">double</span> b, <span class="hljs-type">double</span> * ans)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (a == -b)<br>    &#123;<br>        *ans = DBL_MAX;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        *ans = <span class="hljs-number">2.0</span> * a * b / (a + b);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="Exception-Handling"><a href="#Exception-Handling" class="headerlink" title="Exception Handling"></a>Exception Handling</h2><p>首先解决第一个问题，上文两种异常处理的方法有什么局限性？</p><p><code>Abort()</code>不必多说，没有程序员希望在程序中使用这个丑陋的东西，那<code>返回值</code>呢？这确实是一种方法，但这种方法的本质还是<strong>if-else大法进行分类讨论</strong>，如果判断错误的情况就进行特殊的处理，会增加程序的复杂性。（你也不希望自己的程序满眼望过去全是用来if-else处理异常情况的代码块吧）</p><p>不过值得庆幸的时，第二种方法给了我们一种思路，即<strong>异常处理可以跳转程序的控制流到一个特殊的地方，在那个地方我们专门来处理错误</strong>，这样即可以保证程序的控制流不会<strong>异常中断（像<code>abort()</code>一样）</strong>，也无需使用if-else大法，是程序更加的简洁。</p><p>这就是异常处理的最基本思路：<strong>提供了一种将程序的控制权从一个部分传递到另一个部分的途径</strong>。</p><div class="note note-primary">            <p>从另一个角度来说，异常处理就像是一个<strong>踢皮球</strong>的过程，矛盾上交，让函数在发现自己无法处理的错误时<strong>抛出一个异常</strong>，希望他的调用者能够处理这个问题，<strong>将异常检测和异常处理分开，将异常处理和解决问题的主逻辑分开，更加的清晰</strong>。</p>          </div><p>C++中的异常处理包括三个基本部分：<strong>throw</strong>、<strong>try</strong> 和 <strong>catch</strong>。</p><h3 id="示例程序"><a href="#示例程序" class="headerlink" title="示例程序"></a>示例程序</h3><ol><li><strong>throw</strong>：用于<strong>抛出异常</strong>。可以抛出任何类型的对象，通常是类的实例，但也可以是原始数据类型。</li><li><strong>try</strong>：用来定义异常检测的代码块。try块中的代码会被执行，若出现异常，程序会跳转到相应的catch块处理异常。</li><li><strong>catch</strong>：用于捕获和处理异常。每个catch块对应一个特定类型的异常，可以根据异常类型进行不同的处理。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdexcept&gt;</span> <span class="hljs-comment">// 引入标准异常头文件</span></span><br><br><span class="hljs-comment">// 一个简单的函数，用来演示异常处理</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">divide</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (b == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 抛出异常</span><br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">invalid_argument</span>(<span class="hljs-string">&quot;Division by zero is not allowed&quot;</span>);<br>    &#125;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Result: &quot;</span> &lt;&lt; a / b &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-built_in">divide</span>(<span class="hljs-number">10</span>, <span class="hljs-number">0</span>);  <span class="hljs-comment">// 这里会抛出异常</span><br>    &#125; <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::invalid_argument&amp; e) &#123;<br>        <span class="hljs-comment">// 捕获并处理异常</span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Error: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：<code>Division by zero is not allowed</code></p><blockquote><p>如果将第15行代码修改为：<code>divide(10, 1);</code>输出：<code>Result: 10</code></p></blockquote><h4 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h4><ol><li>**throw std::invalid_argument(“…”)**：如果除数为0，抛出一个<code>std::invalid_argument</code>类型的异常，带有错误信息。</li><li><strong>try-catch</strong>：在<code>main()</code>函数中，调用<code>divide()</code>时使用了<code>try</code>块，如果发生异常（例如除数为0），会跳转到相应的<code>catch</code>块处理异常。</li><li>**catch (const std::invalid_argument&amp; e)**：捕获异常并处理，<code>e.what()</code>返回异常的详细信息。</li></ol><h2 id="Throw-异常抛出"><a href="#Throw-异常抛出" class="headerlink" title="Throw 异常抛出"></a>Throw 异常抛出</h2><p>如果程序发生了异常，程序希望将错误信息发送到更大的环境中。（转移程序的控制权）这就是<strong>throw</strong>语句（异常抛出语句），它的功能将一个<strong>操作数</strong>抛出到“更大的环境”（即<strong>跳出当前的程序块</strong>）</p><p>还是以除数不可以为0为例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">divv</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(y==<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">throw</span>(y);<br>    &#125;<br>    <span class="hljs-keyword">return</span> x/y;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cout&lt;&lt;<span class="hljs-built_in">divv</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)&lt;&lt;endl;<br>    cout&lt;&lt;<span class="hljs-built_in">divv</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<br>    cout&lt;&lt;<span class="hljs-built_in">divv</span>(<span class="hljs-number">0</span>,<span class="hljs-number">3</span>)&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><p><img src="/posts/Exception-Handling-in-C-plus-plus/throw.png" alt="Throw"></p><p>很不幸的是，这里程序仍然是异常终止的，程序的控制流被直接切断，我们想要程序执行的第三条语句 <code>cout&lt;&lt;divv(0,3)&lt;&lt;endl</code>并没有执行。因为throw只是<strong>抛出了一个异常</strong>，我们并没有定义对所抛出异常的后续处理方法。Anyway，我们成功迈出了异常处理的第一步！</p><p>在这个程序中，<strong>操作数</strong>就是被抛出的int值<code>y</code>。异常抛出语句的一般形式为<code>throw &lt;操作数&gt;</code>。<strong>throw对应的操作数可以是任何类型，可以是基本的数据类型，也可以是自定义的类和对象（异常对象）</strong>。下面我们来看一个如何自定义一个异常类和异常对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Divide_by_zero</span>&#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">Divide_by_zero</span>():<span class="hljs-built_in">message</span>(<span class="hljs-string">&quot;attempted to divide by zero&quot;</span>)&#123;<br>            cout&lt;&lt;message&lt;&lt;endl;<br>        &#125;<br>        <span class="hljs-comment">//构造函数</span><br>        <span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title">what</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> message;<br>        &#125;<br>        <span class="hljs-comment">//what方法来调用私有数据成员message</span><br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-type">const</span> <span class="hljs-type">char</span>* message;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">divv</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(y==<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Divide_by_zero</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> x/y;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cout&lt;&lt;<span class="hljs-built_in">divv</span>(<span class="hljs-number">14</span>,<span class="hljs-number">2</span>)&lt;&lt;endl;<br>    cout&lt;&lt;<span class="hljs-built_in">divv</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<br>    cout&lt;&lt;<span class="hljs-built_in">divv</span>(<span class="hljs-number">6</span>,<span class="hljs-number">3</span>)&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs smali">输出示例：<br>7<br>attempted to divide by zero<br>terminate called after throwing an<span class="hljs-built_in"> instance </span>of &#x27;Divide_by_zero&#x27;<br></code></pre></td></tr></table></figure><p>在输出中，出现了<code>message</code>的内容，说明语句 <code>throw Divide_by_zero()</code>首先创建了一个<code>throw Divide_by_zero()</code>类的临时对象，调用了其构造函数，然后抛出这个临时对象（输出的第三行）。</p><blockquote><p>这里没有构造显式的析构函数，因为默认的析构函数就会销毁成员message。</p></blockquote><h2 id="Try-Catch-异常捕获"><a href="#Try-Catch-异常捕获" class="headerlink" title="Try-Catch 异常捕获"></a>Try-Catch 异常捕获</h2><h3 id="异常抛出后的控制权问题"><a href="#异常抛出后的控制权问题" class="headerlink" title="异常抛出后的控制权问题"></a>异常抛出后的控制权问题</h3><p>在上文我们知道，<strong>程序在异常处理后需要被捕获</strong>。何为捕获？在开始这一部分内容之前，我们首先介绍一下<strong>在抛出异常的时候，程序的控制权发生了什么。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdexcept&gt;</span> <span class="hljs-comment">// std::runtime_error</span></span><br><br><span class="hljs-comment">// 函数A抛出异常</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">functionA</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Inside functionA\n&quot;</span>;<br>    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;An error occurred in functionA&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// 函数B调用函数A</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">functionB</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Inside functionB\n&quot;</span>;<br>    <span class="hljs-built_in">functionA</span>(); <span class="hljs-comment">// 调用抛出异常的函数</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;FunctionB ends normally\n&quot;</span>;  <span class="hljs-comment">// 这行不会执行</span><br>&#125;<br><br><span class="hljs-comment">// main函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Inside main\n&quot;</span>;<br>        <span class="hljs-built_in">functionB</span>(); <span class="hljs-comment">// 调用functionB</span><br>    &#125;<br>    <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::runtime_error&amp; e) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Caught exception: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    &#125;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Program ends\n&quot;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs inform7"><span class="hljs-keyword">Inside</span> main<br><span class="hljs-keyword">Inside</span> functionB<br><span class="hljs-keyword">Inside</span> functionA<br>Caught exception: An error occurred in functionA<br>Program ends<br></code></pre></td></tr></table></figure><p>相信读者应该从名字就能猜出来，<code>try</code>和<code>catch</code>块就是用来<strong>捕获throw抛出的异常的</strong>，在上文程序中，他们被设置在了main函数中，也就是说，相当于在main函数里面<strong>设下了一张网</strong>，用来捕获上游函数抛出的异常。</p><p>接下来我们来重点关注上游函数，读者应该不难看出，函数的调用权转移是如下的顺序（在遇到异常情况前）：<strong>main函数→functionB→functionA</strong>，在functionA中，遇到异常情况被抛出，此时，<strong>异常将会跳出当前的程序块（functionA），而跳转到外部，即调用该函数的函数functionB</strong>。接下来，functionB没有捕获异常，因此，<strong>程序跳出functionB，异常继续传播</strong>，终于在main函数被捕获。</p><blockquote><p>这就是为什么程序没有输出<code>FunctionB ends normally</code>，因为异常的传播导致functionB的执行被异常终止了。</p></blockquote><p>也就是说，<strong>被抛出的异常需要被捕获</strong>，否则异常会切断在其被捕获的路上的函数的正常执行。</p><p>举一反三，如果我们修改了try-catch的位置：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdexcept&gt;</span> <span class="hljs-comment">// std::runtime_error</span></span><br><br><span class="hljs-comment">// 函数A抛出异常</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">functionA</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">try</span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Inside functionA\n&quot;</span>;<br>    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;An error occurred in functionA&quot;</span>);<br>&#125;<br>    <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::runtime_error&amp; e) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Caught exception2: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 函数B调用函数A</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">functionB</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Inside functionB\n&quot;</span>;<br>    <span class="hljs-built_in">functionA</span>(); <span class="hljs-comment">// 调用抛出异常的函数</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;FunctionB ends normally\n&quot;</span>;  <span class="hljs-comment">// 这行不会执行</span><br>&#125;<br><br><span class="hljs-comment">// main函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Inside main\n&quot;</span>;<br>        <span class="hljs-built_in">functionB</span>(); <span class="hljs-comment">// 调用functionB</span><br>    &#125;<br>    <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::runtime_error&amp; e) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Caught exception1: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    &#125;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Program ends\n&quot;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">Inside </span>main<br><span class="hljs-keyword">Inside </span>functionB<br><span class="hljs-keyword">Inside </span>functionA<br>Caught exception2: An error occurred in functionA<br>FunctionB ends <span class="hljs-keyword">normally</span><br><span class="hljs-keyword"></span>Program ends<br></code></pre></td></tr></table></figure><p>我们会发现，异常在被函数A抛出后直接被函数A中的<code>try-catch</code>捕获，没有打扰到后续functionB和main函数的正常执行。</p><h3 id="try-catch基本语法"><a href="#try-catch基本语法" class="headerlink" title="try-catch基本语法"></a>try-catch基本语法</h3><p><code>try</code>的作用是通知系统启动异常处理机制，这样可以使在try代码块中的所有抛出异常都能够被捕获。一旦捕获，<strong>则退出try块，跳过tey块后面的语句，进入try后面的异常处理部分</strong>。<code>catch</code>块的作用是<strong>处理某种类型异常的异常处理器</strong>。它们俩常常搭配使用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">try</span>&#123;<br>    <span class="hljs-comment">//可能抛出的异常代码</span><br>&#125;<br><span class="hljs-built_in">catch</span>(类型<span class="hljs-number">1</span> 参数<span class="hljs-number">1</span>)&#123;<br>    <span class="hljs-comment">//处理异常的代码1;</span><br>&#125;<br><span class="hljs-built_in">catch</span>(类型<span class="hljs-number">2</span> 参数<span class="hljs-number">2</span>)&#123;<br>    <span class="hljs-comment">//处理异常的代码2;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>值得注意的是，如果try没有捕获异常，<strong>不会执行任何一条跟在其后面的catch语句</strong>。也就是说，异常处理建立在异常抛出和异常捕获的基础之上。</p><p><code>catch</code> 处理器定义了自己处理的异常范围。<strong>异常范围是按类型区分的</strong>。 <code>catch</code> 在小括号中指定要<strong>捕获的异常类型以及参数</strong>。参数是所捕获的异常类型的一个<strong>对象</strong>，即 try 块中的某个语句抛出的<strong>对象</strong>。catch 处理器中的参数名是可选的。 如果给出了参数名， 则可以在异常处理代码中引用这个异常对象。如果没有指定参数名，只指定匹配抛出对象的类型，则信息不从抛出点传递到处理器中，只是把控制从抛出点转到处理器中。</p><p>如果 try 块中的某个语句抛出了异常，则跳出 <code>try</code> 块，开始异常捕获。先将抛出的异常类型与第一个异常处理器捕获的类型相比较，如果可以匹配，则执行异常处理代码，然后转到所有 catch 后的语句继续执行。如果不匹配，则与下一个异常处理器比较，直到找到一个匹配的异常处理器。如果找遍了所有的异常处理器，都不匹配，则函数执行结束，并将该<strong>异常抛给调用它的函数，由调用它的函数来处理该异常</strong>（异常继续向下传播）。  </p><p>回到那个除数不能为0的例子，如果我们使用try-catch块：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @Author: Xiyuan Yang   xiyuan_yang@outlook.com</span><br><span class="hljs-comment"> * @Date: 2024-10-13 11:06:15</span><br><span class="hljs-comment"> * @LastEditors: Xiyuan Yang   xiyuan_yang@outlook.com</span><br><span class="hljs-comment"> * @LastEditTime: 2024-12-15 14:53:59</span><br><span class="hljs-comment"> * @FilePath: \CODE_for_Vscode\C++_project\testcode_1.cpp</span><br><span class="hljs-comment"> * @Description: </span><br><span class="hljs-comment"> * Do you code and make progress today?</span><br><span class="hljs-comment"> * Copyright (c) 2024 by Xiyuan Yang, All Rights Reserved. </span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Divide_by_zero</span>&#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">Divide_by_zero</span>():<span class="hljs-built_in">message</span>(<span class="hljs-string">&quot;attempted to divide by zero&quot;</span>)&#123;<br>            cout&lt;&lt;message&lt;&lt;endl;<br>        &#125;<br>        <span class="hljs-comment">//构造函数</span><br>        <span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title">what</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> message;<br>        &#125;<br>        <span class="hljs-comment">//what方法来调用私有数据成员message</span><br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-type">const</span> <span class="hljs-type">char</span>* message;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">divv</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br>    <span class="hljs-keyword">try</span>&#123;<br>        <span class="hljs-keyword">if</span>(y==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Divide_by_zero</span>();<br>        &#125;<br>        cout&lt;&lt;x/y&lt;&lt;endl;<br>    &#125;<span class="hljs-built_in">catch</span>(Divide_by_zero ex)&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;Excpetion occured: &quot;</span>&lt;&lt;ex.<span class="hljs-built_in">what</span>()&lt;&lt;endl;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">divv</span>(<span class="hljs-number">14</span>,<span class="hljs-number">2</span>);<br>    <span class="hljs-built_in">divv</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">divv</span>(<span class="hljs-number">6</span>,<span class="hljs-number">3</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>终于成功了！程序成功捕获了<code>divv(1,0)</code>所抛出的异常，并正常执行了第三条语句 <code>divv(6,3)</code>并正常退出。</p><h2 id="Advanced-Usage"><a href="#Advanced-Usage" class="headerlink" title="Advanced Usage"></a>Advanced Usage</h2><h3 id="Periodic-Reflection"><a href="#Periodic-Reflection" class="headerlink" title="Periodic Reflection"></a>Periodic Reflection</h3><p>我们已经学习了异常处理的三种最基本的处理工具：</p><p><strong>throw（抛出异常）——try（捕获异常）——catch（处理异常）</strong></p><p>接下来，我们将从应用的角度出发，介绍异常处理的一些高级用法。</p><h3 id="标准库中的异常类"><a href="#标准库中的异常类" class="headerlink" title="标准库中的异常类"></a>标准库中的异常类</h3><p>C++标准库提供了多种异常类，如<code>std::out_of_range</code>、<code>std::invalid_argument</code>、<code>std::runtime_error</code>等。</p><h4 id="1-标准库中的异常类"><a href="#1-标准库中的异常类" class="headerlink" title="1. 标准库中的异常类"></a>1. <strong>标准库中的异常类</strong></h4><h5 id="std-exception"><a href="#std-exception" class="headerlink" title="std::exception"></a><strong><code>std::exception</code></strong></h5><p><code>std::exception</code> 是所有标准异常类的基类。它提供了一个虚函数 <code>what()</code>，用于获取异常的描述信息。用户通常会继承它并重写 <code>what()</code> 来创建自定义的异常类。</p><ul><li>**<code>what()</code>**：返回一个描述异常原因的 C 风格字符串。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;An error occurred&quot;</span>);<br>&#125; <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::exception&amp; e) &#123;<br>    std::cout &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="std-logic-error"><a href="#std-logic-error" class="headerlink" title="std::logic_error"></a><strong><code>std::logic_error</code></strong></h5><p><code>std::logic_error</code> 用于表示程序的逻辑错误。它是继承自 <code>std::exception</code> 的派生类，表示程序运行时存在设计缺陷。以下是其常见的子类：</p><ul><li>**<code>std::invalid_argument</code>**：表示函数接收到无效的参数，通常用于输入参数检查。</li><li>**<code>std::domain_error</code>**：表示数学函数的参数不在有效的数学域内。</li><li>**<code>std::length_error</code>**：表示容器的大小超过了容器的最大限制（例如 <code>std::vector</code>）。</li><li>**<code>std::out_of_range</code>**：表示访问超出了容器或数组的有效范围。</li></ul><h5 id="std-runtime-error"><a href="#std-runtime-error" class="headerlink" title="std::runtime_error"></a><strong><code>std::runtime_error</code></strong></h5><p><code>std::runtime_error</code> 用于表示程序在运行过程中遇到的错误，通常是由于不可预料的问题或外部条件造成的。以下是其常见的子类：</p><ul><li>**<code>std::overflow_error</code>**：表示数值计算中的溢出错误（例如，整数溢出）。</li><li>**<code>std::underflow_error</code>**：表示数值计算中的下溢错误（例如，浮点数精度问题）。</li><li>**<code>std::range_error</code>**：表示某些计算超出了有效的数值范围。</li></ul><h5 id="std-bad-alloc"><a href="#std-bad-alloc" class="headerlink" title="std::bad_alloc"></a><strong><code>std::bad_alloc</code></strong></h5><p><code>std::bad_alloc</code> 是在内存分配失败时抛出的异常。当使用 <code>new</code> 或 <code>std::vector</code> 等容器分配内存时，若内存不足，通常会抛出该异常。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-type">int</span>* arr = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">1000000000</span>];  <span class="hljs-comment">// 可能抛出 std::bad_alloc</span><br>&#125; <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::bad_alloc&amp; e) &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Memory allocation failed: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="std-bad-cast"><a href="#std-bad-cast" class="headerlink" title="std::bad_cast"></a><strong><code>std::bad_cast</code></strong></h5><p><code>std::bad_cast</code> 在使用 <code>dynamic_cast</code> 进行类型转换失败时抛出，通常用于不合法的指针类型转换。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">try</span> &#123;<br>    Base* base = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Derived</span>();<br>    Derived* derived = <span class="hljs-built_in">dynamic_cast</span>&lt;Derived*&gt;(base);  <span class="hljs-comment">// 如果转换失败，将抛出 std::bad_cast</span><br>&#125; <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::bad_cast&amp; e) &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Bad cast: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="std-bad-typeid"><a href="#std-bad-typeid" class="headerlink" title="std::bad_typeid"></a><strong><code>std::bad_typeid</code></strong></h5><p><code>std::bad_typeid</code> 在 <code>typeid</code> 运算符用于空指针时抛出。这常发生在运行时类型识别（RTTI）中，尤其是在多态类型系统中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">try</span> &#123;<br>    Base* base = <span class="hljs-literal">nullptr</span>;<br>    std::cout &lt;&lt; <span class="hljs-built_in">typeid</span>(*base).<span class="hljs-built_in">name</span>();  <span class="hljs-comment">// 如果 base 是 nullptr，将抛出 std::bad_typeid</span><br>&#125; <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::bad_typeid&amp; e) &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Bad typeid: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="2-用户自定义异常类"><a href="#2-用户自定义异常类" class="headerlink" title="2. 用户自定义异常类"></a>2. <strong>用户自定义异常类</strong></h4><p>除了标准库提供的异常类，用户可以根据程序的需要自定义异常类。这些异常类可以从 <code>std::exception</code> 或其他标准异常类继承，并根据具体需求实现错误处理和信息传递。</p><h5 id="自定义异常类示例"><a href="#自定义异常类示例" class="headerlink" title="自定义异常类示例"></a><strong>自定义异常类示例</strong></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;exception&gt;</span></span><br><br><span class="hljs-comment">// 自定义异常类继承自 std::exception</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyException</span> : <span class="hljs-keyword">public</span> std::exception &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 重写 what() 方法，返回自定义的错误信息</span><br>    <span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title">what</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;My custom exception occurred!&quot;</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-built_in">MyException</span>();  <span class="hljs-comment">// 抛出自定义异常</span><br>    &#125; <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> MyException&amp; e) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Caught exception: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="自定义异常类传递额外信息"><a href="#自定义异常类传递额外信息" class="headerlink" title="自定义异常类传递额外信息"></a><strong>自定义异常类传递额外信息</strong></h5><p>有时需要在异常类中存储附加信息，比如错误代码或上下文信息。可以通过构造函数传递这些信息，并在 <code>what()</code> 中返回它们。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;exception&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DetailedException</span> : <span class="hljs-keyword">public</span> std::exception &#123;<br><span class="hljs-keyword">private</span>:<br>    std::string message;<br>    <span class="hljs-type">int</span> errorCode;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">DetailedException</span>(<span class="hljs-type">const</span> std::string&amp; msg, <span class="hljs-type">int</span> code)<br>        : <span class="hljs-built_in">message</span>(msg), <span class="hljs-built_in">errorCode</span>(code) &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title">what</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> message.<span class="hljs-built_in">c_str</span>();  <span class="hljs-comment">// 返回错误信息</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getErrorCode</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> errorCode;  <span class="hljs-comment">// 返回错误码</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-built_in">DetailedException</span>(<span class="hljs-string">&quot;Something went wrong&quot;</span>, <span class="hljs-number">42</span>);<br>    &#125; <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> DetailedException&amp; e) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Error: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; <span class="hljs-string">&quot;, Code: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">getErrorCode</span>() &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="catch-的用法"><a href="#catch-的用法" class="headerlink" title="catch(...)的用法"></a><code>catch(...)</code>的用法</h3><p>C++ 的异常处理通常通过 <code>try-catch</code> 语句块来实现，<code>try</code> 块包含可能引发异常的代码，而 <code>catch</code> 块处理异常。可以捕获指定类型的异常，也可以捕获所有类型的异常。</p><ul><li><p><strong>捕获特定异常类型</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;Runtime error&quot;</span>);<br>&#125; <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::runtime_error&amp; e) &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Caught runtime error: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>捕获所有异常</strong>（<strong>必须作为最后一个异常处理器</strong>）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;Runtime error&quot;</span>);<br>&#125; <span class="hljs-built_in">catch</span> (...) &#123;  <span class="hljs-comment">// 捕获所有类型的异常</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Caught an unknown exception&quot;</span> &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><blockquote><p><code>catch (...) </code>诚然是一种很强大的处理异常的工具，他相当于一张密不透风的超强大网可以兜住所有的错误类型，但是在一定程度上牺牲了个性化。（他即使抛出了错误，你也不知道抛出的错误是什么类型）</p></blockquote><ul><li><strong>只捕获类型，不指明对象</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">try</span> &#123;<br>cout &lt;&lt; <span class="hljs-built_in">div</span>(<span class="hljs-number">6</span>, <span class="hljs-number">3</span>) &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-built_in">div</span>(<span class="hljs-number">10</span>, <span class="hljs-number">0</span>) &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-built_in">div</span>(<span class="hljs-number">5</span>, <span class="hljs-number">2</span>) &lt;&lt; endl;<br>&#125;<br><span class="hljs-built_in">catch</span> (<span class="hljs-type">int</span>) &#123; cout &lt;&lt; <span class="hljs-string">&quot;divide by zero&quot;</span> &lt;&lt; endl; &#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;It&#x27;s Over&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>That‘s it! 这就是C++中异常处理的基本知识点，你可以在自己的程序中尝试使用这一种异常处理的机制了。不过切记来时的路：<strong>异常处理机制是让程序在不中止的情况下对异常情况通过“跳出—捕获—处理”的过程异常处理。</strong>所以，不要让你的程序到处都是Try-Catch！这一点可以在后续的编程实践中逐步巩固。</p><blockquote><p>The END 2024&#x2F;12&#x2F;15</p></blockquote><div class="note note-info">            <p>笔者接下来将会将重点放在STL和数据结构的系统化更新中~有关Cpp的语法博客可能就暂时告一段落啦，不过之后会专门更新Cmake的使用，敬请期待！</p>          </div>]]></content>
    
    
    <categories>
      
      <category>Code</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tutorial</tag>
      
      <tag>Finished</tag>
      
      <tag>C/C++</tag>
      
      <tag>C++ Primer Plus</tag>
      
      <tag>Exception Handling</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Code-Reuse-in-OOP</title>
    <link href="/posts/Code-Reuse-in-OOP/"/>
    <url>/posts/Code-Reuse-in-OOP/</url>
    
    <content type="html"><![CDATA[<style>  html, body, .markdown-body {    font-family: Georgia, sans, serif;  }</style><h1 id="Code-Reuse-in-OOP"><a href="#Code-Reuse-in-OOP" class="headerlink" title="Code Reuse in OOP"></a>Code Reuse in OOP</h1><h1 id="C-Primer-Plus-Tutorial-15"><a href="#C-Primer-Plus-Tutorial-15" class="headerlink" title="C++ Primer Plus Tutorial-15"></a>C++ Primer Plus Tutorial-15</h1><h1 id="面向对象编程教程——Section④"><a href="#面向对象编程教程——Section④" class="headerlink" title="面向对象编程教程——Section④"></a>面向对象编程教程——Section④</h1><center><p style="color: red;"><b><font size=6.5>Chapter 15 Code Reuse in OOP</font></b></p></center><center><p style="color: red;"><b><font size=6.5>面向对象编程中的代码重用</font></b></p></center><p>【写在前面的话】</p><p><a href="https://xiyuanyang-code.github.io/posts/C-plus-plus-Primer-Plus-tutorial/">C++ Primer Plus Tutorial</a></p><p><a href="https://xiyuanyang-code.github.io/tags/OOP/">系列文章</a></p><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>C++的一个主要目标是促进代码重用。公有继承是实现这种目标的机制之一，但并不是唯一的机制。本章将介绍其他方法，其中之一是使用这样的类成员：本身是另一个类的对象。这种方法称为<strong>包含（containment）、组合（composition）或层次化（layering）</strong>。另一种方法是使用私有或保护继承。通常，<strong>包含、私有继承和保护继承</strong>用于实现 <strong>has-a</strong> 关系，即新的类将包含另一个类的对象。多重继承使得能够使用两个或更多的基类派生出新的类，将基类的功能组合在一起。</p><p>同时，本章将介绍<strong>类模板</strong>——另一种重用代码的方法。类模板使我们能够使用通用术语定义类，然后使用模板来创建针对特定类型定义的特殊类。</p><blockquote><p>One of the main goals of C++ is to promote code reuse. Public inheritance is one of the mechanisms to achieve this goal, but not the only one. This chapter will introduce other methods, one of which is to use class members that are themselves objects of another class. This method is called containment, composition, or layering. Another method is to use private or protected inheritance. Generally, containment, private inheritance, and protected inheritance are used to implement the has - a relationship, that is, the new class will contain an object of another class. Multiple inheritance enables new classes to be derived from two or more base classes, combining the functionality of the base classes.</p><p>At the same time, this chapter will introduce class templates - another method of reusing code. Class templates enable us to define classes in general terms and then use the templates to create special classes defined for specific types.</p></blockquote><h2 id="Table-of-Contents"><a href="#Table-of-Contents" class="headerlink" title="Table of Contents"></a>Table of Contents</h2><ul><li>Containment Composition Layering</li><li>Multiple Inheritance</li><li>Class Template</li><li>Friend Class and Friend Functions</li></ul><h2 id="Containment-Composition-Layering"><a href="#Containment-Composition-Layering" class="headerlink" title="Containment Composition Layering"></a>Containment Composition Layering</h2><h3 id="valarray"><a href="#valarray" class="headerlink" title="valarray"></a><code>valarray</code></h3><p><code>valarray</code>被定义为一个模板类，能够处理不同的数据类型。</p><p>下面来看<code>valarray</code>的基本操作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;valarray&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">valarray&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">list</span><span class="hljs-params">(<span class="hljs-number">10</span>,<span class="hljs-number">8</span>)</span></span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> num:list)&#123;<br>        cout&lt;&lt;num&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：8个10</p><p><code>valarray</code>的基本使用和数组完全一样，但是<code>valarray</code>在数值计算方面具有更大的优势。</p><div class="note note-info">            <ol><li>构造函数<ul><li><strong>默认构造函数</strong>：可以创建一个空的<code>valarray</code>。例如<code>std::valarray&lt;int&gt; va;</code>，这样就创建了一个空的<code>valarray</code>，其中元素类型为<code>int</code>。</li><li><strong>大小指定构造函数</strong>：可以指定<code>valarray</code>的大小和初始值。例如<code>std::valarray&lt;double&gt; va1(10, 3.14);</code>，这个构造函数创建了一个包含 10 个元素的<code>valarray</code>，每个元素初始值为 3.14。</li><li><strong>拷贝构造函数</strong>：用于从另一个<code>valarray</code>创建一个新的<code>valarray</code>。例如<code>std::valarray&lt;int&gt; va2(va1);</code>，这里<code>va2</code>是<code>va1</code>的一个拷贝，它们具有相同的元素个数和对应位置相同的元素。</li><li><strong>初始化列表构造函数</strong>：可以使用花括号初始化列表来创建<code>valarray</code>。例如<code>std::valarray&lt;int&gt; va3 = {1, 2, 3, 4, 5};</code>，这种方式方便快捷地创建并初始化一个<code>valarray</code>。</li></ul></li><li>元素访问方法<ul><li><strong><code>[]</code>操作符</strong>：用于访问<code>valarray</code>中的单个元素。例如：</li></ul></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::valarray&lt;<span class="hljs-type">int</span>&gt; va = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><span class="hljs-type">int</span> element = va[<span class="hljs-number">2</span>];  <span class="hljs-comment">// 访问第三个元素，element的值为3</span><br></code></pre></td></tr></table></figure><ul><li><strong><code>size()</code>方法</strong>：返回<code>valarray</code>中元素的个数。例如：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::valarray&lt;<span class="hljs-type">double</span>&gt; <span class="hljs-title">va1</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">3.14</span>)</span></span>;<br>std::cout &lt;&lt; va<span class="hljs-number">1.</span><span class="hljs-built_in">size</span>() &lt;&lt; std::endl;  <span class="hljs-comment">// 输出10</span><br></code></pre></td></tr></table></figure><ol><li>数学运算方法<ul><li>算术运算符重载<ul><li><strong>加法</strong>：可以将两个<code>valarray</code>相加，或者将一个<code>valarray</code>与一个标量相加。例如：</li></ul></li></ul></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::valarray&lt;<span class="hljs-type">int</span>&gt; va1 = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>std::valarray&lt;<span class="hljs-type">int</span>&gt; va2 = &#123;<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;;<br>std::valarray&lt;<span class="hljs-type">int</span>&gt; result1 = va1 + va2;  <span class="hljs-comment">// 对应元素相加，result1为&#123;5, 7, 9&#125;</span><br>std::valarray&lt;<span class="hljs-type">int</span>&gt; result2 = va1 + <span class="hljs-number">2</span>;    <span class="hljs-comment">// 每个元素加2，result2为&#123;3, 4, 5&#125;</span><br></code></pre></td></tr></table></figure><ul><li>减法、乘法、除法等运算与之类似<ul><li>减法：<code>std::valarray&lt;int&gt; result3 = va2 - va1;</code>（对应元素相减）</li><li>乘法：<code>std::valarray&lt;int&gt; result4 = va1 * 3;</code>（每个元素乘以 3）</li><li>除法：<code>std::valarray&lt;double&gt; va3 = {4.0, 8.0, 12.0};</code>，<code>std::valarray&lt;double&gt; result5 = va3 / 2.0;</code>（每个元素除以 2.0）</li></ul></li><li>数学函数应用<ul><li><strong><code>std::pow</code>函数</strong>：用于计算<code>valarray</code>中每个元素的幂。例如</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::valarray&lt;<span class="hljs-type">int</span>&gt; va = &#123;<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br>std::valarray&lt;<span class="hljs-type">int</span>&gt; result = std::<span class="hljs-built_in">pow</span>(va, <span class="hljs-number">2</span>);  <span class="hljs-comment">// 计算每个元素的平方，result为&#123;4, 9, 16&#125;</span><br></code></pre></td></tr></table></figure><ul><li><code>std::sin</code>、<code>std::cos</code>等三角函数也可以应用于<code>valarray</code>元素<ul><li>例如<code>std::valarray&lt;double&gt; va1 = {0.0, 3.14159 / 2.0, 3.14159};</code>，<code>std::valarray&lt;double&gt; sin_result = std::sin(va1);</code>，会分别计算<code>va1</code>中每个元素的正弦值。</li></ul></li></ul><ol><li>切片操作（<code>slice</code>）相关方法<ul><li><strong><code>valarray</code>支持切片操作</strong>：可以通过定义<code>slice</code>对象来提取<code>valarray</code>中的一部分元素。例如：</li></ul></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::valarray&lt;<span class="hljs-type">int</span>&gt; va = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>&#125;;<br><span class="hljs-function">std::slice <span class="hljs-title">s</span><span class="hljs-params">(<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>)</span></span>;  <span class="hljs-comment">// 从索引2开始，长度为4，步长为2的切片</span><br>std::valarray&lt;<span class="hljs-type">int</span>&gt; sliced_va = va[s];  <span class="hljs-comment">// sliced_va为&#123;3, 5, 7, 9&#125;</span><br></code></pre></td></tr></table></figure><ul><li><strong><code>cshift</code>方法（循环移位）</strong>：可以对<code>valarray</code>中的元素进行循环移位操作。例如：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::valarray&lt;<span class="hljs-type">int</span>&gt; va = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>std::valarray&lt;<span class="hljs-type">int</span>&gt; shifted_va = va.<span class="hljs-built_in">cshift</span>(<span class="hljs-number">2</span>);  <span class="hljs-comment">// 元素向右循环移2位，shifted_va为&#123;4, 5, 1, 2, 3&#125;</span><br></code></pre></td></tr></table></figure>          </div><h3 id="如何操作has-a关系？"><a href="#如何操作has-a关系？" class="headerlink" title="如何操作has-a关系？"></a>如何操作<code>has-a</code>关系？</h3><p>公有继承比较适合的是<code>is-a-king-of</code>关系的建立，即构建一种<strong>种类上子集</strong>的关系。那如果是是一种<strong>has-a</strong>关系呢？举个简单的例子，我们现在又<strong>string</strong>类（姓名）和<strong>valarry</strong>类（分数）两个底层的基类，我想从这两个基类派生出我的<strong>student类</strong>（每个学生都有自己的姓名和分数）。</p><p>如果使用<strong>公有继承</strong>（在这里是多重公有继承），显然不合适。因为学生和姓名不属于同类事物。通常，我们使用<strong>包含（containment）</strong>的技术来构建一种<strong>has-a</strong>关系，即<strong>创建一个包含其他类对象的类</strong>。</p><p>下文给出<code>student</code>类的代码示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// studentc.h -- defining a Student class using containment</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> STUDENTC_H_</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> STUDENTC_H_</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span>   </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;valarray&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span><br>&#123;   <br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">typedef</span> std::valarray&lt;<span class="hljs-type">double</span>&gt; ArrayDb;<br>    std::string name;       <span class="hljs-comment">// contained object</span><br>    ArrayDb scores;         <span class="hljs-comment">// contained object</span><br>    <span class="hljs-comment">// private method for scores output</span><br>    <span class="hljs-function">std::ostream &amp; <span class="hljs-title">arr_out</span><span class="hljs-params">(std::ostream &amp; os)</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Student</span>() : <span class="hljs-built_in">name</span>(<span class="hljs-string">&quot;Null Student&quot;</span>), <span class="hljs-built_in">scores</span>() &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Student</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp; s)</span></span><br><span class="hljs-function">        : name(s), scores() &#123;</span>&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Student</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> : name(<span class="hljs-string">&quot;Nully&quot;</span>), scores(n) &#123;</span>&#125;<br>    <span class="hljs-built_in">Student</span>(<span class="hljs-type">const</span> std::string &amp; s, <span class="hljs-type">int</span> n)<br>        : <span class="hljs-built_in">name</span>(s), <span class="hljs-built_in">scores</span>(n) &#123;&#125;<br>    <span class="hljs-built_in">Student</span>(<span class="hljs-type">const</span> std::string &amp; s, <span class="hljs-type">const</span> ArrayDb &amp; a)<br>        : <span class="hljs-built_in">name</span>(s), <span class="hljs-built_in">scores</span>(a) &#123;&#125;<br>    <span class="hljs-built_in">Student</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> * str, <span class="hljs-type">const</span> <span class="hljs-type">double</span> * pd, <span class="hljs-type">int</span> n)<br>        : <span class="hljs-built_in">name</span>(str), <span class="hljs-built_in">scores</span>(pd, n) &#123;&#125;<br>    ~<span class="hljs-built_in">Student</span>() &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">Average</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">const</span> std::string &amp; <span class="hljs-title">Name</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-type">double</span> &amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> i);<br>    <span class="hljs-type">double</span> <span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> i) <span class="hljs-type">const</span>;<br><span class="hljs-comment">// friends</span><br>    <span class="hljs-comment">// input</span><br>    <span class="hljs-keyword">friend</span> std::istream &amp; <span class="hljs-keyword">operator</span>&gt;&gt;(std::istream &amp; is,<br>                                     Student &amp; stu);  <span class="hljs-comment">// 1 word</span><br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> std::istream &amp; <span class="hljs-title">getline</span><span class="hljs-params">(std::istream &amp; is,</span></span><br><span class="hljs-params"><span class="hljs-function">                                  Student &amp; stu)</span></span>;     <span class="hljs-comment">// 1 line</span><br>    <span class="hljs-comment">// output</span><br>    <span class="hljs-keyword">friend</span> std::ostream &amp; <span class="hljs-keyword">operator</span>&lt;&lt;(std::ostream &amp; os,<br>                                     <span class="hljs-type">const</span> Student &amp; stu);<br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br></code></pre></td></tr></table></figure><blockquote><p>复习一下：<code>explicit</code>关键词可以避免编译器进行隐式类型转换。</p><p>在这种情况下，Student类的成员函可以使用string类的共用接口来修改和访问name对象，但是在类的外部只能通过Student类的成员函数对私有数据进行访问。</p><p>换句话说，在has-a关系的继承中，<strong>类对象不能自动获得被包含对象的接口，而应该通过定义成员函数来实现。</strong>举个例子，在string类中重载了加法运算符用于字符串的拼接，但是student类继承这种方法是没有任何意义的（你不可以把两个学生拼在一起）。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// studentc.cpp -- Student class using containment</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;studentc.h&quot;</span></span><br><span class="hljs-keyword">using</span> std::ostream;<br><span class="hljs-keyword">using</span> std::endl;<br><span class="hljs-keyword">using</span> std::istream;<br><span class="hljs-keyword">using</span> std::string;<br><br><span class="hljs-comment">//public methods</span><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">Student::Average</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (scores.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> scores.<span class="hljs-built_in">sum</span>()/scores.<span class="hljs-built_in">size</span>();  <br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">const</span> string &amp; <span class="hljs-title">Student::Name</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> name;<br>&#125;<br><br><span class="hljs-type">double</span> &amp; Student::<span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> i)<br>&#123;<br>    <span class="hljs-keyword">return</span> scores[i];         <span class="hljs-comment">// use valarray&lt;double&gt;::operator[]()</span><br>&#125;<br><br><span class="hljs-type">double</span> Student::<span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> i) <span class="hljs-type">const</span><br>&#123;<br>    <span class="hljs-keyword">return</span> scores[i];<br>&#125;<br><br><span class="hljs-comment">// private method</span><br><span class="hljs-function">ostream &amp; <span class="hljs-title">Student::arr_out</span><span class="hljs-params">(ostream &amp; os)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-type">int</span> lim = scores.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">if</span> (lim &gt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; lim; i++)<br>        &#123;<br>            os &lt;&lt; scores[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>            <span class="hljs-keyword">if</span> (i % <span class="hljs-number">5</span> == <span class="hljs-number">4</span>)<br>                os &lt;&lt; endl;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (i % <span class="hljs-number">5</span> != <span class="hljs-number">0</span>)<br>            os &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>        os &lt;&lt; <span class="hljs-string">&quot; empty array &quot;</span>;<br>    <span class="hljs-keyword">return</span> os; <br>&#125;<br><br><span class="hljs-comment">// friends</span><br><br><span class="hljs-comment">// use string version of operator&gt;&gt;()</span><br>istream &amp; <span class="hljs-keyword">operator</span>&gt;&gt;(istream &amp; is, Student &amp; stu)<br>&#123;<br>    is &gt;&gt; stu.name;<br>    <span class="hljs-keyword">return</span> is; <br>&#125;<br><br><span class="hljs-comment">// use string friend getline(ostream &amp;, const string &amp;)</span><br><span class="hljs-function">istream &amp; <span class="hljs-title">getline</span><span class="hljs-params">(istream &amp; is, Student &amp; stu)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">getline</span>(is, stu.name);<br>    <span class="hljs-keyword">return</span> is;<br>&#125;<br><br><span class="hljs-comment">// use string version of operator&lt;&lt;()</span><br>ostream &amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp; os, <span class="hljs-type">const</span> Student &amp; stu)<br>&#123;<br>    os &lt;&lt; <span class="hljs-string">&quot;Scores for &quot;</span> &lt;&lt; stu.name &lt;&lt; <span class="hljs-string">&quot;:\n&quot;</span>;<br>    stu.<span class="hljs-built_in">arr_out</span>(os);  <span class="hljs-comment">// use private method for scores</span><br>    <span class="hljs-keyword">return</span> os;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="私有继承与保护继承（Additional）"><a href="#私有继承与保护继承（Additional）" class="headerlink" title="私有继承与保护继承（Additional）"></a>私有继承与保护继承（Additional）</h3><p>在C++中，<strong>私有继承</strong>也是实现<strong>has-a</strong>关系的重要实现方式之一，在这里不再展开涉及具体的细节（毕竟第一种方法已经够用了，不是吗），只给出头文件的语法规范示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// studenti.h -- defining a Student class using private inheritance</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> STUDENTC_H_</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> STUDENTC_H_</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;valarray&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span>   </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> : <span class="hljs-keyword">private</span> std::string, <span class="hljs-keyword">private</span> std::valarray&lt;<span class="hljs-type">double</span>&gt;<br>&#123;   <br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">typedef</span> std::valarray&lt;<span class="hljs-type">double</span>&gt; ArrayDb;<br>    <span class="hljs-comment">// private method for scores output</span><br>    <span class="hljs-function">std::ostream &amp; <span class="hljs-title">arr_out</span><span class="hljs-params">(std::ostream &amp; os)</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Student</span>() : std::<span class="hljs-built_in">string</span>(<span class="hljs-string">&quot;Null Student&quot;</span>), <span class="hljs-built_in">ArrayDb</span>() &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Student</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp; s)</span></span><br><span class="hljs-function">            : std::string(s), ArrayDb() &#123;</span>&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Student</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> : std::string(<span class="hljs-string">&quot;Nully&quot;</span>), ArrayDb(n) &#123;</span>&#125;<br>    <span class="hljs-built_in">Student</span>(<span class="hljs-type">const</span> std::string &amp; s, <span class="hljs-type">int</span> n)<br>            : std::<span class="hljs-built_in">string</span>(s), <span class="hljs-built_in">ArrayDb</span>(n) &#123;&#125;<br>    <span class="hljs-built_in">Student</span>(<span class="hljs-type">const</span> std::string &amp; s, <span class="hljs-type">const</span> ArrayDb &amp; a)<br>            : std::<span class="hljs-built_in">string</span>(s), <span class="hljs-built_in">ArrayDb</span>(a) &#123;&#125;<br>    <span class="hljs-built_in">Student</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> * str, <span class="hljs-type">const</span> <span class="hljs-type">double</span> * pd, <span class="hljs-type">int</span> n)<br>            : std::<span class="hljs-built_in">string</span>(str), <span class="hljs-built_in">ArrayDb</span>(pd, n) &#123;&#125;<br>    ~<span class="hljs-built_in">Student</span>() &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">Average</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-type">double</span> &amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> i);<br>    <span class="hljs-type">double</span> <span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> i) <span class="hljs-type">const</span>;<br>    <span class="hljs-function"><span class="hljs-type">const</span> std::string &amp; <span class="hljs-title">Name</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-comment">// friends</span><br>    <span class="hljs-comment">// input</span><br>    <span class="hljs-keyword">friend</span> std::istream &amp; <span class="hljs-keyword">operator</span>&gt;&gt;(std::istream &amp; is,<br>                                     Student &amp; stu);  <span class="hljs-comment">// 1 word</span><br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> std::istream &amp; <span class="hljs-title">getline</span><span class="hljs-params">(std::istream &amp; is,</span></span><br><span class="hljs-params"><span class="hljs-function">                                  Student &amp; stu)</span></span>;     <span class="hljs-comment">// 1 line</span><br>    <span class="hljs-comment">// output</span><br>    <span class="hljs-keyword">friend</span> std::ostream &amp; <span class="hljs-keyword">operator</span>&lt;&lt;(std::ostream &amp; os,<br>                                     <span class="hljs-type">const</span> Student &amp; stu);<br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br></code></pre></td></tr></table></figure><h2 id="Multiple-Inheritance"><a href="#Multiple-Inheritance" class="headerlink" title="Multiple Inheritance"></a>Multiple Inheritance</h2><p>从单继承，我们很容易的推理出多重继承（Multiple Inheritance），简称MI。</p><p><img src="/posts/Code-Reuse-in-OOP/MI.png" alt="Multiple Inheritance"></p><div class="note note-danger">            <p><strong>注意！！！多重继承在一定程度上大大提高了继承的复杂性！一定要慎用！（笔者建议能使用单继承就使用单继承）</strong></p>          </div><div class="note note-info">            <h3 id="小故事：钻石问题"><a href="#小故事：钻石问题" class="headerlink" title="小故事：钻石问题"></a>小故事：钻石问题</h3><p>钻石问题（Diamond Problem）是多重继承中的一个经典问题，特别是在面向对象编程语言中。这个问题发生在一个类继承自两个或更多有共同父类的类时，导致继承结构中产生二义性和不明确的继承路径。它的名字来源于继承关系图形的形状，通常呈现一个钻石形状。</p><p><strong>钻石问题的例子</strong>：</p><p>假设有一个类 <code>A</code>，它是两个类 <code>B</code> 和 <code>C</code> 的父类，而 <code>B</code> 和 <code>C</code> 又被一个类 <code>D</code> 继承。继承关系可以表示为一个钻石形状：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Css">  <span class="hljs-selector-tag">A</span><br> / \<br><span class="hljs-selector-tag">B</span>   C<br> \ /<br>  D<br></code></pre></td></tr></table></figure><p><strong>问题的具体情况</strong>：</p><p>在这个继承关系中，类 <code>B</code> 和类 <code>C</code> 都继承了类 <code>A</code>，并且类 <code>D</code> 同时继承了 <code>B</code> 和 <code>C</code>。假设类 <code>A</code> 中有一个成员函数 <code>foo()</code>，而类 <code>B</code> 和类 <code>C</code> 都没有覆盖（override）该函数。那么，类 <code>D</code> 在继承时会遇到以下问题：</p><ul><li><strong>二义性</strong>：类 <code>D</code> 继承了 <code>B</code> 和 <code>C</code>，它同时会继承来自 <code>A</code> 的 <code>foo()</code> 函数。但是，当你尝试调用 <code>foo()</code> 时，编译器无法确定应该调用 <code>B</code> 中的 <code>foo()</code>，还是 <code>C</code> 中的 <code>foo()</code>（假设 <code>B</code> 和 <code>C</code> 都没有覆盖这个函数）。如果 <code>B</code> 和 <code>C</code> 都没有 <code>foo()</code>，那么 <code>D</code> 也会得到二义性错误。</li><li><strong>重复继承</strong>：由于 <code>B</code> 和 <code>C</code> 都继承自 <code>A</code>，在类 <code>D</code> 中可能会包含 <code>A</code> 的多个副本，导致同一个基类成员被多次继承，这种冗余的继承可能会导致不必要的资源浪费和代码混乱。</li></ul><blockquote><p>实际上，C++ 引入了 <strong>虚拟继承（Virtual Inheritance）</strong> 来解决钻石问题。虚拟继承可以确保在多重继承时，<code>A</code> 类的子对象只会被继承一次。</p></blockquote>          </div><h2 id="Class-Template"><a href="#Class-Template" class="headerlink" title="Class Template"></a>Class Template</h2><p>面向对象的程序设计提供了一种称为<strong>泛型程序设计</strong>的机制，即允许将类中成员的类型设置为一个可变的参数，使多个类变成一个类。泛型程序设计可以以独立于任何特定类型的方式编写代码。使用泛型程序时，必须提供具体所操作的类型或值。第 5 章介绍的<strong>函数模板</strong>就是泛型机制的一种实现方法，本章将介绍<strong>类模板</strong>，即<strong>用泛型机制设计的类</strong>。  </p><p>在函数章节，我们学习了模版函数，实现了一个模版在多个不同数据类型之间的通用，大大提高了代码重用的效率。在类的定义中同样也是如此，模板提供<strong>参数化（parameterized）类型</strong>，即能够将类型名作为参数传递给接收方来建立类或函数。例如，将类型名 <code>int</code> 传递给 <code>Queue</code> 模板，可以让编译器构造一个对 int 进行排队的 <code>Queue</code> 类。  </p><p>在接下来的内容中，我们将以非常重要的数据结构——<strong>栈（Stack）</strong>为示例，向读者演示模板类的强大之处。</p><h3 id="The-Implementation-of-Stack"><a href="#The-Implementation-of-Stack" class="headerlink" title="The Implementation of Stack"></a>The Implementation of Stack</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// stack.h -- class definition for the stack ADT</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> STACK_H_</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> STACK_H_</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> Item;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Stack</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">enum</span> &#123;MAX = <span class="hljs-number">10</span>&#125;;    <span class="hljs-comment">// constant specific to class</span><br>    Item items[MAX];    <span class="hljs-comment">// holds stack items</span><br>    <span class="hljs-type">int</span> top;            <span class="hljs-comment">// index for top stack item</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Stack</span>();<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isempty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isfull</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-comment">// push() returns false if stack already is full, true otherwise</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">const</span> Item &amp; item)</span></span>;   <span class="hljs-comment">// add item to stack</span><br>    <span class="hljs-comment">// pop() returns false if stack already is empty, true otherwise</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">pop</span><span class="hljs-params">(Item &amp; item)</span></span>;          <span class="hljs-comment">// pop top into item</span><br>&#125;;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><br><span class="hljs-comment">// stack.cpp -- Stack member functions</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stack.h&quot;</span></span><br>Stack::<span class="hljs-built_in">Stack</span>()    <span class="hljs-comment">// create an empty stack</span><br>&#123;<br>    top = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Stack::isempty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> top == <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Stack::isfull</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> top == MAX;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Stack::push</span><span class="hljs-params">(<span class="hljs-type">const</span> Item &amp; item)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (top &lt; MAX)<br>    &#123;<br>        items[top++] = item;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Stack::pop</span><span class="hljs-params">(Item &amp; item)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (top &gt; <span class="hljs-number">0</span>)<br>    &#123;<br>        item = items[--top];<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><p>在第十章书中给出了针对<code>unsigned long</code>类型的栈数据结构示例，此处不再解释具体代码的含义。</p></blockquote><h3 id="The-Definition"><a href="#The-Definition" class="headerlink" title="The Definition"></a>The Definition</h3><p>我们先给出模板类的头文件声明，读者可以自行比较有哪边进行了修改：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Type</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Stack</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">enum</span> &#123;SIZE = <span class="hljs-number">10</span>&#125;;    <span class="hljs-comment">// default size</span><br>    <span class="hljs-type">int</span> stacksize;<br>    Type * items;       <span class="hljs-comment">// holds stack items</span><br>    <span class="hljs-comment">//在这里优化为了指针，更加的高效（相比使用数组存储）</span><br>    <span class="hljs-type">int</span> top;            <span class="hljs-comment">// index for top stack item</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Stack</span><span class="hljs-params">(<span class="hljs-type">int</span> ss = SIZE)</span></span>;<br>    <span class="hljs-built_in">Stack</span>(<span class="hljs-type">const</span> Stack &amp; st);<br>    ~<span class="hljs-built_in">Stack</span>() &#123; <span class="hljs-keyword">delete</span> [] items; &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isempty</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> top == <span class="hljs-number">0</span>; &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isfull</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> top == stacksize; &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">const</span> Type &amp; item)</span></span>;   <span class="hljs-comment">// add item to stack</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">pop</span><span class="hljs-params">(Type &amp; item)</span></span>;          <span class="hljs-comment">// pop top into item</span><br>    Stack &amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Stack &amp; st);<br>&#125;;<br></code></pre></td></tr></table></figure><p>采用模板时，将使用模板定义替换 <code>Stack</code> 声明，使用模板成员函数替换 <code>Stack</code> 的成员函数。和模板函数一样，模板类以下面这样的代码开头 :<code>template &lt;class Type&gt;</code>。</p><p>剩下的操作基本上没什么区别了。（因为定义类在很大程度上就是定义成员函数和方法。那定义模版类就是定义模版函数的过程）</p><p>接下来我们来看类方法的定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Type</span>&gt;<br>    <span class="hljs-comment">//这一行必不可少（相当于定义模版函数的过程）</span><br>Stack&lt;Type&gt;::<span class="hljs-built_in">Stack</span>(<span class="hljs-type">int</span> ss) : <span class="hljs-built_in">stacksize</span>(ss), <span class="hljs-built_in">top</span>(<span class="hljs-number">0</span>)<br>&#123;<br>    items = <span class="hljs-keyword">new</span> Type [stacksize];<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Type</span>&gt;<br>Stack&lt;Type&gt;::<span class="hljs-built_in">Stack</span>(<span class="hljs-type">const</span> Stack &amp; st)<br>&#123;<br>    stacksize = st.stacksize;<br>    top = st.top;<br>    items = <span class="hljs-keyword">new</span> Type [stacksize];<br>    <span class="hljs-comment">//使用动态内存分配，注意指针的安全使用！</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; top; i++)<br>        items[i] = st.items[i];<br>&#125;<br><span class="hljs-comment">//这个显示复制构造函数也是为了指针栈的使用（后文会提到）</span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Type</span>&gt;<br><span class="hljs-type">bool</span> Stack&lt;Type&gt;::<span class="hljs-built_in">push</span>(<span class="hljs-type">const</span> Type &amp; item)<br>&#123;<br>    <span class="hljs-keyword">if</span> (top &lt; stacksize)<br>    &#123;<br>        items[top++] = item;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Type</span>&gt;<br><span class="hljs-type">bool</span> Stack&lt;Type&gt;::<span class="hljs-built_in">pop</span>(Type &amp; item)<br>&#123;<br>    <span class="hljs-keyword">if</span> (top &gt; <span class="hljs-number">0</span>)<br>    &#123;<br>        item = items[--top];<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Type</span>&gt;<br>Stack&lt;Type&gt; &amp; Stack&lt;Type&gt;::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Stack&lt;Type&gt; &amp; st)<br>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;st)<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    <span class="hljs-keyword">delete</span> [] items;<br>    stacksize = st.stacksize;<br>    top = st.top;<br>    items = <span class="hljs-keyword">new</span> Type [stacksize];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; top; i++)<br>        items[i] = st.items[i];<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>; <br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br></code></pre></td></tr></table></figure><div class="note note-info">            <p>类模板的成员函数本身不是一个函数，故不可以<strong>单独编译</strong>，需要在指定模版形式参数的值后（即实现<strong>模版的实例化</strong>后）才能被编译成一个程序。因此，对于类模版而言，往往将<strong>函数定义和类模板的定义</strong>写在同一个头文件中。</p>          </div><h3 id="The-Use-of-Pointer-Stack"><a href="#The-Use-of-Pointer-Stack" class="headerlink" title="The Use of Pointer Stack"></a>The Use of Pointer Stack</h3><p>细心的读者可能会发现，在模版类的函数定义中，多出了这样一个函数（对赋值运算符的运算符重载）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++">Stack &amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Stack &amp; st);<br><span class="hljs-comment">//在public中的函数声明</span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Type</span>&gt;<br>Stack&lt;Type&gt; &amp; Stack&lt;Type&gt;::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Stack&lt;Type&gt; &amp; st)<br>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;st)<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    <span class="hljs-keyword">delete</span> [] items;<br>    stacksize = st.stacksize;<br>    top = st.top;<br>    items = <span class="hljs-keyword">new</span> Type [stacksize];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; top; i++)<br>        items[i] = st.items[i];<br>    <span class="hljs-comment">//考虑到如果数据类型为指针，直接整块赋值会产生非常严重的问题。</span><br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>; <br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>同时，对构造函数和析构函数的定义也做出了相关修改。</p></blockquote><p>为什么要做这样一个修改？<strong>模板类和模版函数非常重要的一点就是模版必须具有通用性</strong>（也可以使用<strong>显示具体化</strong>来为特殊类型打补丁，后文会讲到）。如果模板类型是<strong>指针</strong>（即<strong>指针栈</strong>），那么使用默认的赋值运算符会产生比较严重的问题。</p><blockquote><p>什么严重的问题？欢迎参考第十二章有关动态内存分配的知识，此处不再展开。</p><p><a href="https://xiyuanyang-code.github.io/posts/Dynamic-Memory-and-Classes/">我的博客链接</a></p></blockquote><h4 id="正确使用指针栈"><a href="#正确使用指针栈" class="headerlink" title="正确使用指针栈"></a>正确使用指针栈</h4><p>使用指针栈的方法之一是，让调用程序提供一个指针数组，其中每个指针都指向不同的字符串。把这些指针放在栈中是有意义的，因为每个指针都将指向不同的字符串。注意，创建不同指针是调用程序的职责，而不是栈的职责。<strong>栈的任务是管理指针，而不是创建指针</strong>。  </p><h3 id="Advanced-Usage"><a href="#Advanced-Usage" class="headerlink" title="Advanced Usage"></a>Advanced Usage</h3><h4 id="非类型参数"><a href="#非类型参数" class="headerlink" title="非类型参数"></a>非类型参数</h4><p>在使用模板类的时候，我们通过构造函数在堆上动态分配内存，这样的效率往往比较低。如果<strong>在确定具体类型之后再栈上开辟空间，将会变得更加的高效。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//arraytp.h  -- Array Template</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> ARRAYTP_H_</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ARRAYTP_H_</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>, <span class="hljs-type">int</span> n&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayTP</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>    T ar[n];<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">ArrayTP</span>() &#123;&#125;;<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">ArrayTP</span><span class="hljs-params">(<span class="hljs-type">const</span> T &amp; v)</span></span>;<br>    <span class="hljs-keyword">virtual</span> T &amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> i);<br>    <span class="hljs-keyword">virtual</span> T <span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> i) <span class="hljs-type">const</span>;<br>&#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>, <span class="hljs-type">int</span> n&gt;<br>ArrayTP&lt;T,n&gt;::<span class="hljs-built_in">ArrayTP</span>(<span class="hljs-type">const</span> T &amp; v)<br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        ar[i] = v;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>, <span class="hljs-type">int</span> n&gt;<br>T &amp; ArrayTP&lt;T,n&gt;::<span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> i)<br>&#123;<br>    <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || i &gt;= n)<br>    &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;Error in array limits: &quot;</span> &lt;&lt; i<br>            &lt;&lt; <span class="hljs-string">&quot; is out of range\n&quot;</span>;<br>        std::<span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ar[i];<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>, <span class="hljs-type">int</span> n&gt;<br>T ArrayTP&lt;T,n&gt;::<span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> i) <span class="hljs-type">const</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || i &gt;= n)<br>    &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;Error in array limits: &quot;</span> &lt;&lt; i<br>            &lt;&lt; <span class="hljs-string">&quot; is out of range\n&quot;</span>;<br>        std::<span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ar[i]; <br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p><code>template &lt;class T, int n&gt;</code> 是 C++ 中的一种模板声明方式，其中包含了两种不同类型的模板参数：</p><ul><li><strong><code>T</code><strong>：这是一个</strong>类型模板参数</strong>（Type Template Parameter），表示一个类型，通常用来代表类、结构体、函数等的类型。</li><li><strong><code>n</code><strong>：这是一个</strong>非类型模板参数</strong>（Non-type Template Parameter），表示一个常量值，通常是整数、指针、引用或其他常量值。</li></ul><p><img src="/posts/Code-Reuse-in-OOP/biaodashi.png" alt="表达式参数"></p><p>缺点是，在<code>n</code>不相同的情况下，编译器会生成两种不同的模版（<strong>哪怕非类型模版参数是相同的</strong>）。非类型参数的使用本质是更改了内存的存储方式，在提升效率的同时牺牲了部分的通用性。（无法创建数组大小可变的类了）</p><h4 id="递归使用模板"><a href="#递归使用模板" class="headerlink" title="递归使用模板"></a>递归使用模板</h4><p><code>ArrayTP&lt; ArrayTP&lt;int,5&gt;, 10&gt; twodee;</code></p><h4 id="pair类"><a href="#pair类" class="headerlink" title="pair类"></a>pair类</h4><div class="note note-info">            <p><code>std::pair</code> 是 C++ 标准库中的一个模板类，用于存储两个不同类型的元素。它可以将两个数据组合成一个对象，这两个数据可以是任意类型，因此 <code>std::pair</code> 是一种非常常见的<strong>通用容器</strong>，特别适用于需要将两个相关数据关联在一起的场景。</p><p><code>std::pair</code> 定义在 <code>&lt;utility&gt;</code> 头文件中，其模板定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span>&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">pair</span> &#123;<br>    T1 first;   <span class="hljs-comment">// 第一个元素</span><br>    T2 second;  <span class="hljs-comment">// 第二个元素</span><br><br>    <span class="hljs-comment">// 默认构造函数</span><br>    <span class="hljs-built_in">pair</span>();<br>    <br>    <span class="hljs-comment">// 带参数的构造函数</span><br>    <span class="hljs-built_in">pair</span>(<span class="hljs-type">const</span> T1&amp; a, <span class="hljs-type">const</span> T2&amp; b);<br>    <br>    <span class="hljs-comment">// 构造函数（使用移动语义）</span><br>    <span class="hljs-built_in">pair</span>(T1&amp;&amp; a, T2&amp;&amp; b);<br><br>    <span class="hljs-comment">// 比较运算符</span><br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> pair&amp; other) <span class="hljs-type">const</span>;<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-type">const</span> pair&amp; other) <span class="hljs-type">const</span>;<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> pair&amp; other) <span class="hljs-type">const</span>;<br>    <span class="hljs-type">bool</span> <span class="hljs-built_in">operator</span>&lt;=(<span class="hljs-type">const</span> pair&amp; other) <span class="hljs-type">const</span>;<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&gt;(<span class="hljs-type">const</span> pair&amp; other) <span class="hljs-type">const</span>;<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&gt;=(<span class="hljs-type">const</span> pair&amp; other) <span class="hljs-type">const</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p><code>std::pair</code> 存储两个值：<code>first</code> 和 <code>second</code>，它们可以是不同类型的数据。<code>T1</code> 是第一个元素的类型，<code>T2</code> 是第二个元素的类型。</p><ul><li><p><strong>默认构造函数</strong>：<code>pair</code> 的两个成员 <code>first</code> 和 <code>second</code> 都会被默认初始化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">double</span>&gt; p1;  <span class="hljs-comment">// p1.first 和 p1.second 都是默认初始化</span><br></code></pre></td></tr></table></figure></li><li><p><strong>带参构造函数</strong>：通过提供两个值初始化 <code>first</code> 和 <code>second</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">double</span>&gt; <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">3.14</span>)</span></span>;  <span class="hljs-comment">// p2.first = 1, p2.second = 3.14</span><br></code></pre></td></tr></table></figure></li><li><p><strong>拷贝构造函数</strong>：允许使用另一个 <code>pair</code> 来初始化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">double</span>&gt; p3 = p2;  <span class="hljs-comment">// p3.first = p2.first, p3.second = p2.second</span><br></code></pre></td></tr></table></figure></li><li><p><strong>移动构造函数</strong>：允许通过右值引用来初始化（C++11 引入的特性）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">double</span>&gt; p4 = std::<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20.5</span>);<br></code></pre></td></tr></table></figure></li></ul><p><strong>操作：</strong></p><ul><li><p><strong>访问成员</strong>：<code>pair</code> 提供了两个公共成员变量 <code>first</code> 和 <code>second</code>，可以直接访问。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">double</span>&gt; <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">3.14</span>)</span></span>;<br>std::cout &lt;&lt; p.first &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; p.second &lt;&lt; std::endl;  <span class="hljs-comment">// 输出: 1, 3.14</span><br></code></pre></td></tr></table></figure></li><li><p>**<code>std::make_pair</code>**：<code>make_pair</code> 是一个方便的函数模板，用于创建 <code>pair</code> 对象，避免手动指定类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> p = std::<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">1</span>, <span class="hljs-number">3.14</span>);  <span class="hljs-comment">// p 是 pair&lt;int, double&gt;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>比较操作符</strong>：<code>pair</code> 支持常见的比较操作符（<code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>）。比较时，<code>pair</code> 会首先比较 <code>first</code>，如果相等，则再比较 <code>second</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">double</span>&gt; <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">3.14</span>)</span>, <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2.718</span>)</span></span>;<br><span class="hljs-keyword">if</span> (p1 &lt; p2) &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;p1 &lt; p2&quot;</span> &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>交换元素</strong>：<code>std::pair</code> 提供了一个 <code>swap</code> 方法用于交换 <code>first</code> 和 <code>second</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">double</span>&gt; <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">3.14</span>)</span>, <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-number">2</span>, <span class="hljs-number">2.718</span>)</span></span>;<br>p<span class="hljs-number">1.</span><span class="hljs-built_in">swap</span>(p2);  <span class="hljs-comment">// 交换 p1 和 p2 的值</span><br></code></pre></td></tr></table></figure></li></ul><p><strong>使用场景</strong></p><p><code>std::pair</code> 经常用于以下场景：</p><ul><li><p><strong>返回多个值</strong>：有时我们需要返回多个相关的值（例如，函数返回两个值），<code>std::pair</code> 是一个非常方便的方式来做到这一点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">double</span>&gt; <span class="hljs-title">get_coordinates</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20.5</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>在容器中存储键值对</strong>：例如，<code>std::map</code> 和 <code>std::unordered_map</code> 等容器使用 <code>std::pair</code> 来存储键值对。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::map&lt;<span class="hljs-type">int</span>, std::string&gt; m;<br>m[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;apple&quot;</span>;<br>m[<span class="hljs-number">2</span>] = <span class="hljs-string">&quot;banana&quot;</span>;<br></code></pre></td></tr></table></figure></li><li><p><strong>配对数据</strong>：在某些算法或数据结构中，两个相关的数据项经常被配对在一起。<code>std::pair</code> 允许你简洁地存储和访问它们。</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span>  <span class="hljs-comment">// 引入 std::pair 和 std::make_pair</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 创建一个 pair</span><br>    <span class="hljs-function">std::pair&lt;<span class="hljs-type">int</span>, std::string&gt; <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;apple&quot;</span>)</span></span>;<br><br>    <span class="hljs-comment">// 访问 pair 的元素</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;First: &quot;</span> &lt;&lt; p<span class="hljs-number">1.f</span>irst &lt;&lt; <span class="hljs-string">&quot;, Second: &quot;</span> &lt;&lt; p<span class="hljs-number">1.</span>second &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 使用 std::make_pair 创建一个 pair</span><br>    <span class="hljs-keyword">auto</span> p2 = std::<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;banana&quot;</span>);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;First: &quot;</span> &lt;&lt; p<span class="hljs-number">2.f</span>irst &lt;&lt; <span class="hljs-string">&quot;, Second: &quot;</span> &lt;&lt; p<span class="hljs-number">2.</span>second &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 比较两个 pair</span><br>    <span class="hljs-keyword">if</span> (p1 &lt; p2) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;p1 is less than p2&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-comment">// 交换两个 pair</span><br>    p<span class="hljs-number">1.</span><span class="hljs-built_in">swap</span>(p2);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;After swap: &quot;</span> &lt;&lt; <span class="hljs-string">&quot;First: &quot;</span> &lt;&lt; p<span class="hljs-number">1.f</span>irst &lt;&lt; <span class="hljs-string">&quot;, Second: &quot;</span> &lt;&lt; p<span class="hljs-number">1.</span>second &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;After swap: &quot;</span> &lt;&lt; <span class="hljs-string">&quot;First: &quot;</span> &lt;&lt; p<span class="hljs-number">2.f</span>irst &lt;&lt; <span class="hljs-string">&quot;, Second: &quot;</span> &lt;&lt; p<span class="hljs-number">2.</span>second &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">First</span>: <span class="hljs-number">1</span>, <span class="hljs-keyword">Second</span>: apple<br><span class="hljs-keyword">First</span>: <span class="hljs-number">2</span>, <span class="hljs-keyword">Second</span>: banana<br>p1 <span class="hljs-keyword">is</span> less than p2<br>After swap: <span class="hljs-keyword">First</span>: <span class="hljs-number">2</span>, <span class="hljs-keyword">Second</span>: banana<br>After swap: <span class="hljs-keyword">First</span>: <span class="hljs-number">1</span>, <span class="hljs-keyword">Second</span>: apple<br></code></pre></td></tr></table></figure>          </div><div class="note note-info">            <h4 id="tuple和tie（补充知识）"><a href="#tuple和tie（补充知识）" class="headerlink" title="tuple和tie（补充知识）"></a>tuple和tie（补充知识）</h4><h5 id="打包函数：std-tie"><a href="#打包函数：std-tie" class="headerlink" title="打包函数：std::tie"></a>打包函数：<code>std::tie</code></h5><p><code>std::tie</code> 是 C++11 引入的一个非常强大且方便的工具，它可以将多个值打包成一个元组，并使得这些值能够像元组一样被进行比较、解构或传递。它在多个方面提供了便利，以下是其强大之处：</p><ol><li><strong>简化多重比较</strong></li></ol><p><code>std::tie</code> 可以将多个变量组合成一个元组，然后直接进行比较。这样，我们可以避免手动写出冗长的多重 <code>if</code> 语句来比较多个值。例如，比较结构体中的多个成员时，<code>std::tie</code> 可以将多个成员打包，按字典顺序（lexicographical order）进行比较。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span> &#123;<br>    <span class="hljs-type">int</span> x, y, z;<br>&#125;;<br><br><span class="hljs-comment">// 使用 std::tie 对 Point 进行比较</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-type">const</span> Point&amp; p1, <span class="hljs-type">const</span> Point&amp; p2)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">tie</span>(p<span class="hljs-number">1.</span>x, p<span class="hljs-number">1.</span>y, p<span class="hljs-number">1.</span>z) &lt; std::<span class="hljs-built_in">tie</span>(p<span class="hljs-number">2.</span>x, p<span class="hljs-number">2.</span>y, p<span class="hljs-number">2.</span>z);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的比较会首先比较 <code>x</code>，如果 <code>x</code> 相同，再比较 <code>y</code>，如果 <code>y</code> 也相同，则比较 <code>z</code>。<strong>这是一个典型的按字典顺序的比较</strong>。</p><ol start="2"><li><strong>简化排序操作</strong></li></ol><p>通过 <code>std::tie</code>，你可以在排序操作中直接比较多个字段，而无需手动指定每个字段的比较方式。比如在 <code>std::sort</code> 中进行排序时，使用 <code>std::tie</code> 让代码更加简洁且易于维护。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;Point&gt; points = &#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;, &#123;<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;&#125;;<br>std::<span class="hljs-built_in">sort</span>(points.<span class="hljs-built_in">begin</span>(), points.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">const</span> Point&amp; p1, <span class="hljs-type">const</span> Point&amp; p2) &#123;<br>    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">tie</span>(p<span class="hljs-number">1.</span>x, p<span class="hljs-number">1.</span>y, p<span class="hljs-number">1.</span>z) &lt; std::<span class="hljs-built_in">tie</span>(p<span class="hljs-number">2.</span>x, p<span class="hljs-number">2.</span>y, p<span class="hljs-number">2.</span>z);<br>&#125;);<br></code></pre></td></tr></table></figure><p>这样，排序时就不需要多个嵌套的 <code>if</code> 语句来分别比较 <code>x</code>, <code>y</code>, <code>z</code>。<code>std::tie</code> 会自动按字段顺序进行比较。</p><ol start="3"><li><strong>方便的结构体解构</strong></li></ol><p><code>std::tie</code> 不仅可以用于比较，还可以用于解构，特别是在函数中返回多个值时，或者从一个元组中提取值时。它让你可以直接将多个值赋给多个变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::tuple&lt;<span class="hljs-type">int</span>, <span class="hljs-type">double</span>, std::string&gt; <span class="hljs-title">getValues</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">make_tuple</span>(<span class="hljs-number">1</span>, <span class="hljs-number">3.14</span>, <span class="hljs-string">&quot;hello&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-type">double</span> d;<br>    std::string s;<br>    std::<span class="hljs-built_in">tie</span>(i, d, s) = <span class="hljs-built_in">getValues</span>();  <span class="hljs-comment">// 直接解构</span><br>    std::cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; d &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; s &lt;&lt; std::endl;  <span class="hljs-comment">// 输出: 1 3.14 hello</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这样，你就可以将一个元组中的元素直接解构到不同的变量中，而不需要手动访问每个元素。</p><ol start="4"><li><strong>元组和非元组类型的统一接口</strong></li></ol><p><code>std::tie</code> 的强大之处还在于它能够与普通类型（如 <code>int</code>，<code>double</code> 等）和标准库类型（如 <code>std::tuple</code>）无缝结合。这使得你在处理多个返回值时非常方便。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a = <span class="hljs-number">5</span>;<br><span class="hljs-type">double</span> b = <span class="hljs-number">3.14</span>;<br>std::<span class="hljs-built_in">tie</span>(a, b) = std::<span class="hljs-built_in">make_tuple</span>(<span class="hljs-number">10</span>, <span class="hljs-number">2.718</span>);  <span class="hljs-comment">// 可以直接解构元组</span><br></code></pre></td></tr></table></figure><ol start="5"><li><strong>更灵活的函数返回值</strong></li></ol><p>当你需要一个函数返回多个值时，<code>std::tie</code> 可以帮助你轻松解构并同时返回多个值，而不需要使用 <code>std::pair</code> 或 <code>std::tuple</code> 来包裹它们。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::tuple&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; <span class="hljs-title">divide</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">make_tuple</span>(a / b, a % b);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> quotient, remainder;<br>    std::<span class="hljs-built_in">tie</span>(quotient, remainder) = <span class="hljs-built_in">divide</span>(<span class="hljs-number">10</span>, <span class="hljs-number">3</span>);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Quotient: &quot;</span> &lt;&lt; quotient &lt;&lt; <span class="hljs-string">&quot;, Remainder: &quot;</span> &lt;&lt; remainder &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="std-tuple"><a href="#std-tuple" class="headerlink" title="std::tuple"></a><code>std::tuple</code></h5><p><code>std::tuple</code> 是 C++11 引入的一个标准库容器，它允许你存储多个不同类型的元素，类似于数组或结构体，但与这两者不同的是，<code>std::tuple</code> 的元素可以是不同类型的。换句话说，<code>tuple</code> 可以看作是一个异构的容器，即它可以存储多个不同类型的值，而不像数组那样只能存储相同类型的元素。</p><ul><li><strong>异构性</strong>：<code>std::tuple</code> 可以包含不同类型的元素（如 <code>int</code>、<code>double</code>、<code>std::string</code> 等），而不像 <code>std::vector</code> 或 <code>std::array</code> 这样的容器只能包含相同类型的元素。</li><li><strong>固定大小</strong>：<code>std::tuple</code> 的大小在编译时就确定了，无法动态改变大小。也就是说，它的大小（即元素的个数）是固定的。</li><li><strong>元素访问</strong>：可以通过索引或者 <code>std::get</code> 来访问 <code>tuple</code> 中的元素。</li></ul><p>你可以通过 <code>std::make_tuple</code> 或直接使用构造函数来创建 <code>tuple</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;tuple&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 创建一个 tuple，包含不同类型的元素</span><br>    <span class="hljs-function">std::tuple&lt;<span class="hljs-type">int</span>, <span class="hljs-type">double</span>, std::string&gt; <span class="hljs-title">t</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">3.14</span>, <span class="hljs-string">&quot;Hello&quot;</span>)</span></span>;<br><br>    <span class="hljs-comment">// 通过 std::get 访问 tuple 中的元素</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;First element: &quot;</span> &lt;&lt; std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">0</span>&gt;(t) &lt;&lt; std::endl;  <span class="hljs-comment">// 输出 10</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Second element: &quot;</span> &lt;&lt; std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">1</span>&gt;(t) &lt;&lt; std::endl; <span class="hljs-comment">// 输出 3.14</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Third element: &quot;</span> &lt;&lt; std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">2</span>&gt;(t) &lt;&lt; std::endl;  <span class="hljs-comment">// 输出 Hello</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>t</code> 是一个包含三个元素的 <code>tuple</code>，它的元素分别是 <code>int</code>、<code>double</code> 和 <code>std::string</code> 类型。</p><p><strong>获取 <code>tuple</code> 中的元素：</strong></p><p>使用 <code>std::get&lt;index&gt;(tuple)</code> 来访问特定位置的元素。索引是编译时确定的，因此使用时需要指定元素的类型或位置。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::tuple&lt;<span class="hljs-type">int</span>, <span class="hljs-type">double</span>, std::string&gt; <span class="hljs-title">t</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">3.14</span>, <span class="hljs-string">&quot;Hello&quot;</span>)</span></span>;<br><br><span class="hljs-comment">// 使用 std::get 获取元素</span><br><span class="hljs-type">int</span> i = std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">0</span>&gt;(t);           <span class="hljs-comment">// 获取第一个元素</span><br><span class="hljs-type">double</span> d = std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">1</span>&gt;(t);        <span class="hljs-comment">// 获取第二个元素</span><br>std::string s = std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">2</span>&gt;(t);   <span class="hljs-comment">// 获取第三个元素</span><br></code></pre></td></tr></table></figure><p><strong>获取 <code>tuple</code> 的大小：</strong></p><p>你可以使用 <code>std::tuple_size</code> 来获取 <code>tuple</code> 中元素的个数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::tuple&lt;<span class="hljs-type">int</span>, <span class="hljs-type">double</span>, std::string&gt; <span class="hljs-title">t</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">3.14</span>, <span class="hljs-string">&quot;Hello&quot;</span>)</span></span>;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;Tuple size: &quot;</span> &lt;&lt; std::tuple_size&lt;<span class="hljs-keyword">decltype</span>(t)&gt;::value &lt;&lt; std::endl;  <span class="hljs-comment">// 输出 3</span><br></code></pre></td></tr></table></figure><p><strong>解构 <code>tuple</code>：</strong></p><p>你可以使用 <code>std::tie</code> 来解构 <code>tuple</code> 中的值，或者直接通过 <code>std::get</code> 提取多个值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::tuple&lt;<span class="hljs-type">int</span>, <span class="hljs-type">double</span>, std::string&gt; <span class="hljs-title">t</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">3.14</span>, <span class="hljs-string">&quot;Hello&quot;</span>)</span></span>;<br><br><span class="hljs-comment">// 解构 tuple</span><br><span class="hljs-type">int</span> a;<br><span class="hljs-type">double</span> b;<br>std::string c;<br>std::<span class="hljs-built_in">tie</span>(a, b, c) = t;<br><br>std::cout &lt;&lt; <span class="hljs-string">&quot;a: &quot;</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot;, b: &quot;</span> &lt;&lt; b &lt;&lt; <span class="hljs-string">&quot;, c: &quot;</span> &lt;&lt; c &lt;&lt; std::endl;<br></code></pre></td></tr></table></figure><p><strong>scenario：</strong></p><ol><li><p><strong>函数返回多个值</strong>：使用 <code>tuple</code> 可以方便地在函数中返回多个不同类型的值，而无需创建自定义结构体。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::tuple&lt;<span class="hljs-type">int</span>, <span class="hljs-type">double</span>&gt; <span class="hljs-title">getValues</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">make_tuple</span>(<span class="hljs-number">10</span>, <span class="hljs-number">3.14</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> values = <span class="hljs-built_in">getValues</span>();<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;First value: &quot;</span> &lt;&lt; std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">0</span>&gt;(values) &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Second value: &quot;</span> &lt;&lt; std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">1</span>&gt;(values) &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>存储异构数据</strong>：当你需要存储异构数据（不同类型的元素）时，<code>tuple</code> 是一个非常方便的选择。例如，可以用它来存储一个人的年龄、名字和身高等不同类型的数据。</p></li><li><p><strong>元组解构和泛型编程</strong>：<code>std::tuple</code> 常用于模板编程中，特别是在处理多类型的返回值或元组解构时，能够提供强大的灵活性。</p></li></ol>          </div><h4 id="模版的实例化和具体化"><a href="#模版的实例化和具体化" class="headerlink" title="模版的实例化和具体化"></a>模版的实例化和具体化</h4><h5 id="隐式实例化"><a href="#隐式实例化" class="headerlink" title="隐式实例化"></a>隐式实例化</h5><p>函数模板的实例化通常由<strong>编译器自动完成</strong>， 编译器根据函数调用时的实际参数类型推断出模板参数的值，将模板参数的值代入函数模板，从而生成一个可执行的模板函数。类模板没这么幸运。编译器无法根据对象定义确定模板实际参数值。例如，定义 <code>Array</code> 类对象时给出的是代表数组下标范围的两个整数， 从中无法推断数组元素的类型，因而需要<strong>定义对象时明确指出模板实际参数的值</strong>。</p><p>以<code>std::vector</code>为例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">thetest</span><span class="hljs-params">(<span class="hljs-number">5</span>,<span class="hljs-number">3</span>)</span></span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> num:thetest)&#123;<br>        cout&lt;&lt;num&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*输出结果</span><br><span class="hljs-comment">3</span><br><span class="hljs-comment">3</span><br><span class="hljs-comment">3</span><br><span class="hljs-comment">3</span><br><span class="hljs-comment">3</span><br><span class="hljs-comment">*/</span><br><br></code></pre></td></tr></table></figure><p>在初始化一个<code>vector</code>对象的时候，我们需要<strong>给出类模板的实际参数表</strong>（即<code>class Type</code>）到底是什么，编译器才会<strong>隐式的根据我们的提示生成对应的示例类和对象</strong>。</p><p>如果使用<code>vector thetest(5,3);</code>的方式进行定义，会产生如下报错：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">testcode_1.cpp: In <span class="hljs-keyword">function</span> <span class="hljs-string">&#x27;int main()&#x27;</span>:<br>testcode_1.cpp:15:12: error: missing template arguments before <span class="hljs-string">&#x27;thetest&#x27;</span><br>     vector thetest(5,3);<br>            ^~~~~~~<br>testcode_1.cpp:16:18: error: <span class="hljs-string">&#x27;thetest&#x27;</span> was not declared <span class="hljs-keyword">in</span> this scope<br>     <span class="hljs-keyword">for</span>(auto num:thetest)&#123;<br>                  ^~~~~~~<br>testcode_1.cpp:16:18: note: suggested alternative: <span class="hljs-string">&#x27;_heapset&#x27;</span><br>     <span class="hljs-keyword">for</span>(auto num:thetest)&#123;<br>                  ^~~~~~~<br>                  _heapset<br></code></pre></td></tr></table></figure><h5 id="显示实例化"><a href="#显示实例化" class="headerlink" title="显示实例化"></a>显示实例化</h5><p>当使用关键词<code>template</code>并指出所需类型来声明类的时候，编译器会生成<strong>类声明的显式实例化</strong>。显式实例化通知编译器生成类模板的完整实例。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Array</span>&#123;<br>    <span class="hljs-comment">//模版类的声明</span><br>&#125;<br><br><br><span class="hljs-keyword">template</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Array</span>&lt;<span class="hljs-type">double</span>&gt;;<br><span class="hljs-comment">//显式实例化生成具体的类</span><br></code></pre></td></tr></table></figure><h5 id="显示具体化（Explicit-Specialization）"><a href="#显示具体化（Explicit-Specialization）" class="headerlink" title="显示具体化（Explicit Specialization）"></a>显示具体化（Explicit Specialization）</h5><p>显式具体化是指特定类型（用于<strong>替换模版中的泛型</strong>）的定义。这一种操作为泛型模版提供了更灵活的可操作性。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Generic version&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 显式特化：针对int类型</span><br><span class="hljs-keyword">template</span> &lt;&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>&lt;<span class="hljs-type">int</span>&gt; &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Specialized version for int&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    MyClass&lt;<span class="hljs-type">double</span>&gt; obj1; <span class="hljs-comment">// 调用通用版本</span><br>    obj<span class="hljs-number">1.</span><span class="hljs-built_in">print</span>();<br>    <br>    MyClass&lt;<span class="hljs-type">int</span>&gt; obj2; <span class="hljs-comment">// 调用针对int类型的特化版本</span><br>    obj<span class="hljs-number">2.</span><span class="hljs-built_in">print</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h5 id="部分具体化（Partial-Specialization）"><a href="#部分具体化（Partial-Specialization）" class="headerlink" title="部分具体化（Partial Specialization）"></a>部分具体化（Partial Specialization）</h5><p>部分特化是指对<strong>模板参数的某些部分进行特化</strong>，而不需要完全特化整个模板。它允许针对一些特定的类型组合或模板参数条件进行特定实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Generic version&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 部分特化：针对T是指针类型的情况</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>&lt;T*, <span class="hljs-type">int</span>&gt; &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Specialized version for pointer and int&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    MyClass&lt;<span class="hljs-type">double</span>, <span class="hljs-type">int</span>&gt; obj1; <span class="hljs-comment">// 调用通用版本</span><br>    obj<span class="hljs-number">1.</span><span class="hljs-built_in">print</span>();<br>    <br>    MyClass&lt;<span class="hljs-type">int</span>*, <span class="hljs-type">int</span>&gt; obj2; <span class="hljs-comment">// 调用部分特化版本</span><br>    obj<span class="hljs-number">2.</span><span class="hljs-built_in">print</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Bash">Generic version<br>Specialized version <span class="hljs-keyword">for</span> pointer and int<br></code></pre></td></tr></table></figure><h4 id="成员模版"><a href="#成员模版" class="headerlink" title="成员模版"></a>成员模版</h4><p>模板可用作<strong>结构、类或模板类的成员</strong>。要完全实现 STL 的设计，必须使用这项特性。  </p><p><strong>成员模板（Member Template）</strong>是 C++ 中的一种功能，允许<strong>在类中定义模板成员函数</strong>。这样，类的成员函数可以根据调用时的类型自动实例化，具备模板的灵活性。</p><p>成员模板的主要作用是实现根据不同类型提供不同实现的功能，而不需要为每种类型手动编写多个成员函数。成员模板与类模板的结合使用，可以让类对不同类型的对象和数据进行通用处理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 成员模板函数</span><br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> U&gt;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(U value)</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Value: &quot;</span> &lt;&lt; value &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    MyClass&lt;<span class="hljs-type">int</span>&gt; obj;<br>    obj.<span class="hljs-built_in">print</span>(<span class="hljs-number">42</span>);       <span class="hljs-comment">// 传入 int 类型</span><br>    obj.<span class="hljs-built_in">print</span>(<span class="hljs-number">3.14</span>);     <span class="hljs-comment">// 传入 double 类型</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>MyClass</code> 是一个类模板，接受一个类型 <code>T</code>。</li><li><code>print</code> 是一个成员模板函数，接受任意类型 <code>U</code> 的参数。</li><li>在 <code>main</code> 函数中，分别用 <code>int</code> 和 <code>double</code> 类型调用 <code>print</code>，成员模板会根据传入类型进行实例化。</li></ul><ol><li><strong>模板参数化成员函数</strong>：成员模板使得同一个成员函数可以根据调用的类型实例化不同的实现。</li><li><strong>灵活性</strong>：可以使类的成员函数适应多种不同的数据类型，而不需要手动为每种类型编写重载函数。</li><li><strong>与类模板配合使用</strong>：通常<strong>成员模板</strong>是与<strong>类模板</strong>配合使用的，使得类和其成员函数都可以泛化。</li></ol><blockquote><p>成员模版相当于对类中的成员函数使用<strong>函数模版</strong>。C++泛型的两种<strong>模板机制</strong>在此刻得到了统一。</p></blockquote><p>我们来看一个更加复杂的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// tempmemb.cpp -- template members</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> std::cout;<br><span class="hljs-keyword">using</span> std::endl;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">beta</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> V&gt;  <span class="hljs-comment">// nested template class member</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">hold</span><br>    &#123;<br>    <span class="hljs-keyword">private</span>:<br>        V val;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">hold</span>(V v  = <span class="hljs-number">0</span>) : <span class="hljs-built_in">val</span>(v) &#123;&#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; cout &lt;&lt; val &lt;&lt; endl; &#125;<br>        <span class="hljs-function">V <span class="hljs-title">Value</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> val; &#125;<br>    &#125;;<br>    hold&lt;T&gt; q;             <span class="hljs-comment">// template object</span><br>    hold&lt;<span class="hljs-type">int</span>&gt; n;           <span class="hljs-comment">// template object</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">beta</span>( T t, <span class="hljs-type">int</span> i) : <span class="hljs-built_in">q</span>(t), <span class="hljs-built_in">n</span>(i) &#123;&#125;<br>    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> U&gt;   <span class="hljs-comment">// template method</span><br>    <span class="hljs-function">U <span class="hljs-title">blab</span><span class="hljs-params">(U u, T t)</span> </span>&#123; <span class="hljs-keyword">return</span> (n.<span class="hljs-built_in">Value</span>() + q.<span class="hljs-built_in">Value</span>()) * u / t; &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Show</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; q.<span class="hljs-built_in">show</span>(); n.<span class="hljs-built_in">show</span>();&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">beta&lt;<span class="hljs-type">double</span>&gt; <span class="hljs-title">guy</span><span class="hljs-params">(<span class="hljs-number">3.5</span>, <span class="hljs-number">3</span>)</span></span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;T was set to double\n&quot;</span>;<br>    guy.<span class="hljs-built_in">Show</span>();<br>    cout &lt;&lt; <span class="hljs-string">&quot;V was set to T, which is double, then V was set to int\n&quot;</span>;<br>    cout &lt;&lt; guy.<span class="hljs-built_in">blab</span>(<span class="hljs-number">10</span>, <span class="hljs-number">2.3</span>) &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;U was set to int\n&quot;</span>;<br>    cout &lt;&lt; guy.<span class="hljs-built_in">blab</span>(<span class="hljs-number">10.0</span>, <span class="hljs-number">2.3</span>) &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;U was set to double\n&quot;</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Done\n&quot;</span>;<br>    <span class="hljs-comment">// std::cin.get();</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>&#125;<br><br></code></pre></td></tr></table></figure><p>输出示例</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Bash">T was <span class="hljs-built_in">set</span> to double<br>3.5<br>3<br>V was <span class="hljs-built_in">set</span> to T, <span class="hljs-built_in">which</span> is double, <span class="hljs-keyword">then</span> V was <span class="hljs-built_in">set</span> to int<br>28<br>U was <span class="hljs-built_in">set</span> to int<br>28.2609<br>U was <span class="hljs-built_in">set</span> to double<br>Done<br></code></pre></td></tr></table></figure><p>模板类<code>hold</code>是<code>beta</code>类的私有成员，在此处一共定义了三个<strong>模版参数</strong>T，V和U，在main函数中，语句<code> beta&lt;double&gt; guy(3.5, 3);</code>将T设置为<code>double</code>类型，因此在guy（是一个beta类）中有两个数据成员：<code>hold&lt;double&gt;</code>和<code>hold&lt;int&gt;</code>。（在这里模版参数V先后被<strong>隐式实例化</strong>为<code>int</code>和<code>double</code>）接下来执行语句<code>guy.blab(10, 2.3)</code>，模版参数U被<strong>隐式实例化</strong>为<code>int</code>（<code>guy.blab(10, 2.3)</code>时也类似）。</p><h4 id="将模板用作参数"><a href="#将模板用作参数" class="headerlink" title="将模板用作参数"></a>将模板用作参数</h4><p>将模板用作参数（Template as a Parameter）是 C++ 中的一种技术，允许将模板本身作为函数、类或其他模板的参数。这种技术通常被称为 <strong>模板模板参数</strong>。它使得可以灵活地将一个模板传递给另一个模板，从而实现高度的泛化和定制化。</p><p>当你将模板用作参数时，你可以传递<strong>一个模板的类型</strong>，而不是实际的类型。这对于处理模板类或函数更加灵活，允许<strong>模板参数不仅是类型，还可以是其他模板类型</strong>。</p><blockquote><p>有一点套娃的感觉</p></blockquote><p><strong>示例 1：将模板作为函数参数</strong></p><p>下面的例子展示了如何将一个模板类作为另一个模板函数的参数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 模板类</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    T value;<br>    <span class="hljs-built_in">MyClass</span>(T v) : <span class="hljs-built_in">value</span>(v) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Value: &quot;</span> &lt;&lt; value &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 一个函数模板，接受模板类作为参数</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br>    <span class="hljs-comment">//这里模版参数T代表一个模版类(在后续main函数中，T被隐式实例化为MyClass这个模板类)</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">callTemplateClass</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">T&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">obj</span><span class="hljs-params">(<span class="hljs-number">42</span>)</span></span>;  <span class="hljs-comment">// 使用模板类 MyClass&lt;int&gt;</span><br>    obj.<span class="hljs-built_in">print</span>();     <span class="hljs-comment">// 输出 &quot;Value: 42&quot;</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">callTemplateClass</span>&lt;MyClass&gt;();  <span class="hljs-comment">// 调用时传递 MyClass 作为模板</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">Value: 42<br></code></pre></td></tr></table></figure><ul><li><code>MyClass</code> 是一个模板类，接受一个类型 <code>T</code>。</li><li><code>callTemplateClass</code> 是一个<strong>模板函数，接受一个模板类作为参数</strong>。<code>template &lt;template &lt;typename&gt; class T&gt;</code> 表示 <code>T</code> 是一个<strong>模板模板参数</strong>。</li><li>在 <code>main</code> 函数中，我们调用 <code>callTemplateClass&lt;MyClass&gt;()</code>，将 <code>MyClass</code> 作为模板传递给 <code>callTemplateClass</code> 函数。</li></ul><blockquote><p>这种规则本质上增添了<strong>模版参数的多样性和灵活性</strong>。</p></blockquote><p><strong>示例 2：将模板作为类参数</strong></p><p>模板也可以作为类的成员，允许类在定义时接受模板作为参数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 定义一个模板类</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    T value;<br>    <span class="hljs-built_in">MyClass</span>(T v) : <span class="hljs-built_in">value</span>(v) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Value: &quot;</span> &lt;&lt; value &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 定义一个类模板，接受模板作为参数</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Wrapper</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    T&lt;<span class="hljs-type">int</span>&gt; obj;  <span class="hljs-comment">// 用 T&lt;int&gt; 来实例化模板类</span><br>    <span class="hljs-built_in">Wrapper</span>(<span class="hljs-type">int</span> v) : <span class="hljs-built_in">obj</span>(v) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;<br>        obj.<span class="hljs-built_in">print</span>();<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">Wrapper&lt;MyClass&gt; <span class="hljs-title">w</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;  <span class="hljs-comment">// 传递 MyClass 作为模板</span><br>    w.<span class="hljs-built_in">print</span>();  <span class="hljs-comment">// 输出 &quot;Value: 10&quot;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>Wrapper</code> 是一个模板类，接受一个模板类作为参数（<code>template &lt;template &lt;typename&gt; class T&gt;</code>）。</li><li><code>Wrapper</code> 类使用 <code>T&lt;int&gt;</code> 来实例化模板类，并通过 <code>obj.print()</code> 来调用它的成员函数。</li><li>在 <code>main</code> 函数中，我们创建了 <code>Wrapper&lt;MyClass&gt;</code> 对象，将 <code>MyClass</code> 作为模板传递给 <code>Wrapper</code>。</li></ul><p><strong>使用模板作为参数的优点</strong></p><ol><li><strong>高度灵活性</strong>：允许传递不同的模板类或函数，增强代码的复用性。</li><li><strong>避免代码重复</strong>：通过接受模板模板参数，可以减少对同类逻辑的多次实现，只需一个模板就能处理不同的类型或类。</li><li><strong>泛化</strong>：通过使用模板模板参数，可以让代码对更多的类型和模板更加通用。</li></ol><h2 id="Friend-Functions-and-Friend-Class"><a href="#Friend-Functions-and-Friend-Class" class="headerlink" title="Friend Functions and Friend Class"></a>Friend Functions and Friend Class</h2><h3 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h3><p>友元函数（<strong>Friend Function</strong>）是 C++ 中的一种机制，允许一个函数（或类）访问另一个类的私有成员和保护成员。虽然友元函数可以访问类的私有和保护成员，但它本身并不是类的成员函数。友元函数通常用于操作一些类内部的细节，但它可能会引入一些需要注意的问题。</p><ul><li>让函数成为类的友元，可以赋予该函数与类的成员函数相同的访问权限（<strong>访问private</strong>）</li><li>例：将运算符重载编写成一个非成员函数</li><li>友元函数具有成员函数的权限，但<strong>作为非成员函数不能使用成员运算符进行调用</strong><ul><li>使用成员函数，可以使用构造函数，这更加高效</li></ul></li><li><strong>只有在函数声明的时候需要加上friend关键词，在函数定义时不可以</strong></li></ul><h4 id="友元函数和在成员函数中运算符重载的区别"><a href="#友元函数和在成员函数中运算符重载的区别" class="headerlink" title="友元函数和在成员函数中运算符重载的区别"></a>友元函数和在成员函数中运算符重载的区别</h4><p>在成员函数中实现运算符重载</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Complex</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    Complex <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Complex&amp; other) <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Complex</span>(real + other.real, imag + other.imag);<br>    &#125;<br>    <span class="hljs-comment">//成员函数重载运算符中，所需的参数数目比运算符使用的参数数目少一个，其中一个是被隐式传递的调用对象(this 指针)</span><br>    <span class="hljs-comment">// 其它成员函数和数据成员</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">double</span> real;<br>    <span class="hljs-type">double</span> imag;<br>&#125;;<br><br></code></pre></td></tr></table></figure><p>在非成员函数中实现运算符重载（友元函数）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Complex</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">double</span> real;<br>    <span class="hljs-type">double</span> imag;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Complex</span>(<span class="hljs-type">double</span> r = <span class="hljs-number">0.0</span>, <span class="hljs-type">double</span> i = <span class="hljs-number">0.0</span>) : <span class="hljs-built_in">real</span>(r), <span class="hljs-built_in">imag</span>(i) &#123;&#125;<br><br>    <span class="hljs-comment">// 声明友元函数</span><br>    <span class="hljs-keyword">friend</span> Complex <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Complex&amp; left, <span class="hljs-type">const</span> Complex&amp; right);<br>&#125;;<br><br></code></pre></td></tr></table></figure><h4 id="友元函数相比于成员函数的优势"><a href="#友元函数相比于成员函数的优势" class="headerlink" title="友元函数相比于成员函数的优势"></a>友元函数相比于成员函数的优势</h4><p>友元函数相对于成员函数具有一些特定的优势，尽管它们打破了类的封装原则，但这些优势在某些情境下是非常有用的：</p><ol><li><strong>操作符重载</strong></li></ol><p>友元函数常用于操作符重载，特别是当操作符需要访问两个不同类或类型的对象时。成员函数只能通过 <code>this</code> 指针访问当前对象的成员，而友元函数可以直接访问两个对象的私有成员。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Complex</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">double</span> real;<br>    <span class="hljs-type">double</span> imag;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// ... 其他成员函数 ...</span><br>    <span class="hljs-keyword">friend</span> Complex <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Complex&amp; a, <span class="hljs-type">const</span> Complex&amp; b);<br>&#125;;<br><br><span class="hljs-comment">// 友元函数定义</span><br>Complex <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Complex&amp; a, <span class="hljs-type">const</span> Complex&amp; b) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Complex</span>(a.real + b.real, a.imag + b.imag);<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li><strong>提高代码的可读性和简洁性</strong></li></ol><ul><li><strong>全局函数</strong>：友元函数可以作为全局函数，这在某些情况下可以使代码更易于理解和维护。例如，上面的 <code>operator+</code> 作为友元函数，使得加法操作看起来更自然，不需要通过对象调用。</li><li><strong>避免不必要的成员函数</strong>：有时，某些操作并不适合作为类的一部分，但仍然需要访问类的私有成员。友元函数可以提供这种访问，而不需要增加类的成员函数。</li></ul><ol start="3"><li><strong>对称性</strong></li></ol><ul><li>友元函数可以提供操作的对称性。例如，在 <code>operator==</code> 的情况下，如果是成员函数，<code>a == b</code> 和 <code>b == a</code> 可能需要不同的实现，而友元函数可以使这两个操作等价。</li></ul><ol start="4"><li><strong>减少this指针的使用</strong></li></ol><ul><li>友元函数没有隐式的 <code>this</code> 指针，这在某些情况下可以提高效率，因为不需要额外的参数传递。</li></ul><ol start="5"><li><strong>访问私有成员而不改变类的接口</strong></li></ol><ul><li>如果你需要一个函数访问类的数据，但不想将这个函数作为类的成员（因为它不属于类的逻辑部分），友元函数可以让你实现这一点，而不改变类的公共接口。</li></ul><ol start="6"><li><strong>跨类访问</strong></li></ol><ul><li>友元函数可以被多个类声明为友元，从而允许<strong>这些类之间共享数据，而不需要通过公共接口或继承</strong>。</li></ul><ol start="7"><li><strong>设计模式的实现</strong></li></ol><ul><li>在一些设计模式中，如桥接模式、适配器模式等，友元函数可以帮助实现跨类协作，而无需暴露类的内部实现细节。</li></ul><p><strong>注意事项</strong>：</p><p>尽管友元函数有这些优势，但它们也有一些潜在的缺点：</p><ul><li><strong>打破封装</strong>：友元函数允许非成员函数访问类的私有成员，可能会破坏类的封装性。</li><li><strong>代码维护</strong>：友元关系可能会使代码的维护变得复杂，因为它增加了类的依赖性。</li><li><strong>滥用</strong>：如果不谨慎使用，友元函数可能会导致代码的可读性和结构性下降。</li></ul><p>因此，在使用友元函数时，应该谨慎考虑是否真的需要这种访问权限，并尽量限制友元函数的数量和范围，以保持类的封装性和代码的清晰度。</p><h3 id="友元类"><a href="#友元类" class="headerlink" title="友元类"></a>友元类</h3><p>在 C++ 中，<code>friend</code> 是一种特殊的机制，它允许某些函数或类访问其他类的私有成员。<code>friend</code> 主要有两种形式：<strong>友元函数</strong> 和 <strong>友元类</strong>。这两种机制在设计某些复杂系统时非常有用，可以让不同类之间进行密切的合作，同时保持类内部的封装性。</p><p><strong>友元类</strong> 是一个类，它被声明为某个类的友元类。友元类的成员函数可以访问该类的私有成员。这种机制通常用于设计两个紧密相关的类，它们需要互相访问私有数据，但又不希望暴露给外部。</p><p><strong>友元类的基本语法</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setA</span><span class="hljs-params">(A&amp; obj)</span></span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> x;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> val) : <span class="hljs-built_in">x</span>(val) &#123;&#125;<br><br>    <span class="hljs-comment">// 声明 B 为友元类</span><br>    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>;<br>&#125;;<br><br><span class="hljs-comment">// B 是 A 的友元类，可以访问 A 的私有成员</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">B::setA</span><span class="hljs-params">(A&amp; obj)</span> </span>&#123;<br>    obj.x = <span class="hljs-number">100</span>;  <span class="hljs-comment">// 直接访问 A 的私有成员</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">A <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br>    B b;<br>    b.<span class="hljs-built_in">setA</span>(a);  <span class="hljs-comment">// B 可以访问 A 的私有成员</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>友元类的应用场景</strong></p><ul><li><strong>设计复杂系统</strong>：友元类的使用可以让两个类之间共享数据和功能，而不暴露这些数据给其他类。例如，在某些库中，可能有一个类负责管理资源（如内存管理），另一个类负责使用这些资源。为了实现高效和紧密的合作，这两个类可能需要互相访问对方的私有成员，这时可以将其中一个类声明为友元类。</li><li><strong>实现成员共享</strong>：友元类通常用于需要相互访问成员数据的类，特别是在某些算法和数据结构的实现中，如链表、树、图等。</li></ul><p><strong>友元类的设计示例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Engine</span>;  <span class="hljs-comment">// 前向声明</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    Engine* engine;  <span class="hljs-comment">// Engine 对象是 Car 的私有成员</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Car</span>() : <span class="hljs-built_in">engine</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br><br>    <span class="hljs-comment">// 声明 Engine 为友元类</span><br>    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Engine</span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Engine</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> horsepower;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Engine</span>(<span class="hljs-type">int</span> hp) : <span class="hljs-built_in">horsepower</span>(hp) &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setCarEngine</span><span class="hljs-params">(Car&amp; car)</span> </span>&#123;<br>        car.engine = <span class="hljs-keyword">this</span>;  <span class="hljs-comment">// Engine 可以访问 Car 的私有成员</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showCarEngineInfo</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Car engine horsepower: &quot;</span> &lt;&lt; horsepower &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>Engine</code> 类被声明为 <code>Car</code> 类的友元类，使得 <code>Engine</code> 类能够访问 <code>Car</code> 类的私有成员。</p><h4 id="友元类与继承"><a href="#友元类与继承" class="headerlink" title="友元类与继承"></a><strong>友元类与继承</strong></h4><p>友元类与继承之间有一些特别的关系。虽然子类继承了父类的公共和保护成员，但<strong>友元关系不被继承</strong>。也就是说，如果<strong>某个类是另一个类的友元类，它并不能自动成为其子类的友元类</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> value;<br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> val) : <span class="hljs-built_in">value</span>(val) &#123;&#125;<br>    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>;  <span class="hljs-comment">// B 是 A 的友元类</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> : <span class="hljs-keyword">public</span> A &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">C</span>(<span class="hljs-type">int</span> val) : <span class="hljs-built_in">A</span>(val) &#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showValue</span><span class="hljs-params">(A&amp; obj)</span> </span>&#123;<br>        std::cout &lt;&lt; obj.value &lt;&lt; std::endl;  <span class="hljs-comment">// B 可以访问 A 的私有成员</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">A <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br>    B b;<br>    b.<span class="hljs-built_in">showValue</span>(a);  <span class="hljs-comment">// 正常，B 可以访问 A 的私有成员</span><br><br>    <span class="hljs-function">C <span class="hljs-title">c</span><span class="hljs-params">(<span class="hljs-number">20</span>)</span></span>;<br>    <span class="hljs-comment">// b.showValue(c);  // 错误，C 没有继承 B 对 A 的友元关系</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的例子中，<code>B</code> 是 <code>A</code> 的友元类，但 <code>C</code> 并没有继承 <code>B</code> 对 <code>A</code> 的友元关系，因此 <code>B</code> 无法访问 <code>C</code> 的私有成员。</p><h4 id="友元与封装"><a href="#友元与封装" class="headerlink" title="友元与封装"></a><strong>友元与封装</strong></h4><p>尽管 <code>friend</code> 允许类外部的函数和类访问私有成员，但它仍然保持了一定的封装性。在设计时，应注意不要过度使用友元关系，因为过多的友元可能会破坏类的封装性，增加类之间的耦合度，导致维护困难。</p><ul><li><strong>适度使用友元</strong>：只有在确实需要类之间紧密合作时，才应考虑使用友元关系。尤其是当某些函数需要访问类的内部细节时，友元函数和友元类可以提供非常强大的功能。</li><li><strong>减少友元的使用</strong>：不推荐随意将大量的类或函数声明为友元，尽量保持类的封装性，使其更具独立性和可维护性。</li></ul><h3 id="更加复杂的友元关系"><a href="#更加复杂的友元关系" class="headerlink" title="更加复杂的友元关系"></a>更加复杂的友元关系</h3><p>在上文我们介绍了两种友元的使用：<strong>友元类和友元函数</strong>。友元函数具有作为外部函数访问类内私有数据成员的特权，而友元类具有<strong>更多的特权</strong>。可以实现<strong>类之间的数据共享</strong>。但是，<strong>类友元的实现</strong>在一定程度上也抹杀了类之间数据的安全性，不符合OOP中<strong>封装</strong>的基本理念。因此，我们可以不将整个类设置为友元，而是只将<strong>另一个类的成员函数设置为友元，限制这种特权的使用</strong>，保证安全性。</p><p>我们来看下面的示例，下文代码给出了电视机和遥控器的类实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// tvfm.h -- Tv and Remote classes using a friend member</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> TVFM_H_</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TVFM_H_</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Tv</span>;                       <span class="hljs-comment">// forward declaration</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Remote</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">enum</span> <span class="hljs-title class_">State</span>&#123;Off, On&#125;;<br>    <span class="hljs-keyword">enum</span> &#123;MinVal,MaxVal = <span class="hljs-number">20</span>&#125;;<br>    <span class="hljs-keyword">enum</span> &#123;Antenna, Cable&#125;;<br>    <span class="hljs-keyword">enum</span> &#123;TV, DVD&#125;;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> mode;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Remote</span>(<span class="hljs-type">int</span> m = TV) : <span class="hljs-built_in">mode</span>(m) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">volup</span><span class="hljs-params">(Tv &amp; t)</span></span>;         <span class="hljs-comment">// prototype only</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">voldown</span><span class="hljs-params">(Tv &amp; t)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">onoff</span><span class="hljs-params">(Tv &amp; t)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">chanup</span><span class="hljs-params">(Tv &amp; t)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">chandown</span><span class="hljs-params">(Tv &amp; t)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set_mode</span><span class="hljs-params">(Tv &amp; t)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set_input</span><span class="hljs-params">(Tv &amp; t)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set_chan</span><span class="hljs-params">(Tv &amp; t, <span class="hljs-type">int</span> c)</span></span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Tv</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">Remote::set_chan</span><span class="hljs-params">(Tv &amp; t, <span class="hljs-type">int</span> c)</span></span>;<br>    <span class="hljs-keyword">enum</span> <span class="hljs-title class_">State</span>&#123;Off, On&#125;;<br>    <span class="hljs-keyword">enum</span> &#123;MinVal,MaxVal = <span class="hljs-number">20</span>&#125;;<br>    <span class="hljs-keyword">enum</span> &#123;Antenna, Cable&#125;;<br>    <span class="hljs-keyword">enum</span> &#123;TV, DVD&#125;;<br><br>    <span class="hljs-built_in">Tv</span>(<span class="hljs-type">int</span> s = Off, <span class="hljs-type">int</span> mc = <span class="hljs-number">125</span>) : <span class="hljs-built_in">state</span>(s), <span class="hljs-built_in">volume</span>(<span class="hljs-number">5</span>),<br>        <span class="hljs-built_in">maxchannel</span>(mc), <span class="hljs-built_in">channel</span>(<span class="hljs-number">2</span>), <span class="hljs-built_in">mode</span>(Cable), <span class="hljs-built_in">input</span>(TV) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">onoff</span><span class="hljs-params">()</span> </span>&#123;state = (state == On)? Off : On;&#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ison</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<span class="hljs-keyword">return</span> state == On;&#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">volup</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">voldown</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">chanup</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">chandown</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set_mode</span><span class="hljs-params">()</span> </span>&#123;mode = (mode == Antenna)? Cable : Antenna;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set_input</span><span class="hljs-params">()</span> </span>&#123;input = (input == TV)? DVD : TV;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">settings</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> state;<br>    <span class="hljs-type">int</span> volume;<br>    <span class="hljs-type">int</span> maxchannel;<br>    <span class="hljs-type">int</span> channel;<br>    <span class="hljs-type">int</span> mode;<br>    <span class="hljs-type">int</span> input;<br>&#125;;<br><br><span class="hljs-comment">// Remote methods as inline functions</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">Remote::volup</span><span class="hljs-params">(Tv &amp; t)</span> </span>&#123; <span class="hljs-keyword">return</span> t.<span class="hljs-built_in">volup</span>();&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">Remote::voldown</span><span class="hljs-params">(Tv &amp; t)</span> </span>&#123; <span class="hljs-keyword">return</span> t.<span class="hljs-built_in">voldown</span>();&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">Remote::onoff</span><span class="hljs-params">(Tv &amp; t)</span> </span>&#123; t.<span class="hljs-built_in">onoff</span>(); &#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">Remote::chanup</span><span class="hljs-params">(Tv &amp; t)</span> </span>&#123;t.<span class="hljs-built_in">chanup</span>();&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">Remote::chandown</span><span class="hljs-params">(Tv &amp; t)</span> </span>&#123;t.<span class="hljs-built_in">chandown</span>();&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">Remote::set_mode</span><span class="hljs-params">(Tv &amp; t)</span> </span>&#123;t.<span class="hljs-built_in">set_mode</span>();&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">Remote::set_input</span><span class="hljs-params">(Tv &amp; t)</span> </span>&#123;t.<span class="hljs-built_in">set_input</span>();&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">Remote::set_chan</span><span class="hljs-params">(Tv &amp; t, <span class="hljs-type">int</span> c)</span> </span>&#123;t.channel = c;&#125; <br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br></code></pre></td></tr></table></figure><p>遥控器可以访问电视机的信息，因此我们自然想到可以把遥控器类设置为电视机类的友元类，但是这样的操作使安全性降低（毕竟电视机还有很多遥控器完成不了的操作），我们可以优化，将<code>Remote::set_chan</code>作为Tv类的友元函数，使其作为<strong>唯一需要友元的方法实现</strong>。</p><p>基于这个想法，我们需要对友元的定义和声明做一些修改。首先，就像函数声明一样，我们需要<code>class Tv</code>语句来实现<strong>前置声明（forward declaration）</strong>。同时，在<code>Remote</code>类的函数定义中包含<code>Tv</code>类的参数列表，因此<strong>需要将Tv类的声明提前到Remote类的函数定义之前。</strong></p><p>内联函数的链接性是内部的，这意味着<strong>函数定义必须在使用函数的文件</strong>中。在这个例子中，内联定义位于头文件中，因此在使用函数的文件中包含头文件可确保将定义放在正确的地方。也可以将定义放在实现文件中，但必须删除关键字 <code>inline</code>，这样函数的链接性将是外部的  </p><blockquote><p>总之就一个原则，<strong>在使用对应的类的时候编译器应该已经看到对应的内容！</strong></p></blockquote><h4 id="互为友元"><a href="#互为友元" class="headerlink" title="互为友元"></a>互为友元</h4><p>除本章前面讨论的，还有其他友元和类的组合形式，下面简要地介绍其中的一些。</p><p>假设由于技术进步，出现了交互式遥控器。例如，交互式遥控器让您能够回答电视节目中的问题，如果回答错误，电视将在控制器上产生嗡嗡声。忽略电视使用这种设施安排观众进入节目的可能性，我们只看 C++的编程方面。新的方案将受益于相互的友情，一些 Remote 方法能够像前面那样影响 Tv 对象，而一些 Tv 方法也能影响 Remote 对象。这可以通过让<strong>类彼此成为对方的友元</strong>来实现，即除了 Remote 是 Tv 的友元外， Tv还是 Remote 的友元。需要记住的一点是，对于使用 Remote 对象的 Tv 方法，其原型可在 Remote 类声明之前声明，但必须在 Remote 类声明之后定义，以便编译器有足够的信息来编译该方法。</p><p><img src="/posts/Code-Reuse-in-OOP/friend.png" alt="互为友元"></p><h4 id="共同的友元"><a href="#共同的友元" class="headerlink" title="共同的友元"></a>共同的友元</h4><p>需要使用友元的另一种情况是，<strong>函数需要访问两个类的私有数据</strong>。从逻辑上看，这样的函数应是每个类的成员函数，但这是不可能的。它可以是一个类的成员，同时是另一个类的友元，但有时<strong>将函数作为两个类的友元更合理</strong>。例如，假定有一个 Probe 类和一个 Analyzer 类，前者表示某种可编程的测量设备，后者表示某种可编程的分析设备。  </p><p><img src="/posts/Code-Reuse-in-OOP/frineds.png" alt="共同的友元"></p><h3 id="模板类和友元"><a href="#模板类和友元" class="headerlink" title="模板类和友元"></a>模板类和友元</h3><p>模板类声明也可以有友元。模板的友元分 3 类：</p><ul><li><strong>非模板友元</strong>；</li><li><strong>约束（bound）模板友元</strong>，即友元的类型取决于类被<strong>实例化</strong>时的类型；</li><li><strong>非约束（unbound）模板友元</strong>，即友元的所有具体化都是类的每一个具体化的友元。</li></ul><h5 id="非模版友元"><a href="#非模版友元" class="headerlink" title="非模版友元"></a>非模版友元</h5><p>在 C++ 中，<strong>模板类的非模板友元函数</strong>是指一个<strong>非模板函数</strong>被声明为一个模板类的友元。这样，非模板友元函数可以访问模板类的私有和保护成员。与普通的友元函数类似，非模板友元函数允许特定的函数访问类的内部实现，但在模板类中，它们<strong>并不依赖于模板参数</strong>。</p><p>假设我们有一个模板类 <code>MyClass</code>，其中包含一个私有成员 <code>value</code>，并希望定义一个非模板函数来访问它。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    T value;<br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyClass</span>(T v) : <span class="hljs-built_in">value</span>(v) &#123;&#125;<br><br>    <span class="hljs-comment">// 声明一个非模板友元函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">printValue</span><span class="hljs-params">(<span class="hljs-type">const</span> MyClass&lt;<span class="hljs-type">int</span>&gt;&amp; obj)</span></span>;  <span class="hljs-comment">// 只对 MyClass&lt;int&gt; 类型的对象有效</span><br>&#125;;<br><br><span class="hljs-comment">// 非模板友元函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printValue</span><span class="hljs-params">(<span class="hljs-type">const</span> MyClass&lt;<span class="hljs-type">int</span>&gt;&amp; obj)</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Value: &quot;</span> &lt;&lt; obj.value &lt;&lt; endl;  <span class="hljs-comment">// 可以访问 MyClass&lt;int&gt; 的私有成员</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">MyClass&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">obj</span><span class="hljs-params">(<span class="hljs-number">42</span>)</span></span>;  <span class="hljs-comment">// 创建一个 MyClass&lt;int&gt; 类型的对象</span><br>    <span class="hljs-built_in">printValue</span>(obj);       <span class="hljs-comment">// 调用非模板友元函数，打印值</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li><code>MyClass</code> 是一个模板类，接受类型 <code>T</code> 作为模板参数，并包含一个私有成员 <code>value</code>。</li><li><code>printValue</code> 是一个非模板函数，它被声明为 <code>MyClass&lt;int&gt;</code> 的友元函数。由于 <code>printValue</code> 只与 <code>MyClass&lt;int&gt;</code> 相关，因此它的参数类型为 <code>MyClass&lt;int&gt;</code>，而不是模板类型 <code>T</code>。</li><li>在 <code>main</code> 函数中，我们创建了一个 <code>MyClass&lt;int&gt;</code> 类型的对象，并通过 <code>printValue</code> 访问其私有成员。</li></ol><p><strong>注意点</strong></p><ul><li><strong>非模板友元函数的类型限定</strong>：非模板友元函数只能访问<strong>特定模板实例化的类的成员</strong>。在上述例子中，<code>printValue</code> 只能作为 <code>MyClass&lt;int&gt;</code> 的友元函数，而无法访问其他类型实例化的 <code>MyClass</code> 对象（例如 <code>MyClass&lt;double&gt;</code>）。</li><li><strong>模板类和非模板友元函数的结合</strong>：非模板友元函数与模板类的结合需要对特定类型的模板实例进行访问，因此它通常不如模板友元函数灵活。但它在某些场景中非常有用，例如当<strong>你只希望特定类型的模板类暴露内部实现时</strong>。</li></ul><blockquote><p>一般来说，非模版友元函数和普通的友元函数没有区别（针对<strong>特定实例化后的友元函数</strong>），这样做一定程度上牺牲了泛型编程的<strong>通用性</strong>，但可以对特定类型做<strong>更精细的操作</strong>。</p></blockquote><h5 id="约束友元"><a href="#约束友元" class="headerlink" title="约束友元"></a>约束友元</h5><p>为约束模板友元作准备，要使<strong>类的每一个具体化都获得与友元匹配的具体化</strong>。这比非模板友元复杂些。包含以下三步：</p><ul><li>在类定义的前面声明每个模板函数  <ul><li><code>template &lt;typename T&gt; void counts();</code></li><li><code>template &lt;typename T&gt; void report(T &amp;);</code></li></ul></li><li>在函数中再次将模板声明为友元。这些语句根据类模板参数的类型声明具体化  <ul><li><code>template &lt;typename TT&gt;</code>（类模版的模版参数声明）</li><li><code> friend void counts&lt;TT&gt;();</code></li><li>声明中的<code>&lt;&gt;</code>指出这是模板具体化。对于<code>report()</code>， <code>&lt;&gt;</code>可以为空，因为可以从函数参数推断出。</li></ul></li><li>为友元提供模板定义 <ul><li><code>template &lt;typename T&gt;   void counts()</code></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// tmp2tmp.cpp -- template friends to a template class</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> std::cout;<br><span class="hljs-keyword">using</span> std::endl;<br><br><span class="hljs-comment">// template prototypes</span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">report</span><span class="hljs-params">(T &amp;)</span></span>;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">counts</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-comment">// template class</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> TT&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HasFriendT</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>    TT item;<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> ct;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">HasFriendT</span>(<span class="hljs-type">const</span> TT &amp; i) : <span class="hljs-built_in">item</span>(i) &#123;ct++;&#125;<br>    ~<span class="hljs-built_in">HasFriendT</span>() &#123; ct--; &#125;<br>    <span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-built_in">counts</span>&lt;TT&gt;();<br>    <span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> report&lt;&gt;(HasFriendT&lt;TT&gt; &amp;);<br>&#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-type">int</span> HasFriendT&lt;T&gt;::ct = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// template friend functions definitions</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">counts</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;template size: &quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(HasFriendT&lt;T&gt;) &lt;&lt; <span class="hljs-string">&quot;; &quot;</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;template counts(): &quot;</span> &lt;&lt; HasFriendT&lt;T&gt;::ct &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">report</span><span class="hljs-params">(T &amp; hf)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; hf.item &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">counts</span>&lt;<span class="hljs-type">int</span>&gt;();<br>    <span class="hljs-function">HasFriendT&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">hfi1</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br>    <span class="hljs-function">HasFriendT&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">hfi2</span><span class="hljs-params">(<span class="hljs-number">20</span>)</span></span>;<br>    <span class="hljs-function">HasFriendT&lt;<span class="hljs-type">double</span>&gt; <span class="hljs-title">hfdb</span><span class="hljs-params">(<span class="hljs-number">10.5</span>)</span></span>;<br>    <span class="hljs-built_in">report</span>(hfi1);  <span class="hljs-comment">// generate report(HasFriendT&lt;int&gt; &amp;)</span><br>    <span class="hljs-built_in">report</span>(hfi2);  <span class="hljs-comment">// generate report(HasFriendT&lt;int&gt; &amp;)</span><br>    <span class="hljs-built_in">report</span>(hfdb);  <span class="hljs-comment">// generate report(HasFriendT&lt;double&gt; &amp;)</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;counts&lt;int&gt;() output:\n&quot;</span>;<br>    <span class="hljs-built_in">counts</span>&lt;<span class="hljs-type">int</span>&gt;();<br>    cout &lt;&lt; <span class="hljs-string">&quot;counts&lt;double&gt;() output:\n&quot;</span>;<br>    <span class="hljs-built_in">counts</span>&lt;<span class="hljs-type">double</span>&gt;();<br>    <span class="hljs-comment">// std::cin.get();</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-number">10</span><br><span class="hljs-number">20</span><br><span class="hljs-number">10.5</span><br>counts&lt;int&gt;() output:<br>template size: <span class="hljs-number">4</span>; template counts(): <span class="hljs-number">2</span><br>counts&lt;double&gt;() output:<br>template size: <span class="hljs-number">8</span>; template counts(): <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h5 id="非约束友元"><a href="#非约束友元" class="headerlink" title="非约束友元"></a>非约束友元</h5><p>前一节中的约束模板友元函数是在<strong>类外面声明的模板的具体化</strong>。 int 类具体化获得 int 函数具体化，依此类推。通过在类内部声明模板，可以<strong>创建非约束友元函数</strong>，即每个函数具体化都是每个类具体化的友元。对于非约束友元，友元模板类型参数与模板类类型参数是不同的。</p><p><strong>非约束友元</strong>指的是模板类的友元函数或类没有任何类型约束，它们可以接受任何类型的模板实例化，并且不对模板参数施加限制。</p><p>特点：</p><ul><li>友元函数可以访问模板类的私有成员。</li><li>友元函数没有模板参数的约束，因此可以接受任何类型的模板实例化。</li><li>没有额外的限制条件，适用性广泛。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// manyfrnd.cpp -- unbound template friend to a template class</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> std::cout;<br><span class="hljs-keyword">using</span> std::endl;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ManyFriend</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>    T item;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">ManyFriend</span>(<span class="hljs-type">const</span> T &amp; i) : <span class="hljs-built_in">item</span>(i) &#123;&#125;<br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> C, <span class="hljs-keyword">typename</span> D&gt; <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">show2</span><span class="hljs-params">(C &amp;, D &amp;)</span></span>;<br>&#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> C, <span class="hljs-keyword">typename</span> D&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show2</span><span class="hljs-params">(C &amp; c, D &amp; d)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; c.item &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; d.item &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">ManyFriend&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">hfi1</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br>    <span class="hljs-function">ManyFriend&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">hfi2</span><span class="hljs-params">(<span class="hljs-number">20</span>)</span></span>;<br>    <span class="hljs-function">ManyFriend&lt;<span class="hljs-type">double</span>&gt; <span class="hljs-title">hfdb</span><span class="hljs-params">(<span class="hljs-number">10.5</span>)</span></span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;hfi1, hfi2: &quot;</span>;<br>    <span class="hljs-built_in">show2</span>(hfi1, hfi2);<br>    cout &lt;&lt; <span class="hljs-string">&quot;hfdb, hfi2: &quot;</span>;<br>    <span class="hljs-built_in">show2</span>(hfdb, hfi2);<br>    <span class="hljs-comment">// std::cin.get();</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell">hfi1, hfi2: <span class="hljs-number">10</span>, <span class="hljs-number">20</span><br>hfdb, hfi2: <span class="hljs-number">10.5</span>, <span class="hljs-number">20</span><br></code></pre></td></tr></table></figure><p><strong>非约束友元 vs 约束友元</strong></p><table><thead><tr><th>特性</th><th>非约束友元</th><th>约束友元</th></tr></thead><tbody><tr><td><strong>定义</strong></td><td>不对模板参数进行类型约束</td><td>对<strong>模板参数进行类型约束</strong>（如通过概念、<code>enable_if</code>）</td></tr><tr><td><strong>适用性</strong></td><td>可以接受任何类型的模板实例</td><td>只能接受符合约束条件的模板实例</td></tr><tr><td><strong>类型安全性</strong></td><td>没有类型限制，可能出现不安全的用法</td><td>强制类型安全，只有符合特定条件的类型才能使用</td></tr><tr><td><strong>灵活性</strong></td><td>更加灵活，不限制类型</td><td>更加严格，只能与特定类型一起使用</td></tr><tr><td><strong>示例</strong></td><td><code>friend void printValue(const MyClass&lt;T&gt;&amp; obj);</code></td><td><code>friend void printValue(const MyClass&lt;T&gt;&amp; obj) requires IntegralType&lt;T&gt;;</code></td></tr></tbody></table><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>C++提供了几种重用代码的手段。第 13 章介绍的公有继承能够建立 is-a 关系，这样派生类可以重用基类的代码。私有继承和保护继承也使得能够重用基类的代码，但建立的是 has-a 关系。使用私有继承时，基类的公有成员和保护成员将成为派生类的私有成员；使用保护继承时，基类的公有成员和保护成员将成为派生类的保护成员。无论使用哪种继承，基类的公有接口都将成为派生类的内部接口。这有时候被称为继承实现，但并不继承接口，因为派生类对象不能显式地使用基类的接口。因此，不能将派生对象看作是一种基类对象。由于这个原因，在不进行显式类型转换的情况下，基类指针或引用将不能指向派生类对象。</p><p>还可以通过开发包含对象成员的类来重用类代码。这种方法被称为包含、层次化或组合，它建立的也是has-a 关系。与私有继承和保护继承相比，包含更容易实现和使用，所以通常优先采用这种方式。然而，私有继承和保护继承比包含有一些不同的功能。例如，继承允许派生类访问基类的保护成员；还允许派生类重新定义从基类那里继承的虚函数。因为包含不是继承，所以通过包含来重用类代码时，不能使用这些功能。另一方面，如果需要使用某个类的几个对象，则用包含更适合。例如， State 类可以包含一组 County对象。</p><p>多重继承（MI）使得能够在类设计中重用多个类的代码。私有 MI 或保护 MI 建立 has-a 关系，而公有MI 建立 is-a 关系。 MI 会带来一些问题，即多次定义同一个名称，继承多个基类对象。可以使用类限定符来解决名称二义性的问题，使用虚基类来避免继承多个基类对象的问题。但使用虚基类后，就需要为编写构造函数初始化列表以及解决二义性问题引入新的规则。</p><p>类模板使得能够创建通用的类设计，其中类型（通常是成员类型）由类型参数表示。</p><blockquote><p>END For OOP</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Code</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tutorial</tag>
      
      <tag>Finished</tag>
      
      <tag>C/C++</tag>
      
      <tag>OOP</tag>
      
      <tag>C++ Primer Plus</tag>
      
      <tag>Inheritance</tag>
      
      <tag>Code Reuse</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode-Mistake-Collection-31-40</title>
    <link href="/posts/Leetcode-Mistake-collection-31-40/"/>
    <url>/posts/Leetcode-Mistake-collection-31-40/</url>
    
    <content type="html"><![CDATA[<style>  html, body, .markdown-body {    font-family: Georgia, sans, serif;  }</style><h1 id="Leetcode-Mistake-collection-31-40"><a href="#Leetcode-Mistake-collection-31-40" class="headerlink" title="Leetcode-Mistake-collection-31-40"></a>Leetcode-Mistake-collection-31-40</h1><h1 id="程设错题-31-35-20241112"><a href="#程设错题-31-35-20241112" class="headerlink" title="程设错题 31-35 20241112"></a>程设错题 31-35 20241112</h1><h2 id="1-上机错题-寻找字符串的最大非重复子串问题"><a href="#1-上机错题-寻找字符串的最大非重复子串问题" class="headerlink" title="1 上机错题 寻找字符串的最大非重复子串问题"></a>1 上机错题 寻找字符串的最大非重复子串问题</h2><h4 id="解法1基本双循环枚举（略）"><a href="#解法1基本双循环枚举（略）" class="headerlink" title="解法1基本双循环枚举（略）"></a>解法1基本双循环枚举（略）</h4><h4 id="解法2-使用双指针"><a href="#解法2-使用双指针" class="headerlink" title="解法2 使用双指针"></a>解法2 使用双指针</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    string theinput;cin&gt;&gt;theinput;<br>    <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,j=<span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> maxoflength=<span class="hljs-number">0</span>;<br>    unordered_map&lt;<span class="hljs-type">char</span>,<span class="hljs-type">int</span>&gt; list;<br><br>    <span class="hljs-keyword">for</span>(;j&lt;theinput.<span class="hljs-built_in">length</span>();j++)&#123;<br>        <span class="hljs-keyword">if</span>(list.<span class="hljs-built_in">find</span>(theinput[j])!=list.<span class="hljs-built_in">end</span>())&#123;<br>            i=list[theinput[j]]<span class="hljs-number">+1</span>;<br>            <span class="hljs-keyword">if</span>(j-i<span class="hljs-number">+1</span>&gt;maxoflength)&#123;<br>                maxoflength=j-i<span class="hljs-number">+1</span>;<br>            &#125;<br>        &#125;<br>        list[theinput[j]]=j;<br>    &#125;<br>    cout&lt;&lt;maxoflength;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-Leetcode-888-公平糖果交换"><a href="#2-Leetcode-888-公平糖果交换" class="headerlink" title="2 Leetcode 888 公平糖果交换"></a>2 Leetcode 888 公平糖果交换</h2><p>爱丽丝和鲍勃拥有不同总数量的糖果。给你两个数组 <code>aliceSizes</code> 和 <code>bobSizes</code> ，<code>aliceSizes[i]</code> 是爱丽丝拥有的第 <code>i</code> 盒糖果中的糖果数量，<code>bobSizes[j]</code> 是鲍勃拥有的第 <code>j</code> 盒糖果中的糖果数量。</p><p>两人想要互相交换一盒糖果，这样在交换之后，他们就可以拥有相同总数量的糖果。一个人拥有的糖果总数量是他们每盒糖果数量的总和。</p><p>返回一个整数数组 <code>answer</code>，其中 <code>answer[0]</code> 是爱丽丝必须交换的糖果盒中的糖果的数目，<code>answer[1]</code> 是鲍勃必须交换的糖果盒中的糖果的数目。如果存在多个答案，你可以返回其中 <strong>任何一个</strong> 。题目测试用例保证存在与输入对应的答案。</p><h4 id="解法1-双循环枚举"><a href="#解法1-双循环枚举" class="headerlink" title="解法1 双循环枚举"></a>解法1 双循环枚举</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">fairCandySwap</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; aliceSizes, vector&lt;<span class="hljs-type">int</span>&gt;&amp; bobSizes)</span> </span>&#123;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> sum1=<span class="hljs-number">0</span>,sum2=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> alice:aliceSizes)&#123;<br>            sum1+=alice;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> bob:bobSizes)&#123;<br>            sum2+=bob;<br>        &#125;<br>        <span class="hljs-type">int</span> target=<span class="hljs-built_in">abs</span>(sum1-sum2)/<span class="hljs-number">2</span>;<br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> alice:aliceSizes)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> bob:bobSizes)&#123;<br>                <span class="hljs-keyword">if</span>(sum1&gt;sum2&amp;&amp;alice-bob==target)&#123;<br>                    ans.<span class="hljs-built_in">push_back</span>(alice);<br>                    ans.<span class="hljs-built_in">push_back</span>(bob);<br>                    <span class="hljs-keyword">return</span> ans;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(sum1&lt;sum2&amp;&amp;bob-alice==target)&#123;<br>                    ans.<span class="hljs-built_in">push_back</span>(alice);<br>                    ans.<span class="hljs-built_in">push_back</span>(bob);<br>                    <span class="hljs-keyword">return</span> ans;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> &#123;&#125;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="解法2-使用哈希表存储，优化查找方案"><a href="#解法2-使用哈希表存储，优化查找方案" class="headerlink" title="解法2 使用哈希表存储，优化查找方案"></a>解法2 使用哈希表存储，优化查找方案</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">fairCandySwap</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; aliceSizes, vector&lt;<span class="hljs-type">int</span>&gt;&amp; bobSizes)</span> </span>&#123;<br>        <span class="hljs-type">int</span> sumA = <span class="hljs-built_in">accumulate</span>(aliceSizes.<span class="hljs-built_in">begin</span>(), aliceSizes.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>);<br>        <span class="hljs-type">int</span> sumB = <span class="hljs-built_in">accumulate</span>(bobSizes.<span class="hljs-built_in">begin</span>(), bobSizes.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>);<br>        <span class="hljs-type">int</span> delta = (sumA - sumB) / <span class="hljs-number">2</span>;<br>        <span class="hljs-comment">//这里差值可以取负值，就不用分类讨论</span><br>        <span class="hljs-function">unordered_set&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">rec</span><span class="hljs-params">(aliceSizes.begin(), aliceSizes.end())</span></span>;<br>        <span class="hljs-comment">//对Alice的数组创建哈希表（自动删去重复元素）</span><br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; y : bobSizes) &#123;<br>            <span class="hljs-type">int</span> x = y + delta;<br>            <span class="hljs-keyword">if</span> (rec.<span class="hljs-built_in">count</span>(x)) &#123;<br>                <span class="hljs-comment">//如果找到了，就说明存在</span><br>                ans = vector&lt;<span class="hljs-type">int</span>&gt;&#123;x, y&#125;;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h2 id="3-Leetcode-473-火柴拼正方形"><a href="#3-Leetcode-473-火柴拼正方形" class="headerlink" title="3 Leetcode 473 火柴拼正方形"></a>3 Leetcode 473 火柴拼正方形</h2><p>你将得到一个整数数组 <code>matchsticks</code> ，其中 <code>matchsticks[i]</code> 是第 <code>i</code> 个火柴棒的长度。你要用 <strong>所有的火柴棍</strong> 拼成一个正方形。你 <strong>不能折断</strong> 任何一根火柴棒，但你可以把它们连在一起，而且每根火柴棒必须 <strong>使用一次</strong> 。</p><p>如果你能使这个正方形，则返回 <code>true</code> ，否则返回 <code>false</code> 。</p><h3 id="补充：DFS（深度优先搜索）的C-代码实现"><a href="#补充：DFS（深度优先搜索）的C-代码实现" class="headerlink" title="补充：DFS（深度优先搜索）的C++代码实现"></a>补充：DFS（深度优先搜索）的C++代码实现</h3><p>DFS的关键：优先搜索点的未被访问的邻居节点</p><p>非递归的代码示例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">const</span> vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; graph, vector&lt;<span class="hljs-type">bool</span>&gt;&amp; visited)</span> </span>&#123;<br>    <span class="hljs-comment">// 使用一个栈来模拟递归</span><br>    stack&lt;<span class="hljs-type">int</span>&gt; s;<br>    s.<span class="hljs-built_in">push</span>(start);<br>    <span class="hljs-comment">//将起始点start压入栈中</span><br><br>    <span class="hljs-keyword">while</span> (!s.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-comment">// 从栈顶取出一个节点</span><br>        <span class="hljs-type">int</span> node = s.<span class="hljs-built_in">top</span>();<br>        s.<span class="hljs-built_in">pop</span>();<br><br>        <span class="hljs-comment">// 如果节点未被访问过</span><br>        <span class="hljs-keyword">if</span> (!visited[node]) &#123;<br>            <span class="hljs-comment">// 标记为已访问</span><br>            visited[node] = <span class="hljs-literal">true</span>;<br>            <br>            <span class="hljs-comment">// 打印当前访问的节点</span><br>            cout &lt;&lt; <span class="hljs-string">&quot;Visiting node: &quot;</span> &lt;&lt; node &lt;&lt; endl;<br><br>            <span class="hljs-comment">// 将该节点的所有未访问的邻居节点压入栈中</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = graph[node].<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>                <span class="hljs-keyword">if</span> (!visited[graph[node][i]]) &#123;<br>                    s.<span class="hljs-built_in">push</span>(graph[node][i]);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 示例图的邻接表表示</span><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; graph = &#123;<br>        &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;,      <span class="hljs-comment">// 节点0的邻居节点是1和2</span><br>        &#123;<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;,   <span class="hljs-comment">// 节点1的邻居节点是0、3和4</span><br>        &#123;<span class="hljs-number">0</span>, <span class="hljs-number">5</span>&#125;,      <span class="hljs-comment">// 节点2的邻居节点是0和5</span><br>        &#123;<span class="hljs-number">1</span>, <span class="hljs-number">4</span>&#125;,      <span class="hljs-comment">// 节点3的邻居节点是1和4</span><br>        &#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>&#125;,      <span class="hljs-comment">// 节点4的邻居节点是1和3</span><br>        &#123;<span class="hljs-number">2</span>&#125;          <span class="hljs-comment">// 节点5的邻居节点是2</span><br>    &#125;;<br><br>    <span class="hljs-type">int</span> numNodes = graph.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">visited</span><span class="hljs-params">(numNodes, <span class="hljs-literal">false</span>)</span></span>;<br><br>    <span class="hljs-comment">// 从节点0开始DFS</span><br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>, graph, visited);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>优化为递归的版本：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> node, <span class="hljs-type">const</span> vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; graph, vector&lt;<span class="hljs-type">bool</span>&gt;&amp; visited)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (visited[node]) <span class="hljs-keyword">return</span>;<br>    visited[node] = <span class="hljs-literal">true</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Visiting node: &quot;</span> &lt;&lt; node &lt;&lt; endl;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> neighbor : graph[node]) &#123;<br>        <span class="hljs-keyword">if</span> (!visited[neighbor]) &#123;<br>            <span class="hljs-built_in">dfs</span>(neighbor, graph, visited);<br>            <span class="hljs-comment">//遍历每一个未被访问的邻居节点实现全局搜索</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BFS-广度优先搜索"><a href="#BFS-广度优先搜索" class="headerlink" title="BFS 广度优先搜索"></a>BFS 广度优先搜索</h3><p>下面是使用C++实现的BFS的示例代码，该代码会遍历一个图，并打印每个节点的访问顺序：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">const</span> vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; graph, vector&lt;<span class="hljs-type">bool</span>&gt;&amp; visited)</span> </span>&#123;<br>    <span class="hljs-comment">// 使用队列来存储待访问的节点</span><br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    <br>    <span class="hljs-comment">// 将起始节点标记为已访问并入队</span><br>    visited[start] = <span class="hljs-literal">true</span>;<br>    q.<span class="hljs-built_in">push</span>(start);<br><br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-comment">// 从队列中取出一个节点</span><br>        <span class="hljs-type">int</span> node = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br><br>        <span class="hljs-comment">// 打印当前访问的节点</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;Visiting node: &quot;</span> &lt;&lt; node &lt;&lt; endl;<br><br>        <span class="hljs-comment">// 遍历当前节点的所有邻居节点</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> neighbor : graph[node]) &#123;<br>            <span class="hljs-comment">// 如果邻居节点未被访问过，标记为已访问并入队</span><br>            <span class="hljs-keyword">if</span> (!visited[neighbor]) &#123;<br>                visited[neighbor] = <span class="hljs-literal">true</span>;<br>                q.<span class="hljs-built_in">push</span>(neighbor);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 示例图的邻接表表示</span><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; graph = &#123;<br>        &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;,      <span class="hljs-comment">// 节点0的邻居节点是1和2</span><br>        &#123;<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;,   <span class="hljs-comment">// 节点1的邻居节点是0、3和4</span><br>        &#123;<span class="hljs-number">0</span>, <span class="hljs-number">5</span>&#125;,      <span class="hljs-comment">// 节点2的邻居节点是0和5</span><br>        &#123;<span class="hljs-number">1</span>, <span class="hljs-number">4</span>&#125;,      <span class="hljs-comment">// 节点3的邻居节点是1和4</span><br>        &#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>&#125;,      <span class="hljs-comment">// 节点4的邻居节点是1和3</span><br>        &#123;<span class="hljs-number">2</span>&#125;          <span class="hljs-comment">// 节点5的邻居节点是2</span><br>    &#125;;<br><br>    <span class="hljs-type">int</span> numNodes = graph.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">visited</span><span class="hljs-params">(numNodes, <span class="hljs-literal">false</span>)</span></span>;<br><br>    <span class="hljs-comment">// 从节点0开始BFS</span><br>    <span class="hljs-built_in">bfs</span>(<span class="hljs-number">0</span>, graph, visited);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li><p><strong>图的表示</strong>: 这里使用邻接表来表示图，每个节点的邻居节点存储在一个<code>vector</code>中。</p></li><li><p><strong>BFS函数</strong>：</p><ul><li><code>bfs</code>函数接受起始节点<code>start</code>，图<code>graph</code>，以及一个用于标记节点是否已访问的<code>visited</code>数组。</li><li>使用一个队列<code>queue</code>来模拟BFS的层级访问过程。</li><li>将起始节点标记为已访问并入队。</li><li>当队列不为空时，弹出队列的第一个节点（FIFO），打印该节点，然后将其所有未访问的邻居节点标记为已访问并入队。</li></ul></li><li><p><strong>主函数</strong>：</p><ul><li>定义了一个示例图。</li><li>创建一个<code>visited</code>数组来跟踪每个节点的访问状态。</li><li>从节点0开始调用BFS函数。</li></ul></li></ol><p>这个示例展示了如何使用队列来实现BFS。如果你更喜欢使用递归来实现BFS，可以使用一个辅助函数来模拟队列的功能，但通常非递归的实现更直观和高效，因为BFS本身就是一个层级遍历的过程。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> index, vector&lt;<span class="hljs-type">int</span>&gt; &amp;matchsticks, vector&lt;<span class="hljs-type">int</span>&gt; &amp;edges, <span class="hljs-type">int</span> len)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (index == matchsticks.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; edges.<span class="hljs-built_in">size</span>()<span class="hljs-comment">/*4*/</span>; i++) &#123;<br>            edges[i] += matchsticks[index];<br>            <span class="hljs-keyword">if</span> (edges[i] &lt;= len &amp;&amp; <span class="hljs-built_in">dfs</span>(index + <span class="hljs-number">1</span>, matchsticks, edges, len)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            edges[i] -= matchsticks[index];<br>            <span class="hljs-comment">//算法的关键：判断条件：如果edges没有超过边界，那么尝试把第index+1根火柴添加到每一条边上</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">makesquare</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;matchsticks)</span> </span>&#123;<br>        <span class="hljs-type">int</span> totalLen = <span class="hljs-built_in">accumulate</span>(matchsticks.<span class="hljs-built_in">begin</span>(), matchsticks.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span> (totalLen % <span class="hljs-number">4</span> != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-built_in">sort</span>(matchsticks.<span class="hljs-built_in">begin</span>(), matchsticks.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">greater</span>&lt;<span class="hljs-type">int</span>&gt;()); <br>        <span class="hljs-comment">// 减少搜索量</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">edges</span><span class="hljs-params">(<span class="hljs-number">4</span>)</span></span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>, matchsticks, edges, totalLen / <span class="hljs-number">4</span>);<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h2 id="4-Leetcode-921-栈（LIFO）的应用"><a href="#4-Leetcode-921-栈（LIFO）的应用" class="headerlink" title="4 Leetcode 921 栈（LIFO）的应用"></a>4 Leetcode 921 栈（LIFO）的应用</h2><p>栈的“先进后出”</p><p>只有满足下面几点之一，括号字符串才是有效的：</p><ul><li>它是一个空字符串，或者</li><li>它可以被写成 <code>AB</code> （<code>A</code> 与 <code>B</code> 连接）, 其中 <code>A</code> 和 <code>B</code> 都是有效字符串，或者</li><li>它可以被写作 <code>(A)</code>，其中 <code>A</code> 是有效字符串。</li></ul><p>给定一个括号字符串 <code>s</code> ，在每一次操作中，你都可以在字符串的任何位置插入一个括号</p><ul><li>例如，如果 <code>s = &quot;()))&quot;</code> ，你可以插入一个开始括号为 <code>&quot;(()))&quot;</code> 或结束括号为 <code>&quot;())))&quot;</code> 。</li></ul><p>返回 <em>为使结果字符串 <code>s</code> 有效而必须添加的最少括号数</em>。</p><h4 id="解法：使用栈！"><a href="#解法：使用栈！" class="headerlink" title="解法：使用栈！"></a>解法：使用栈！</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minAddToMakeValid</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        stack &lt;<span class="hljs-type">char</span>&gt; thekuohao;<br>        <span class="hljs-comment">//代表一个栈，之后不断压入内容</span><br>        <span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> ch:s)&#123;<br>            <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;(&#x27;</span>)&#123;<br>                thekuohao.<span class="hljs-built_in">push</span>(ch);<br>                <span class="hljs-comment">//左括号希望在后面找到他唯一匹配的右括号</span><br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;)&#x27;</span>)&#123;<br>                <span class="hljs-keyword">if</span>(!thekuohao.<span class="hljs-built_in">empty</span>()&amp;&amp;thekuohao.<span class="hljs-built_in">top</span>()==<span class="hljs-string">&#x27;(&#x27;</span>)&#123;<br>                    thekuohao.<span class="hljs-built_in">pop</span>();<br>                    <span class="hljs-comment">//找到了，弹出栈顶的左括号，同时不压入右括号</span><br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    count++;<br>                    <span class="hljs-comment">//说明此时的右括号无人访问，需要在另一个方向压入新的左括号</span><br>                    <span class="hljs-comment">//count统计到的时需要添加的左括号（即存在盈余的右括号）</span><br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count+thekuohao.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">//最后留在栈中的括号都是未被匹配到的左括号</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>如果降低空间复杂度O（1），则可以这样做：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minAddToMakeValid</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> leftCount = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;c : s) &#123;<br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                leftCount++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (leftCount &gt; <span class="hljs-number">0</span>) &#123;<br>                    leftCount--;<br>                    <span class="hljs-comment">//那么右括号一定可以找到被匹配的左括号</span><br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    ans++;<br>                    <span class="hljs-comment">//leftcount==0，说明此时应该在另一侧加入括号</span><br>                &#125;<br>            &#125;<br>        &#125;<br>        ans += leftCount;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h2 id="5-Leetcode-937-自定义排序"><a href="#5-Leetcode-937-自定义排序" class="headerlink" title="5 Leetcode 937 自定义排序"></a>5 Leetcode 937 自定义排序</h2><p>给你一个日志数组 <code>logs</code>。每条日志都是以空格分隔的字串，其第一个字为字母与数字混合的 <strong>标识符</strong> 。</p><p>有两种不同类型的日志：</p><ul><li><strong>字母日志</strong>：除标识符之外，所有字均由小写字母组成</li><li><strong>数字日志</strong>：除标识符之外，所有字均由数字组成</li></ul><p>请按下述规则将日志重新排序：</p><ul><li>所有 <strong>字母日志</strong> 都排在 <strong>数字日志</strong> 之前。</li><li><strong>字母日志</strong> 在内容不同时，忽略标识符后，按内容字母顺序排序；在内容相同时，按标识符排序。</li><li><strong>数字日志</strong> 应该保留原来的相对顺序。</li></ul><p>返回日志的最终顺序。</p><p><strong>示例 1：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：logs = [<span class="hljs-string">&quot;dig1 8 1 5 1&quot;</span>,<span class="hljs-string">&quot;let1 art can&quot;</span>,<span class="hljs-string">&quot;dig2 3 6&quot;</span>,<span class="hljs-string">&quot;let2 own kit dig&quot;</span>,<span class="hljs-string">&quot;let3 art zero&quot;</span>]<br>输出：[<span class="hljs-string">&quot;let1 art can&quot;</span>,<span class="hljs-string">&quot;let3 art zero&quot;</span>,<span class="hljs-string">&quot;let2 own kit dig&quot;</span>,<span class="hljs-string">&quot;dig1 8 1 5 1&quot;</span>,<span class="hljs-string">&quot;dig2 3 6&quot;</span>]<br>解释：<br>字母日志的内容都不同，所以顺序为 <span class="hljs-string">&quot;art can&quot;</span>, <span class="hljs-string">&quot;art zero&quot;</span>, <span class="hljs-string">&quot;own kit dig&quot;</span> 。<br>数字日志保留原来的相对顺序 <span class="hljs-string">&quot;dig1 8 1 5 1&quot;</span>, <span class="hljs-string">&quot;dig2 3 6&quot;</span> 。<br></code></pre></td></tr></table></figure><p><strong>对于较为复杂的排序问题，可以尝试使用自定义排序的方法实现排序规则的“自定义”。</strong></p><h4 id="最基本的例子：使用sort函数实现升序和降序数组排序"><a href="#最基本的例子：使用sort函数实现升序和降序数组排序" class="headerlink" title="最基本的例子：使用sort函数实现升序和降序数组排序"></a>最基本的例子：使用sort函数实现升序和降序数组排序</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-comment">// 自定义比较函数</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    <span class="hljs-comment">// 这里定义你的排序规则</span><br>    <span class="hljs-comment">// 返回true表示a应该在b之前（即a较小）</span><br>    <span class="hljs-keyword">return</span> a &lt; b;  <span class="hljs-comment">// 这是一个简单的升序比较</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; numbers = &#123;<span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">9</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;;<br><br>    <span class="hljs-comment">// 使用自定义比较函数进行升序排序</span><br>    std::<span class="hljs-built_in">sort</span>(numbers.<span class="hljs-built_in">begin</span>(), numbers.<span class="hljs-built_in">end</span>(), compare);<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;自定义升序排序后的结果: &quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; num : numbers) &#123;<br>        std::cout &lt;&lt; num &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    std::cout &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 现在定义一个不同的比较函数进行降序排序</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">descendingCompare</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> a &gt; b;  <span class="hljs-comment">// 返回true表示a应该在b之后（即b较小）</span><br>    &#125;<br><br>    <span class="hljs-comment">// 使用自定义比较函数进行降序排序</span><br>    std::<span class="hljs-built_in">sort</span>(numbers.<span class="hljs-built_in">begin</span>(), numbers.<span class="hljs-built_in">end</span>(), descendingCompare);<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;自定义降序排序后的结果: &quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; num : numbers) &#123;<br>        std::cout &lt;&lt; num &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    std::cout &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">reorderLogFiles</span><span class="hljs-params">(vector&lt;string&gt;&amp; logs)</span> </span>&#123;<br>        <span class="hljs-built_in">stable_sort</span>(logs.<span class="hljs-built_in">begin</span>(), logs.<span class="hljs-built_in">end</span>(), [&amp;](<span class="hljs-type">const</span> string &amp; log1, <span class="hljs-type">const</span> string &amp; log2) &#123;<br>            <span class="hljs-comment">//使用stable_sort保证相同元素排序的稳定性</span><br>            <span class="hljs-type">int</span> pos1 = log<span class="hljs-number">1.f</span>ind_first_of(<span class="hljs-string">&quot; &quot;</span>);<br>            <span class="hljs-type">int</span> pos2 = log<span class="hljs-number">2.f</span>ind_first_of(<span class="hljs-string">&quot; &quot;</span>);<br>            <span class="hljs-comment">//库函数find_first_of()可以实现定位到字符串的目标字符的第一个索引位置</span><br>            <br>            <span class="hljs-type">bool</span> isDigit1 = <span class="hljs-built_in">isdigit</span>(log1[pos1 + <span class="hljs-number">1</span>]);<br>            <span class="hljs-type">bool</span> isDigit2 = <span class="hljs-built_in">isdigit</span>(log2[pos2 + <span class="hljs-number">1</span>]);<br>            <span class="hljs-comment">//这两个bool值判断是否为数字，进而实现对两种不同的日志的分类</span><br>            <span class="hljs-keyword">if</span> (isDigit1 &amp;&amp; isDigit2) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                <span class="hljs-comment">//都是数字，保持位置</span><br>            &#125;<br>            <span class="hljs-keyword">if</span> (!isDigit1 &amp;&amp; !isDigit2) &#123;<br>                <span class="hljs-comment">//如果都不是数字</span><br>                string s1 = log<span class="hljs-number">1.</span><span class="hljs-built_in">substr</span>(pos1);<br>                <span class="hljs-comment">//复制子串的库函数 substr()</span><br>                string s2 = log<span class="hljs-number">2.</span><span class="hljs-built_in">substr</span>(pos2);<br>                <span class="hljs-keyword">if</span> (s1 != s2) &#123;<br>                    <span class="hljs-comment">//string类重载了对应运算符，可以直接实现字符串的比较(逐位比较)</span><br>                    <span class="hljs-keyword">return</span> s1 &lt; s2;<br>                &#125;<br>                <span class="hljs-keyword">return</span> log1 &lt; log2;<br>                <span class="hljs-comment">//如果内容相同，则比较日志头部log1和log2</span><br>            &#125;<br>            <span class="hljs-keyword">return</span> isDigit1 ? <span class="hljs-literal">false</span> : <span class="hljs-literal">true</span>;<br>            <span class="hljs-comment">//最后一种情况，一个为数字，一个为字符，则根据规则字符应该排在前面</span><br>        &#125;);<br>        <span class="hljs-comment">//以上内容都是Lambda表达式，实现对自定义排序函数compare的定义</span><br>        <span class="hljs-comment">//在compare中，如果匿名函数返回false，说明不用交换顺序</span><br>        <span class="hljs-keyword">return</span> logs;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h3 id="补充知识点讲解：Lambda表达式"><a href="#补充知识点讲解：Lambda表达式" class="headerlink" title="补充知识点讲解：Lambda表达式"></a>补充知识点讲解：Lambda表达式</h3><p>在C++中，lambda表达式（Lambda Expressions）<strong>是一种简洁的方式来定义匿名函数对象</strong>（即没有名称的函数），它允许你直接在代码中定义小型的、一次性使用的函数。<strong>这些函数对象可以捕获外部作用域中的变量</strong>，并可以在需要时直接使用。Lambda表达式的引入使得C++编程更加灵活和方便，特别是在需要短小、临时函数时。以下是关于lambda表达式的一些关键点：</p><h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><p>Lambda表达式的基本形式如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">[捕获列表](参数列表)可变性规范 -&gt; 返回类型 &#123;<br>    <span class="hljs-comment">// 函数体</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>捕获列表</strong>：<code>[]</code> 用于指定哪些外部变量应该被lambda表达式捕获。可以是：<ul><li><code>[]</code> 什么都不捕获。</li><li><code>[=]</code> 按值捕获所有可见的外部变量。</li><li><code>[&amp;]</code> 按引用捕获所有可见的外部变量。</li><li><code>[x, &amp;y]</code> 按值捕获<code>x</code>，按引用捕获<code>y</code>。</li></ul></li><li><strong>参数列表</strong>：类似于普通函数的参数列表，可以为空。</li><li><strong>可变性规范</strong>：<code>mutable</code>关键字表示lambda表达式可以修改被值捕获的变量。</li><li><strong>返回类型</strong>：如果lambda表达式包含多个<code>return</code>语句或需要明确指定返回类型，可以使用<code>-&gt;</code>来指定。</li><li><strong>函数体</strong>：包含lambda表达式的实际代码。</li></ul><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; numbers = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>    <span class="hljs-type">int</span> factor = <span class="hljs-number">2</span>;<br><br>    <span class="hljs-comment">// 使用lambda表达式对向量中的每个元素乘以factor</span><br>    std::for_each(numbers.<span class="hljs-built_in">begin</span>(), numbers.<span class="hljs-built_in">end</span>(), [factor](<span class="hljs-type">int</span> &amp;n) &#123;<br>        n *= factor;<br>    &#125;);<br><br>    <span class="hljs-comment">// 打印结果</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; num : numbers) &#123;<br>        std::cout &lt;&lt; num &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    std::cout &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 另一个lambda表达式示例，返回一个函数</span><br>    <span class="hljs-keyword">auto</span> add = [](<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y) -&gt; <span class="hljs-type">int</span> &#123;<br>        <span class="hljs-keyword">return</span> x + y;<br>    &#125;;<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;1 + 2 = &quot;</span> &lt;&lt; <span class="hljs-built_in">add</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li><strong>匿名性</strong>：Lambda表达式是匿名的，不需要为其定义一个名称。</li><li><strong>捕获外部变量</strong>：可以捕获外部作用域的变量，允许这些变量在lambda表达式内使用。</li><li><strong>简洁性</strong>：相比于定义一个函数对象或函数指针，lambda表达式更加简洁。</li><li><strong>闭包</strong>：lambda表达式可以创建闭包，捕获的变量在lambda表达式执行时仍然有效。</li></ul><p>Lambda表达式在C++11及以后的标准中被引入，极大地方便了编写简短的函数式代码，常用于STL算法、事件处理、异步编程等场景。</p><h3 id="补充知识点讲解：深入了解sort函数"><a href="#补充知识点讲解：深入了解sort函数" class="headerlink" title="补充知识点讲解：深入了解sort函数"></a>补充知识点讲解：深入了解sort函数</h3><p><code>std::sort</code>在C++标准库中实现的是<strong>内省排序（Introsort）</strong>，这是一种混合排序算法，结合了快速排序（Quicksort）、堆排序（Heapsort）和插入排序（Insertion Sort）的优点。以下是<code>std::sort</code>的基本原理：</p><h4 id="1-快速排序（Quicksort）"><a href="#1-快速排序（Quicksort）" class="headerlink" title="1. 快速排序（Quicksort）"></a>1. <strong>快速排序（Quicksort）</strong></h4><ul><li><code>std::sort</code>首先尝试使用快速排序，因为快速排序在平均情况下有很好的性能，时间复杂度为O(n log n)。</li><li>快速排序通过选择一个枢轴元素（pivot）将数组分成两部分，比枢轴小的元素放在一侧，比枢轴大的元素放在另一侧，然后递归地对这两部分进行排序。</li></ul><h4 id="2-堆排序（Heapsort）"><a href="#2-堆排序（Heapsort）" class="headerlink" title="2. 堆排序（Heapsort）"></a>2. <strong>堆排序（Heapsort）</strong></h4><ul><li>当快速排序的递归深度超过一定阈值时（通常是log n），<code>std::sort</code>会切换到堆排序。</li><li>堆排序保证了最坏情况下的时间复杂度为O(n log n)，避免了快速排序在某些情况下可能退化到O(n^2)的性能。</li></ul><h4 id="3-插入排序（Insertion-Sort）"><a href="#3-插入排序（Insertion-Sort）" class="headerlink" title="3. 插入排序（Insertion Sort）"></a>3. <strong>插入排序（Insertion Sort）</strong></h4><ul><li>对于小规模的数据（通常是少于16个元素的子数组），<code>std::sort</code>会使用插入排序，因为在小数据集上，插入排序的性能通常优于其他排序算法。</li></ul><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ul><li><strong>自适应性</strong>：<code>std::sort</code>根据数据的大小和递归深度自动选择最适合的排序策略，这使得它在各种情况下都表现良好。</li><li><strong>稳定性</strong>：<code>std::sort</code>不是稳定的排序算法，这意味着相同元素的相对顺序在排序后可能改变。如果需要稳定排序，可以使用<code>std::stable_sort</code>。</li><li><strong>内存使用</strong>：<code>std::sort</code>通常是原地排序算法，意味它不需要额外的内存空间（除了递归调用栈），这对大规模数据的排序是非常有利的。</li></ul><p>由于C++标准库的具体实现可能会因不同的编译器和标准库版本而有所不同，这里提供一个简化的、概念性的<code>std::sort</code>实现，展示内省排序的核心思想：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">namespace</span> std &#123;<br>    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">RandomIt</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">Compare</span> = std::less&lt;&gt;&gt;<br>    <span class="hljs-type">void</span> <span class="hljs-built_in">sort</span>(RandomIt first, RandomIt last, Compare comp = <span class="hljs-built_in">Compare</span>()) &#123;<br>        <span class="hljs-comment">// 内省排序的阈值，通常为log(n)</span><br>        <span class="hljs-type">const</span> <span class="hljs-type">int</span> introsort_threshold = <span class="hljs-number">2</span> * <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-built_in">log</span>(last - first) / <span class="hljs-built_in">log</span>(<span class="hljs-number">2</span>));<br><br>        <span class="hljs-comment">// 辅助函数，执行快速排序</span><br>        <span class="hljs-keyword">auto</span> quicksort = [&amp;](RandomIt low, RandomIt high, <span class="hljs-type">int</span> depth) &#123;<br>            <span class="hljs-keyword">if</span> (high - low &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 已经排序或只有一个元素</span><br><br>            <span class="hljs-keyword">if</span> (depth == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// 达到最大深度，使用堆排序</span><br>                std::<span class="hljs-built_in">make_heap</span>(low, high, comp);<br>                std::<span class="hljs-built_in">sort_heap</span>(low, high, comp);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br><br>            --depth;<br><br>            <span class="hljs-comment">// 选择枢轴并进行分区</span><br>            RandomIt pivot = std::<span class="hljs-built_in">partition</span>(low, high, <br>                [&amp;](<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; a) &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">comp</span>(a, *std::<span class="hljs-built_in">next</span>(high, <span class="hljs-number">-1</span>)); &#125;);<br><br>            <span class="hljs-comment">// 递归排序左右两部分</span><br>            <span class="hljs-built_in">quicksort</span>(low, pivot, depth);<br>            <span class="hljs-built_in">quicksort</span>(pivot, high, depth);<br>        &#125;;<br><br>        <span class="hljs-comment">// 开始内省排序</span><br>        <span class="hljs-built_in">quicksort</span>(first, last, introsort_threshold);<br><br>        <span class="hljs-comment">// 对小规模数据使用插入排序</span><br>        <span class="hljs-keyword">if</span> (last - first &lt;= <span class="hljs-number">16</span>) &#123;<br>            <span class="hljs-keyword">for</span> (RandomIt i = first + <span class="hljs-number">1</span>; i != last; ++i) &#123;<br>                <span class="hljs-keyword">auto</span> key = *i;<br>                RandomIt j = i - <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">while</span> (j &gt;= first &amp;&amp; <span class="hljs-built_in">comp</span>(key, *j)) &#123;<br>                    *(j + <span class="hljs-number">1</span>) = *j;<br>                    --j;<br>                &#125;<br>                *(j + <span class="hljs-number">1</span>) = key;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h4><ol><li><p><strong>内省排序阈值</strong>：<code>introsort_threshold</code>用于决定何时从快速排序切换到堆排序，通常设置为<code>2 * log(n)</code>。</p></li><li><p><strong>快速排序部分</strong>：</p><ul><li><code>quicksort</code>函数实现了快速排序的核心逻辑。</li><li>使用<code>std::partition</code>进行分区，基于比较函数<code>comp</code>。</li><li>当递归深度达到<code>introsort_threshold</code>时，切换到堆排序。</li></ul></li><li><p><strong>堆排序</strong>：</p><ul><li>当达到最大递归深度时，调用<code>std::make_heap</code>和<code>std::sort_heap</code>来完成排序。</li></ul></li><li><p><strong>插入排序</strong>：</p><ul><li>对于小规模数据（这里设定为16个元素或更少），使用插入排序来优化性能。</li></ul></li><li><p><strong>比较函数</strong>：</p><ul><li><code>comp</code>参数允许用户提供自定义的比较函数，实现自定义排序逻辑。</li></ul></li></ol><p>请注意，这是一个简化的实现，实际的标准库实现可能包含更多的优化：</p><ul><li>选择枢轴的策略可能更复杂，以避免最坏情况（如已经排序或逆序的数组）。</li><li>可能使用不同的阈值来决定何时切换到堆排序或插入排序。</li><li>内存管理和性能优化，如减少递归调用的栈空间使用。</li><li>可能使用其他技术来减少比较次数或提高缓存命中率。</li></ul><p>这种实现展示了内省排序的基本理念：结合快速排序的平均性能优势、堆排序的最坏情况保证，以及插入排序在小数据集上的效率。</p><h1 id="程序设计错题-36-40"><a href="#程序设计错题-36-40" class="headerlink" title="程序设计错题 36-40"></a>程序设计错题 36-40</h1><h2 id="1-Leetcode-334-经典算法题：递增三元子序列排序"><a href="#1-Leetcode-334-经典算法题：递增三元子序列排序" class="headerlink" title="1.Leetcode 334 经典算法题：递增三元子序列排序"></a>1.Leetcode 334 经典算法题：递增三元子序列排序</h2><p>给你一个整数数组 nums ，判断这个数组中是否存在长度为 3 的递增子序列。</p><p>如果存在这样的三元组下标 (i, j, k) 且满足 i &lt; j &lt; k ，使得 nums[i] &lt; nums[j] &lt; nums[k] ，返回 true ；否则，返回 false。</p><h4 id="解法1-O-n-3-暴力枚举"><a href="#解法1-O-n-3-暴力枚举" class="headerlink" title="解法1 O(n^3)暴力枚举"></a>解法1 O(n^3)暴力枚举</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">increasingTriplet</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>()&lt;<span class="hljs-number">3</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i<span class="hljs-number">+2</span>&lt;nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i<span class="hljs-number">+2</span>;j&lt;nums.<span class="hljs-built_in">size</span>();j++)&#123;<br>                <span class="hljs-keyword">if</span>(nums[j]&lt;=nums[i])&#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=i<span class="hljs-number">+1</span>;k&lt;j;k++)&#123;<br>                        <span class="hljs-keyword">if</span>(nums[j]&gt;nums[k]&amp;&amp;nums[k]&gt;nums[i])&#123;<br>                            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="解法2-动态规划（也会超时）"><a href="#解法2-动态规划（也会超时）" class="headerlink" title="解法2 动态规划（也会超时）"></a>解法2 动态规划（也会超时）</h4><p>维护一个dp[i]<strong>来记录每个位置的最长递增子序列的长度</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">increasingTriplet</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() &lt; <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(nums.size(), <span class="hljs-number">1</span>)</span></span>;<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; i; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (nums[i] &gt; nums[j]) &#123;<br>                    dp[i] = std::<span class="hljs-built_in">max</span>(dp[i], dp[j] + <span class="hljs-number">1</span>);<br>                    <span class="hljs-keyword">if</span> (dp[i] &gt;= <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><p>牺牲空间复杂度，换取时间复杂度：O(n^2)和O(n)</p><h4 id="优化1-使用双向遍历"><a href="#优化1-使用双向遍历" class="headerlink" title="优化1 使用双向遍历"></a>优化1 使用双向遍历</h4><p><img src="/posts/Leetcode-Mistake-collection-31-40/1.png" alt="双向遍历"></p><p>维护数组的好处：提高了空间复杂度，但是不用在每一次遍历的时候重新找存在的元素了（相当于动态规划的思想）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">increasingTriplet</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n=nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(n&lt;<span class="hljs-number">3</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">leftnum</span><span class="hljs-params">(n,nums[<span class="hljs-number">0</span>])</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">rightnum</span><span class="hljs-params">(n,nums[n<span class="hljs-number">-1</span>])</span></span>;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;<br>            leftnum[i]=<span class="hljs-built_in">min</span>(leftnum[i<span class="hljs-number">-1</span>],nums[i]);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n<span class="hljs-number">-2</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>            rightnum[i]=<span class="hljs-built_in">max</span>(rightnum[i<span class="hljs-number">+1</span>],nums[i]);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n<span class="hljs-number">-1</span>;i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i]&gt;leftnum[i<span class="hljs-number">-1</span>]&amp;&amp;nums[i]&lt;rightnum[i<span class="hljs-number">+1</span>])&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>时间复杂度：O(n^2)</p><p>空间复杂度：O(n^2)</p><h4 id="优化2-贪婪算法"><a href="#优化2-贪婪算法" class="headerlink" title="优化2 贪婪算法"></a>优化2 贪婪算法</h4><p>first 和 second 代表这个数组中我们所找到的最小值和次小值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;climits&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">increasingTriplet</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> first = INT_MAX, second = INT_MAX;<br>        <span class="hljs-comment">//定义系统的最大最小值</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> n : nums) &#123;<br>            <span class="hljs-keyword">if</span> (n &lt;= first) &#123;<br>                first = n;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n &lt;= second) &#123;<br>                second = n;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//(n&gt;first &amp;&amp; n&gt;second)</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                <span class="hljs-comment">//理论分析：找到最小值和次小值为什么就可以判定true？</span><br>                <span class="hljs-comment">//找到了n&gt;first &amp;&amp; n&gt;second，则n作为三元组的最后一个数，而且根据遍历的规则，n的前面一个数一定是当前数组的second或者first！</span><br>                <span class="hljs-comment">//如果是second，那么说明first还在前面，找到了符合条件的三元组</span><br>                <span class="hljs-comment">//如果是first，因为这里n&gt;second，说明second的值已经被更新过，说明在n前面，first的值至少被更新过两次，second至少被更新过一次</span><br>                <span class="hljs-comment">//a1(数组第一个数，被更新为first)——a2(second)--a3(first)--n</span><br>                <span class="hljs-comment">//a1和a3之间还可以有很多次second和first值的更新，a3&lt;a1&lt;a2&lt;n;</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><p>时间复杂度O(n)，空间复杂度O(1)</p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Finished</tag>
      
      <tag>C/C++</tag>
      
      <tag>Leetcode notes</tag>
      
      <tag>algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode-Mistake-Collection-21-30</title>
    <link href="/posts/Leetcode-Mistake-collection-21-30/"/>
    <url>/posts/Leetcode-Mistake-collection-21-30/</url>
    
    <content type="html"><![CDATA[<style>  html, body, .markdown-body {    font-family: Georgia, sans, serif;  }</style><h1 id="Leetcode-Mistake-collection-21-30"><a href="#Leetcode-Mistake-collection-21-30" class="headerlink" title="Leetcode-Mistake-collection-21-30"></a>Leetcode-Mistake-collection-21-30</h1><h1 id="程设错题-21-24-2024-11-1-2024-11-4"><a href="#程设错题-21-24-2024-11-1-2024-11-4" class="headerlink" title="程设错题 21-24 2024-11-1 2024-11-4"></a>程设错题 21-24 2024-11-1 2024-11-4</h1><h2 id="1-Leetcode-453-最小操作次数使数组元素相等"><a href="#1-Leetcode-453-最小操作次数使数组元素相等" class="headerlink" title="1. Leetcode 453 最小操作次数使数组元素相等"></a>1. Leetcode 453 最小操作次数使数组元素相等</h2><p><strong>不要所有方法都使用最原始的编程方法解决！</strong></p><p>给你一个长度为 <code>n</code> 的整数数组，每次操作将会使 <code>n - 1</code> 个元素增加 <code>1</code> 。返回让数组所有元素相等的最小操作次数。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,2,3]</span><br>输出：3<br>解释：<br>只需要3次操作（注意每次操作会增加两个元素的值）：<br><span class="hljs-comment">[1,2,3]</span>  =&gt;  <span class="hljs-comment">[2,3,3]</span>  =&gt;  <span class="hljs-comment">[3,4,3]</span>  =&gt;  <span class="hljs-comment">[4,4,4]</span><br></code></pre></td></tr></table></figure><h3 id="解法1-最基本解法（计算-枚举）"><a href="#解法1-最基本解法（计算-枚举）" class="headerlink" title="解法1 最基本解法（计算+枚举）"></a>解法1 最基本解法（计算+枚举）</h3><p>​<strong>时间复杂度过高</strong>（最坏时间复杂度：O(n^2)）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minMoves</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>()==<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> max=nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> num:nums)&#123;<br>            sum+=num;<br>            <span class="hljs-keyword">if</span>(num&gt;max)&#123;<br>                max=num;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> diff=nums.<span class="hljs-built_in">size</span>()*max-sum;<br>        <span class="hljs-keyword">while</span>(diff%(nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>))&#123;<br>            diff+=(nums.<span class="hljs-built_in">size</span>());<br>        &#125;<br>        <span class="hljs-type">bool</span> flag=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> standard=(<span class="hljs-built_in">long</span>(diff)+sum)/nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">while</span>(!flag)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> num:nums)&#123;<br>                <span class="hljs-keyword">if</span>(standard-num&gt;(diff/(nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>)))&#123;<br>                    flag=<span class="hljs-number">0</span>;<br>                    standard+=nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>                    diff+=nums.<span class="hljs-built_in">size</span>()*(nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                flag=<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> diff/(nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="解法2-巧妙的转化"><a href="#解法2-巧妙的转化" class="headerlink" title="解法2 巧妙的转化"></a>解法2 巧妙的转化</h3><p>​因为只需要找出让数组所有元素相等的最小操作次数，所以我们不需要考虑数组中各个元素的绝对大小，即不需要真正算出数组中所有元素相等时的元素值，只需要考虑数组中元素相对大小的变化即可。</p><p>​因此，每次操作既可以理解为使 n−1 个元素增加 1，也可以理解使 1 个元素减少 1。显然，后者更利于我们的计算。</p><p>​于是，要计算让数组中所有元素相等的操作数，我们只需要计算将数组中所有元素都减少到数组中元素最小值所需的操作数。</p><p><strong>这个方法没有次数的限制，所以不用通过枚举找到可行解！</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minMoves</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> minNum = *<span class="hljs-built_in">min_element</span>(nums.<span class="hljs-built_in">begin</span>(),nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-comment">//找到数组中的最小值</span><br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            res += num - minNum;<br>        &#125;<br>        <span class="hljs-comment">//通过累加得到一共需要操作的次数</span><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="2-Leetcode-448-找到数组中消失的数字"><a href="#2-Leetcode-448-找到数组中消失的数字" class="headerlink" title="2. Leetcode 448 找到数组中消失的数字"></a>2. Leetcode 448 找到数组中消失的数字</h2><p>给你一个含 <code>n</code> 个整数的数组 <code>nums</code> ，其中 <code>nums[i]</code> 在区间 <code>[1, n]</code> 内。请你找出所有在 <code>[1, n]</code> 范围内但没有出现在 <code>nums</code> 中的数字，并以数组的形式返回结果。</p><h3 id="解法1-使用动态数组（new-delete）"><a href="#解法1-使用动态数组（new-delete）" class="headerlink" title="解法1 使用动态数组（new&amp;delete）"></a>解法1 使用动态数组（new&amp;delete）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">findDisappearedNumbers</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        vector &lt;<span class="hljs-type">int</span>&gt; successful;<br>        <span class="hljs-type">int</span> n=nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">bool</span> *list=<span class="hljs-keyword">new</span> <span class="hljs-type">bool</span>[n];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            list[i]=<span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> num:nums)&#123;<br>            list[num<span class="hljs-number">-1</span>]=<span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(!list[i])&#123;<br>                successful.<span class="hljs-built_in">push_back</span>(i<span class="hljs-number">+1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">delete</span>[] list;<br>        <span class="hljs-keyword">return</span> successful;<br>        <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="解法2-原地哈希表"><a href="#解法2-原地哈希表" class="headerlink" title="解法2 原地哈希表"></a>解法2 原地哈希表</h3><p><strong>不开辟新的内存空间，在原来的数组上进行操作</strong></p><p>我们可以用一个哈希表记录数组 nums 中的数字，由于数字范围均在 [1,n] 中，记录数字后我们再利用哈希表检查 [1,n] 中的每一个数是否出现，从而找到缺失的数字。</p><p>由于数字范围均在 [1,n] 中，我们也可以用一个长度为 n 的数组来代替哈希表。这一做法的空间复杂度是 O(n) 的。我们的目标是优化空间复杂度到 O(1)。</p><p>注意到 nums 的长度恰好也为 n，能否让 nums 充当哈希表呢？</p><p>由于 nums 的数字范围均在 [1,n] 中，我们可以<strong>利用这一范围之外的数字</strong>，来表达「是否存在」的含义。</p><p>具体来说，遍历 nums，每遇到一个数 x，就让 nums[x−1] 增加 n。由于 nums 中所有数均在 [1,n] 中，增加以后，这些数必然大于 n。最后我们遍历 nums，若 nums[i] 未大于 n，就说明没有遇到过数 i+1。这样我们就找到了缺失的数字。</p><p>注意，<strong>当我们遍历到某个位置时，其中的数可能已经被增加过，因此需要对 n 取模</strong>来还原出它本来的值。</p><p><strong>取模&amp;加倍数（进制）</strong>可以让一个数通过不同的运算储存不同的信息，例如32以10为进制可以储存3,2两个信息</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">findDisappearedNumbers</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; num : nums) &#123;<br>            <span class="hljs-type">int</span> x = (num - <span class="hljs-number">1</span>) % n;<br>            <span class="hljs-comment">//-1 problem，注意数组下标从0开始</span><br>            <span class="hljs-comment">//通过%取余运算得到原来的值</span><br>            nums[x] += n;<br>        &#125;<br>        vector&lt;<span class="hljs-type">int</span>&gt; ret;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] &lt;= n) &#123;<br>                <span class="hljs-comment">//证明这个值未出现过</span><br>                ret.<span class="hljs-built_in">push_back</span>(i + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h2 id="3-Leetcode-455-贪心算法分配饼干"><a href="#3-Leetcode-455-贪心算法分配饼干" class="headerlink" title="3. Leetcode 455 贪心算法分配饼干"></a>3. Leetcode 455 贪心算法分配饼干</h2><h3 id="补充：贪心算法"><a href="#补充：贪心算法" class="headerlink" title="补充：贪心算法"></a>补充：贪心算法</h3><p><strong>保证局部最优解&#x3D;全局最优解！</strong></p><h4 id="1-最优子结构性质"><a href="#1-最优子结构性质" class="headerlink" title="1. 最优子结构性质"></a>1. 最优子结构性质</h4><p><strong>定义</strong>：一个问题具有最优子结构性质，意味着问题的最优解可以通过其子问题的最优解来构建。这是动态规划和贪婪算法的共同特征。</p><p><strong>作用</strong>：如果一个问题具有最优子结构性质，贪婪算法可以通过解决每个子问题的最优解来逐步构建全局最优解。例如，在最小生成树问题中，局部最优的边选择能够合并成全局最优的生成树。</p><h4 id="2-无后效性"><a href="#2-无后效性" class="headerlink" title="2. 无后效性"></a>2. 无后效性</h4><p><strong>定义</strong>：无后效性是指当前选择不会影响未来选择的可行性或最优性。这意味着每一步做出的选择不会限制后续步骤中其他选择的可能性。</p><p><strong>作用</strong>：无后效性确保了贪婪算法在每一步做出局部最优选择时，不会对后续步骤产生负面影响。例如，在活动选择问题中，选择结束时间最早的活动不会影响后续活动的选择空间。</p><h4 id="3-贪婪选择性质的应用场景"><a href="#3-贪婪选择性质的应用场景" class="headerlink" title="3. 贪婪选择性质的应用场景"></a>3. 贪婪选择性质的应用场景</h4><p>一些典型的应用场景包括：</p><ul><li><strong>活动选择问题</strong>：选择一组互不重叠的活动，贪婪选择性质确保选择最早结束的活动是最优的。</li><li><strong>最小生成树问题</strong>：通过选择权重最小且不形成环的边来构建最小生成树。</li><li><strong>单源最短路径问题（无负权边）</strong>：在Dijkstra算法中，每次选择当前未访问顶点中距离最小的顶点。</li></ul><h4 id="4-不适用贪婪算法的问题"><a href="#4-不适用贪婪算法的问题" class="headerlink" title="4. 不适用贪婪算法的问题"></a>4. 不适用贪婪算法的问题</h4><p>并不是所有问题都适合用贪婪算法来解决。对于不具备贪婪选择性质的问题，贪婪算法可能无法找到全局最优解。例如：</p><ul><li><strong>旅行商问题（TSP）</strong>：贪婪算法可能无法找到最短路径，因为局部最优选择可能导致全局次优解。</li><li><strong>背包问题</strong>：在0-1背包问题中，贪婪算法可能无法找到最优解，因为选择价值密度最高的物品可能导致无法装入其他更有价值的组合。</li></ul><h4 id="5-识别适用性"><a href="#5-识别适用性" class="headerlink" title="5. 识别适用性"></a>5. 识别适用性</h4><p>在应用贪婪算法之前，识别问题是否具备贪婪选择性质和最优子结构是关键。通常需要通过理论分析或构造反例来验证贪婪策略的有效性。</p><p>总结来说，贪婪算法适用于那些具有最优子结构和无后效性的问题。在这些问题中，贪婪选择性质确保每一步的局部最优选择最终能组合成全局最优解。对于不具备这些性质的问题，可能需要其他算法（如动态规划或回溯）来找到全局最优解。</p><h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。</p><p>对每个孩子 <code>i</code>，都有一个胃口值 <code>g[i]</code>，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 <code>j</code>，都有一个尺寸 <code>s[j]</code> 。如果 <code>s[j] &gt;= g[i]</code>，我们可以将这个饼干 <code>j</code> 分配给孩子 <code>i</code> ，这个孩子会得到满足。你的目标是满足尽可能多的孩子，并输出这个最大数值。</p><h3 id="解法1-排序后遍历（繁琐做法）"><a href="#解法1-排序后遍历（繁琐做法）" class="headerlink" title="解法1:排序后遍历（繁琐做法）"></a>解法1:排序后遍历（繁琐做法）</h3><p>时间复杂度：<em>O</em>(<em>m</em>log<em>m</em>+<em>n</em>log<em>n</em>+<em>m</em>⋅<em>n</em>)</p><p>​mlogm和nlogn是排序的时间复杂度，mn是最后遍历的时间复杂度</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findContentChildren</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; g, vector&lt;<span class="hljs-type">int</span>&gt;&amp; s)</span> </span>&#123;<br>        <span class="hljs-built_in">sort</span>(g.<span class="hljs-built_in">begin</span>(),g.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">sort</span>(s.<span class="hljs-built_in">begin</span>(),s.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> select=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;g.<span class="hljs-built_in">size</span>()&amp;&amp;select&lt;s.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=select;j&lt;s.<span class="hljs-built_in">size</span>();j++)&#123;<br>                <span class="hljs-keyword">if</span>(s[j]&gt;=g[i])&#123;<br>                    count++;<br>                    j++;<br>                    select=j;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">//其实这里通过select不断提升j的枚举起点有点类似于双指针策略，但是代码的冗余之处在于如果出现遍历完还没有找到的情况，应该直接跳出外循环（我们已经排序过数组了）</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>解法1的小修改:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findContentChildren</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; g, vector&lt;<span class="hljs-type">int</span>&gt;&amp; s)</span> </span>&#123;<br>        <span class="hljs-built_in">sort</span>(g.<span class="hljs-built_in">begin</span>(),g.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">sort</span>(s.<span class="hljs-built_in">begin</span>(),s.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> select=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">bool</span> flag=<span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;g.<span class="hljs-built_in">size</span>()&amp;&amp;select&lt;s.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=select;j&lt;s.<span class="hljs-built_in">size</span>();j++)&#123;<br>                <span class="hljs-keyword">if</span>(s[j]&gt;=g[i])&#123;<br>                    flag=<span class="hljs-literal">true</span>;<br>                    count++;<br>                    j++;<br>                    select=j;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(!flag)&#123;<br>                <span class="hljs-keyword">return</span> count;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>        <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>(这样就不会超时了，但是代码还有优化的空间)</p><ul><li>这里其实不需要写两层for循环控制两个指针！</li></ul><h3 id="解法2：优化使用双指针"><a href="#解法2：优化使用双指针" class="headerlink" title="解法2：优化使用双指针"></a>解法2：优化使用双指针</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findContentChildren</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; g, vector&lt;<span class="hljs-type">int</span>&gt;&amp; s)</span> </span>&#123;<br>        <span class="hljs-built_in">sort</span>(g.<span class="hljs-built_in">begin</span>(), g.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">sort</span>(s.<span class="hljs-built_in">begin</span>(), s.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//define two pointers</span><br>        <span class="hljs-keyword">while</span> (i &lt; g.<span class="hljs-built_in">size</span>() &amp;&amp; j &lt; s.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-keyword">if</span> (s[j] &gt;= g[i]) &#123;<br>                count++;<br>                i++;<br>                <span class="hljs-comment">//if allocate successfully,then the both pointers get forward</span><br>            &#125;<br>            j++;<br>            <span class="hljs-comment">//whenever the allocate, the biscuit pointer gets forward</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><p>时间复杂度：O(mlogm)+O(nlogn)+O(m+n)&#x3D;O(mlogm+nlogn)</p><h3 id="补充：双指针"><a href="#补充：双指针" class="headerlink" title="补充：双指针"></a>补充：双指针</h3><p>双指针是一种常用的算法技巧，尤其在处理数组或链表等线性数据结构时非常有效。它通过使用两个指针来遍历数据结构，能够在某些情况下优化时间复杂度或简化逻辑。以下是双指针技巧的一些常见应用场景和简单介绍：</p><h3 id="1-快慢指针"><a href="#1-快慢指针" class="headerlink" title="1. 快慢指针"></a>1. 快慢指针</h3><ul><li><strong>应用场景</strong>：检测链表中的环、找到链表的中间节点。</li><li><strong>方法</strong>：<ul><li>使用两个指针，一个快指针每次移动两步，一个慢指针每次移动一步。</li><li>如果快指针和慢指针相遇，说明存在环。</li><li>找中间节点时，当快指针到达链表末尾时，慢指针正好在中间。</li></ul></li></ul><h3 id="2-左右指针"><a href="#2-左右指针" class="headerlink" title="2. 左右指针"></a>2. 左右指针</h3><ul><li><strong>应用场景</strong>：解决排序数组中的问题，如二分查找、三数之和。</li><li><strong>方法</strong>：<ul><li>初始化两个指针，分别指向数组的两端。</li><li>根据问题的要求，向中间移动指针。</li><li>常用于查找满足某种条件的对或子序列。</li><li>也可以实现动态的查找。</li></ul></li></ul><h3 id="3-滑动窗口"><a href="#3-滑动窗口" class="headerlink" title="3. 滑动窗口"></a>3. 滑动窗口</h3><ul><li><strong>应用场景</strong>：解决子数组问题，如最长无重复子串、最小覆盖子串。</li><li><strong>方法</strong>：<ul><li>使用两个指针定义一个窗口，初始时窗口为空。</li><li>移动右指针扩展窗口，移动左指针缩小窗口，直到满足条件。</li><li>在每次窗口变化时更新结果。</li></ul></li></ul><h3 id="示例：使用双指针解决有序数组中的两数之和"><a href="#示例：使用双指针解决有序数组中的两数之和" class="headerlink" title="示例：使用双指针解决有序数组中的两数之和"></a>示例：使用双指针解决有序数组中的两数之和</h3><p>假设我们有一个有序数组，想找到两个数，使它们的和等于目标值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; numbers, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = numbers.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>        <span class="hljs-type">int</span> sum = numbers[left] + numbers[right];<br>        <span class="hljs-keyword">if</span> (sum == target) &#123;<br>            <span class="hljs-keyword">return</span> &#123;left + <span class="hljs-number">1</span>, right + <span class="hljs-number">1</span>&#125;; <span class="hljs-comment">// 返回索引从1开始</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &lt; target) &#123;<br>            left++; <span class="hljs-comment">// 增加左指针以增加总和</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            right--; <span class="hljs-comment">// 减少右指针以减少总和</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> &#123;&#125;; <span class="hljs-comment">// 如果没有找到，返回空</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>双指针技巧通过合理移动两个指针，可以有效地减少遍历次数或简化算法逻辑。选择合适的双指针策略（如快慢指针、左右指针、滑动窗口）可以帮助解决许多复杂的算法问题。</p><h2 id="4-ACwing-633-两数平方和判断"><a href="#4-ACwing-633-两数平方和判断" class="headerlink" title="4. ACwing 633 两数平方和判断"></a>4. ACwing 633 两数平方和判断</h2><p>给定一个非负整数 <code>c</code> ，你要判断是否存在两个整数 <code>a</code> 和 <code>b</code>，使得 <code>a^2 + b^2 = c</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：c = 5<br>输出：true<br>解释：1 *<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 2 </span>*<span class="hljs-number"> 2 </span>= 5<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs llvm">输入：<span class="hljs-keyword">c</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span><br>输出：<span class="hljs-keyword">false</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= c &lt;= 2^31 - 1</code></li></ul><p>最暴力的解法：双循环暴力枚举（复杂度：O(n^2))</p><p>优化方法：使用sqrt函数省去一层循环</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">judgeSquareSum</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span> </span>&#123;<br>        <span class="hljs-type">double</span> b;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">long</span> <span class="hljs-type">long</span>  i=<span class="hljs-number">0</span>;(i)*i&lt;=c;i++)&#123;<br>            b=<span class="hljs-built_in">sqrt</span>(c-i*i);&#123;<br>                <span class="hljs-keyword">if</span>(b==<span class="hljs-built_in">int</span>(b))&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="补充方法：使用双指针枚举"><a href="#补充方法：使用双指针枚举" class="headerlink" title="补充方法：使用双指针枚举"></a>补充方法：使用双指针枚举</h4><p><img src="/1.png" alt="two pointers"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">judgeSquareSum</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span> </span>&#123;<br>        <span class="hljs-type">long</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">long</span> right = (<span class="hljs-type">int</span>)<span class="hljs-built_in">sqrt</span>(c);<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-type">long</span> sum = left * left + right * right;<br>            <span class="hljs-keyword">if</span> (sum == c) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &gt; c) &#123;<br>                right--;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                left++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h1 id="程序设计错题-25-30-20241105"><a href="#程序设计错题-25-30-20241105" class="headerlink" title="程序设计错题  25-30 20241105"></a>程序设计错题  25-30 20241105</h1><h2 id="1-Leetcode-877-先手必胜策略判断"><a href="#1-Leetcode-877-先手必胜策略判断" class="headerlink" title="1. Leetcode 877 先手必胜策略判断"></a>1. Leetcode 877 先手必胜策略判断</h2><p>Alice 和 Bob 用几堆石子在做游戏一共有偶数堆石子，<strong>排成一行</strong>；每堆都有 <strong>正</strong> 整数颗石子，数目为 <code>piles[i]</code> 。</p><p>游戏以谁手中的石子最多来决出胜负。石子的 <strong>总数</strong> 是 <strong>奇数</strong> ，所以没有平局。</p><p>Alice 和 Bob 轮流进行，<strong>Alice 先开始</strong> 。 每回合，玩家从行的 <strong>开始</strong> 或 <strong>结束</strong> 处取走整堆石头。 这种情况一直持续到没有更多的石子堆为止，此时手中 <strong>石子最多</strong> 的玩家 <strong>获胜</strong> 。</p><p>假设 Alice 和 Bob 都发挥出最佳水平，当 Alice 赢得比赛时返回 <code>true</code> ，当 Bob 赢得比赛时返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：piles = [5,3,4,5]<br>输出：true<br>解释：<br>Alice 先开始，只能拿前<span class="hljs-number"> 5 </span>颗或后<span class="hljs-number"> 5 </span>颗石子 。<br>假设他取了前<span class="hljs-number"> 5 </span>颗，这一行就变成了 [3,4,5] 。<br>如果 Bob 拿走前<span class="hljs-number"> 3 </span>颗，那么剩下的是 [4,5]，Alice 拿走后<span class="hljs-number"> 5 </span>颗赢得<span class="hljs-number"> 10 </span>分。<br>如果 Bob 拿走后<span class="hljs-number"> 5 </span>颗，那么剩下的是 [3,4]，Alice 拿走后<span class="hljs-number"> 4 </span>颗赢得<span class="hljs-number"> 9 </span>分。<br>这表明，取前<span class="hljs-number"> 5 </span>颗石子对 Alice 来说是一个胜利的举动，所以返回 true 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">piles</span> = [<span class="hljs-number">3</span>,<span class="hljs-number">7</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>2 &lt;= piles.length &lt;= 500</code></li><li><code>piles.length</code> 是 <strong>偶数</strong></li><li><code>1 &lt;= piles[i] &lt;= 500</code></li><li><code>sum(piles[i])</code> 是 <strong>奇数</strong></li></ul><p><strong>分析</strong>：此题贪婪算法并不适应，因为局部最优并不是全局最优</p><h4 id="为什么不能用贪婪算法？"><a href="#为什么不能用贪婪算法？" class="headerlink" title="为什么不能用贪婪算法？"></a>为什么不能用贪婪算法？</h4><ol><li><strong>局部最优不等于全局最优</strong>：在这种零和博弈中，贪婪策略只能保证每次选择当前最佳（即最多的石子堆），但这并不一定能得到最终的胜利。因为后续的选择会影响到剩余石子的选择，而不只是当前的选择。例如，某个玩家如果总是选择当前最多的石子堆，可能会在后续失去更多的机会，最终导致输掉游戏。</li><li><strong>博弈的前瞻性</strong>：每次玩家的选择不仅仅影响当前局面，还会影响到接下来的选择。理想的策略需要考虑未来的回合，预测对方的反应，并选择一个能最终获得胜利的方案。贪婪算法通常缺乏这种全局视野。</li><li><strong>博弈的相互作用</strong>：这道题的核心在于两方玩家都在做决策，而每个决策都会影响到后续的局面。需要通过动态规划来考虑在所有可能的局面下，哪种选择能够获得最终最优的结果。</li></ol><h3 id="解法-：区间动态规划"><a href="#解法-：区间动态规划" class="headerlink" title="解法 ：区间动态规划"></a>解法 ：区间动态规划</h3><p>为了求解这个问题，我们可以定义一个动态规划表 <code>dp[i][j]</code> 来表示在石子堆的区间 <code>[i, j]</code> 中，<strong>当前玩家</strong>（注意有可能是Bob！）与对手玩家的所得到石子之差的最大值。</p><h4 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h4><p>假设当前玩家面对的石子堆是 <code>[i, j]</code>，他可以选择：</p><ul><li>从前端取走 <code>piles[i]</code>，剩下的区间是 <code>[i+1, j]</code>，这个时候，剩下的区间 <code>[i+1, j]</code> 会是对方的回合。</li><li>从后端取走 <code>piles[j]</code>，剩下的区间是 <code>[i, j-1]</code>，这个时候，剩下的区间 <code>[i, j-1]</code> 会是对方的回合。</li></ul><p>对于每种选择，当前玩家的得分是<strong>他取走的石子的数量加上对方在剩余区间中的最差得分</strong>。为了确保当前玩家的策略最优，我们需要选取对方最差的选择（即，最小化对方得到的分数）。</p><p>因此，状态转移方程为：</p><ul><li><code>dp[i][j] = max(piles[i] + (sum(i+1, j) - dp[i+1][j]), piles[j] + (sum(i, j-1) - dp[i][j-1]))</code></li><li>这里是全局最优解！</li></ul><p>其中，<code>sum(i, j)</code> 是从 <code>i</code> 到 <code>j</code> 的石子堆总数。</p><h4 id="动态规划实现"><a href="#动态规划实现" class="headerlink" title="动态规划实现"></a>动态规划实现</h4><p>为了避免重复计算区间和，我们可以预先计算所有区间的石子总和，并使用这些预计算的和来加速我们的 DP 计算。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">stoneGame</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; piles)</span> </span>&#123;<br>        <span class="hljs-type">int</span> length = piles.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">auto</span> dp = vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;(length, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(length));<br>        <span class="hljs-comment">//定义二维数组</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>            dp[i][i] = piles[i];<br>        &#125;<br>        <span class="hljs-comment">//特殊情况：游戏进行到了最后一轮</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = length - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; length; j++) &#123;<br>                dp[i][j] = <span class="hljs-built_in">max</span>(piles[i] - dp[i + <span class="hljs-number">1</span>][j], piles[j] - dp[i][j - <span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//特殊的检索方法。类似于一个上三角矩阵并且确定了矩阵主对角线的元素的值</span><br>        <span class="hljs-comment">//这样可以保证每个元素在递归的时候都有值！</span><br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][length - <span class="hljs-number">1</span>] &gt; <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//dp[0][length - 1]代表能拿到的最优解</span><br>        <span class="hljs-comment">//在这里使用了归一化的思路，这样只要判断是否&gt;0就行了</span><br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><p>使用不同的动态规划数组：</p><p>​dp代表当前玩家在当前状态下，能够得到的最优解</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">stoneGame</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; piles)</span> </span>&#123;<br>        <br>        <span class="hljs-type">int</span> length=piles.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">auto</span> sumcount=vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;(length,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(length));<br>        <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;length;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;length;j++)&#123;<br>                <span class="hljs-keyword">if</span>(j&lt;i)&#123;<br>                    sumcount[i][j]=<span class="hljs-number">0</span>;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=i;k&lt;=j;k++)&#123;<br>                        sum+=piles[k];<br>                    &#125;<br>                    sumcount[i][j]=sum;<br>                    sum=<span class="hljs-number">0</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">auto</span> dp = vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;(length,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(length));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;length;i++)&#123;<br>            dp[i][i]=<span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=length<span class="hljs-number">-2</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i<span class="hljs-number">+1</span>;j&lt;length;j++)&#123;<br>                dp[i][j]=<span class="hljs-built_in">max</span>(piles[i]+sumcount[i<span class="hljs-number">+1</span>][j]-dp[i<span class="hljs-number">+1</span>][j],piles[j]+sumcount[i][j<span class="hljs-number">-1</span>]-dp[i][j<span class="hljs-number">-1</span>]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-number">2</span>*dp[<span class="hljs-number">0</span>][length<span class="hljs-number">-1</span>]&gt;sumcount[<span class="hljs-number">0</span>][length<span class="hljs-number">-1</span>])&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="2-Leetcode-942-DI字符串序列匹配生成"><a href="#2-Leetcode-942-DI字符串序列匹配生成" class="headerlink" title="2. Leetcode 942 DI字符串序列匹配生成"></a>2. Leetcode 942 DI字符串序列匹配生成</h2><p>由范围 <code>[0,n]</code> 内所有整数组成的 <code>n + 1</code> 个整数的排列序列可以表示为长度为 <code>n</code> 的字符串 <code>s</code> ，其中:</p><ul><li>如果 <code>perm[i] &lt; perm[i + 1]</code> ，那么 <code>s[i] == &#39;I&#39;</code> </li><li>如果 <code>perm[i] &gt; perm[i + 1]</code> ，那么 <code>s[i] == &#39;D&#39;</code></li></ul><p>给定一个字符串 <code>s</code> ，重构排列 <code>perm</code> 并返回它。如果有多个有效排列perm，则返回其中 <strong>任何一个</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：s = <span class="hljs-string">&quot;IDID&quot;</span><br>输出：[<span class="hljs-number">0</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：s = <span class="hljs-string">&quot;III&quot;</span><br>输出：[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：s = <span class="hljs-string">&quot;DDI&quot;</span><br>输出：[<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><h3 id="非常经典的贪心算法！"><a href="#非常经典的贪心算法！" class="headerlink" title="非常经典的贪心算法！"></a>非常经典的贪心算法！</h3><p>考虑 perm[0] 的值，根据题意：</p><p>如果 s[0]&#x3D;‘I’，那么令 perm[0]&#x3D;0，则无论 perm[1] 为何值都满足 perm[0]&lt;perm[1]；<br>如果 s[0]&#x3D;‘D’，那么令 perm[0]&#x3D;n，则无论 perm[1] 为何值都满足 perm[0]&gt;perm[1]；<br>确定好 perm[0] 后，剩余的 n−1 个字符和 n 个待确定的数就变成了一个和原问题相同，但规模为 n−1 的问题。因此我们可以继续按照上述方法确定 perm[1]：如果 s[1]&#x3D;‘I’，那么令 perm[1] 为剩余数字中的最小数；如果 s[1]&#x3D;‘D’，那么令 perm[1] 为剩余数字中的最大数。如此循环直至剩下一个数，填入 perm[n] 中。</p><p>如何实现该贪心算法？</p><h3 id="解法1：使用set容器自动削头去尾"><a href="#解法1：使用set容器自动削头去尾" class="headerlink" title="解法1：使用set容器自动削头去尾"></a>解法1：使用set容器自动削头去尾</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">diStringMatch</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        vector &lt;<span class="hljs-type">int</span>&gt; ans;<br>        <span class="hljs-type">int</span> n=s.<span class="hljs-built_in">length</span>();<br>        set &lt;<span class="hljs-type">int</span>&gt; allthenum;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;i++)&#123;<br>            allthenum.<span class="hljs-built_in">insert</span>(i);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;I&#x27;</span>)&#123;<br>                ans.<span class="hljs-built_in">push_back</span>(*(allthenum.<span class="hljs-built_in">begin</span>()));<br>                allthenum.<span class="hljs-built_in">erase</span>(allthenum.<span class="hljs-built_in">begin</span>());<br><br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                ans.<span class="hljs-built_in">push_back</span>((*<span class="hljs-built_in">prev</span>(allthenum.<span class="hljs-built_in">end</span>())));<br>                allthenum.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">prev</span>(allthenum.<span class="hljs-built_in">end</span>()));<br>                <br>            &#125;<br>        &#125;<br>        ans.<span class="hljs-built_in">push_back</span>(*(allthenum.<span class="hljs-built_in">begin</span>()));<br>        <span class="hljs-keyword">return</span> ans;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>set容器的底层是红黑树，可以实现自动元素的排序，但不支持元素的索引，要使用迭代器</strong></p><p><code>std::set</code>的迭代器是双向迭代器（bidirectional iterator），而不是随机访问迭代器（random access iterator），因此不支持减法操作。</p><p>如果你想获取<code>std::set</code>中最后一个元素的值，可以使用如下方法：</p><p>使用<code>std::prev</code></p><p><code>std::prev</code>是一个标准库函数，用于获取给定迭代器的前一个位置。你可以使用它来获取<code>set</code>的最后一个元素：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iterator&gt;</span> <span class="hljs-comment">// for std::prev</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::set&lt;<span class="hljs-type">int</span>&gt; allthenum = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><br>    <span class="hljs-comment">// 获取 set 的最后一个元素</span><br>    <span class="hljs-keyword">if</span> (!allthenum.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-type">int</span> lastElement = *std::<span class="hljs-built_in">prev</span>(allthenum.<span class="hljs-built_in">end</span>());<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Last element: &quot;</span> &lt;&lt; lastElement &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>allthenum.end()</code>返回的是一个指向<code>set</code>末尾的迭代器（即在最后一个元素之后的位置）。</li><li><code>std::prev(allthenum.end())</code>返回的是指向最后一个元素的迭代器。</li><li>使用<code>*</code>解引用这个迭代器来获取最后一个元素的值。</li></ul><p>这种方法是标准的方式来访问<code>std::set</code>的最后一个元素。确保在访问元素之前，检查集合是否为空，以避免解引用无效迭代器。</p><h3 id="解法2：优化解法：这里斩头或者去尾并不会改变剩下元素的排列顺序，所以可以使用vector数组（略）"><a href="#解法2：优化解法：这里斩头或者去尾并不会改变剩下元素的排列顺序，所以可以使用vector数组（略）" class="headerlink" title="解法2：优化解法：这里斩头或者去尾并不会改变剩下元素的排列顺序，所以可以使用vector数组（略）"></a>解法2：优化解法：这里斩头或者去尾并不会改变剩下元素的排列顺序，所以可以使用vector数组（略）</h3><p>此处也可以选择不开新的数组，直接使用双指针完成</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">diStringMatch</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">length</span>(), lo = <span class="hljs-number">0</span>, hi = n;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">perm</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            perm[i] = (s[i] == <span class="hljs-string">&#x27;I&#x27;</span> ? lo++ : hi--);<br>        &#125;<br>        perm[n] = lo; <span class="hljs-comment">// 最后剩下一个数，此时 lo == hi</span><br>        <span class="hljs-keyword">return</span> perm;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h2 id="3-Leetcode-11-盛水容器"><a href="#3-Leetcode-11-盛水容器" class="headerlink" title="3. Leetcode 11 盛水容器"></a>3. Leetcode 11 盛水容器</h2><p>给定一个长度为 <code>n</code> 的整数数组 <code>height</code> 。有 <code>n</code> 条垂线，第 <code>i</code> 条线的两个端点是 <code>(i, 0)</code> 和 <code>(i, height[i])</code> 。</p><p>找出其中的两条线，使得它们与 <code>x</code> 轴共同构成的容器可以容纳最多的水。</p><p>返回容器可以储存的最大水量。</p><p><strong>说明：</strong>你不能倾斜容器。</p><p><strong>示例 1：</strong></p><p><img src="https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg" alt="img"></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：[<span class="hljs-number">1,8,6,2</span>,<span class="hljs-number">5,4,8,3</span>,<span class="hljs-number">7</span>]<br>输出：<span class="hljs-number">49</span> <br>解释：图中垂直线代表输入数组 [<span class="hljs-number">1,8,6,2</span>,<span class="hljs-number">5,4,8,3</span>,<span class="hljs-number">7</span>]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 <span class="hljs-number">49</span>。<br></code></pre></td></tr></table></figure><p>最暴力解法：双枚举（超时）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxArea</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; height)</span> </span>&#123;<br>        <span class="hljs-type">long</span> max=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">long</span> ans;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;height.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i<span class="hljs-number">+1</span>;j&lt;height.<span class="hljs-built_in">size</span>();j++)&#123;<br>                ans=(j-i)*<span class="hljs-built_in">min</span>(height[i],height[j]);<br>                <span class="hljs-keyword">if</span>(ans&gt;max)&#123;<br>                    max=ans;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="解法优化：对枚举的剪枝操作"><a href="#解法优化：对枚举的剪枝操作" class="headerlink" title="解法优化：对枚举的剪枝操作"></a>解法优化：对枚举的剪枝操作</h4><p>剪枝算法是一种在搜索算法中用于减少计算量和提高效率的技术。它通过在搜索过程中剪去不必要的分支，从而避免遍历整个搜索空间。剪枝算法在许多领域中都有应用，尤其是在解决组合优化问题和博弈树搜索（如棋类游戏）时非常有效。以下是剪枝算法的一些关键概念和常见应用：</p><h5 id="关键概念"><a href="#关键概念" class="headerlink" title="关键概念"></a>关键概念</h5><ol><li><p><strong>搜索空间</strong>：这是所有可能解的集合。搜索算法的目标是找到满足某些条件的解。</p></li><li><p><strong>剪枝条件</strong>：在搜索过程中，算法会评估当前路径或分支是否有可能产生更优解。如果确定某个分支不可能产生更优解，则可以安全地剪去该分支。</p></li><li><p><strong>有效性</strong>：剪枝的有效性在于它能显著减少需要评估的节点数量，从而加快搜索速度。</p></li></ol><h5 id="常见类型"><a href="#常见类型" class="headerlink" title="常见类型"></a>常见类型</h5><ol><li><p><strong>Alpha-Beta 剪枝</strong>：</p><ul><li>这是博弈树搜索中常用的剪枝算法，特别是在两人零和游戏中（如国际象棋、围棋）。</li><li>它通过维护两个值（alpha 和 beta）来跟踪当前已知的最佳选择，从而剪去不可能影响最终决策的分支。</li></ul></li><li><p><strong>分支限界法</strong>：</p><ul><li>这是一种用于解决组合优化问题（如旅行商问题、背包问题）的算法。</li><li>它通过在搜索过程中计算当前路径的下界，并与当前已知的最优解进行比较，来决定是否剪去某个分支。</li></ul></li></ol><h5 id="应用领域"><a href="#应用领域" class="headerlink" title="应用领域"></a>应用领域</h5><ul><li><strong>人工智能和游戏</strong>：在游戏 AI 中，剪枝算法用于减少需要考虑的可能动作组合。</li><li><strong>组合优化</strong>：在解决诸如旅行商问题、背包问题等问题时，剪枝算法可以显著减少计算复杂度。</li><li><strong>决策树</strong>：在机器学习中，剪枝用于简化决策树模型，防止过拟合。</li></ul><h5 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h5><ul><li><strong>提高效率</strong>：通过减少需要评估的节点数量，剪枝算法可以显著加快搜索速度。</li><li><strong>节省资源</strong>：减少计算和内存使用，使得算法能够处理更大的问题规模。</li></ul><p>剪枝算法的核心在于通过合理的评估和决策，<strong>避免不必要的计算</strong>，从而提升算法的整体性能。</p><p>有哪些不必要的计算？</p><ul><li><p>嵌套循环————双指针</p></li><li><p>在指针移动是根据判定进行移动，而不是先移动再做判断</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxArea</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; height)</span> </span>&#123;<br>        <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,j=height.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-type">long</span> max=<span class="hljs-built_in">min</span>(height[<span class="hljs-number">0</span>],height[j])*(height.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>);<br>        <span class="hljs-type">long</span> ans;<br>        <span class="hljs-keyword">while</span>(i&lt;j)&#123;<br>            ans=<span class="hljs-built_in">min</span>(height[i],height[j])*(j-i);<br>            <span class="hljs-keyword">if</span>(ans&gt;max)&#123;<br>                max=ans;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(height[i]&lt;height[j])&#123;<br>                i++;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                j--;<br>            &#125;<br>            <span class="hljs-comment">//关键的if—else语句，确定是哪边往哪个方向移动。</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>时间复杂度：O(n)</p></li></ul><h2 id="4-Leetcode-121-买卖股票的最佳时期"><a href="#4-Leetcode-121-买卖股票的最佳时期" class="headerlink" title="4 Leetcode 121 买卖股票的最佳时期"></a>4 Leetcode 121 买卖股票的最佳时期</h2><p>给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。</p><p>你只能选择 <strong>某一天</strong> 买入这只股票，并选择在 <strong>未来的某一个不同的日子</strong> 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p><p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 <code>0</code> 。</p><p>方法1：暴力方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(prices.<span class="hljs-built_in">size</span>()==<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <br>        <span class="hljs-type">int</span> summax=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i<span class="hljs-number">+1</span>&lt;prices.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i<span class="hljs-number">+1</span>;j&lt;prices.<span class="hljs-built_in">size</span>();j++)&#123;<br>                <span class="hljs-keyword">if</span>(prices[j]-prices[i]&gt;summax)&#123;<br>                    summax=prices[j]-prices[i];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> summax;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>方法2：优化暴力双循环（枚举剪枝）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(prices.<span class="hljs-built_in">size</span>()==<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <br>        <span class="hljs-type">int</span> summax=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i<span class="hljs-number">+1</span>&lt;prices.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(i&gt;=<span class="hljs-number">1</span>&amp;&amp;prices[i]&gt;prices[i<span class="hljs-number">-1</span>])&#123;<br>                <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-comment">//去掉一些完全不可能的情况（枚举剪枝）</span><br>            &#125;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i<span class="hljs-number">+1</span>;j&lt;prices.<span class="hljs-built_in">size</span>();j++)&#123;<br>                <span class="hljs-keyword">if</span>(j&gt;=<span class="hljs-number">1</span>&amp;&amp;prices[j]&lt;prices[j<span class="hljs-number">-1</span>])&#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(prices[j]-prices[i]&gt;summax)&#123;<br>                    summax=prices[j]-prices[i];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> summax;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>方法3：一次遍历（双指针）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(prices.<span class="hljs-built_in">size</span>()==<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,j=<span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//前后指针：j为前置指针，i为后置指针</span><br>        <span class="hljs-type">int</span> summax=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(j&lt;prices.<span class="hljs-built_in">size</span>())&#123;<br>            <span class="hljs-keyword">if</span>(prices[j]&lt;prices[i])&#123;<br>                i=j;<br>                <span class="hljs-comment">//更新i的位置</span><br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">if</span>(prices[j]-prices[i]&gt;summax)&#123;<br>                    summax=prices[j]-prices[i];<br>                &#125;<br>            &#125;<br>            j++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> summax;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>方法4：核心：在任何时刻，最大利润等于当前价格减去最低价格</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;<br>        <span class="hljs-comment">// 初始化一个很大的数值作为初始的股票最低价格</span><br>        <span class="hljs-type">int</span> inf = <span class="hljs-number">1e9</span>;<br>        <span class="hljs-type">int</span> minprice = inf;<br>        <span class="hljs-comment">// 初始化最大利润为0</span><br>        <span class="hljs-type">int</span> maxprofit = <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-comment">// 遍历价格数组</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> price : prices) &#123;<br>            <span class="hljs-comment">// 计算当前的利润（当前价格减去最低价格），并更新最大利润</span><br>            maxprofit = <span class="hljs-built_in">max</span>(maxprofit, price - minprice);<br>            <span class="hljs-comment">//price-mimprice就是在price之前的所有数的最小值！</span><br>            <span class="hljs-comment">// 更新最低价格</span><br>            minprice = <span class="hljs-built_in">min</span>(price, minprice);<br>        &#125;<br>        <br>        <span class="hljs-comment">// 返回最大利润</span><br>        <span class="hljs-keyword">return</span> maxprofit;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h2 id="5-Leetcode-136-只出现一次的数字"><a href="#5-Leetcode-136-只出现一次的数字" class="headerlink" title="5 Leetcode 136 只出现一次的数字"></a>5 Leetcode 136 只出现一次的数字</h2><p>给你一个 <strong>非空</strong> 整数数组 <code>nums</code> ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p><p>你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。</p><p>方法1：哈希表存储（线性时间复杂度&amp;线性空间复杂度）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        unordered_set&lt;<span class="hljs-type">int</span>&gt; judge;<br>        <span class="hljs-type">long</span> sum1=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> num:nums)&#123;<br>            sum1+=num;<br>            <span class="hljs-keyword">if</span>(judge.<span class="hljs-built_in">find</span>(num)==judge.<span class="hljs-built_in">end</span>())&#123;<br>                judge.<span class="hljs-built_in">insert</span>(num);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                sum1-=<span class="hljs-number">2</span>*num;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum1;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>方法2：使用<strong>位运算</strong>！</p><h3 id="补充：位运算中的异或运算"><a href="#补充：位运算中的异或运算" class="headerlink" title="补充：位运算中的异或运算"></a>补充：位运算中的异或运算</h3><p>异或运算（XOR，eXclusive OR）是一种逻辑运算，它在计算机科学和数学中有着广泛的应用。以下是关于异或运算的原理和运算律的简要介绍：</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>异或运算的基本规则如下：</p><ul><li><strong>0 XOR 0 &#x3D; 0</strong></li><li><strong>1 XOR 0 &#x3D; 1</strong></li><li><strong>0 XOR 1 &#x3D; 1</strong></li><li><strong>1 XOR 1 &#x3D; 0</strong></li></ul><p>换句话说，两个操作数不同时结果为1，相同则结果为0。这解释了“eXclusive OR”的含义，即“排他或”。</p><p>对于十进制数：a^0&#x3D;a！</p><h4 id="运算律"><a href="#运算律" class="headerlink" title="运算律"></a>运算律</h4><p>异或运算具有以下特性：</p><ol><li><p><strong>交换律（Commutative Law）</strong>：</p><ul><li><code>A ^ B = B ^ A</code>，即异或操作的结果与操作数的顺序无关。</li></ul></li><li><p><strong>结合律（Associative Law）</strong>：</p><ul><li><code>(A ^ B) ^ C = A ^ (B ^ C)</code>，这意味着异或操作可以任意分组进行。</li></ul></li><li><p><strong>恒等律（Identity Law）</strong>：</p><ul><li><code>A ^ 0 = A</code>，即任何数与0异或，结果还是该数。</li></ul></li><li><p><strong>自反律（Self-Inverse Law）</strong>：</p><ul><li><code>A ^ A = 0</code>，任何数与自身异或，结果为0。</li></ul></li><li><p><strong>零元素（Zero Element）</strong>：</p><ul><li><code>A ^ 1 = ~A</code>（即A的补码），这表明1在异或运算中起到了一种特殊的作用，它可以翻转操作数的每一位。</li></ul></li><li><p><strong>分配律（Distributive Law）</strong>：</p><ul><li>异或运算不遵循传统意义上的分配律，但它与与运算（AND）有部分分配律：<ul><li><code>A ^ (B &amp; C) = (A ^ B) &amp; (A ^ C)</code>，这在某些情况下可以用于简化计算。</li></ul></li></ul></li></ol><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><ul><li><strong>数据校验</strong>：异或运算常用于数据校验，如奇偶校验或检验和。</li><li><strong>加密</strong>：在一些简单的加密算法中使用异或运算，因为它可以隐藏信息。</li><li><strong>位操作</strong>：在编程中，异或运算可以用来交换变量值（不使用临时变量），翻转特定位，计算汉明距离等。</li><li><strong>解决问题</strong>：在算法设计中，异或运算可以用于解决一些特殊问题，如找出数组中唯一不重复的元素。</li></ul><p>异或运算由于其独特的特性，在计算机编程和数字电路设计中都有广泛的应用，它提供了一种非常高效的方式来处理和操作二进制数据。</p><p>所以：<strong>对这个数组的所有数进行位运算</strong>，最后通过位运算的 <strong>结合律和交换律</strong>，一定可以化成a^0&#x3D;a的形式，其中a就是目标数！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> e: nums) ret ^= e;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h2 id="6-Leetcode-169-多数元素问题"><a href="#6-Leetcode-169-多数元素问题" class="headerlink" title="6 Leetcode 169 多数元素问题"></a>6 Leetcode 169 多数元素问题</h2><p><strong>非常经典的一道例题！</strong></p><p>给定一个大小为 <code>n</code> 的数组 <code>nums</code> ，返回其中的多数元素。多数元素是指在数组中出现次数 <strong>大于</strong> <code>⌊ n/2 ⌋</code> 的元素。</p><p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p><h4 id="方法1：使用哈希表（unordered-map"><a href="#方法1：使用哈希表（unordered-map" class="headerlink" title="方法1：使用哈希表（unordered_map)"></a>方法1：使用哈希表（unordered_map)</h4><p>时空复杂度均为O(n)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n=nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> standard=n/<span class="hljs-number">2</span>;<br>        unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; Mymap;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> num:nums)&#123;<br>            <span class="hljs-keyword">if</span>(Mymap.<span class="hljs-built_in">find</span>(num)!=Mymap.<span class="hljs-built_in">end</span>())&#123;<br>                Mymap[num]++;<br>                <span class="hljs-keyword">if</span>(Mymap[num]&gt;standard)&#123;<br>                    <span class="hljs-keyword">return</span> num;<br>                &#125;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                Mymap.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(num,<span class="hljs-number">1</span>));<br>                <span class="hljs-keyword">if</span>(Mymap[num]&gt;standard)&#123;<br>                    <span class="hljs-keyword">return</span> num;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> &#123;&#125;;<br>       <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="方法2：字符串匹配算法"><a href="#方法2：字符串匹配算法" class="headerlink" title="方法2：字符串匹配算法"></a>方法2：字符串匹配算法</h4><p>（详细内容见补充讲义：KMP算法和BM算法）：两种十分高效的字符串检索算法</p><p>首先：如果一个数组存在多数元素，<strong>则多数元素唯一</strong></p><p>所以多数元素一定会被当选作为candidate！</p><p><strong><code>Boyer-Moore 投票算法</code></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> candidate = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 假设第一个元素是候选者</span><br>        <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;      <span class="hljs-comment">// 计数器</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            <span class="hljs-keyword">if</span> (count == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// 如果计数器为0，则将当前元素设为新的候选者(因为如果count==0,说明当前的candidate元素肯定不是多数元素！)</span><br>                candidate = num;<br>                <span class="hljs-comment">//选择了一位新的候选者！</span><br>            &#125;<br>            <br>            <span class="hljs-comment">// 如果当前元素与候选者相同，计数器加1；否则减1</span><br>            count += (num == candidate) ? <span class="hljs-number">1</span> : <span class="hljs-number">-1</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 在结束遍历后，candidate 就是多数元素</span><br>        <span class="hljs-keyword">return</span> candidate;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><p>算法解释：</p><p>这个算法基于一个关键的观察：如果一个元素是多数元素，<strong>那么它出现的次数一定超过数组长度的一半</strong>。因此：</p><ul><li>每次我们遇到一个与当前候选者相同的元素，<code>count</code>就增加1，因为这支持了我们的候选者。</li><li>每次遇到不同的元素，<code>count</code>就减1，因为这对当前候选者不利。</li></ul><p>由于多数元素出现的次数超过一半，只要我们遍历完整个数组，最后剩下的候选者一定是多数元素。这是因为：</p><ul><li>当<code>count</code>为0时，我们选择新的候选者，这意味着之前的候选者在当前位置之前出现的次数和非候选者出现的次数相等。</li><li>由于多数元素出现的次数超过一半，在数组结束时，它一定会成为最后的候选者。</li><li>时间复杂度O(n)，空间复杂度O（1）</li></ul><p>算法的弊端：优化了时空复杂度，只依赖一次遍历就解决了问题，但无法解决不存在多数元素的情况！</p><h4 id="方法3：分治算法"><a href="#方法3：分治算法" class="headerlink" title="方法3：分治算法"></a>方法3：分治算法</h4><p>如果数 a 是数组 nums 的众数，如果我们将 nums 分成两部分，那么 a 必定是至少一部分的众数。</p><p>我们可以使用反证法来证明这个结论。假设 a 既不是左半部分的众数，也不是右半部分的众数，那么 a 出现的次数少于 l &#x2F; 2 + r &#x2F; 2 次，其中 l 和 r 分别是左半部分和右半部分的长度。由于 l &#x2F; 2 + r &#x2F; 2 &lt;&#x3D; (l + r) &#x2F; 2，说明 a 也不是数组 nums 的众数，因此出现了矛盾。所以这个结论是正确的。</p><p>这样以来，我们就可以使用分治法解决这个问题：将数组分成左右两部分，分别求出左半部分的众数 a1 以及右半部分的众数 a2，随后在 a1 和 a2 中选出正确的众数。</p><p>根据众数的唯一性，总能通过类似的方法逼近得到最后的众数（<strong>类似于闭区间套定理</strong>）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">count_in_range</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> lo, <span class="hljs-type">int</span> hi)</span> </span>&#123;<br>        <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = lo; i &lt;= hi; ++i)<br>            <span class="hljs-keyword">if</span> (nums[i] == target)<br>                ++count;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>    <span class="hljs-comment">//区间求target出现次数函数</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">majority_element_rec</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> lo, <span class="hljs-type">int</span> hi)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (lo == hi)<br>            <span class="hljs-keyword">return</span> nums[lo];<br>        <span class="hljs-comment">//递归的结束标志</span><br>        <span class="hljs-type">int</span> mid = (lo + hi) / <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> left_majority = <span class="hljs-built_in">majority_element_rec</span>(nums, lo, mid);<br>        <span class="hljs-type">int</span> right_majority = <span class="hljs-built_in">majority_element_rec</span>(nums, mid + <span class="hljs-number">1</span>, hi);<br>        <span class="hljs-comment">//此处为递归的重复调用！</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">count_in_range</span>(nums, left_majority, lo, hi) &gt; (hi - lo + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">return</span> left_majority;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">count_in_range</span>(nums, right_majority, lo, hi) &gt; (hi - lo + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">return</span> right_majority;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">majority_element_rec</span>(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Finished</tag>
      
      <tag>C/C++</tag>
      
      <tag>Leetcode notes</tag>
      
      <tag>algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode-Mistake-Collection-11-20</title>
    <link href="/posts/Leetcode-Mistake-collection-11-20/"/>
    <url>/posts/Leetcode-Mistake-collection-11-20/</url>
    
    <content type="html"><![CDATA[<style>  html, body, .markdown-body {    font-family: Georgia, sans, serif;  }</style><h1 id="Leetcode-Mistake-collection-11-20"><a href="#Leetcode-Mistake-collection-11-20" class="headerlink" title="Leetcode-Mistake-collection-11-20"></a>Leetcode-Mistake-collection-11-20</h1><h1 id="程设错题-6-10-20241015-20241020"><a href="#程设错题-6-10-20241015-20241020" class="headerlink" title="程设错题 6-10 20241015-20241020"></a>程设错题 6-10 20241015-20241020</h1><h2 id="1-ACwing-776-字符串移位问题"><a href="#1-ACwing-776-字符串移位问题" class="headerlink" title="1.ACwing 776 字符串移位问题"></a>1.ACwing 776 字符串移位问题</h2><p>对于一个字符串来说，定义一次循环移位操作为：将字符串的第一个字符移动到末尾形成新的字符串。</p><p>给定两个字符串 s1s1 和 s2s2，要求判定其中一个字符串是否是另一字符串通过若干次循环移位后的新字符串的子串。</p><p>例如 <code>CDAA</code> 是由 <code>AABCD</code> 两次移位后产生的新串 <code>BCDAA</code> 的子串，而 <code>ABCD</code> 与 <code>ACBD</code> 则不能通过多次移位来得到其中一个字符串是新串的子串。</p><p><strong>输入格式</strong></p><p>共一行，包含两个字符串，中间由单个空格隔开。</p><p>字符串只包含字母和数字，长度不超过 3030。</p><p><strong>输出格式</strong></p><p>如果一个字符串是另一字符串通过若干次循环移位产生的新串的子串，则输出 <code>true</code>，否则输出 <code>false</code>。</p><h3 id="基本思路："><a href="#基本思路：" class="headerlink" title="基本思路："></a>基本思路：</h3><ul><li>使用函数，判断一个字符串是不是另一个字符串的子串</li><li>利用for循环实现对目标数组的移位处理，并且对每个新移位的字符串调用该函数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">judgestring</span><span class="hljs-params">(string teststring,string standardstring)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(teststring.<span class="hljs-built_in">length</span>()&lt;standardstring.<span class="hljs-built_in">length</span>())&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">if</span>(teststring.<span class="hljs-built_in">find</span>(standardstring)==<span class="hljs-number">-1</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    string movestring,standardstring;<br>    cin&gt;&gt;movestring&gt;&gt;standardstring;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;movestring.<span class="hljs-built_in">length</span>()<span class="hljs-number">-1</span>;)&#123;<br>        movestring.<span class="hljs-built_in">push_back</span>(movestring[<span class="hljs-number">0</span>]);<br>        movestring.<span class="hljs-built_in">erase</span>(movestring.<span class="hljs-built_in">begin</span>());<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">judgestring</span>(movestring,standardstring))&#123;<br>            cout&lt;&lt;<span class="hljs-string">&quot;true&quot;</span>;<br>            <span class="hljs-keyword">goto</span> end;<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;<span class="hljs-string">&quot;false&quot;</span>;<br>    end:;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="优化思路："><a href="#优化思路：" class="headerlink" title="优化思路："></a>优化思路：</h3><p>若将一个字符串首尾相接，则不需要进行移项操作（相当于顺序没有发生变化）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(string a, string b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> len = a.<span class="hljs-built_in">size</span>();<br>    a += a; <span class="hljs-comment">//复制字符串并连接</span><br>    <span class="hljs-comment">//if (a.find(b) &gt;= 0 &amp;&amp; a.find(b) &lt; len) return true; //判断是否包含</span><br>    <span class="hljs-keyword">if</span> (a.<span class="hljs-built_in">find</span>(b) != string::npos) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">//判断a中是否包含b</span><br>    <span class="hljs-comment">//两种判断方式，推荐第二种，若find函数未找到，则会返回一个特殊常量string::npos</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    string a, b;<br>    cin &gt;&gt; a &gt;&gt; b;<br>    <span class="hljs-keyword">if</span> (a.<span class="hljs-built_in">size</span>() &lt; b.<span class="hljs-built_in">size</span>()) <span class="hljs-built_in">swap</span>(a, b);<br>    <span class="hljs-comment">//默认a是更大的string类</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(a, b)) cout &lt;&lt; <span class="hljs-string">&quot;true&quot;</span>;<br>    <span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-string">&quot;false&quot;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="2-ACwing-777-字符串的最小周期问题"><a href="#2-ACwing-777-字符串的最小周期问题" class="headerlink" title="2.ACwing 777 字符串的最小周期问题"></a>2.ACwing 777 字符串的最小周期问题</h2><p>给定一个字符串s,求其最小的周期格段</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    string s;<br>    <span class="hljs-type">int</span> flag=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=s.<span class="hljs-built_in">length</span>();++i)&#123;<br>        <span class="hljs-comment">//外层循环：枚举可能的周期，从小到大枚举，第一个得到的值就是目标值</span><br>        flag=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(len%i!=<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;i&lt;s.<span class="hljs-built_in">length</span>();j++)&#123;<br>            <span class="hljs-keyword">if</span>(s[j]!=s[j%i])&#123;<br>                <span class="hljs-comment">//核心代码:判断每一个j和j%i是否相等，判断是否符合周期性的定义。</span><br>                flag=<span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(flag)&#123;<br>                cout&lt;&lt;s.<span class="hljs-built_in">length</span>()/i&lt;&lt;endl;<br>                <span class="hljs-keyword">goto</span> :end;<br>            &#125;<br>        &#125;<br>        cout&lt;&lt;<span class="hljs-string">&quot;-1&quot;</span>;<br>        end:;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-Leetcode-217-存在重复元素（进阶版）"><a href="#3-Leetcode-217-存在重复元素（进阶版）" class="headerlink" title="3.Leetcode 217 存在重复元素（进阶版）"></a>3.Leetcode 217 存在重复元素（进阶版）</h2><p><a href="https://leetcode.cn/problems/contains-duplicate/">原题链接</a></p><p>给你一个整数数组 <code>nums</code> 。如果任一值在数组中出现 <strong>至少两次</strong> ，返回 <code>true</code> ；如果数组中每个元素互不相同，返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><p><strong>输入：</strong>nums &#x3D; [1,2,3,1]</p><p><strong>输出：</strong>true</p><p><strong>解释：</strong></p><p>元素 1 在下标 0 和 3 出现。</p><h3 id="1-最暴力方法：使用枚举筛查-O-n-2"><a href="#1-最暴力方法：使用枚举筛查-O-n-2" class="headerlink" title="1.最暴力方法：使用枚举筛查 O(n^2)"></a>1.最暴力方法：使用枚举筛查 O(n^2)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">containsDuplicate</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; findnums;<br>        findnums.<span class="hljs-built_in">reserve</span>(<span class="hljs-number">10000</span>);<br>        <span class="hljs-type">int</span> input=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">auto</span> it=std::<span class="hljs-built_in">find</span>(findnums.<span class="hljs-built_in">begin</span>(),findnums.<span class="hljs-built_in">end</span>(),nums[i]);<br>            <span class="hljs-keyword">if</span>(it!=findnums.<span class="hljs-built_in">end</span>())&#123;<br>                input=<span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                findnums.<span class="hljs-built_in">push_back</span>(nums[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">bool</span>(input);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>分析：效率过低，每次插入一个新值都需要重新查找一遍findnums数组</p><p>优化：将findnums数组优化为unordered_set（使用哈希表来存储出现过的元素效率更高）</p><h3 id="优化代码："><a href="#优化代码：" class="headerlink" title="优化代码："></a>优化代码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">containsDuplicate</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        std::unordered_set&lt;<span class="hljs-type">int</span>&gt; seen;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            <span class="hljs-comment">//编程习惯：遍历的简化写法</span><br>            <span class="hljs-keyword">if</span> (seen.<span class="hljs-built_in">find</span>(num) != seen.<span class="hljs-built_in">end</span>()) &#123;<br>                <span class="hljs-comment">//如果找到了num,直接输出true</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            seen.<span class="hljs-built_in">insert</span>(num);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h3 id="知识补充：哈希表"><a href="#知识补充：哈希表" class="headerlink" title="知识补充：哈希表"></a>知识补充：哈希表</h3><p>​使用哈希表（如 <code>std::unordered_set</code>）存储已经遇到的元素，<strong>时间复杂度更低</strong>的原因主要在于哈希表的查找和插入操作的平均时间复杂度是 O(1)。这是因为哈希表通过哈希函数将元素映射到一个数组中的特定位置，从而实现了快速的查找和插入。以下是详细解释：</p><h5 id="哈希表的工作原理"><a href="#哈希表的工作原理" class="headerlink" title="哈希表的工作原理"></a>哈希表的工作原理</h5><ol><li><strong>哈希函数</strong>：哈希表使用一个哈希函数将每个元素的值转换为一个哈希码（通常是一个整数），这个哈希码对应哈希表中的一个位置（桶）。</li><li><strong>存储位置</strong>：元素被存储在对应的桶中，查找和插入操作都可以通过计算哈希码直接定位到相应的桶，从而避免了线性扫描。</li><li><strong>冲突处理</strong>：当多个元素映射到同一个桶时，哈希表使用冲突处理机制（如链地址法或开放地址法）来处理这些冲突。</li></ol><h5 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h5><ul><li><strong>查找</strong>：在理想情况下，哈希表的查找操作只需计算一次哈希函数并访问一个桶，时间复杂度为 O(1)。</li><li><strong>插入</strong>：插入操作也只需计算一次哈希函数并将元素放入相应的桶中，时间复杂度为 O(1)。</li><li><strong>删除</strong>：类似于查找和插入，删除操作也可以在 O(1) 时间内完成。</li></ul><h5 id="对比线性查找"><a href="#对比线性查找" class="headerlink" title="对比线性查找"></a>对比线性查找</h5><ul><li><strong>线性查找</strong>：在向量或链表中查找一个元素需要遍历所有元素，时间复杂度为 O(n)。（例如vector)</li><li><strong>哈希查找</strong>：在哈希表中查找一个元素平均只需要 O(1) 时间，可以显著提高查找效率。</li></ul><h5 id="实际应用中的考虑"><a href="#实际应用中的考虑" class="headerlink" title="实际应用中的考虑"></a>实际应用中的考虑</h5><p>虽然哈希表的平均时间复杂度是 O(1)，但在最坏情况下（例如哈希函数不均匀导致所有元素映射到同一个桶），时间复杂度可以退化到 O(n)。然而，通过选择合适的哈希函数和合理的负载因子，最坏情况发生的概率可以被大大降低。</p><h5 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h5><p>使用哈希表存储已经遇到的元素，可以利用其快速查找和插入的特性，将包含重复元素的检查操作的时间复杂度从 O(n^2) 降低到 O(n)，在处理大数据集时显著提高性能。</p><h2 id="4-Leetcode-219-存在重复元素II-（进阶版）"><a href="#4-Leetcode-219-存在重复元素II-（进阶版）" class="headerlink" title="4.Leetcode 219 存在重复元素II （进阶版）"></a>4.Leetcode 219 存在重复元素II （进阶版）</h2><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，判断数组中是否存在两个 <strong>不同的索引</strong> <code>i</code> 和 <code>j</code> ，满足 <code>nums[i] == nums[j]</code> 且 <code>abs(i - j) &lt;= k</code> 。如果存在，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p>思路：此处使用unordered_set会比较麻烦，unordered_set 键值对就是自己本身，这里可以使用unordered_map类型的容器，实现两个值之间的一一映射。</p><p>（在上一题中只是判断是否存在，对元素的索引和顺序并未提出要求，故使用unordered_set 即可）</p><h3 id="代码实现：使用映射"><a href="#代码实现：使用映射" class="headerlink" title="代码实现：使用映射"></a>代码实现：使用映射</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">containsNearbyDuplicate</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; dictionary; <span class="hljs-comment">// 用于存储每个元素的最新索引</span><br>        <span class="hljs-type">int</span> length = nums.<span class="hljs-built_in">size</span>(); <span class="hljs-comment">// 获取数组的长度</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123; <span class="hljs-comment">// 遍历数组</span><br>            <span class="hljs-type">int</span> num = nums[i]; <span class="hljs-comment">// 当前元素</span><br>            <span class="hljs-comment">// 如果当前元素已经存在于字典中，并且当前索引与存储的索引之差小于等于 k</span><br>            <span class="hljs-keyword">if</span> (dictionary.<span class="hljs-built_in">count</span>(num) &amp;&amp; i - dictionary[num] &lt;= k) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 找到符合条件的重复元素，返回 true</span><br>            &#125;<br>            dictionary[num] = i; <span class="hljs-comment">// 更新字典中的索引  nums[i]-&gt;i的映射</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 遍历完数组后，未找到符合条件的重复元素，返回 false</span><br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h4 id="相关代码解释"><a href="#相关代码解释" class="headerlink" title="相关代码解释"></a>相关代码解释</h4><ul><li><p>基本思路：创建dictionary的map映射，并对nums数组不断进行操作，如果找到两个相同的元素并且索引小于k，直接return true，如果没有，则储存一对新的映射（元素唯一）</p></li><li><p>unordered_map容器中键值保持唯一性，使用 <code>[]</code> 运算符插入相同键时，新值会覆盖旧值。使用 <code>insert</code> 方法插入相同键时，插入操作会失败，原值保持不变。</p></li><li><p>count函数：</p><p><code>std::unordered_map</code> 的 <code>count</code> 函数用于检查特定键是否存在于映射中。它返回一个整数值，表示具有指定键的元素数量。在 <code>std::unordered_map</code> 中，每个键是唯一的，因此 <code>count</code> 函数的返回值只能是 <code>0</code> 或 <code>1</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">count</span><span class="hljs-params">(<span class="hljs-type">const</span> Key&amp; key)</span> <span class="hljs-type">const</span></span>;<br></code></pre></td></tr></table></figure><ul><li><code>key</code>：要检查的键。</li><li>返回值：如果键存在，则返回 <code>1</code>；否则返回 <code>0</code>。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::unordered_map&lt;<span class="hljs-type">int</span>, std::string&gt; myMap;<br>    myMap[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;one&quot;</span>;<br>    myMap[<span class="hljs-number">2</span>] = <span class="hljs-string">&quot;two&quot;</span>;<br>    myMap[<span class="hljs-number">3</span>] = <span class="hljs-string">&quot;three&quot;</span>;<br><br>    <span class="hljs-type">int</span> key = <span class="hljs-number">2</span>;<br><br>    <span class="hljs-comment">// 使用 count 函数检查键是否存在</span><br>    <span class="hljs-keyword">if</span> (myMap.<span class="hljs-built_in">count</span>(key)) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Key &quot;</span> &lt;&lt; key &lt;&lt; <span class="hljs-string">&quot; exists in the map with value: &quot;</span> &lt;&lt; myMap[key] &lt;&lt; std::endl;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Key &quot;</span> &lt;&lt; key &lt;&lt; <span class="hljs-string">&quot; does not exist in the map.&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">Key <span class="hljs-number">2</span> exists <span class="hljs-keyword">in</span> <span class="hljs-keyword">the</span> map <span class="hljs-keyword">with</span> <span class="hljs-built_in">value</span>: <span class="hljs-literal">two</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="容器：unordered-map简介"><a href="#容器：unordered-map简介" class="headerlink" title="容器：unordered_map简介"></a>容器：unordered_map简介</h4><p><code>unordered_map</code> 是 C++ 标准库中的一个关联容器，用于存储键值对。它基于哈希表实现，提供了平均常数时间复杂度的插入、删除和查找操作。</p><p>特性</p><ol><li><strong>无序存储</strong>：元素存储在哈希表中，因此没有特定的顺序。</li><li><strong>唯一键</strong>：每个键在容器中是唯一的。</li><li><strong>高效操作</strong>：插入、删除和查找操作的平均时间复杂度为 <code>O(1)</code>，最坏情况下为 <code>O(n)</code>，但这种情况很少发生。</li></ol><p>常用操作</p><ul><li><strong>插入元素</strong>：使用 <code>insert</code> 方法或 <code>[]</code> 运算符。</li><li><strong>删除元素</strong>：使用 <code>erase</code> 方法。</li><li><strong>查找元素</strong>：使用 <code>find</code> 方法或 <code>count</code> 方法。</li><li><strong>访问元素</strong>：使用 <code>[]</code> 运算符。</li></ul><p>示例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::unordered_map&lt;<span class="hljs-type">int</span>, std::string&gt; myMap;<br><br>    <span class="hljs-comment">// 插入元素</span><br>    myMap[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;one&quot;</span>;<br>    myMap[<span class="hljs-number">2</span>] = <span class="hljs-string">&quot;two&quot;</span>;<br>    myMap.<span class="hljs-built_in">insert</span>(&#123;<span class="hljs-number">3</span>, <span class="hljs-string">&quot;three&quot;</span>&#125;);<br><br>    <span class="hljs-comment">// 访问元素</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Key 1: &quot;</span> &lt;&lt; myMap[<span class="hljs-number">1</span>] &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Key 2: &quot;</span> &lt;&lt; myMap[<span class="hljs-number">2</span>] &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 查找元素</span><br>    <span class="hljs-keyword">auto</span> it = myMap.<span class="hljs-built_in">find</span>(<span class="hljs-number">3</span>);<br>    <span class="hljs-comment">//find函数用来返回一个迭代器，如果找到就返回特定键值的迭代器，如果没有找到就返回对应的.end()迭代器</span><br>    <span class="hljs-keyword">if</span> (it != myMap.<span class="hljs-built_in">end</span>()) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Found key 3 with value: &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; std::endl;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Key 3 not found.&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-comment">// 删除元素</span><br>    myMap.<span class="hljs-built_in">erase</span>(<span class="hljs-number">2</span>);<br><br>    <span class="hljs-comment">// 检查元素是否存在</span><br>    <span class="hljs-keyword">if</span> (myMap.<span class="hljs-built_in">count</span>(<span class="hljs-number">2</span>)) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Key 2 exists in the map.&quot;</span> &lt;&lt; std::endl;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Key 2 does not exist in the map.&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">Key <span class="hljs-number">1</span>: <span class="hljs-literal">one</span><br>Key <span class="hljs-number">2</span>: <span class="hljs-literal">two</span><br>Found key <span class="hljs-number">3</span> <span class="hljs-keyword">with</span> <span class="hljs-built_in">value</span>: <span class="hljs-literal">three</span><br>Key <span class="hljs-number">2</span> does <span class="hljs-keyword">not</span> exist <span class="hljs-keyword">in</span> <span class="hljs-keyword">the</span> map.<br></code></pre></td></tr></table></figure><h3 id="思路2：滑动窗口"><a href="#思路2：滑动窗口" class="headerlink" title="思路2：滑动窗口"></a>思路2：滑动窗口</h3><p>根据题目要求，并不是所有的题目的数据都要用一个数组进行储存再查找的过程。</p><p>思路：设置滑动窗口的双枚举i，j</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">containsNearbyDuplicate</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i<span class="hljs-number">+1</span>;j&lt;=i+k&amp;&amp;j&lt;nums.<span class="hljs-built_in">size</span>();j++)&#123;<br>                <span class="hljs-keyword">if</span>(nums[i]==nums[j])&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>时间复杂度：O(Kn)      空间复杂度O(1)</p><p>算法优化：</p><p>​考虑数组 nums 中的每个长度不超过 k+1 的滑动窗口，同一个滑动窗口中的任意两个下标差的绝对值不超过 k。如果存在一个滑动窗口，其中有重复元素，则<strong>存在两个不同的下标 i 和 j 满足 nums[i]&#x3D;nums[j] 且 ∣i−j∣≤k</strong>。如果所有滑动窗口中都没有重复元素，则不存在符合要求的下标。因此，只要<strong>遍历每个滑动窗口，判断滑动窗口中是否有重复元素即可</strong>。</p><p>​如果一个滑动窗口的结束下标是 i，则该滑动窗口的开始下标是 max(0,i−k)。可以使用哈希集合存储滑动窗口中的元素。从左到右遍历数组 nums，当遍历到下标 i 时，具体操作如下：</p><p>​如果 i&gt;k，则下标 i−k−1 处的元素被移出滑动窗口，因此将 nums[i−k−1] 从哈希集合中删除；</p><p>​判断 nums[i] 是否在哈希集合中，如果在哈希集合中则在同一个滑动窗口中有重复元素，返回 true，如果不在哈希集合中则将其加入哈希集合。</p><p>​当遍历结束时，如果所有滑动窗口中都没有重复元素，返回 false。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">containsNearbyDuplicate</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        unordered_set&lt;<span class="hljs-type">int</span>&gt; s;<br>        <span class="hljs-comment">//s就是滑动窗口，用一个unordered_set存储，可以减少一个for循环，降低时间复杂度</span><br>        <span class="hljs-type">int</span> length = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i &gt; k) &#123;<br>                s.<span class="hljs-built_in">erase</span>(nums[i - k - <span class="hljs-number">1</span>]);<br>            &#125;<br>            <span class="hljs-comment">//当i&gt;k时，每次执行i++时都需要将滑动窗口的最后一个元素驱逐出窗口</span><br>            <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">count</span>(nums[i])) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            s.<span class="hljs-built_in">emplace</span>(nums[i]);<br>            <span class="hljs-comment">//在每一次i++前，都会插入一个新元素，之后会执行命令count，判断新插入的元素是否已经存在在滑动窗口中，如果是，直接return true</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><p>时间复杂度：O(n)</p><h4 id="emplace函数"><a href="#emplace函数" class="headerlink" title="emplace函数"></a>emplace函数</h4><p><code>emplace</code> 是 C++11 引入的一个成员函数，用于在容器中原地构造元素。对于 <code>unordered_map</code>，<code>emplace</code> 可以避免不必要的临时对象创建和复制，从而提高性能。<code>emplace</code> 方法接受键和值的构造参数，并直接在容器中构造元素。</p><p><code>emplace</code> 的用法</p><p><code>emplace</code> 的函数签名如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span>... Args&gt;<br><span class="hljs-function">std::pair&lt;iterator, <span class="hljs-type">bool</span>&gt; <span class="hljs-title">emplace</span><span class="hljs-params">(Args&amp;&amp;... args)</span></span>;<br></code></pre></td></tr></table></figure><ul><li><strong>参数</strong>：<code>args</code> 是传递给元素构造函数的参数。</li><li><strong>返回值</strong>：返回一个 <code>std::pair</code>，其中第一个元素是指向插入元素的迭代器，第二个元素是一个布尔值，表示插入是否成功。</li></ul><p>示例</p><p>以下示例展示了如何使用 <code>emplace</code> 在 <code>unordered_map</code> 中插入元素：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::unordered_map&lt;<span class="hljs-type">int</span>, std::string&gt; myMap;<br><br>    <span class="hljs-comment">// 使用 emplace 插入元素</span><br>    myMap.<span class="hljs-built_in">emplace</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;one&quot;</span>);<br>    myMap.<span class="hljs-built_in">emplace</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;two&quot;</span>);<br><br>    <span class="hljs-comment">// 打印初始内容</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Initial map:&quot;</span> &lt;&lt; std::endl;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; pair : myMap) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Key: &quot;</span> &lt;&lt; pair.first &lt;&lt; <span class="hljs-string">&quot;, Value: &quot;</span> &lt;&lt; pair.second &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-comment">// 尝试使用 emplace 插入相同键</span><br>    <span class="hljs-keyword">auto</span> result = myMap.<span class="hljs-built_in">emplace</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;uno&quot;</span>);<br><br>    <span class="hljs-keyword">if</span> (result.second) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Emplace succeeded.&quot;</span> &lt;&lt; std::endl;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Emplace failed. Key 1 already exists with value: &quot;</span> &lt;&lt; myMap[<span class="hljs-number">1</span>] &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-comment">// 打印更新后的内容</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Updated map:&quot;</span> &lt;&lt; std::endl;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; pair : myMap) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Key: &quot;</span> &lt;&lt; pair.first &lt;&lt; <span class="hljs-string">&quot;, Value: &quot;</span> &lt;&lt; pair.second &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">Initial map:</span><br><span class="hljs-attr">Key:</span> <span class="hljs-number">1</span><span class="hljs-string">,</span> <span class="hljs-attr">Value:</span> <span class="hljs-string">one</span><br><span class="hljs-attr">Key:</span> <span class="hljs-number">2</span><span class="hljs-string">,</span> <span class="hljs-attr">Value:</span> <span class="hljs-string">two</span><br><span class="hljs-attr">Emplace failed. Key 1 already exists with value:</span> <span class="hljs-string">one</span><br><span class="hljs-attr">Updated map:</span><br><span class="hljs-attr">Key:</span> <span class="hljs-number">1</span><span class="hljs-string">,</span> <span class="hljs-attr">Value:</span> <span class="hljs-string">one</span><br><span class="hljs-attr">Key:</span> <span class="hljs-number">2</span><span class="hljs-string">,</span> <span class="hljs-attr">Value:</span> <span class="hljs-string">two</span><br></code></pre></td></tr></table></figure><p><code>emplace</code> 与 <code>insert</code> 的区别</p><ul><li>**<code>insert</code>**：需要先构造一个临时对象，然后再插入到容器中，可能会有额外的复制或移动操作。</li><li>**<code>emplace</code>**：直接在容器中构造对象，避免了不必要的临时对象创建和复制操作，提高了性能。</li></ul><p>总结</p><ul><li><code>emplace</code> 方法用于在 <code>unordered_map</code> 中原地构造元素，避免不必要的临时对象创建和复制操作。</li><li>如果插入的键已经存在，<code>emplace</code> 操作将失败，原值保持不变。</li></ul><h1 id="程设错题-15-20-20241027-20241031"><a href="#程设错题-15-20-20241027-20241031" class="headerlink" title="程设错题 15-20 20241027-20241031"></a>程设错题 15-20 20241027-20241031</h1><h2 id="1-Leetcode-283-移动零"><a href="#1-Leetcode-283-移动零" class="headerlink" title="1.Leetcode 283 移动零"></a>1.Leetcode 283 移动零</h2><p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p><p><strong>请注意</strong> ，必须在不复制数组的情况下原地对数组进行操作。</p><p><strong>示例 1:</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入: nums = <span class="hljs-string">[0,1,0,3,12]</span><br>输出: <span class="hljs-string">[1,3,12,0,0]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: nums = <span class="hljs-comment">[0]</span><br>输出: <span class="hljs-comment">[0]</span><br></code></pre></td></tr></table></figure><p><strong>提示</strong>:</p><ul><li><code>1 &lt;= nums.length &lt;= 104</code></li><li><code>-231 &lt;= nums[i] &lt;= 231 - 1</code></li></ul><h3 id="解法①"><a href="#解法①" class="headerlink" title="解法①"></a>解法①</h3><p>使用vector数组中的push_back和erase成员函数对数组进行遍历，得到移动完成的数组</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">moveZeroes</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> counter=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> iter=nums.<span class="hljs-built_in">begin</span>();counter&lt;nums.<span class="hljs-built_in">size</span>();counter++)&#123;<br>            <span class="hljs-keyword">if</span>(*(iter)==<span class="hljs-number">0</span>)&#123;<br>                nums.<span class="hljs-built_in">erase</span>(iter,iter<span class="hljs-number">+1</span>);<br>                nums.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);<br>                <span class="hljs-comment">//如果发现0，对数组进行操作，将0删除，并添加至末尾</span><br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                iter++;<br>                <span class="hljs-comment">//如果发现的不是0，不进行操作，迭代器后移一位</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> num:nums)&#123;<br>            cout&lt;&lt;num;<br>            <span class="hljs-comment">//遍历数组输出结果</span><br>        &#125;<br>        <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>时间复杂度：O(n^2)(erase操作的时间复杂度是O(n)，再加上外层的循环)</p><h3 id="解法②"><a href="#解法②" class="headerlink" title="解法②"></a>解法②</h3><p>解法①的低效之处：在于erase的清除过程太繁琐</p><p>改进：操作所有非零数值，使其按顺序挪到数组的开头，覆盖开头的值，并将结尾的所有剩余值修改成0。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">moveZeroes</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> nonZeroIndex = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// 将所有非零元素移动到数组的前面</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] != <span class="hljs-number">0</span>) &#123;<br>                nums[nonZeroIndex++] = nums[i];<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 将剩余的位置填充为零</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = nonZeroIndex; i &lt; n; ++i) &#123;<br>            nums[i] = <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 打印数组</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> num : nums) &#123;<br>            cout &lt;&lt; num &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>        cout &lt;&lt; endl;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>时间复杂度：O(n)</p><h3 id="解法③-双指针并行处理"><a href="#解法③-双指针并行处理" class="headerlink" title="解法③ 双指针并行处理"></a>解法③ 双指针并行处理</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">moveZeroes</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>(), left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (right &lt; n) &#123;<br>            <span class="hljs-keyword">if</span> (nums[right]) &#123;<br>                <span class="hljs-built_in">swap</span>(nums[left], nums[right]);<br>                left++;<br>                <span class="hljs-comment">//如果nums[right]不是0，那么和左指针发生交换，右指针是试探指针，左指针代表已经检查过是非零值的元素，并将左指针右移一位</span><br>                <span class="hljs-comment">//最坏的情况:没有0，则左指针和右指针完全同步</span><br>            &#125;<br>            right++;<br>        &#125;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><p>时间复杂度：O(n)</p><h2 id="2-Leetcode-290-单词映射"><a href="#2-Leetcode-290-单词映射" class="headerlink" title="2.Leetcode 290 单词映射"></a>2.Leetcode 290 单词映射</h2><p>给定一种规律 <code>pattern</code> 和一个字符串 <code>s</code> ，判断 <code>s</code> 是否遵循相同的规律。</p><p>这里的 <strong>遵循</strong> 指完全匹配，例如， <code>pattern</code> 里的每个字母和字符串 <code>s</code> 中的每个非空单词之间存在着双向连接的对应规律。</p><p><strong>示例1:</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">输入: <span class="hljs-keyword">pattern</span> <span class="hljs-operator">=</span> &quot;abba&quot;, s <span class="hljs-operator">=</span> &quot;dog cat cat dog&quot;<br>输出: <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elixir">输入<span class="hljs-symbol">:pattern</span> = <span class="hljs-string">&quot;abba&quot;</span>, s = <span class="hljs-string">&quot;dog cat cat fish&quot;</span><br>输出: <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">输入: <span class="hljs-keyword">pattern</span> <span class="hljs-operator">=</span> &quot;aaaa&quot;, s <span class="hljs-operator">=</span> &quot;dog cat cat dog&quot;<br>输出: <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p> 代码解法</p><p>思路：</p><ul><li><p>如何获得子字符串作为单词？</p><ul><li><p>使用substr()</p></li><li><p>使用双指针</p></li><li><p><code>substr</code> 是 C++ 中 <code>std::string</code> 类的一个成员函数，用于从字符串中提取子字符串。它有两个参数：</p><ol><li><strong>起始位置（pos）</strong>：要提取的子字符串的起始索引。</li><li><strong>长度（len）</strong>：要提取的子字符串的长度（可选）。如果不指定，则提取到字符串的末尾。</li></ol><p>语法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::string <span class="hljs-title">substr</span><span class="hljs-params">(<span class="hljs-type">size_t</span> pos = <span class="hljs-number">0</span>, <span class="hljs-type">size_t</span> len = npos)</span> <span class="hljs-type">const</span></span>;<br></code></pre></td></tr></table></figure><ul><li><code>pos</code>：开始提取的位置。</li><li><code>len</code>：要提取的字符数。</li><li><code>npos</code>：一个特殊值，表示直到字符串的末尾。</li></ul><p>示例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::string text = <span class="hljs-string">&quot;Hello, World!&quot;</span>;<br>    <br>    <span class="hljs-comment">// 提取从位置 7 开始的子字符串，长度为 5</span><br>    std::string sub1 = text.<span class="hljs-built_in">substr</span>(<span class="hljs-number">7</span>, <span class="hljs-number">5</span>);<br>    std::cout &lt;&lt; sub1 &lt;&lt; std::endl;  <span class="hljs-comment">// 输出 &quot;World&quot;</span><br>    <br>    <span class="hljs-comment">// 提取从位置 7 开始的子字符串，直到字符串末尾</span><br>    std::string sub2 = text.<span class="hljs-built_in">substr</span>(<span class="hljs-number">7</span>);<br>    std::cout &lt;&lt; sub2 &lt;&lt; std::endl;  <span class="hljs-comment">// 输出 &quot;World!&quot;</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意事项</p><ul><li>如果 <code>pos</code> 超出字符串长度，会抛出 <code>std::out_of_range</code> 异常。</li><li>如果 <code>len</code> 超出可用长度，则提取到字符串的末尾。</li></ul><p><code>substr</code> 是处理字符串时非常有用的工具，尤其是在需要提取特定部分的场景中。</p></li></ul></li><li><p>如何构建一一映射的关系</p><ul><li>使用两个unordered_map</li></ul></li><li><p>如何处理两个数量不相等的情况</p><ul><li>使用计数器</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">wordPattern</span><span class="hljs-params">(string pattern, string str)</span> </span>&#123;<br>        unordered_map&lt;string, <span class="hljs-type">char</span>&gt; str2ch;<br>        unordered_map&lt;<span class="hljs-type">char</span>, string&gt; ch2str;<br>        <span class="hljs-type">int</span> m = str.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> ch : pattern) &#123;<br>            <span class="hljs-keyword">if</span> (i &gt;= m) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                <span class="hljs-comment">//如果 i 超过或等于 str 的长度，说明 str 中的单词数量不足以匹配 pattern，返回 false(此时ch还在遍历Pattern，但是i已经超过str的长度了，说明str不够长)</span><br>            &#125;<br>            <span class="hljs-type">int</span> j = i;<br>            <span class="hljs-comment">//经典的双指针解法，截取一个子字符串</span><br>            <span class="hljs-keyword">while</span> (j &lt; m &amp;&amp; str[j] != <span class="hljs-string">&#x27; &#x27;</span>) j++;<br>            <span class="hljs-comment">//截取一个单词</span><br>            <span class="hljs-type">const</span> string &amp;tmp = str.<span class="hljs-built_in">substr</span>(i, j - i);<br>            <span class="hljs-comment">//此处已经跳出循环，故包含了&#x27; &#x27;的情况，单词长度就是j-i</span><br>            <span class="hljs-keyword">if</span> (str2ch.<span class="hljs-built_in">count</span>(tmp) &amp;&amp; str2ch[tmp] != ch) &#123;<br>                <span class="hljs-comment">//如果map映射中已经有了这个单词的映射，并且这个单词的映射并不等于现在遍历得到的ch</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (ch2str.<span class="hljs-built_in">count</span>(ch) &amp;&amp; ch2str[ch] != tmp) &#123;<br>                <span class="hljs-comment">//反过来，如果map映射已经有了字符的映射并且这个字符的映射并不等于现在得到的单词</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-comment">//以上两个条件都为false，故在两个映射中填充进新的值。</span><br>            str2ch[tmp] = ch;<br>            ch2str[ch] = tmp;<br>            i = j + <span class="hljs-number">1</span>;<br>            <span class="hljs-comment">//更新双指针ij的位置</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> i &gt;= m;<br>        <span class="hljs-comment">//如果i&lt;m,说明还有单词未被输出，说明Pattern不够长，输出false</span><br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h2 id="3-Leetcode-350-两数组交集"><a href="#3-Leetcode-350-两数组交集" class="headerlink" title="3. Leetcode 350 两数组交集"></a>3. Leetcode 350 两数组交集</h2><p>给你两个整数数组 <code>nums1</code> 和 <code>nums2</code> ，请你以数组形式返回两数组的交集。返回结果中每个元素出现的次数，应与元素在两个数组中都出现的次数一致（如果出现次数不一致，则考虑取较小值）。可以不考虑输出结果的顺序。</p><h3 id="解法1-最基本的思路"><a href="#解法1-最基本的思路" class="headerlink" title="解法1   最基本的思路"></a>解法1   最基本的思路</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">intersect</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>        <span class="hljs-type">int</span> list1[<span class="hljs-number">1001</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-type">int</span> list2[<span class="hljs-number">1001</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br>        vector&lt;<span class="hljs-type">int</span>&gt; succedd;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> num1:nums1)&#123;<br>            list1[num1]++;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> num2:nums2)&#123;<br>            list2[num2]++;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">1001</span>;i++)&#123;<br>            <span class="hljs-keyword">if</span>(list1[i]&amp;&amp;list2[i])&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-built_in">min</span>(list1[i],list2[i]);j++)&#123;<br>                    succedd.<span class="hljs-built_in">push_back</span>(i);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> succedd;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="解法2-优化：使用哈希表存储值"><a href="#解法2-优化：使用哈希表存储值" class="headerlink" title="解法2 优化：使用哈希表存储值"></a>解法2 优化：使用哈希表存储值</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">intersect</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (nums<span class="hljs-number">1.</span><span class="hljs-built_in">size</span>() &gt; nums<span class="hljs-number">2.</span><span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">intersect</span>(nums2, nums1);<br>        &#125;<br>        <span class="hljs-comment">//为了减少空间复杂度，优先遍历元素数较少的数组</span><br>        unordered_map &lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; m;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums1) &#123;<br>            ++m[num];<br>        &#125;<br>        <span class="hljs-comment">//遍历nums1</span><br>        vector&lt;<span class="hljs-type">int</span>&gt; intersection;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums2) &#123;<br>            <span class="hljs-keyword">if</span> (m.<span class="hljs-built_in">count</span>(num)) &#123;<br>                intersection.<span class="hljs-built_in">push_back</span>(num);<br>                <span class="hljs-comment">//如果出现，则插入到目标序列中</span><br>                --m[num];<br>                <span class="hljs-comment">//相当于用掉了num1中的一个数，故要减1</span><br>                <span class="hljs-keyword">if</span> (m[num] == <span class="hljs-number">0</span>) &#123;<br>                    m.<span class="hljs-built_in">erase</span>(num);<br>                &#125;<br>                <span class="hljs-comment">//踢出num出s，代表nums1中对应的数已经被用完了</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> intersection;<br>    &#125;<br>&#125;;<br><br><br></code></pre></td></tr></table></figure><h3 id="解法3-排序-双指针遍历"><a href="#解法3-排序-双指针遍历" class="headerlink" title="解法3  排序+双指针遍历"></a>解法3  排序+双指针遍历</h3><p><strong>对于数组问题，可以先进行排序再进行操作！</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">intersect</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>        <span class="hljs-built_in">sort</span>(nums<span class="hljs-number">1.</span><span class="hljs-built_in">begin</span>(), nums<span class="hljs-number">1.</span><span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">sort</span>(nums<span class="hljs-number">2.</span><span class="hljs-built_in">begin</span>(), nums<span class="hljs-number">2.</span><span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> length1 = nums<span class="hljs-number">1.</span><span class="hljs-built_in">size</span>(), length2 = nums<span class="hljs-number">2.</span><span class="hljs-built_in">size</span>();<br>        vector&lt;<span class="hljs-type">int</span>&gt; intersection;<br>        <span class="hljs-type">int</span> index1 = <span class="hljs-number">0</span>, index2 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (index1 &lt; length1 &amp;&amp; index2 &lt; length2) &#123;<br>            <span class="hljs-keyword">if</span> (nums1[index1] &lt; nums2[index2]) &#123;<br>                index1++;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums1[index1] &gt; nums2[index2]) &#123;<br>                index2++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">//nums1[]==nums2[]</span><br>                <span class="hljs-comment">//同时向前前进一位</span><br>                intersection.<span class="hljs-built_in">push_back</span>(nums1[index1]);<br>                index1++;<br>                index2++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> intersection;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h2 id="4-Leetcode-438-字符串的字母异位词"><a href="#4-Leetcode-438-字符串的字母异位词" class="headerlink" title="4. Leetcode 438 字符串的字母异位词"></a>4. Leetcode 438 字符串的字母异位词</h2><p>给定两个字符串 <code>s</code> 和 <code>p</code>，找到 <code>s</code> 中所有 <code>p</code> 的 <strong>异位词</strong> 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。</p><p><strong>示例 1:</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入: s = <span class="hljs-string">&quot;cbaebabacd&quot;</span>, <span class="hljs-selector-tag">p</span> = <span class="hljs-string">&quot;abc&quot;</span><br>输出: <span class="hljs-selector-attr">[0,6]</span><br>解释:<br>起始索引等于 <span class="hljs-number">0</span> 的子串是 <span class="hljs-string">&quot;cba&quot;</span>, 它是 <span class="hljs-string">&quot;abc&quot;</span> 的异位词。<br>起始索引等于 <span class="hljs-number">6</span> 的子串是 <span class="hljs-string">&quot;bac&quot;</span>, 它是 <span class="hljs-string">&quot;abc&quot;</span> 的异位词。<br></code></pre></td></tr></table></figure><p> <strong>示例 2:</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入: s = <span class="hljs-string">&quot;abab&quot;</span>, <span class="hljs-selector-tag">p</span> = <span class="hljs-string">&quot;ab&quot;</span><br>输出: <span class="hljs-selector-attr">[0,1,2]</span><br>解释:<br>起始索引等于 <span class="hljs-number">0</span> 的子串是 <span class="hljs-string">&quot;ab&quot;</span>, 它是 <span class="hljs-string">&quot;ab&quot;</span> 的异位词。<br>起始索引等于 <span class="hljs-number">1</span> 的子串是 <span class="hljs-string">&quot;ba&quot;</span>, 它是 <span class="hljs-string">&quot;ab&quot;</span> 的异位词。<br>起始索引等于 <span class="hljs-number">2</span> 的子串是 <span class="hljs-string">&quot;ab&quot;</span>, 它是 <span class="hljs-string">&quot;ab&quot;</span> 的异位词。<br></code></pre></td></tr></table></figure><h3 id="解法1-使用基本思路"><a href="#解法1-使用基本思路" class="headerlink" title="解法1 使用基本思路"></a>解法1 使用基本思路</h3><p>从i&#x3D;0开始，遍历s数组，切割得到子串，然后判定s的子串和p是否为异位串。</p><p><strong>本质上是优化的滑动窗口</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">findAnagrams</span><span class="hljs-params">(string s, string p)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">length</span>() &lt; p.<span class="hljs-built_in">length</span>()) &#123;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i + p.<span class="hljs-built_in">length</span>() - <span class="hljs-number">1</span> &lt; s.<span class="hljs-built_in">length</span>(); i++) &#123;<br>                string s2 = s.<span class="hljs-built_in">substr</span>(i, p.<span class="hljs-built_in">length</span>());<br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">judgeyiwei</span>(s2, p)) &#123;<br>                    ans.<span class="hljs-built_in">push_back</span>(i);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">judgeyiwei</span><span class="hljs-params">(string s1, string s2)</span> </span>&#123;<br>        <span class="hljs-type">int</span> numlist[<span class="hljs-number">26</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s<span class="hljs-number">1.l</span>ength(); i++) &#123;<br>            numlist[s1[i] - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>            numlist[s2[i] - <span class="hljs-string">&#x27;a&#x27;</span>]--;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (numlist[i]) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="解法2-不定长滑动窗口优化"><a href="#解法2-不定长滑动窗口优化" class="headerlink" title="解法2 不定长滑动窗口优化"></a>解法2 不定长滑动窗口优化</h3><p>基本原理：枚举子串 s ′的右端点，如果发现 s ′其中一种字母的出现次数大于 p 的这种字母的出现次数，则右移 s ′的左端点。如果发现 s ′的长度等于 p 的长度，则说明 s ′的每种字母的出现次数，和 p 的每种字母的出现次数都相同，那么 s ′是 p 的异位词。</p><p><strong>有点类似于双指针</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">findAnagrams</span><span class="hljs-params">(string s, string p)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        <span class="hljs-type">int</span> cnt[<span class="hljs-number">26</span>]&#123;<span class="hljs-number">0</span>&#125;; <span class="hljs-comment">// 统计 p 的每种字母的出现次数</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : p) &#123;<br>            cnt[c - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        &#125;<br>        <span class="hljs-comment">//接下来对s字符串进行遍历操作(遍历右端点作为外层循环，在内部用while循环控制左端点)</span><br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> right = <span class="hljs-number">0</span>; right &lt; s.<span class="hljs-built_in">size</span>(); right++) &#123;<br>            <span class="hljs-type">int</span> c = s[right] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            cnt[c]--; <span class="hljs-comment">// 右端点字母进入窗口，相当于把p中减掉一个对应的字符</span><br>            <span class="hljs-keyword">while</span> (cnt[c] &lt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// c对应的字符(ASCII)太多了</span><br>                cnt[s[left] - <span class="hljs-string">&#x27;a&#x27;</span>]++; <span class="hljs-comment">// 左端点字母离开窗口</span><br>                left++; <br>            &#125;<br>            <span class="hljs-keyword">if</span> (right - left + <span class="hljs-number">1</span> == p.<span class="hljs-built_in">length</span>()) &#123; <span class="hljs-comment">// s&#x27; 和 p 的每种字母的出现次数都相同</span><br>                ans.<span class="hljs-built_in">push_back</span>(left); <span class="hljs-comment">// s&#x27; 左端点下标加入答案</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h2 id="5-Leetcode-443-字符串压缩问题"><a href="#5-Leetcode-443-字符串压缩问题" class="headerlink" title="5.Leetcode 443 字符串压缩问题"></a>5.Leetcode 443 字符串压缩问题</h2><p>给你一个字符数组 <code>chars</code> ，请使用下述算法压缩：</p><p>从一个空字符串 <code>s</code> 开始。对于 <code>chars</code> 中的每组 <strong>连续重复字符</strong> ：</p><ul><li>如果这一组长度为 <code>1</code> ，则将字符追加到 <code>s</code> 中。</li><li>否则，需要向 <code>s</code> 追加字符，后跟这一组的长度。</li></ul><p>压缩后得到的字符串 <code>s</code> <strong>不应该直接返回</strong> ，需要转储到字符数组 <code>chars</code> 中。需要注意的是，如果组长度为 <code>10</code> 或 <code>10</code> 以上，则在 <code>chars</code> 数组中会被拆分为多个字符。</p><p>请在 <strong>修改完输入数组后</strong> ，返回该数组的新长度。</p><p>你必须设计并实现一个只使用常量额外空间的算法来解决此问题。</p><p><strong>必须在原来的数组上进行修改！</strong></p><h3 id="解法：双指针"><a href="#解法：双指针" class="headerlink" title="解法：双指针"></a>解法：双指针</h3><p>为了实现原地压缩，我们可以使用双指针分别标志我们在字符串中读和写的位置。每次当读指针 read 移动到某一段连续相同子串的最右侧，我们就在写指针 write 处依次写入该子串对应的字符和子串长度即可。</p><p>在实际代码中，当读指针 read 位于字符串的末尾，或读指针 read 指向的字符不同于下一个字符时，我们就认为<strong>读指针 read 位于某一段连续相同子串的最右侧</strong>。该子串对应的字符即为读指针 read 指向的字符串。我们使用变量 left 记录该子串的最左侧的位置，这样子串长度即为 read−left+1。</p><p>特别地，为了达到 O(1) 空间复杂度，我们需要自行实现将数字转化为字符串写入到原字符串的功能。这里我们采用短除法将子串长度倒序写入原字符串中，然后再将其反转即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">compress</span><span class="hljs-params">(vector&lt;<span class="hljs-type">char</span>&gt;&amp; chars)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = chars.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> write = <span class="hljs-number">0</span>, left = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> read = <span class="hljs-number">0</span>; read &lt; n; read++) &#123;<br>            <span class="hljs-keyword">if</span> (read == n - <span class="hljs-number">1</span> || chars[read] != chars[read + <span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-comment">//由于写的速度肯定没有读的快，故不用担心write会覆盖未被读取的初始值</span><br>                chars[write++] = chars[read];<br>                <span class="hljs-type">int</span> num = read - left + <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span> (num &gt; <span class="hljs-number">1</span>) &#123;<br>                    <span class="hljs-type">int</span> anchor = write;<br>                    <span class="hljs-keyword">while</span> (num &gt; <span class="hljs-number">0</span>) &#123;<br>                        chars[write++] = num % <span class="hljs-number">10</span> + <span class="hljs-string">&#x27;0&#x27;</span>;<br>                        num /= <span class="hljs-number">10</span>;<br>                    &#125;<br>                    <span class="hljs-built_in">reverse</span>(&amp;chars[anchor], &amp;chars[write]);<br>                    <span class="hljs-comment">//实现输入一个数字倒序插入char数组中（也可以使用stringstream）</span><br>                &#125;<br>                left = read + <span class="hljs-number">1</span>;<br>                <span class="hljs-comment">//后面还会执行read++，本质上就是更新read和left的位置使其对齐</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> write;<br>    &#125;<br>&#125;;<br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Finished</tag>
      
      <tag>C/C++</tag>
      
      <tag>Leetcode notes</tag>
      
      <tag>algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode-Mistake-Collection-1-10</title>
    <link href="/posts/Leetcode-Mistake-collection-1-10/"/>
    <url>/posts/Leetcode-Mistake-collection-1-10/</url>
    
    <content type="html"><![CDATA[<style>  html, body, .markdown-body {    font-family: Georgia, sans, serif;  }</style><h1 id="Leetcode-Mistake-collection-1-10"><a href="#Leetcode-Mistake-collection-1-10" class="headerlink" title="Leetcode-Mistake-collection-1-10"></a>Leetcode-Mistake-collection-1-10</h1><h1 id="程设错题总结-1-5"><a href="#程设错题总结-1-5" class="headerlink" title="程设错题总结 1~5"></a>程设错题总结 1~5</h1><p>【完成时间：2024-10-15】</p><p>【补档时间：2024-12-9】</p><h2 id="1-Leetcode202-Happynumber"><a href="#1-Leetcode202-Happynumber" class="headerlink" title="1.Leetcode202 Happynumber"></a>1.Leetcode202 Happynumber</h2><p><a href="https://leetcode.cn/problems/happy-number/description/">原题链接</a></p><hr><p>编写一个算法来判断一个数 <code>n</code> 是不是快乐数。</p><p><strong>「快乐数」</strong> 定义为：</p><ul><li>对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。</li><li>然后重复这个过程直到这个数变为 1，也可能是 <strong>无限循环</strong> 但始终变不到 1。</li><li>如果这个过程 <strong>结果为</strong> 1，那么这个数就是快乐数。</li></ul><p>如果 <code>n</code> 是 <em>快乐数</em> 就返回 <code>true</code> ；不是，则返回 <code>false</code> 。</p><p> <strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：n = 19<br>输出：true<br>解释：<br>12 +<span class="hljs-number"> 92 </span>= 82<br>82 +<span class="hljs-number"> 22 </span>= 68<br>62 +<span class="hljs-number"> 82 </span>= 100<br>12 +<span class="hljs-number"> 02 </span>+<span class="hljs-number"> 02 </span>= 1<br></code></pre></td></tr></table></figure><hr><h3 id="1-使用快慢指针解决循环问题"><a href="#1-使用快慢指针解决循环问题" class="headerlink" title="1.使用快慢指针解决循环问题"></a>1.使用快慢指针解决循环问题</h3><p>当快指针追上慢指针时，代表完成了一次循环。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">happynumber</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123;<br>        <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(n!=<span class="hljs-number">0</span>)&#123;<br>            sum+=(n%<span class="hljs-number">10</span>)*(n%<span class="hljs-number">10</span>);<br>            n/=<span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isHappy</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-type">int</span> i=n,j=n;<br>        <span class="hljs-keyword">do</span>&#123;<br>            i=<span class="hljs-built_in">happynumber</span>(i);<br>            j=<span class="hljs-built_in">happynumber</span>(j);<br>            j=<span class="hljs-built_in">happynumber</span>(j);<br>            <span class="hljs-keyword">if</span>(i==<span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(i!=j);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="2-使用哈希表存储"><a href="#2-使用哈希表存储" class="headerlink" title="2.使用哈希表存储"></a>2.使用哈希表存储</h3><p>此处使用容器：unordered_set</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">happynumber</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123;<br>        <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(n!=<span class="hljs-number">0</span>)&#123;<br>            sum+=(n%<span class="hljs-number">10</span>)*(n%<span class="hljs-number">10</span>);<br>            n/=<span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isHappy</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        unordered_set &lt;<span class="hljs-type">int</span>&gt; list;<br>        <span class="hljs-keyword">while</span>(n!=<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">if</span>(list.<span class="hljs-built_in">find</span>(n)!=list.<span class="hljs-built_in">end</span>())&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                list.<span class="hljs-built_in">insert</span>(n);<br>            &#125;<br>            n=<span class="hljs-built_in">happynumber</span>(n);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="2-Acwing-817-数组去重"><a href="#2-Acwing-817-数组去重" class="headerlink" title="2.Acwing 817 数组去重"></a>2.Acwing 817 数组去重</h2><p><a href="https://www.acwing.com/problem/content/819/">原题链接</a></p><hr><p>给定一个长度为 nn 的数组 aa，请你编写一个函数：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_unique_count</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> n)</span></span>;  <span class="hljs-comment">// 返回数组前n个数中的不同数的个数</span><br></code></pre></td></tr></table></figure><p><strong>输入格式</strong></p><p>第一行包含一个整数 nn。</p><p>第二行包含 nn 个整数，表示数组 aa。</p><p><strong>输出格式</strong></p><p>共一行，包含一个整数表示数组中不同数的个数。</p><p><strong>数据范围</strong></p><p>1≤n≤10001≤n≤1000,<br>1≤ai≤10001≤ai≤1000。</p><p><strong>输入样例：</strong></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">5</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p><strong>输出样例：</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">4<br></code></pre></td></tr></table></figure><hr><h3 id="method1：使用STL"><a href="#method1：使用STL" class="headerlink" title="method1：使用STL"></a>method1：使用STL</h3><p><strong>unique函数</strong>：</p><p>unique是C++语言中的STL函数，包含于<algorithm>头文件中。 <strong>功能是将数组中相邻的重复元素去除</strong>。 然而其本质是将重复的元素移动到数组的末尾，最后再将迭代器指向第一个重复元素的下标。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n, s[<span class="hljs-number">1010</span>];<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) cin &gt;&gt; s[i];<br>    <span class="hljs-built_in">sort</span>(s, s + n);<br>    cout &lt;&lt; <span class="hljs-built_in">unique</span>(s, s + n) - s;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="method2：基本方法"><a href="#method2：基本方法" class="headerlink" title="method2：基本方法"></a>method2：基本方法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> b[<span class="hljs-number">1001</span>];<br><span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br><span class="hljs-comment">/*两个数组的区别：</span><br><span class="hljs-comment">a[]代表输入的数组（待去重的数组）</span><br><span class="hljs-comment">b[]数组是一个状态数组，其下标对应的值和a[]对应，初始值均为0，一旦出现a[i],即代表下标为a[i]的b[]被访问过，状态值变为1。（且只有初次访问是生效的）</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_unique_count</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(b[a[i]]==<span class="hljs-number">0</span>)<br>        b[a[i]]=<span class="hljs-number">1</span>;<br>        sum++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br><span class="hljs-comment">//函数作用：统计数组中一共出现了多少不相同的数。</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">int</span> n;<br>  cin&gt;&gt;n;<br>  <span class="hljs-type">int</span> a[n<span class="hljs-number">+1</span>];<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>  &#123;<br>      cin&gt;&gt;a[i];<br>  &#125;<br>  cout&lt;&lt;<span class="hljs-built_in">get_unique_count</span>(a,n);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="3-ACwing-15-二维数组的查找"><a href="#3-ACwing-15-二维数组的查找" class="headerlink" title="3.ACwing 15 二维数组的查找"></a>3.ACwing 15 二维数组的查找</h2><p><a href="https://www.acwing.com/problem/content/16/">题目链接</a></p><p>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。</p><p>请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><p><strong>数据范围</strong></p><p>二维数组中元素个数范围 [0,1000][0,1000]</p><p><strong>样例</strong></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">输入数组：<br><span class="hljs-string"></span><br><span class="hljs-string">[</span><br><span class="hljs-string">  [1,2,8,9]</span>，<br><span class="hljs-string">  [2,4,9,12]</span>，<br><span class="hljs-string">  [4,7,10,13]</span>，<br><span class="hljs-string">  [6,8,11,15]</span><br>]<br><br>如果输入查找数值为<span class="hljs-number">7</span>，则返回<span class="hljs-literal">true</span>，<br><br>如果输入查找数值为<span class="hljs-number">5</span>，则返回<span class="hljs-literal">false</span>。<br></code></pre></td></tr></table></figure><p><img src="/posts/Leetcode-Mistake-collection-1-10/3.png" alt="Scanning"></p><p>思路：</p><p>​1.暴力循环（两个for循环嵌套）</p><p>​2.通过数组大小关系的规律实现<strong>逐步逼近</strong>的策略</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Find</span><span class="hljs-params">(<span class="hljs-type">int</span> target, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; array)</span> </span>&#123;<br>        <span class="hljs-type">int</span> row=array.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> col=array[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> i=row<span class="hljs-number">-1</span>;<br>        <span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//定义扫描的初始位置，(row-1,0),即数组棋盘的左下角</span><br>        <span class="hljs-keyword">while</span>(i&gt;=<span class="hljs-number">0</span>&amp;&amp;j&lt;col)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(target==array[i][j])<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-comment">//得到return后即可跳出循环，代表查找成功</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(target&lt;array[i][j])<br>                i--;<br>            <span class="hljs-comment">//删去最下面一行(判断大小关系)</span><br>            <span class="hljs-keyword">else</span><br>                j++;<br>            <span class="hljs-comment">//删去第一列，移动到第二列(判断大小关系)</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br></code></pre></td></tr></table></figure><h2 id="4-Acwing3801-最佳连续子数组"><a href="#4-Acwing3801-最佳连续子数组" class="headerlink" title="4.Acwing3801 最佳连续子数组"></a>4.Acwing3801 最佳连续子数组</h2><p><a href="https://www.acwing.com/problem/content/3804/">原题链接</a></p><p>给定一个长度为 nn 的数组 a1,a2,…,ana1,a2,…,an。</p><p>请你找到其中的最佳<strong>连续</strong>子数组。</p><p>最佳连续子数组需满足：</p><ol><li>子数组内各元素的算术平均数（即所有元素之和除以元素个数）尽可能大。</li><li>满足条件 11 的前提下，子数组的长度尽可能长。</li></ol><p>输出最佳连续子数组的长度。</p><p><strong>输入格式</strong></p><p>第一行包含整数 TT，表示共有 TT 组测试数据。</p><p>每组数据，第一行包含整数 nn。</p><p>第二行包含 nn 个整数 a1,a2,…,ana1,a2,…,an。</p><p><strong>输出格式</strong></p><p>每组数据输出一行结果，表示最佳连续子数组的长度。</p><h3 id="最暴力解法：分别枚举首项和尾项-O-n-2"><a href="#最暴力解法：分别枚举首项和尾项-O-n-2" class="headerlink" title="最暴力解法：分别枚举首项和尾项 O(n^2)"></a>最暴力解法：分别枚举首项和尾项 O(n^2)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">testbestarray</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n; cin&gt;&gt;n;<br>    <span class="hljs-type">int</span> numarray[n];<br>    <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>,targetnumber=<span class="hljs-number">0</span>;<br>    <span class="hljs-type">double</span> maxave=<span class="hljs-number">0</span>,ave;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        cin&gt;&gt;numarray[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i;j&lt;n;j++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=i;k&lt;=j;k++)&#123;<br>                sum+=numarray[k];<br>            &#125;<br>            <span class="hljs-comment">//在已知i，j的情况下，遍历对子数组求和</span><br>            ave=<span class="hljs-built_in">double</span>(sum)/(j-i<span class="hljs-number">+1</span>);<br>            <span class="hljs-keyword">if</span>(ave&gt;maxave)&#123;<br>                maxave=ave;<br>                targetnumber=(j-i<span class="hljs-number">+1</span>);<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ave==maxave)&#123;<br>                <span class="hljs-keyword">if</span>((j-i<span class="hljs-number">+1</span>)&gt;targetnumber)&#123;<br>                    targetnumber=(j-i<span class="hljs-number">+1</span>);<br>                &#125;<br>            &#125;<br>            sum=<span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> targetnumber;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> T; cin&gt;&gt;T;<br>    <span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (count&lt;T)&#123;<br>        cout&lt;&lt;<span class="hljs-built_in">testbestarray</span>()&lt;&lt;endl;<br>        count++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="解法优化："><a href="#解法优化：" class="headerlink" title="解法优化："></a>解法优化：</h3><p><strong>分治的思想</strong>：将一个大问题拆分成若干个小问题再分别解决。</p><p>子问题1：最大子数列的值</p><p>​<em><strong>最大子数列的值一定等于数列中最大项的值</strong></em></p><p>子问题2：在子数列平均值最大的情况下，找到最长长度：</p><p>​<em><strong>找到数列中是否有若干项连续，且值均为最大值。</strong></em></p><p>优化代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">testbestarray</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n; cin&gt;&gt;n;<br>    <span class="hljs-type">int</span> numarray[n];<br>    <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>,max=<span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;<span class="hljs-type">int</span> countmax=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        cin&gt;&gt;numarray[i];<br>        max=(numarray[i]&gt;max?numarray[i]:max);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;)&#123;<br>        <span class="hljs-keyword">if</span>(i&lt;n&amp;&amp;numarray[i]==max)&#123;<br>            <span class="hljs-keyword">while</span>(i&lt;n&amp;&amp;numarray[i]==max)&#123;<br>            count++;<br>            i++;<br>            &#125;<br>            i++;<br>            countmax=(countmax&lt;count?count:countmax);<br>            count=<span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i&lt;n)&#123;<br>            i++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//这一段for循环是筛查的核心，如果某元素是列表中最大值，则进入while循环直到第一个非最大值元素的出现终止while循环，同时结束count++，并最大化countmax。在遍历完一整个数组后，即可得到最大子区间的长度。</span><br>    <span class="hljs-keyword">return</span> countmax;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> T; cin&gt;&gt;T;<br>    <span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (count&lt;T)&#123;<br>        cout&lt;&lt;<span class="hljs-built_in">testbestarray</span>()&lt;&lt;endl;<br>        count++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><h3 id="进一步简化："><a href="#进一步简化：" class="headerlink" title="进一步简化："></a>进一步简化：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">10e5</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> a[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> T;<br>    cin &gt;&gt; T;<br>    <span class="hljs-keyword">while</span>(T--)<br>    &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br><br>        <span class="hljs-type">int</span> m = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        &#123;<br>            cin &gt;&gt; a[i];<br>            m = <span class="hljs-built_in">max</span>(m, a[i]);<span class="hljs-comment">//m保存最大值</span><br>        &#125;<br><br>        <span class="hljs-type">int</span> res = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n;i++)<span class="hljs-comment">//求长度</span><br>        &#123;<br>            <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span>(i &lt; n &amp;&amp; a[i] == m)<br>            &#123;<br>                t++;<br>                i++;<br>            &#125;<br>            res = <span class="hljs-built_in">max</span>(res, t);<br>        &#125;<br>        <span class="hljs-comment">/*核心while循环：</span><br><span class="hljs-comment">        此处不用再添加if语句，直接使用外部的for循环即可。</span><br><span class="hljs-comment">        */</span><br>        cout &lt;&lt; res &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="5-ACwing-862-三元组排序"><a href="#5-ACwing-862-三元组排序" class="headerlink" title="5.ACwing 862 三元组排序"></a>5.ACwing 862 三元组排序</h2><p><a href="https://www.acwing.com/problem/content/864/">原题链接</a></p><p>给定 N 个三元组(x,y,z)，其中 xx 是整数，yy 是浮点数，zz 是字符串。</p><p>请你按照 x 从小到大的顺序将这些三元组打印出来。</p><p>数据保证不同三元组的 xx 值互不相同。</p><p><strong>输入格式</strong></p><p>第一行包含整数 N。</p><p>接下来 N 行，每行包含一个整数 x，一个浮点数 y，一个字符串 z，表示一个三元组，三者之间用空格隔开。</p><p><strong>输出格式</strong></p><p>共 N 行，按照 x 从小到大的顺序，每行输出一个三元组。</p><p>注意，所有输入和输出的浮点数 y 均保留两位小数。</p><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><ul><li>最基本的排序使用排序算法（此处用algorithm库中的sort（）函数）</li><li>如何构建一一对应的关系？<ul><li>map容器</li><li>pair：将两组数据整合成一个数据对<ul><li>（int,（double,string））</li><li>对pair类型的int数排序，一一对应的（double，string）满足映射</li></ul></li></ul></li></ul><h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h3><h4 id="①最基本的数组实现"><a href="#①最基本的数组实现" class="headerlink" title="①最基本的数组实现"></a>①最基本的数组实现</h4><p>排序算法（Bubblesort）+交换函数swap（）（内置在C++库中）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n; cin&gt;&gt;n;<br>    <span class="hljs-type">int</span> intlist[n];<br>    <span class="hljs-type">double</span> doublelist[n];<br>    string stringlist[n];<br>    <span class="hljs-comment">//定义三个数组，分别储存三种不同的数据结构。</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        cin&gt;&gt;intlist[i]&gt;&gt;doublelist[i]&gt;&gt;stringlist[i];<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=n;j&gt;<span class="hljs-number">1</span>;j--)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;j<span class="hljs-number">-1</span>;i++)&#123;<br>            <span class="hljs-keyword">if</span>(intlist[i]&gt;intlist[i<span class="hljs-number">+1</span>])&#123;<br>                <span class="hljs-built_in">swap</span>(intlist[i],intlist[i<span class="hljs-number">+1</span>]);<br>                <span class="hljs-built_in">swap</span>(doublelist[i],doublelist[i<span class="hljs-number">+1</span>]);<br>                <span class="hljs-built_in">swap</span>(stringlist[i],stringlist[i<span class="hljs-number">+1</span>]);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//核心算法：冒泡排序</span><br>    <span class="hljs-comment">//从第一位开始逐项与后一位冒泡比较确定是否交换，第一轮下来就确定末尾项为最大值。</span><br>    <span class="hljs-comment">//之后通过外层的for循环逐步确定直至首项</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %.2lf&quot;</span>,intlist[i],doublelist[i]);<br>        cout&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;stringlist[i]&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="②map映射"><a href="#②map映射" class="headerlink" title="②map映射"></a>②map映射</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;map&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> x first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> y second</span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">10010</span>;<br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">double</span>, string&gt; PII;<br>map&lt;<span class="hljs-type">int</span>, PII&gt; ans;<br><span class="hljs-comment">//定义了一个从int向PII的映射，就不用使用两次pair了</span><br><span class="hljs-type">int</span> n;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-type">double</span> b;<br>    string c;<br>    cin &gt;&gt; n;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ )<br>    &#123;<br>        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;<br>        ans.<span class="hljs-built_in">insert</span>(&#123;a, &#123;b, c&#125;&#125;);<br>    &#125;<br><br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> iter = ans.<span class="hljs-built_in">begin</span>(); iter != ans.<span class="hljs-built_in">end</span>(); iter ++ )<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %.2f %s\n&quot;</span>, iter-&gt;x, iter-&gt;y.x, iter-&gt;y.y.<span class="hljs-built_in">c_str</span>());  <br>    <span class="hljs-comment">/*这里 iter是一个迭代器</span><br><span class="hljs-comment">    iter-&gt;first代表指向map类型的first成员函数（即自变量）</span><br><span class="hljs-comment">    iter-&gt;second代表指向因变量</span><br><span class="hljs-comment">    iter-&gt;second.first代表指向因变量pair的第一个元素</span><br><span class="hljs-comment">    iter-&gt;second.second               第二个元素</span><br><span class="hljs-comment">    c_str()返回一个指向字符串的指针</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="③使用pair类型"><a href="#③使用pair类型" class="headerlink" title="③使用pair类型"></a>③使用pair类型</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> x first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> y second</span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">10010</span>;<br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, pair&lt;<span class="hljs-type">double</span>, string &gt;&gt; PII;<br><br>vector&lt;PII&gt; ans;<br><span class="hljs-type">int</span> n, a;<br><span class="hljs-type">double</span> b;<br>string s;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ )<br>    &#123;<br>        cin &gt;&gt; a &gt;&gt; b &gt;&gt; s;<br>        ans.<span class="hljs-built_in">push_back</span>(&#123;a, &#123;b, s&#125;&#125;);<br>        <span class="hljs-comment">//vector类型的push_back函数，&#123;a,&#123;b,s&#125;&#125;是一个PII类型的数据</span><br>    &#125;<br>    <span class="hljs-built_in">sort</span>(ans.<span class="hljs-built_in">begin</span>(), ans.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-comment">//使用sort()函数实现ans这个vector的自动排序(默认升序)</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i: ans)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %.2lf %s\n&quot;</span>,i.x, i.y.x, i.y.y.<span class="hljs-built_in">c_str</span>());   <br>    <span class="hljs-comment">//若i是一个pair类型，则i.first代表pair的第一个元素，而i.second代表pair的第二个元素。</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="程设错题-610-2024101520241020"><a href="#程设错题-610-2024101520241020" class="headerlink" title="程设错题 610 2024101520241020"></a>程设错题 6<del>10 20241015</del>20241020</h1><h2 id="1-经典问题：找质数"><a href="#1-经典问题：找质数" class="headerlink" title="1.经典问题：找质数"></a>1.经典问题：找质数</h2><h3 id="方法1：基本枚举法-O-n-3-2"><a href="#方法1：基本枚举法-O-n-3-2" class="headerlink" title="方法1：基本枚举法 O(n^3&#x2F;2)"></a>方法1：基本枚举法 O(n^3&#x2F;2)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isprime</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">2</span>||n==<span class="hljs-number">3</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i*i&lt;=n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(n%i==<span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countPrimes</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;n;i++)&#123;<br>            sum+=<span class="hljs-built_in">isprime</span>(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="方法2：埃氏筛"><a href="#方法2：埃氏筛" class="headerlink" title="方法2：埃氏筛"></a>方法2：埃氏筛</h3><p>​枚举没有考虑到数与数的关联性，因此难以再继续优化时间复杂度。接下来我们介绍一个常见的算法，该算法由希腊数学家厄拉多塞（Eratosthenes）提出，称为厄拉多塞筛法，简称埃氏筛。</p><p>​我们考虑这样一个事实：<strong>如果 x 是质数，那么大于 x 的 x 的倍数 2x,3x,… 一定不是质数</strong>，因此我们可以从这里入手。</p><p>​我们设 isPrime[i] 表示数 i 是不是质数，如果是质数则为 1，否则为 0。从小到大遍历每个数，如果这个数为质数，则将其所有的倍数都标记为合数（除了该质数本身），即 0，这样在运行结束的时候我们即能知道质数的个数。</p><p>​这种方法的正确性是比较显然的：这种方法显然不会将质数标记成合数；另一方面，当从小到大遍历到数 x 时，倘若它是合数，则它一定是某个小于 x 的质数 y 的整数倍，故根据此方法的步骤，我们在遍历到 y 时，就一定会在此时将 x 标记为 isPrime[x]&#x3D;0。因此，这种方法也不会将合数标记为质数。</p><p>​当然这里还可以继续优化，对于一个质数 x，如果按上文说的我们从 2x 开始标记其实是冗余的，应该直接从 x⋅x 开始标记，因为 2x,3x,… 这些数一定在 x 之前就被其他数的倍数标记过了，例如 2 的所有倍数，3 的所有倍数等。</p><p><strong>这种方法不用再判断单个数是否为质数，可以减少筛查从1~n的次数</strong></p><p><strong>埃氏筛的筛查方法：从一个已知的质数开始排除无限多比他大的合数</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countPrimes</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">isPrime</span><span class="hljs-params">(n, <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-comment">//初始化</span><br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (isPrime[i]) &#123;<br>                <span class="hljs-comment">//则该数为质数</span><br>                ans += <span class="hljs-number">1</span>;<br>                <span class="hljs-comment">//接下来的操作：标志其倍数为合数</span><br>                <span class="hljs-comment">//从n^2开始标记！(对于倍数kn,k&lt;n,一定有数k为质数，在之前被标记过)</span><br>                <span class="hljs-keyword">if</span> ((<span class="hljs-type">long</span> <span class="hljs-type">long</span>)i * i &lt; n) &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i * i; j &lt; n; j += i) &#123;<br>                        isPrime[j] = <span class="hljs-number">0</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h3 id="3-线性筛O-n"><a href="#3-线性筛O-n" class="headerlink" title="3.线性筛O(n)"></a>3.线性筛O(n)</h3><p><img src="/posts/Leetcode-Mistake-collection-1-10/1.png" alt="Linear Time Complexity"></p><p>x&#x3D;k*primes[i]，则对于数x*primes[i+1]&#x3D;k*primes[i]*primes[i+1],可以在primes[i+1]遍历的时候取到</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countPrimes</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; primes;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">isPrime</span><span class="hljs-params">(n, <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (isPrime[i]) &#123;<br>                primes.<span class="hljs-built_in">push_back</span>(i);<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; primes.<span class="hljs-built_in">size</span>() &amp;&amp; i * primes[j] &lt; n; ++j) &#123;<br>                isPrime[i * primes[j]] = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">if</span> (i % primes[j] == <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> primes.<span class="hljs-built_in">size</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="2-数组输出：平方矩阵问题"><a href="#2-数组输出：平方矩阵问题" class="headerlink" title="2.数组输出：平方矩阵问题"></a>2.数组输出：平方矩阵问题</h2><p><img src="/posts/Leetcode-Mistake-collection-1-10/2.png" alt="Question 2"></p><p>思路：<strong>最基本的数组输出：</strong>两层for循环嵌套（通过外层循环每执行一次回车跳转到下一行进行输出）</p><h3 id="解法一：曼哈顿距离-坐标法"><a href="#解法一：曼哈顿距离-坐标法" class="headerlink" title="解法一：曼哈顿距离+坐标法"></a>解法一：曼哈顿距离+坐标法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printarray</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">while</span>(n!=<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">printarray</span>(n);<br>        cout&lt;&lt;endl;<br>        cin&gt;&gt;n;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printarray</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123;<br>    <span class="hljs-type">double</span> maxi;<br>    <span class="hljs-type">int</span> list[n][n];<br>    <span class="hljs-keyword">if</span>(n%<span class="hljs-number">2</span>==<span class="hljs-number">1</span>)&#123;<br>        maxi=(n<span class="hljs-number">+1</span>)/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>                list[i][j]=<span class="hljs-built_in">int</span>(maxi-<span class="hljs-built_in">max</span>(<span class="hljs-built_in">abs</span>((n<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>-i),<span class="hljs-built_in">abs</span>((n<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>-j)));<br>                <span class="hljs-comment">//核心代码：对应位置上的数和其到中心点的曼哈顿距离有关！</span><br>                cout&lt;&lt;list[i][j]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>            &#125;<br>            cout&lt;&lt;endl;<br>        &#125;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        maxi=n/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>                list[i][j]=<span class="hljs-built_in">int</span>(maxi<span class="hljs-number">+0.5</span>-<span class="hljs-built_in">max</span>(<span class="hljs-built_in">abs</span>(<span class="hljs-built_in">double</span>(n<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>-i),<span class="hljs-built_in">abs</span>(<span class="hljs-built_in">double</span>(n<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>-j)));<br>                <span class="hljs-comment">//偶数的情况不存在唯一的中心点，但中心点的作用只是通过曼哈顿距离的坐标表示来确定对应位置上的数的值。故可以引入一个虚拟中心点（浮点数：(n-1)/2）</span><br>                cout&lt;&lt;list[i][j]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>            &#125;<br>            cout&lt;&lt;endl;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="优化解法：不再依赖中心点，直接根据坐标输出值"><a href="#优化解法：不再依赖中心点，直接根据坐标输出值" class="headerlink" title="优化解法：不再依赖中心点，直接根据坐标输出值"></a>优化解法：不再依赖中心点，直接根据坐标输出值</h3><blockquote><p>①通过观察回字形矩阵, 矩阵关于对角线是左上方和右下方对称的<br>②利用二维行列循环, <strong>获取行列+1的最小值(即min(i + 1, j + 1))</strong>, 可得如下图形(例如n &#x3D;&#x3D; 4):<br>1 1 1 1<br>1 2 2 <del>2</del><br>1 2 <del>3 3</del><br>1 <del>2 3 4</del><br>可以看出未划横线部分（左上部分）满足题解,此时如果使图像沿着对角线翻转,再重合,即可求解答案<br>③翻转图像,采用min(n - i, n - j)即可, 得到图像如下(例如n &#x3D;&#x3D; 4):<br><del>4 3 2</del> 1<br><del>3 3</del> 2 1<br><del>2</del> 2 2 1<br>1 1 1 1<br>④进行图像的重合, 对应位置取最小值即可求解min(Left上, right下)</p></blockquote><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br> <span class="hljs-type">int</span> n;<br><span class="hljs-keyword">while</span> (cin &gt;&gt; n, n)&#123;<br> <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)&#123;<br>     <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j ++)&#123;<br>         cout &lt;&lt; <span class="hljs-built_in">min</span>(<span class="hljs-built_in">min</span>(i + <span class="hljs-number">1</span>, j + <span class="hljs-number">1</span>), <span class="hljs-built_in">min</span>(n - i, n - j)) &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>         <span class="hljs-comment">//通过一个min（）,输出对应的数字</span><br>     &#125;<br>     cout &lt;&lt; endl ;<br> &#125;<br> cout &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure></blockquote><h3 id="方法二：蛇形矩阵求解"><a href="#方法二：蛇形矩阵求解" class="headerlink" title="方法二：蛇形矩阵求解"></a>方法二：<strong>蛇形矩阵</strong>求解</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> m[N][N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-type">int</span> dx[] = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, dy[] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;;<br>    <span class="hljs-comment">//每个向量代表向不同方向移动</span><br><br>    <span class="hljs-keyword">while</span>(cin &gt;&gt; n, n )&#123;<br>        <span class="hljs-built_in">memset</span>(m, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> m);<span class="hljs-comment">//初始化数组</span><br>        <span class="hljs-type">int</span> d = <span class="hljs-number">1</span>, x = <span class="hljs-number">0</span>, y = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 表示改变方向次数</span><br>        <span class="hljs-type">int</span> res = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 回形当前圈数</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n * n; i ++)&#123;<br>            <span class="hljs-comment">//i是一个计数器，代表一共输出i个数</span><br>            <span class="hljs-type">int</span> a = x + dx[d], b = y + dy[d];<br>            <span class="hljs-comment">//(x,y) is the previous point,and (a,b)is the point that has moved</span><br>            <span class="hljs-comment">//一个很关键的点：(a,b)相当于探路的坐标，并不会直接赋值给(x,y)。一旦if语句发现(a,b)异常(例如需要拐弯或进入小循环)，则会重新调整方向后再赋值给x,y</span><br>            m[x][y] = res;<br><br>            <span class="hljs-keyword">if</span> (a &lt; <span class="hljs-number">0</span> || a &gt;= n || b &lt; <span class="hljs-number">0</span> || b &gt;= n || m[a][b])&#123;<br>                <span class="hljs-comment">//可能的需要改变方向的情况：走到底需要拐弯，走到头(m[a][b]已经被填充，输出一个非0值)</span><br>                d = (d + <span class="hljs-number">1</span>) % <span class="hljs-number">4</span>;<br>                <span class="hljs-comment">//d的改变：1——2——3——4</span><br>                a = x + dx[d], b = y + dy[d];<br>                cnt ++;<br>                <span class="hljs-keyword">if</span> (!(cnt % <span class="hljs-number">4</span>)) res ++;<br>                <span class="hljs-comment">//当cnt==4时，代表转完了一圈，则进入小圈中</span><br>            &#125;<br>            x = a, y = b;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j ++)<br>                cout &lt;&lt; m[i][j] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>            cout &lt;&lt; endl;<br>        &#125;<br>        cout &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="3-斐波那契数列"><a href="#3-斐波那契数列" class="headerlink" title="3.斐波那契数列"></a>3.斐波那契数列</h2><h3 id="（1）基本的递归做法"><a href="#（1）基本的递归做法" class="headerlink" title="（1）基本的递归做法"></a>（1）基本的递归做法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span>  <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Fib</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n,m;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        cin&gt;&gt;m;<br>        cout&lt;&lt;<span class="hljs-built_in">Fib</span>(m)&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Fib</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(x==<span class="hljs-number">1</span>||x==<span class="hljs-number">2</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Fib</span>(x<span class="hljs-number">-1</span>)+<span class="hljs-built_in">Fib</span>(x<span class="hljs-number">-2</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="（2）方法优化"><a href="#（2）方法优化" class="headerlink" title="（2）方法优化"></a>（2）方法优化</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> t;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  cin&gt;&gt;t;<br>  <span class="hljs-keyword">while</span>(t--)<br>  &#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> number=<span class="hljs-number">0</span>,numberfront=<span class="hljs-number">1</span>,numberfrofront;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;=n; i++)<br>    &#123;<br>      <span class="hljs-keyword">if</span> (i==n)&#123;<br>          <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Fib(%d) = %lld\n&quot;</span>,n,number);<br>      &#125;<br>      numberfrofront=number+numberfront;<br>      number=numberfront;<br>      numberfrofront=numberfront;<br>      <span class="hljs-comment">//相当于做迭代，不断向前进（比递归的时间复杂度要低）</span><br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>·此处也可以使用vector数组存储生成的每一项，可减少计算的复杂（不用每次函数调用的时候都要重新计算一遍）</p><h2 id="4-ACwing-只出现一次的字符"><a href="#4-ACwing-只出现一次的字符" class="headerlink" title="4.ACwing 只出现一次的字符"></a>4.ACwing 只出现一次的字符</h2><p>题目描述<br>给你一个只包含小写字母的字符串。</p><p>请你判断是否存在只在字符串中出现过一次的字符。</p><p>如果存在，则输出满足条件的字符中位置最靠前的那个。</p><p>如果没有，输出 no。</p><p>输入格式<br>共一行，包含一个由小写字母构成的字符串。</p><p>数据保证字符串的长度不超过 100000</p><p>输出格式<br>输出满足条件的第一个字符。</p><p>如果没有，则输出 no。</p><h3 id="思路：构建一种映射的关系"><a href="#思路：构建一种映射的关系" class="headerlink" title="思路：构建一种映射的关系"></a>思路：构建一种映射的关系</h3><p>直接使用两个数组构建映射的关系（前提是数组的长度已知）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    string test;<br>    cin&gt;&gt;test;<br>    <span class="hljs-type">int</span> list[<span class="hljs-number">1000</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i:test)&#123;<br>            list[i]++;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i:test)&#123;<br>        <span class="hljs-comment">//注意这里遍历不是按list的顺序进行遍历，而是还是按照test的值(不同字符的ASCII码)来进行遍历，确保输出的始终是最大且最靠前的一项。</span><br>        <span class="hljs-keyword">if</span>(list[i]==<span class="hljs-number">1</span>)&#123;<br>            cout&lt;&lt;i;<br>            <span class="hljs-keyword">goto</span> end;<br>        &#125; <br>    &#125;<br>    cout&lt;&lt;<span class="hljs-string">&quot;no&quot;</span>;<br>    end:<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-ACwing-字符串中最长的连续出现的字符"><a href="#5-ACwing-字符串中最长的连续出现的字符" class="headerlink" title="5.ACwing 字符串中最长的连续出现的字符"></a>5.ACwing 字符串中最长的连续出现的字符</h2><p>求一个字符串中最长的连续出现的字符，输出该字符及其出现次数，字符串中无空白字符（空格、回车和 tabtab），如果这样的字符不止一个，则输出第一个。</p><p><strong>输入格式</strong></p><p>第一行输入整数 NN，表示测试数据的组数。</p><p>每组数据占一行，包含一个不含空白字符的字符串，字符串长度不超过 200200。</p><p><strong>输出格式</strong></p><p>共一行，输出最长的连续出现的字符及其出现次数，中间用空格隔开。</p><h4 id="解法①：最基本的思路"><a href="#解法①：最基本的思路" class="headerlink" title="解法①：最基本的思路"></a>解法①：最基本的思路</h4><ul><li>使用前后指针和flag判断连续字符</li><li>使用countlist数组记录每个字符连续出现的最大值</li><li>使用vector数组successful按顺序储存连续出现的字符，并且在其值更新时自动移动到序列尾端</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">findthelongest</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> countlist[<span class="hljs-number">300</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br>    vector &lt;<span class="hljs-type">char</span>&gt; successful;<br>    <span class="hljs-type">int</span> flag=<span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> tempcount=<span class="hljs-number">0</span>;<br>    string teststring;<br>    cin&gt;&gt;teststring;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;teststring.<span class="hljs-built_in">length</span>()<span class="hljs-number">-1</span>;i++)&#123;<br>        <span class="hljs-keyword">if</span>(teststring[i]==teststring[i<span class="hljs-number">+1</span>])&#123;<br>            flag=<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">find</span>(successful.<span class="hljs-built_in">begin</span>(),successful.<span class="hljs-built_in">end</span>(),teststring[i])==successful.<span class="hljs-built_in">end</span>())&#123;<br>                successful.<span class="hljs-built_in">push_back</span>(teststring[i]);<br>            &#125;<br>            <br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            flag=<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span>(tempcount&gt;countlist[teststring[i]])&#123;<br>                countlist[teststring[i]]=tempcount;<br>                successful.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">remove</span>(successful.<span class="hljs-built_in">begin</span>(),successful.<span class="hljs-built_in">end</span>(),teststring[i]));<br>                successful.<span class="hljs-built_in">push_back</span>(teststring[i]);<br>            &#125;<br>            tempcount=<span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(flag==<span class="hljs-number">1</span>)&#123;<br>            tempcount++;<br>            <span class="hljs-keyword">if</span>(i==teststring.<span class="hljs-built_in">length</span>()<span class="hljs-number">-2</span>)&#123;<br>                <span class="hljs-keyword">if</span>(tempcount&gt;countlist[teststring[i]])&#123;<br>                countlist[teststring[i]]=tempcount;<br>                successful.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">remove</span>(successful.<span class="hljs-built_in">begin</span>(),successful.<span class="hljs-built_in">end</span>(),teststring[i]));<br>                successful.<span class="hljs-built_in">push_back</span>(teststring[i]);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> max=<span class="hljs-number">0</span>;<br>    <span class="hljs-type">char</span> maxchar=teststring[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">if</span>(!successful.<span class="hljs-built_in">empty</span>())&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> tes:successful)&#123;<br>        <span class="hljs-keyword">if</span>(countlist[tes]&gt;max)&#123;<br>            maxchar=tes;<br>            max=countlist[tes];<br>        &#125;<br>    &#125;<br>    &#125;<br>    cout&lt;&lt;maxchar&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;max<span class="hljs-number">+1</span>&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> N;cin&gt;&gt;N;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;N;i++)&#123;<br>        <span class="hljs-built_in">findthelongest</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="解法②可移动的双指针"><a href="#解法②可移动的双指针" class="headerlink" title="解法②可移动的双指针"></a>解法②可移动的双指针</h3><p>解法优化：</p><ul><li>使用可移动的双指针ij，每次只有j向前不断移动直到遇到不同的元素，i最后追上j</li><li>适应覆盖的思想而不使用指针存储</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> T;<br>    cin &gt;&gt; T;<br>    <span class="hljs-keyword">while</span>(T --)<br>    &#123;<br>        <span class="hljs-type">int</span> maxn = <span class="hljs-number">-1</span>;<span class="hljs-comment">//maxn记录最大长度</span><br>        string str, maxs;<span class="hljs-comment">//maxs记录最大长度时的字符</span><br>        cin &gt;&gt; str;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; str.<span class="hljs-built_in">size</span>();)<br>        &#123;<br>            <span class="hljs-type">int</span> j = i;<br>            <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span>(str[j] == str[i] &amp;&amp; j &lt; str.<span class="hljs-built_in">size</span>())<span class="hljs-comment">//当指针j没有越界且与指针i的内容相同时移动</span><br>                j ++, cnt ++;<br>            <span class="hljs-keyword">if</span>(cnt &gt; maxn)<span class="hljs-comment">//更新最大值</span><br>                maxn = cnt, maxs = str[i];<br>            i = j ;<span class="hljs-comment">//移动指针i</span><br>        &#125;<br>        cout &lt;&lt; maxs &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; maxn &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Finished</tag>
      
      <tag>C/C++</tag>
      
      <tag>Leetcode notes</tag>
      
      <tag>algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode-Mistake-Collection</title>
    <link href="/posts/Leetcode-Mistake-collection/"/>
    <url>/posts/Leetcode-Mistake-collection/</url>
    
    <content type="html"><![CDATA[<style>  html, body, .markdown-body {    font-family: Georgia, sans, serif;  }</style><h1 id="Leetcode-Mistake-collection"><a href="#Leetcode-Mistake-collection" class="headerlink" title="Leetcode-Mistake-collection"></a>Leetcode-Mistake-collection</h1><p>笔者又来开新坑啦！</p><h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>在笔者刚刚步入大一时（也就是这学期），仗着自己暑假为数不多的C语言语法存货，觉得学校C++的课程进度有些落后，便在网上寻寻觅觅，想通过<strong>刷题</strong>的方式提升自己的代码水平。</p><p>当在网上搜索“新手小白刷编程题什么网站上最好”，十有八九跳出来的都是<strong>Leetcode</strong>。确实，<a href="https://leetcode.cn/">Leetcode</a>可以算作是数一数二优秀的编程训练网站了，各种界面设计也很符合我的审美。（就像他自己说的，<strong>全球极客挚爱的技术成长平台</strong>）。但是，对于当时习惯于把所有代码全部放进一个臃肿的<code>main</code>函数的我来说，Leetcode犹如一座高不可攀的山峰，好不容易弄懂了什么叫<strong>函数封装</strong>，竭尽全力也没办法做出 <a href="https://leetcode.cn/problems/two-sum/">第一道题</a>。🤡</p><p>之后在看 <a href="https://www.hello-algo.com/chapter_hello_algo/">Hello 算法</a>的时候在序言看到了一段感同身受的话：</p><blockquote><p>两眼一抹黑地刷题似乎是最受欢迎的方法，简单、直接且有效。然而刷题就如同玩“扫雷”游戏，自学能力强的人能够顺利将地雷逐个排掉，而基础不足的人很可能被炸得满头是包，并在挫折中步步退缩。通读教材也是一种常见做法，但对于面向求职的人来说，毕业论文、投递简历、准备笔试和面试已经消耗了大部分精力，啃厚重的书往往变成了一项艰巨的挑战。</p></blockquote><p>回想自己Leetcode的刷题之旅，真的是<strong>痛并快乐着</strong>，痛在算法题冷酷无情，将你所有的bug暴露无遗，根本不给你侥幸的机会，快乐在钻研一道题后终于看见<strong>超过了100%的人</strong>，快乐在从一开始的举步维艰，到逐渐能够尝试黄色中档题，再到得心应手，心平气和。</p><p><strong>因此，我在此开坑，将自己过去，现在以及将来在Leetcode上所做的好题，错题，看到的优秀题解以及我自己整理一些笔记等等整理成博客的形式，一篇博客五道题，希望以此留作纪念，并能够给有相同志向的小伙伴们一点鼓励和指引。</strong></p><h2 id="内容（实时更新）"><a href="#内容（实时更新）" class="headerlink" title="内容（实时更新）"></a>内容（实时更新）</h2><h3 id="第一学期（主要以语法题和最基本的算法题为主）"><a href="#第一学期（主要以语法题和最基本的算法题为主）" class="headerlink" title="第一学期（主要以语法题和最基本的算法题为主）"></a>第一学期（主要以语法题和最基本的算法题为主）</h3><ul><li>基本语法题<ul><li>数组、引用和指针的相关操作</li><li>OOP</li><li>STL入门</li></ul></li><li>基本算法入门<ul><li>排序算法</li><li>分治算法</li><li>回溯算法和递归算法</li><li>动态规划</li><li>贪心算法</li></ul></li></ul><h3 id="第二学期（重点：数据结构）"><a href="#第二学期（重点：数据结构）" class="headerlink" title="第二学期（重点：数据结构）"></a>第二学期（重点：数据结构）</h3><p>（期待一波来年开春的疯狂更新~）</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://leetcode.cn/u/affectionate-hamiltonyhv/">我的Leetcode主页</a></p><p><a href="https://leetcode.cn/">Leetcode</a></p><p><a href="https://books.halfrost.com/leetcode/">Leetcode Cookbook</a></p><hr><blockquote><p>English Version</p></blockquote><h1 id="Starting-a-New-Adventure-Again"><a href="#Starting-a-New-Adventure-Again" class="headerlink" title="Starting a New Adventure Again!"></a>Starting a New Adventure Again!</h1><h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><p>When I first started university (this semester), armed with my limited knowledge of C language syntax from a short summer learning stint, I felt the pace of my C++ course at school was a bit slow. So, I searched online for ways to improve my coding skills through <strong>problem-solving practice</strong>.</p><p>When looking up “best websites for beginners to practice coding,” <strong>LeetCode</strong> popped up in most results. Indeed, <a href="https://leetcode.cn/">LeetCode</a> is one of the best programming training platforms, and its interface design aligns perfectly with my aesthetic (as they call themselves, <strong>“The beloved tech growth platform for geeks worldwide”</strong>). However, for someone like me who used to put all the code into one bloated <code>main</code> function, LeetCode seemed like an insurmountable mountain. After finally understanding what <strong>function encapsulation</strong> was, I still couldn’t manage to solve <a href="https://leetcode.cn/problems/two-sum/">the first problem</a>. 🤡</p><p>While reading <a href="https://www.hello-algo.com/chapter_hello_algo/">Hello Algorithm</a>, I came across a sentiment in the preface that resonated deeply with me:</p><blockquote><p>Diving blindly into problem-solving is perhaps the most popular method—it’s simple, direct, and effective. However, it’s like playing a “Minesweeper” game: self-learners with a strong foundation can defuse the mines one by one, while those lacking fundamentals might get blown up and retreat in frustration. Reading textbooks is another common approach, but for job seekers, writing theses, submitting resumes, and preparing for tests and interviews consume most of their energy, making heavy textbooks a daunting challenge.</p></blockquote><p>Looking back on my LeetCode journey, it truly has been a mix of <strong>pain and joy</strong>. The pain lies in the ruthless nature of algorithm problems, exposing all your bugs without mercy, leaving no room for luck. The joy comes from finally solving a problem and seeing <strong>“outperformed 100% of users”</strong>, from struggling with initial problems to tackling mid-level yellow questions, and eventually solving problems calmly and confidently.</p><p><strong>That’s why I’m starting this series—to document the good problems, mistakes, excellent solutions, and notes from my past, present, and future LeetCode journey in the form of blog posts. Each post will include five problems, serving as a record and hopefully providing encouragement and guidance to like-minded peers.</strong></p><hr><h2 id="Content-Updated-in-Real-Time"><a href="#Content-Updated-in-Real-Time" class="headerlink" title="Content (Updated in Real-Time)"></a>Content (Updated in Real-Time)</h2><h3 id="First-Semester-Primarily-syntax-and-basic-algorithm-problems"><a href="#First-Semester-Primarily-syntax-and-basic-algorithm-problems" class="headerlink" title="First Semester (Primarily syntax and basic algorithm problems)"></a>First Semester (Primarily syntax and basic algorithm problems)</h3><ul><li><strong>Basic Syntax Problems</strong><ul><li>Array, reference, and pointer operations</li><li>OOP (Object-Oriented Programming)</li><li>Intro to STL (Standard Template Library)</li></ul></li><li><strong>Basic Algorithms</strong><ul><li>Sorting algorithms</li><li>Divide-and-conquer</li><li>Backtracking and recursion</li><li>Dynamic programming</li><li>Greedy algorithms</li></ul></li></ul><h3 id="Second-Semester-Focus-Data-Structures"><a href="#Second-Semester-Focus-Data-Structures" class="headerlink" title="Second Semester (Focus: Data Structures)"></a>Second Semester (Focus: Data Structures)</h3><p><em>(Looking forward to some crazy updates next spring!)</em></p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://leetcode.cn/u/affectionate-hamiltonyhv/">My LeetCode Profile</a></li><li><a href="https://leetcode.cn/">LeetCode</a></li><li><a href="https://books.halfrost.com/leetcode/">LeetCode Cookbook</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Announcement</tag>
      
      <tag>Finished</tag>
      
      <tag>C/C++</tag>
      
      <tag>Leetcode notes</tag>
      
      <tag>algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Class-Inheritance</title>
    <link href="/posts/Class-Inheritance/"/>
    <url>/posts/Class-Inheritance/</url>
    
    <content type="html"><![CDATA[<style>  html, body, .markdown-body {    font-family: Georgia, sans, serif;  }</style><h1 id="C-Primer-Plus-Tutorial-13"><a href="#C-Primer-Plus-Tutorial-13" class="headerlink" title="C++ Primer Plus Tutorial-13"></a>C++ Primer Plus Tutorial-13</h1><h1 id="面向对象编程教程——Section③"><a href="#面向对象编程教程——Section③" class="headerlink" title="面向对象编程教程——Section③"></a>面向对象编程教程——Section③</h1><center><p style="color: red;"><b><font size=6.5>Chapter 13 Class Inheritance</font></b></p></center><center><p style="color: red;"><b><font size=6.5>类的继承</font></b></p></center><p>【写在前面的话】</p><p><a href="https://xiyuanyang-code.github.io/posts/C-plus-plus-Primer-Plus-tutorial/">C++ Primer Plus Tutorial</a></p><p><a href="https://xiyuanyang-code.github.io/tags/OOP/">系列文章</a></p><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>在本文中，你将学到面向对象编程中的又一个核心思想：继承与多态。本文从一个基本的基类讲起并延伸到派生类的定义和基本使用，探讨派生类和基类的特殊关系。接下来本文深入继承的原理，介绍在多态公有继承中的<strong>is-a</strong>关系和虚函数，已经动态联编和静态联编的基本知识。接着本文介绍了抽象基类的使用提高效率以及在派生类中使用动态内存分配的注意事项。最后本文对OOP的基本精神——封装、继承与多态和相关基础知识做了梳理。</p><blockquote><p>In this article, you will learn another core concept in object-oriented programming: inheritance and polymorphism. The article begins with a basic base class and extends to the definition and basic usage of derived classes, exploring the special relationship between derived and base classes. Next, the article delves into the principles of inheritance, introducing the <strong>is-a</strong> relationship in polymorphic public inheritance, virtual functions, and the basics of dynamic and static binding. Then, the article discusses the use of abstract base classes to improve efficiency, as well as considerations for using dynamic memory allocation in derived classes. Finally, the article summarizes the fundamental principles of OOP—encapsulation, inheritance, and polymorphism—along with related foundational knowledge.</p></blockquote><h2 id="Table-of-Contents"><a href="#Table-of-Contents" class="headerlink" title="Table of Contents"></a>Table of Contents</h2><ul><li>基类函数和派生类函数的简单示例<ul><li>派生类的构造函数</li><li>使用派生类</li><li>派生类和基类的特殊关系</li></ul></li><li>继承<ul><li>多态公有继承</li><li>虚函数</li><li>静态联编和动态联编</li></ul></li><li>抽象基类</li><li>继承和动态内存分配</li><li>对面向对象基本知识的总结</li></ul><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>在程序设计中，代码的重用是非常重要的，这一点在面向对象编程也不例外。一种最简单的“代码重用”是最简单的<code>Ctrl-C,Ctrl-V</code>程序员，手动修改代码实现重用（乐）。那么，我们如何在不修改代码的基础上实现代码（对于OOP而言，主要是类和对象）的重用呢？这便是<strong>类的继承</strong>：从已有的类（基类）将特征和方法继承给一个新的类（派生类）。同时，类的继承也保证了安全性，派生类可以提供新特性，甚至不需要访问源代码就可以派生出类，实现<strong>数据的封装</strong>。（这不正是OOP的核心和精髓吗）</p><p>接下来的一章，让我们走进类继承的世界。</p><h2 id="Example-Base-class-and-derived-class"><a href="#Example-Base-class-and-derived-class" class="headerlink" title="Example: Base class and derived class"></a>Example: Base class and derived class</h2><p>文章首先给出一个比较简单的基类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// tabtenn0.h -- a table-tennis base class</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> TABTENN0_H_</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TABTENN0_H_</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> std::string;<br><span class="hljs-comment">// simple base class</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TableTennisPlayer</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>    string firstname;<br>    string lastname;<br>    <span class="hljs-type">bool</span> hasTable;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">TableTennisPlayer</span> (<span class="hljs-type">const</span> string &amp; fn = <span class="hljs-string">&quot;none&quot;</span>,<span class="hljs-type">const</span> string &amp; ln = <span class="hljs-string">&quot;none&quot;</span>, <span class="hljs-type">bool</span> ht = <span class="hljs-literal">false</span>);<br>    <span class="hljs-comment">//默认构造函数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Name</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-comment">//输出会员的姓名</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">HasTable</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> hasTable; &#125;;<br>    <span class="hljs-comment">//判断会员是否有球桌</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ResetTable</span><span class="hljs-params">(<span class="hljs-type">bool</span> v)</span> </span>&#123; hasTable = v; &#125;;<br>    <span class="hljs-comment">//重设球桌状态</span><br>&#125;;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//tabtenn0.cpp -- simple base-class methods</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;tabtenn0.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br>TableTennisPlayer::<span class="hljs-built_in">TableTennisPlayer</span> (<span class="hljs-type">const</span> string &amp; fn, <br>    <span class="hljs-type">const</span> string &amp; ln, <span class="hljs-type">bool</span> ht) : <span class="hljs-built_in">firstname</span>(fn),<span class="hljs-built_in">lastname</span>(ln), <span class="hljs-built_in">hasTable</span>(ht) &#123;&#125;<br>    <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TableTennisPlayer::Name</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>    std::cout &lt;&lt; lastname &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; firstname;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// usett0.cpp -- using a base class</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;tabtenn0.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">( <span class="hljs-type">void</span> )</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">using</span> std::cout;<br>    <span class="hljs-function">TableTennisPlayer <span class="hljs-title">player1</span><span class="hljs-params">(<span class="hljs-string">&quot;Chuck&quot;</span>, <span class="hljs-string">&quot;Blizzard&quot;</span>, <span class="hljs-literal">true</span>)</span></span>;<br>    <span class="hljs-function">TableTennisPlayer <span class="hljs-title">player2</span><span class="hljs-params">(<span class="hljs-string">&quot;Tara&quot;</span>, <span class="hljs-string">&quot;Boomdea&quot;</span>, <span class="hljs-literal">false</span>)</span></span>;<br>    player<span class="hljs-number">1.</span><span class="hljs-built_in">Name</span>();<br>    <span class="hljs-keyword">if</span> (player<span class="hljs-number">1.</span><span class="hljs-built_in">HasTable</span>())<br>        cout &lt;&lt; <span class="hljs-string">&quot;: has a table.\n&quot;</span>;<br>    <span class="hljs-keyword">else</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;: hasn&#x27;t a table.\n&quot;</span>;<br>    player<span class="hljs-number">2.</span><span class="hljs-built_in">Name</span>();<br>    <span class="hljs-keyword">if</span> (player<span class="hljs-number">2.</span><span class="hljs-built_in">HasTable</span>())<br>        cout &lt;&lt; <span class="hljs-string">&quot;: has a table&quot;</span>;<br>    <span class="hljs-keyword">else</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;: hasn&#x27;t a table.\n&quot;</span>;<br>    <span class="hljs-comment">// std::cin.get();</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>现在，我要在这个类的基础之上派生出一个新的类，来记录乒乓球运动员在比赛中的得分。</p><p>先来看写好的头文件，再来逐行解析：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// tabtenn1.h -- a table-tennis base class</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> TABTENN1_H_</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TABTENN1_H_</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> std::string;<br><span class="hljs-comment">// simple base class</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TableTennisPlayer</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>    string firstname;<br>    string lastname;<br>    <span class="hljs-type">bool</span> hasTable;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">TableTennisPlayer</span> (<span class="hljs-type">const</span> string &amp; fn = <span class="hljs-string">&quot;none&quot;</span>,<span class="hljs-type">const</span> string &amp; ln = <span class="hljs-string">&quot;none&quot;</span>, <span class="hljs-type">bool</span> ht = <span class="hljs-literal">false</span>);<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Name</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">HasTable</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> hasTable; &#125;;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ResetTable</span><span class="hljs-params">(<span class="hljs-type">bool</span> v)</span> </span>&#123; hasTable = v; &#125;;<br>&#125;;<br><br><span class="hljs-comment">// simple derived class</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RatedPlayer</span> : <span class="hljs-keyword">public</span> TableTennisPlayer<br>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> rating;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">RatedPlayer</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> r = <span class="hljs-number">0</span>, <span class="hljs-type">const</span> string &amp; fn = <span class="hljs-string">&quot;none&quot;</span>,<br>                 <span class="hljs-type">const</span> string &amp; ln = <span class="hljs-string">&quot;none&quot;</span>, <span class="hljs-type">bool</span> ht = <span class="hljs-literal">false</span>);<br>    <span class="hljs-built_in">RatedPlayer</span>(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> r, <span class="hljs-type">const</span> TableTennisPlayer &amp; tp);<br>    <span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title">Rating</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> rating; &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ResetRating</span> <span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> r)</span> </span>&#123;rating = r;&#125;<br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br></code></pre></td></tr></table></figure><p>很容易的看出，<code>RatedPlayer</code>是从<code>TableTennisPlayer</code>派生出来的派生类。最基本的语法定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">RatedPlayer</span> : <span class="hljs-keyword">public</span> TableTennisPlayer<br>&#123;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-comment">//your Declaration here</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//your Declaration here</span><br>&#125;;<br><br></code></pre></td></tr></table></figure><p>冒号指出 <code>RatedPlayer</code> 类的基类是 <code>TableTennisplayer</code> 类。上述特殊的声明头表明 <code>TableTennisPlayer</code> 是一个<strong>公有基类</strong>，这被称为<strong>公有派生</strong>。<strong>派生类对象包含基类对象</strong>。使用公有派生，<strong>基类的公有成员将成为派生类的公有成员</strong>；<strong>基类的私有部分也将成为派生类的一部分</strong>，但只能通过基类的公有和保护方法访问（稍后将介绍保护成员）。</p><p><code>Ratedplayer</code>对象将具有以下特征：</p><ul><li>派生类对象存储了基类的数据成员（派生类继承了基类的实现）；</li><li>派生类对象可以使用基类的方法（派生类继承了基类的接口）。</li></ul><blockquote><p>派生类就像基类的“儿子”，子承父业，可以直接继承父亲的所有遗产。</p></blockquote><p>这是<strong>继承</strong>的部分，同时，派生类也可以实现自己的新方法和新成员，这也在3~6行的代码处定义。</p><ul><li>派生类<strong>需要</strong>自己的构造函数（<strong>这很重要！</strong>）</li><li>派生类可以添加额外的数据方法和数据成员。</li></ul><h3 id="派生类的构造函数：访问权限的考虑"><a href="#派生类的构造函数：访问权限的考虑" class="headerlink" title="派生类的构造函数：访问权限的考虑"></a>派生类的构造函数：访问权限的考虑</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">RatedPlayer</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> r = <span class="hljs-number">0</span>, <span class="hljs-type">const</span> string &amp; fn = <span class="hljs-string">&quot;none&quot;</span>,<br>             <span class="hljs-type">const</span> string &amp; ln = <span class="hljs-string">&quot;none&quot;</span>, <span class="hljs-type">bool</span> ht = <span class="hljs-literal">false</span>);<br><span class="hljs-built_in">RatedPlayer</span>(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> r, <span class="hljs-type">const</span> TableTennisPlayer &amp; tp);<br></code></pre></td></tr></table></figure><p>上文代码是派生类中实现的两个构造函数，可以看出，构造函数要同时定义<strong>原有基类的数据成员和新添加的数据成员</strong>（第一个构造函数）。当然，偷懒一点也是可以的，可以在构造函数中使用到<strong>基类的对象</strong>（第二个构造函数）。</p><p>但是，构造函数的设计并不是像想象的那么简单。前文的<code>Introduction</code>讲过，派生类甚至可以在不访问基类的情况下实现继承。实际上，<strong>派生类不可以直接访问基类的私有成员，而必须通过基类定义的方法进行访问（和外部的函数一样，只能通过接口进行访问）</strong>，换句话来说，<strong>派生类构造函数必须使用基类构造函数</strong>。</p><h4 id="第一种构造函数"><a href="#第一种构造函数" class="headerlink" title="第一种构造函数"></a>第一种构造函数</h4><p>这点就显得非常矛盾了，因为从上文第一个构造函数的视角看过去，我们貌似<strong>给派生类的每一个私有成员提供了数据，貌似可以直接访问所有的私有成员，包括基类和派生类</strong>。实际上，并不是这样，下面我们来详细解释这一点。</p><p>我们更进一步，给出第一个构造函数的声明和定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//函数声明</span><br><span class="hljs-built_in">RatedPlayer</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> r = <span class="hljs-number">0</span>, <span class="hljs-type">const</span> string &amp; fn = <span class="hljs-string">&quot;none&quot;</span>, <span class="hljs-type">const</span> string &amp; ln = <span class="hljs-string">&quot;none&quot;</span>, <span class="hljs-type">bool</span> ht = <span class="hljs-literal">false</span>);<br><br><span class="hljs-comment">//函数定义</span><br>RatedPlayer::<span class="hljs-built_in">RatedPlayer</span>(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> r, <span class="hljs-type">const</span> string &amp; fn,<span class="hljs-type">const</span> string &amp; ln, <span class="hljs-type">bool</span> ht) : <span class="hljs-built_in">TableTennisPlayer</span>(fn, ln, ht)<br>&#123;<br>    rating = r;<br>&#125;<br></code></pre></td></tr></table></figure><p>在创建派生类对象时，程序首先会创建<strong>基类对象</strong>。因此，在使用派生类对象的构造函数时，对应的基类对象已经存在。</p><blockquote><p>这很好理解，儿子出生之前，爸爸肯定得出生。</p></blockquote><p>理解了这一点后，我们再来看函数的定义，我们会发现很独特的一行，<code>TableTennisPlayer(fn, ln, ht)</code>。这行代码叫<strong>成员初始化列表</strong>，是可执行的代码，用来调用基类<code>TableTennisPlayer</code>的构造函数。<code>fn, ln, ht</code>作为三个形式参数，接受实参并将其本身传递给<code>TableTennisPlayer</code>构造函数的形式参数，后者将创建一个<strong>嵌套的基类对象</strong>（先创建爸爸），接着，进入派生类函数的函数体，完成对派生类对象的创建。（再创建儿子）</p><p>如果省略了成员初始化列表，那么程序会调用<strong>默认的构造函数</strong>创建一个基类对象，而无法使用显式的构造函数，程序就无法读取到我们希望赋给对象的数据。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//没有成员初始化列表的情况</span><br>RatedPlayer::<span class="hljs-built_in">RatedPlayer</span>(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> r, <span class="hljs-type">const</span> string &amp; fn,<span class="hljs-type">const</span> string &amp; ln, <span class="hljs-type">bool</span> ht) : <br>&#123;<br>    rating = r;<br>&#125;<br><br><span class="hljs-comment">//与下面的代码等效</span><br>RatedPlayer::<span class="hljs-built_in">RatedPlayer</span>(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> r, <span class="hljs-type">const</span> string &amp; fn,<span class="hljs-type">const</span> string &amp; ln, <span class="hljs-type">bool</span> ht) : <br><span class="hljs-built_in">TableTennisPlayer</span>()<br><span class="hljs-comment">//使用无参数的默认构造函数</span><br>&#123;<br>    rating = r;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="第二种构造函数"><a href="#第二种构造函数" class="headerlink" title="第二种构造函数"></a>第二种构造函数</h4><p>接下来，我们来看第二种更加简洁的构造函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//函数声明</span><br><span class="hljs-built_in">RatedPlayer</span>(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> r, <span class="hljs-type">const</span> TableTennisPlayer &amp; tp);<br><br><span class="hljs-comment">//函数定义</span><br>RatedPlayer::<span class="hljs-built_in">RatedPlayer</span>(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> r, <span class="hljs-type">const</span> TableTennisPlayer &amp; tp)<br>    : <span class="hljs-built_in">TableTennisPlayer</span>(tp)<br>&#123;<br>        rating=r;<br>&#125;<br><br><span class="hljs-comment">//函数定义的等价形式</span><br>RatedPlayer::<span class="hljs-built_in">RatedPlayer</span>(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> r, <span class="hljs-type">const</span> TableTennisPlayer &amp; tp)<br>    : <span class="hljs-built_in">TableTennisPlayer</span>(tp), <span class="hljs-built_in">rating</span>(r)<br>&#123;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>来看这里的初始化成员列表，传入的参数是一个<code>const TableTennisPlayer &amp;</code>类型，因此，系统会调用默认的<strong>复制构造函数</strong>（这是个很有趣的问题，我们在<a href="https://xiyuanyang-code.github.io/posts/Dynamic-Memory-and-Classes/">第十二章</a>的时候重点讨论了，这里使用默认的复制构造函数是不会产生任何问题的）。</p><p>当然，我们也可以对<strong>派生类成员使用初始化列表</strong>，在这种情况下，应该使用成员名而不是类名。</p><blockquote><p>释放对象的顺序与创建对象的顺序相反，即首先执行派生类的析构函数，然后自动调用基类的析构函数。  </p></blockquote><div class="note note-success">            <p><strong>小总结</strong>： 创建派生类对象时，程序首先<strong>调用基类构造函数</strong>，然后再<strong>调用派生类构造函数</strong>。基类构造函数负责初始化继承的数据成员；派生类构造函数主要用于初始化新增的数据成员。派生类的构造函数总是调用一个基类构造函数。可以使用初始化器列表语法指明要使用的基类构造函数，否则将使用默认的基类构造函数。派生类对象过期时，程序将首先调用派生类析构函数，然后再调用基类析构函数。</p>          </div><p>现在，我们可以给出派生类的全部函数定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//tabtenn1.cpp -- simple base-class methods</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;tabtenn1.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br>TableTennisPlayer::<span class="hljs-built_in">TableTennisPlayer</span> (<span class="hljs-type">const</span> string &amp; fn, <br>    <span class="hljs-type">const</span> string &amp; ln, <span class="hljs-type">bool</span> ht) : <span class="hljs-built_in">firstname</span>(fn),<span class="hljs-built_in">lastname</span>(ln), <span class="hljs-built_in">hasTable</span>(ht) &#123;&#125;<br>    <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TableTennisPlayer::Name</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>    std::cout &lt;&lt; lastname &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; firstname;<br>&#125;<br><br><span class="hljs-comment">// RatedPlayer methods</span><br>RatedPlayer::<span class="hljs-built_in">RatedPlayer</span>(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> r, <span class="hljs-type">const</span> string &amp; fn,<br>    <span class="hljs-type">const</span> string &amp; ln, <span class="hljs-type">bool</span> ht) : <span class="hljs-built_in">TableTennisPlayer</span>(fn, ln, ht)<br>&#123;<br>    rating = r;<br>&#125;<br><br>RatedPlayer::<span class="hljs-built_in">RatedPlayer</span>(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> r, <span class="hljs-type">const</span> TableTennisPlayer &amp; tp)<br>    : <span class="hljs-built_in">TableTennisPlayer</span>(tp), <span class="hljs-built_in">rating</span>(r)<br>&#123;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="使用派生类"><a href="#使用派生类" class="headerlink" title="使用派生类"></a>使用派生类</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// usett1.cpp -- using base class and derived class</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;tabtenn1.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">( <span class="hljs-type">void</span> )</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">using</span> std::cout;<br>    <span class="hljs-keyword">using</span> std::endl;<br>    <span class="hljs-function">TableTennisPlayer <span class="hljs-title">player1</span><span class="hljs-params">(<span class="hljs-string">&quot;Tara&quot;</span>, <span class="hljs-string">&quot;Boomdea&quot;</span>, <span class="hljs-literal">false</span>)</span></span>;<br>    <span class="hljs-function">RatedPlayer <span class="hljs-title">rplayer1</span><span class="hljs-params">(<span class="hljs-number">1140</span>, <span class="hljs-string">&quot;Mallory&quot;</span>, <span class="hljs-string">&quot;Duck&quot;</span>, <span class="hljs-literal">true</span>)</span></span>;<br>    rplayer<span class="hljs-number">1.</span><span class="hljs-built_in">Name</span>();          <span class="hljs-comment">// derived object uses base method</span><br>    <span class="hljs-keyword">if</span> (rplayer<span class="hljs-number">1.</span><span class="hljs-built_in">HasTable</span>())<br>        cout &lt;&lt; <span class="hljs-string">&quot;: has a table.\n&quot;</span>;<br>    <span class="hljs-keyword">else</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;: hasn&#x27;t a table.\n&quot;</span>;<br>    player<span class="hljs-number">1.</span><span class="hljs-built_in">Name</span>();           <span class="hljs-comment">// base object uses base method</span><br>    <span class="hljs-keyword">if</span> (player<span class="hljs-number">1.</span><span class="hljs-built_in">HasTable</span>())<br>        cout &lt;&lt; <span class="hljs-string">&quot;: has a table&quot;</span>;<br>    <span class="hljs-keyword">else</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;: hasn&#x27;t a table.\n&quot;</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Name: &quot;</span>;<br>    rplayer<span class="hljs-number">1.</span><span class="hljs-built_in">Name</span>();<br>    cout &lt;&lt; <span class="hljs-string">&quot;; Rating: &quot;</span> &lt;&lt; rplayer<span class="hljs-number">1.</span><span class="hljs-built_in">Rating</span>() &lt;&lt; endl;<br><span class="hljs-comment">// initialize RatedPlayer using TableTennisPlayer object</span><br>    <span class="hljs-function">RatedPlayer <span class="hljs-title">rplayer2</span><span class="hljs-params">(<span class="hljs-number">1212</span>, player1)</span></span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Name: &quot;</span>;<br>    rplayer<span class="hljs-number">2.</span><span class="hljs-built_in">Name</span>();<br>    cout &lt;&lt; <span class="hljs-string">&quot;; Rating: &quot;</span> &lt;&lt; rplayer<span class="hljs-number">2.</span><span class="hljs-built_in">Rating</span>() &lt;&lt; endl;<br>    <span class="hljs-comment">// std::cin.get();</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="派生类和基类的特殊关系"><a href="#派生类和基类的特殊关系" class="headerlink" title="派生类和基类的特殊关系"></a>派生类和基类的特殊关系</h3><p>用形象的话说，派生类是儿子，继承自基类（爸爸）的方法和数据成员。但是，基类又有自己的“隐私”，派生类是能通过公共接口实现对基类的访问，即无法直接访问其私有成员。</p><blockquote><p>派生类相当于一种<strong>在定义和结构上</strong>获得“权限”的类，权限在于可以直接继承基类所定义好的成员和方法（在定义层面的<strong>继承</strong>），但是<strong>在操作上</strong>，派生类并没有从基类处获得任何特权，不能访问的还是不能访问。</p></blockquote><p>从这条出发，我们可以归纳派生类和基类之间的特殊关系：</p><ul><li>派生类对象可以使用基类的方法，条件是<strong>方法不是私有的</strong>。</li><li><strong>基类指针可以在不进行显示转换的情况下指向派生类对象。</strong></li><li><strong>基类引用可以在不进行显示转换的情况下引用派生类对象。</strong></li></ul><blockquote><p>二、三两条非常的重要，<strong>指针和引用类型的兼容性</strong>确保了其可以在基类和派生类之间反复横跳，更加的灵活。（同时也更加的复杂和危险）</p></blockquote><h4 id="基类指针可以在不进行显示转换的情况下指向派生类对象"><a href="#基类指针可以在不进行显示转换的情况下指向派生类对象" class="headerlink" title="基类指针可以在不进行显示转换的情况下指向派生类对象"></a>基类指针可以在不进行显示转换的情况下指向派生类对象</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base class&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Derived class&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Derived d;<br>    Base* basePtr = &amp;d; <span class="hljs-comment">// 基类指针指向派生类对象</span><br>    basePtr-&gt;<span class="hljs-built_in">display</span>(); <span class="hljs-comment">// 输出: Derived class (多态行为)</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="基类引用可以在不进行显示转换的情况下引用派生类对象。"><a href="#基类引用可以在不进行显示转换的情况下引用派生类对象。" class="headerlink" title="基类引用可以在不进行显示转换的情况下引用派生类对象。"></a>基类引用可以在不进行显示转换的情况下引用派生类对象。</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base class&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Derived class&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Derived d;<br>    Base&amp; baseRef = d; <span class="hljs-comment">// 基类引用绑定到派生类对象</span><br>    baseRef.<span class="hljs-built_in">display</span>(); <span class="hljs-comment">// 输出: Derived class (多态行为)</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><p>注意关键词<code>virtual</code>，之后会讲到，否则会发生静态绑定现象。</p></blockquote><ul><li>基类指针和引用只能调用基类方法，而不可以调用派生类的方法。<ul><li>因为派生类允许添加新的数据成员，如果允许调用会产生很多奇怪的问题。</li></ul></li><li>基类指针和应用可以指向派生类的对象<ul><li><a href="https://blog.csdn.net/goodgoodstudy___/article/details/124905482">这篇讲的很清楚</a></li><li>这里涉及到一些有关虚函数的知识点，暂时先跳过。</li></ul></li><li><strong>基类对象也可以被派生类对象初始化（或赋值）</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">RatedPlayer <span class="hljs-title">player1</span><span class="hljs-params">(<span class="hljs-number">1840</span>,<span class="hljs-string">&quot;o1&quot;</span>,<span class="hljs-string">&quot;Loaf&quot;</span>,<span class="hljs-literal">true</span>)</span></span>;<br><span class="hljs-function">TableTennisPlayer <span class="hljs-title">player2</span><span class="hljs-params">(player1)</span></span>;    <span class="hljs-comment">//VALID</span><br></code></pre></td></tr></table></figure><p>可以用<strong>引用兼容性</strong>的属性来解释这个问题，调用基类的构造函数时不存在匹配的构造函数，故会调用隐式复制构造函数<code>TableTennisPlayer(const TableTennisPlayer&amp;)</code>，形参是<strong>对基类的引用</strong>，<strong>可以在不进行显式转换的</strong>情况下引用派生类对象<code>player1</code>。因此，复制构造函数将嵌套在<code>player1</code>基类中的<code>TableTennisPlayer</code>赋值给了<code>player2</code>。</p><h2 id="Inheritance"><a href="#Inheritance" class="headerlink" title="Inheritance"></a>Inheritance</h2><p>派生类和基类的特殊关系在本质上基于C++继承的底层模型。C++有常见的三种继承方式：</p><ul><li><p>公有继承（<strong>is-a关系</strong>）</p><ul><li>派生类也是一个基类对象，可以执行基类对象执行的任何操作。</li><li><strong>is-a：is a kind of</strong>（往往是抽象与具象的关系）</li></ul><blockquote><p>如果一个派生类选择以<strong>公有继承</strong>的方式，那么应该可以被改写成<strong>XX is a kind of XXX</strong>的形式。例如，香蕉类公有继承水果类（香蕉类可以使用水果类的所有数据和方法，同时香蕉也可以定义自己的数据成员和方法），可以说Banana is a kind of fruit.</p></blockquote><blockquote><p>除了<strong>is a</strong>还有什么关系？有很多，比如<strong>has-a, is-like-a, is-implemented-as-a, uses-a</strong>等等关系，不过，这些都不适合使用公有继承的方式实现。</p></blockquote></li><li><p>保护继承</p></li><li><p>私有继承</p></li></ul><h3 id="多态公有继承"><a href="#多态公有继承" class="headerlink" title="多态公有继承"></a>多态公有继承</h3><p>在传统的继承关系中，派生类可以使用基类的成员函数（只要他不是私有成员）。但有时，派生类希望个性化地修改基类成员函数的方法来实现个性化的目的，因此有必要对基类成员函数进行修改，而非<strong>完全实现</strong>。这种思想被称作<strong>多态</strong>，这种继承方式也被称作多态公有继承。</p><h4 id="例子：Brass-Plus类和Brass类"><a href="#例子：Brass-Plus类和Brass类" class="headerlink" title="例子：Brass Plus类和Brass类"></a>例子：<code>Brass Plus类</code>和<code>Brass类</code></h4><p>书上给出了另一个有关银行的例子，有关类的实现原理请自行阅读。</p><blockquote><p>现在来看另一个例子。由于 Webtown 俱乐部的工作经历，您成了 Pontoon 银行的首席程序员。银行要求您完成的第一项工作是开发两个类。一个类用于表示基本支票账户—Brass Account，另一个类用于表示代表 Brass Plus 支票账户，它添加了透支保护特性。也就是说，如果用户签出一张超出其存款余额的支票——但是超出的数额并不是很大，银行将支付这张支票，对超出的部分收取额外的费用，并追加罚款。可以根据要保存的数据以及允许执行的操作来确定这两种账户的特征。</p><p>下面是用于 Brass Account 支票账户的信息：</p><ul><li>客户姓名；</li><li>账号；</li><li>当前结余。</li></ul><p>下面是可以执行的操作：</p><ul><li>创建账户；</li><li>存款；</li><li>取款；</li><li>显示账户信息。</li></ul><p>Pontoon 银行希望 Brass Plus 支票账户包含 Brass Account 的所有信息及如下信息：</p><ul><li>透支上限；</li><li>透支贷款利率；</li><li>当前的透支总额。</li></ul><p>不需要新增操作，但有两种操作的实现不同：</p><ul><li>对于取款操作，必须考虑透支保护；</li><li>显示操作必须显示 Brass Plus 账户的其他信息。</li></ul><p>假设将第一个类命名为 Brass，第二个类为 BrassPlus。应从 Brass 公有派生出 BrassPlus 吗？要回答这个问题，必须先回答另一个问题： BrassPlus 类是否满足 is-a 条件？当然满足。对于 Brass 对象是正确的事情，对于 BrassPlus 对象也是正确的。它们都将保存客户姓名、账号以及结余。使用这两个类都可以存款、取款和显示账户信息。请注意， is-a 关系通常是不可逆的。也就是说，水果不是香蕉；同样， Brass 对象不具备 BrassPlus 对象的所有功能。</p></blockquote><p>我们直接来看代码，以下是有关两个类实现的头文件声明：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// brass.h  -- bank account classes</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> BRASS_H_</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BRASS_H_</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-comment">// Brass Account Class</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Brass</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>    std::string fullName;<br>    <span class="hljs-type">long</span> acctNum;<br>    <span class="hljs-type">double</span> balance;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Brass</span>(<span class="hljs-type">const</span> std::string &amp; s = <span class="hljs-string">&quot;Nullbody&quot;</span>, <span class="hljs-type">long</span> an = <span class="hljs-number">-1</span>,<br>                <span class="hljs-type">double</span> bal = <span class="hljs-number">0.0</span>);<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Deposit</span><span class="hljs-params">(<span class="hljs-type">double</span> amt)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Withdraw</span><span class="hljs-params">(<span class="hljs-type">double</span> amt)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">Balance</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">ViewAcct</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Brass</span>() &#123;&#125;<br>&#125;;<br><br><span class="hljs-comment">//Brass Plus Account Class</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BrassPlus</span> : <span class="hljs-keyword">public</span> Brass<br>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">double</span> maxLoan;<br>    <span class="hljs-type">double</span> rate;<br>    <span class="hljs-type">double</span> owesBank;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">BrassPlus</span>(<span class="hljs-type">const</span> std::string &amp; s = <span class="hljs-string">&quot;Nullbody&quot;</span>, <span class="hljs-type">long</span> an = <span class="hljs-number">-1</span>,<br>            <span class="hljs-type">double</span> bal = <span class="hljs-number">0.0</span>, <span class="hljs-type">double</span> ml = <span class="hljs-number">500</span>,<br>            <span class="hljs-type">double</span> r = <span class="hljs-number">0.11125</span>);<br>    <span class="hljs-built_in">BrassPlus</span>(<span class="hljs-type">const</span> Brass &amp; ba, <span class="hljs-type">double</span> ml = <span class="hljs-number">500</span>, <br>                        <span class="hljs-type">double</span> r = <span class="hljs-number">0.11125</span>);<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">ViewAcct</span><span class="hljs-params">()</span><span class="hljs-type">const</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Withdraw</span><span class="hljs-params">(<span class="hljs-type">double</span> amt)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ResetMax</span><span class="hljs-params">(<span class="hljs-type">double</span> m)</span> </span>&#123; maxLoan = m; &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ResetRate</span><span class="hljs-params">(<span class="hljs-type">double</span> r)</span> </span>&#123; rate = r; &#125;;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ResetOwes</span><span class="hljs-params">()</span> </span>&#123; owesBank = <span class="hljs-number">0</span>; &#125;<br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>我们发现有以下几点：</p><ul><li><code>BrassPlus</code>类和<code>Brass</code>类都定义了同名函数<code>Withdraw()</code>和<code>Viewacct()</code>。<ul><li>编译器将根据对象的类型自动选择使用哪个类定义中的函数。</li></ul></li><li>出现了新关键词<code>virtual</code><strong>（虚方法）</strong></li></ul><h4 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h4><p>函数<code>Withdraw()</code>和<code>Viewacct()</code>不同于一般的方法 ，在基类和派生类中都有自己的定义（而且定义一般是不同的），这些函数在面向对象编程中被称为<strong>虚函数</strong>。</p><div class="note note-info">            <p>虚函数是指一个<strong>在基类中声明并可以在派生类中重写的成员函数</strong>。虚函数的主要作用是实现<strong>运行时多态</strong>（Runtime Polymorphism），即程序在执行过程中根据对象的实际类型调用相应的函数版本，而不是<strong>根据指针或引用的类型来决定</strong>。</p>          </div><p>下面我们来详细解释一下这个定义，请看如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Base class show&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Derived class show&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Base* basePtr;  <span class="hljs-comment">// 基类指针</span><br>    Derived derivedObj;  <span class="hljs-comment">// 派生类对象</span><br>    <br>    basePtr = &amp;derivedObj;  <span class="hljs-comment">// 基类指针指向派生类对象</span><br>    <br>    <span class="hljs-comment">// 虚函数的调用</span><br>    basePtr-&gt;<span class="hljs-built_in">show</span>();  <span class="hljs-comment">// 运行时会调用派生类的 show()，输出: Derived class show</span><br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在这里，指针<code>basePtr</code>的<strong>定义类型</strong>是Base（基类），但是指向一个派生类的对象（上文提到过这种行为是合法的）。那么在下一行调用<code>show</code>函数的时候是应该<strong>优先考虑指针本身的类型</strong>，还是考虑<strong>指针指向对象的类型</strong>呢？因此，C++引入了关键词<code>virtual</code>来声明一个虚函数，对于虚函数而言，在调用时会<strong>根据对象的实际类型来调用相对应的同名函数</strong>，比如在上文由于baseptr指向的<strong>实际对象</strong>是一个派生类的对象，所以会<strong>调用派生类的函数</strong>。</p><blockquote><p>如果不加virtual关键词，编译器会报错（这个需要更加深入的知识了）</p></blockquote><p>有意思的是，基类<code>Brass</code>的虚构函数同样使用了<code>virtual</code>关键词来定义，这样做是为了确保释放派生对象时，按照正确的顺序调用析构函数。（这形成了一种惯例，后文会再提到）</p><p>接下来，我们来看两个类的具体定义。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// brass.cpp -- bank account class methods</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;brass.h&quot;</span></span><br><span class="hljs-keyword">using</span> std::cout;<br><span class="hljs-keyword">using</span> std::endl;<br><span class="hljs-keyword">using</span> std::string;<br><br><span class="hljs-comment">// formatting stuff</span><br><span class="hljs-keyword">typedef</span> std::ios_base::fmtflags format;<br><span class="hljs-keyword">typedef</span> std::streamsize precis;<br><span class="hljs-function">format <span class="hljs-title">setFormat</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">restore</span><span class="hljs-params">(format f, precis p)</span></span>;<br><br><span class="hljs-comment">// Brass methods</span><br><br>Brass::<span class="hljs-built_in">Brass</span>(<span class="hljs-type">const</span> string &amp; s, <span class="hljs-type">long</span> an, <span class="hljs-type">double</span> bal)<br>&#123;<br>    fullName = s;<br>    acctNum = an;<br>    balance = bal;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Brass::Deposit</span><span class="hljs-params">(<span class="hljs-type">double</span> amt)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (amt &lt; <span class="hljs-number">0</span>)<br>        cout &lt;&lt; <span class="hljs-string">&quot;Negative deposit not allowed; &quot;</span><br>             &lt;&lt; <span class="hljs-string">&quot;deposit is cancelled.\n&quot;</span>;<br>    <span class="hljs-keyword">else</span><br>        balance += amt;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Brass::Withdraw</span><span class="hljs-params">(<span class="hljs-type">double</span> amt)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// set up ###.## format</span><br>    format initialState = <span class="hljs-built_in">setFormat</span>();<br>    precis prec = cout.<span class="hljs-built_in">precision</span>(<span class="hljs-number">2</span>);<br><br>    <span class="hljs-keyword">if</span> (amt &lt; <span class="hljs-number">0</span>)<br>        cout &lt;&lt; <span class="hljs-string">&quot;Withdrawal amount must be positive; &quot;</span><br><br>             &lt;&lt; <span class="hljs-string">&quot;withdrawal canceled.\n&quot;</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (amt &lt;= balance)<br>        balance -= amt;<br>    <span class="hljs-keyword">else</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;Withdrawal amount of $&quot;</span> &lt;&lt; amt<br>             &lt;&lt; <span class="hljs-string">&quot; exceeds your balance.\n&quot;</span><br>             &lt;&lt; <span class="hljs-string">&quot;Withdrawal canceled.\n&quot;</span>;<br>    <span class="hljs-built_in">restore</span>(initialState, prec);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">Brass::Balance</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> balance;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Brass::ViewAcct</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>     <span class="hljs-comment">// set up ###.## format</span><br>    format initialState = <span class="hljs-built_in">setFormat</span>();<br>    precis prec = cout.<span class="hljs-built_in">precision</span>(<span class="hljs-number">2</span>);<br>    cout &lt;&lt; <span class="hljs-string">&quot;Client: &quot;</span> &lt;&lt; fullName &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Account Number: &quot;</span> &lt;&lt; acctNum &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Balance: $&quot;</span> &lt;&lt; balance &lt;&lt; endl;<br>    <span class="hljs-built_in">restore</span>(initialState, prec); <span class="hljs-comment">// Restore original format</span><br>&#125;<br><br><span class="hljs-comment">// BrassPlus Methods</span><br>BrassPlus::<span class="hljs-built_in">BrassPlus</span>(<span class="hljs-type">const</span> string &amp; s, <span class="hljs-type">long</span> an, <span class="hljs-type">double</span> bal,<br>           <span class="hljs-type">double</span> ml, <span class="hljs-type">double</span> r) : <span class="hljs-built_in">Brass</span>(s, an, bal)<br>&#123;<br>    maxLoan = ml;<br>    owesBank = <span class="hljs-number">0.0</span>;<br>    rate = r;<br>&#125;<br><br>BrassPlus::<span class="hljs-built_in">BrassPlus</span>(<span class="hljs-type">const</span> Brass &amp; ba, <span class="hljs-type">double</span> ml, <span class="hljs-type">double</span> r)<br>           : <span class="hljs-built_in">Brass</span>(ba)   <span class="hljs-comment">// uses implicit copy constructor</span><br>&#123;<br>    maxLoan = ml;<br>    owesBank = <span class="hljs-number">0.0</span>;<br>    rate = r;<br>&#125;<br><br><span class="hljs-comment">// redefine how ViewAcct() works</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BrassPlus::ViewAcct</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// set up ###.## format</span><br>    format initialState = <span class="hljs-built_in">setFormat</span>();<br>    precis prec = cout.<span class="hljs-built_in">precision</span>(<span class="hljs-number">2</span>);<br><br>    Brass::<span class="hljs-built_in">ViewAcct</span>();   <span class="hljs-comment">// display base portion</span><br>    <span class="hljs-comment">//注意：这里必须要使用作用域解析运算符，否则会发生无终止递归。（因为编译器会默认认为这里的ViewAcct是调用BrassPlus类中的方法）</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;Maximum loan: $&quot;</span> &lt;&lt; maxLoan &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Owed to bank: $&quot;</span> &lt;&lt; owesBank &lt;&lt; endl;<br>    cout.<span class="hljs-built_in">precision</span>(<span class="hljs-number">3</span>);  <span class="hljs-comment">// ###.### format</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;Loan Rate: &quot;</span> &lt;&lt; <span class="hljs-number">100</span> * rate &lt;&lt; <span class="hljs-string">&quot;%\n&quot;</span>;<br>    <span class="hljs-built_in">restore</span>(initialState, prec); <br>&#125;<br><br><span class="hljs-comment">// redefine how Withdraw() works</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BrassPlus::Withdraw</span><span class="hljs-params">(<span class="hljs-type">double</span> amt)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// set up ###.## format</span><br>    format initialState = <span class="hljs-built_in">setFormat</span>();<br>    precis prec = cout.<span class="hljs-built_in">precision</span>(<span class="hljs-number">2</span>);<br><br>    <span class="hljs-type">double</span> bal = <span class="hljs-built_in">Balance</span>();<br>    <span class="hljs-keyword">if</span> (amt &lt;= bal)<br>        Brass::<span class="hljs-built_in">Withdraw</span>(amt);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( amt &lt;= bal + maxLoan - owesBank)<br>    &#123;<br>        <span class="hljs-type">double</span> advance = amt - bal;<br>        owesBank += advance * (<span class="hljs-number">1.0</span> + rate);<br>        cout &lt;&lt; <span class="hljs-string">&quot;Bank advance: $&quot;</span> &lt;&lt; advance &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Finance charge: $&quot;</span> &lt;&lt; advance * rate &lt;&lt; endl;<br>        <span class="hljs-built_in">Deposit</span>(advance);<br>        Brass::<span class="hljs-built_in">Withdraw</span>(amt);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;Credit limit exceeded. Transaction cancelled.\n&quot;</span>;<br>    <span class="hljs-built_in">restore</span>(initialState, prec); <br>&#125;<br><br><span class="hljs-function">format <span class="hljs-title">setFormat</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// set up ###.## format</span><br>    <span class="hljs-keyword">return</span> cout.<span class="hljs-built_in">setf</span>(std::ios_base::fixed, <br>                std::ios_base::floatfield);<br>&#125; <br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">restore</span><span class="hljs-params">(format f, precis p)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout.<span class="hljs-built_in">setf</span>(f, std::ios_base::floatfield);<br>    cout.<span class="hljs-built_in">precision</span>(p);<br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><p>代码除了注意在定义同名函数的时候<strong>使用作用域运算符以防混淆</strong>，其他都和类的继承的语法知识点没有太多的联系，可自行跳过。</p></blockquote><h3 id="静态联编和动态联编"><a href="#静态联编和动态联编" class="headerlink" title="静态联编和动态联编"></a>静态联编和动态联编</h3><p><strong>函数名联编：</strong>将源代码的函数调用解释为执行特定的函数代码块。</p><p>如果编译器在<strong>编译时</strong>完成了这种联编，那么被称为<strong>静态联编</strong>。但是，由于虚函数的存在，OOP的<strong>多态性</strong>让这种行为变得困难（虚函数保证了调用的函数和对象的实际类型相匹配，而基类指针即可以指向派生类也可以指向基类，这就让编译器很难确定调用哪一个函数）。因此，编译器生成一种<strong>在程序运行时选择正确的虚方法的代码</strong>，这种方法被称为<strong>动态联编</strong>。</p><blockquote><p>和<strong>动态内存分配</strong>有着异曲同工之妙！如果需要再程序运行时确定数组的大小N，则需要使用动态内存分配的方法在程序运行时动态地在<strong>堆</strong>上分配相匹配的内存容量。</p></blockquote><h4 id="指针和引用类型的兼容性"><a href="#指针和引用类型的兼容性" class="headerlink" title="指针和引用类型的兼容性"></a>指针和引用类型的兼容性</h4><p>（这一块有点复杂并且无聊，笔者直接给出结论）</p><ul><li><strong>向上强制转换</strong>：将派生类应用或指针转换为基类引用或指针<ul><li>不需要进行显式类型转换（is-a关系可以看做一种子集关系）</li><li>具有可传递性和兼容性</li></ul></li><li><strong>向下强制转换</strong>：将基类应用或指针转换为派生类引用或指针<ul><li>必须使用显式类型转换</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-comment">// 基类的虚函数</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;Base class display&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Base</span>() &#123;&#125;  <span class="hljs-comment">// 虚析构函数，确保派生类对象能够被正确销毁</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;  <span class="hljs-comment">// 派生类重写 display 函数</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;Derived class display&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-comment">// 派生类的特有函数</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;Derived class show&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 向上转换</span><br>    Derived derivedObj;<br>    Base* basePtr = &amp;derivedObj;  <span class="hljs-comment">// Derived* -&gt; Base* 向上转换</span><br><br>    <span class="hljs-comment">// 使用 basePtr 调用 display()，实际调用的是 Derived 的 display()</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;Using basePtr (upcasting):&quot;</span> &lt;&lt; endl;<br>    basePtr-&gt;<span class="hljs-built_in">display</span>();  <span class="hljs-comment">// 输出: Derived class display</span><br><br>    <span class="hljs-comment">// 向下转换</span><br>    Derived* derivedPtr = <span class="hljs-built_in">dynamic_cast</span>&lt;Derived*&gt;(basePtr);  <span class="hljs-comment">// Base* -&gt; Derived* 向下转换</span><br>    <span class="hljs-keyword">if</span> (derivedPtr) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Using derivedPtr (downcasting):&quot;</span> &lt;&lt; endl;<br>        derivedPtr-&gt;<span class="hljs-built_in">show</span>();  <span class="hljs-comment">// 输出: Derived class show</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Downcasting failed&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-comment">// 向下转换失败的例子</span><br>    Base* anotherBasePtr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Base</span>();  <span class="hljs-comment">// 创建一个纯 Base 类型的对象</span><br>    Derived* failedCastPtr = <span class="hljs-built_in">dynamic_cast</span>&lt;Derived*&gt;(anotherBasePtr);  <span class="hljs-comment">// Base* -&gt; Derived* 向下转换（尝试转换但是转换失败）</span><br>    <span class="hljs-keyword">if</span> (failedCastPtr) &#123;<br>        failedCastPtr-&gt;<span class="hljs-built_in">show</span>();  <span class="hljs-comment">// 不会执行到这里</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Failed downcasting Base* to Derived*&quot;</span> &lt;&lt; endl;  <span class="hljs-comment">// 输出: Failed downcasting Base* to Derived*</span><br>    &#125;<br><br>    <span class="hljs-keyword">delete</span> anotherBasePtr;  <span class="hljs-comment">// 释放内存</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="虚函数成员和动态联编"><a href="#虚函数成员和动态联编" class="headerlink" title="虚函数成员和动态联编"></a>虚函数成员和动态联编</h4><blockquote><p>在原书中，此节介绍了三部分知识：</p><ul><li>为什么有两种类型的联编</li><li>动态联编为何不设置为默认的联编方式</li><li>动态联编的工作原理<ul><li>虚函数表</li></ul></li></ul></blockquote><p>在本文中，我们暂且跳过这一部分，把重点放在虚函数使用的相关注意事项：</p><div class="note note-info">            <ul><li><p>在基类方法的声明中使用关键字 <code>virtual</code> 可使该方法在基类以及所有的派生类（包括从派生类派生出来的类）中是虚的。</p></li><li><p>如果使用指向对象的引用或指针来调用虚方法，程序将使用为对象类型定义的方法，而不使用为引用或指针类型定义的方法。这称为动态联编或晚期联编。这种行为非常重要，因为这样<strong>基类指针或引用可以指向派生类对象</strong>。</p></li><li><p>如果定义的类将被用作基类，则应将那些要在派生类中重新定义的类方法声明为虚的。</p></li><li><p>构造函数不能是虚函数。</p><ul><li>创建派生类对象时会调用基类的构造函数，所以没啥意义。（反正肯定会被调用）</li></ul></li><li><p><strong>析构函数应当是虚函数。</strong></p><ul><li>如果派生类新定义了动态内存分配，那么在调用时如果基类的析构函数不是虚函数，那么如果一个基类指针指向了派生类对象，在调用析构函数的时候会<strong>调用基类的析构函数</strong>，这在派生类中新定义的成员不会被<code>delete</code>掉，产生内存泄漏。</li></ul></li><li><p>友元不能是虚函数（友元不是类成员）</p></li><li><p>重新定义的问题</p><ul><li><p>如果派生类没有重新定义函数，就直接使用基类的版本。</p></li><li><p>如果派生类位于派生链中（一串派生类），那么使用<strong>最新的虚函数版本</strong>。</p></li><li><p><strong>重新定义基类的方法不是重载。</strong>如果在派生类中重新定义函数，将不是使用相同的函数特征标覆盖基类声明，而是隐藏同名的基类方法，不管参数特征标如何。</p><ul><li><p>如果重新定义继承的方法，应确保与原来的原型完全相同，但如果返回类型是基类引用或指针，则可以修改为指向派生类的引用或指针（这种例外是新出现的）。这种特性被称为返回类型协变（covariance of return type），因为允许返回类型随类类型的变化而变化。</p></li><li><p>如果基类声明被重载，应该在派生类中重新定义所有的基类版本。</p></li></ul></li></ul></li></ul>          </div><p><img src="https://ooo.0x0.ooo/2025/01/11/OEfRai.png" alt="Covirance of Return Type"></p><p><img src="https://ooo.0x0.ooo/2025/01/11/OEftNX.png" alt="基类声明被重载"></p><h2 id="Protected"><a href="#Protected" class="headerlink" title="Protected"></a>Protected</h2><p>我们使用<code>public</code>和<code>private</code>来实现对类成员访问权限的控制。同时，我们存在<code>protected</code>关键词。</p><ul><li>与<code>private</code>相比，<code>protected</code>可以被派生类成员直接访问。</li><li>与<code>public</code>相比，<code>protected</code><strong>只能</strong>被派生类成员直接访问，而不能在外部直接访问。</li></ul><blockquote><p>通过protected的实现，基类终于给派生类赋予了一些在访问上的<strong>特权</strong>！</p></blockquote><h2 id="Abstract-Base-Class"><a href="#Abstract-Base-Class" class="headerlink" title="Abstract Base Class"></a>Abstract Base Class</h2><p>在is-a关系中，我们希望<strong>派生类 is a kind of 基类</strong>，因为这样派生类使用基类的成员方法才有意义。但是有些时候使用基类的方法会成为累赘。</p><blockquote><p>例如圆是一种特殊的椭圆。在基类椭圆类中，我们可能会定义椭圆的一些参数和方法，比如长轴短轴离心率，在继承给圆的时候，当然可以把<strong>圆看做一种特殊的椭圆</strong>。但是实际上如果从零开始设计圆类，我们可能只需要圆心和半径即可，这样基类的方法反而是一种使问题变的更加复杂的累赘。</p></blockquote><p>因此，我们可以<strong>从圆和椭圆中提取出抽象的共性，放在一个抽象基类（ABC）中，比如计算面积等方法</strong>，实现代码的重用。如果抽象基类没有包含必要的数据成员来实现有共性的函数，C++使用<strong>纯虚函数（pure virtual function）</strong>提供未实现的函数。</p><blockquote><p>ABC是一种很高深的思想，万事万物的本质原理是什么？亚里士多德提出了<strong>第一性原理</strong>的阐释。在C++中，抽象基类便像第一性原理，后续的派生类都建立在抽象基类的基础之上。真可谓一生二，二生三，三生万物。这便是ABC的哲学！</p></blockquote><p>我们来看代码的示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// acctabc.h  -- bank account classes</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> ACCTABC_H_</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ACCTABC_H_</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-comment">// Abstract Base Class</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AcctABC</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>    std::string fullName;<br>    <span class="hljs-type">long</span> acctNum;<br>    <span class="hljs-type">double</span> balance;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Formatting</span> <br>    &#123;<br>        std::ios_base::fmtflags flag;<br>        std::streamsize pr;<br>        <span class="hljs-comment">//用来设置和恢复格式</span><br>    &#125;;<br>    <span class="hljs-function"><span class="hljs-type">const</span> std::string &amp; <span class="hljs-title">FullName</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<span class="hljs-keyword">return</span> fullName;&#125;<br>    <span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-title">AcctNum</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<span class="hljs-keyword">return</span> acctNum;&#125;<br>    <span class="hljs-function">Formatting <span class="hljs-title">SetFormat</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Restore</span><span class="hljs-params">(Formatting &amp; f)</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-keyword">public</span>: <br>    <span class="hljs-built_in">AcctABC</span>(<span class="hljs-type">const</span> std::string &amp; s = <span class="hljs-string">&quot;Nullbody&quot;</span>, <span class="hljs-type">long</span> an = <span class="hljs-number">-1</span>,<br>                <span class="hljs-type">double</span> bal = <span class="hljs-number">0.0</span>);<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Deposit</span><span class="hljs-params">(<span class="hljs-type">double</span> amt)</span> </span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Withdraw</span><span class="hljs-params">(<span class="hljs-type">double</span> amt)</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">// pure virtual function</span><br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">Balance</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<span class="hljs-keyword">return</span> balance;&#125;;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">ViewAcct</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;     <span class="hljs-comment">// pure virtual function</span><br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">AcctABC</span>() &#123;&#125;<br>    <span class="hljs-comment">//提供纯虚函数接口</span><br>&#125;;<br><br><span class="hljs-comment">// Brass Account Class</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Brass</span> :<span class="hljs-keyword">public</span> AcctABC<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Brass</span>(<span class="hljs-type">const</span> std::string &amp; s = <span class="hljs-string">&quot;Nullbody&quot;</span>, <span class="hljs-type">long</span> an = <span class="hljs-number">-1</span>,<br>           <span class="hljs-type">double</span> bal = <span class="hljs-number">0.0</span>) : <span class="hljs-built_in">AcctABC</span>(s, an, bal) &#123; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Withdraw</span><span class="hljs-params">(<span class="hljs-type">double</span> amt)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">ViewAcct</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Brass</span>() &#123;&#125;<br>&#125;;<br><br><span class="hljs-comment">//Brass Plus Account Class</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BrassPlus</span> : <span class="hljs-keyword">public</span> AcctABC<br>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">double</span> maxLoan;<br>    <span class="hljs-type">double</span> rate;<br>    <span class="hljs-type">double</span> owesBank;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">BrassPlus</span>(<span class="hljs-type">const</span> std::string &amp; s = <span class="hljs-string">&quot;Nullbody&quot;</span>, <span class="hljs-type">long</span> an = <span class="hljs-number">-1</span>,<br>            <span class="hljs-type">double</span> bal = <span class="hljs-number">0.0</span>, <span class="hljs-type">double</span> ml = <span class="hljs-number">500</span>,<br>            <span class="hljs-type">double</span> r = <span class="hljs-number">0.10</span>);<br>    <span class="hljs-built_in">BrassPlus</span>(<span class="hljs-type">const</span> Brass &amp; ba, <span class="hljs-type">double</span> ml = <span class="hljs-number">500</span>, <span class="hljs-type">double</span> r = <span class="hljs-number">0.1</span>);<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">ViewAcct</span><span class="hljs-params">()</span><span class="hljs-type">const</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Withdraw</span><span class="hljs-params">(<span class="hljs-type">double</span> amt)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ResetMax</span><span class="hljs-params">(<span class="hljs-type">double</span> m)</span> </span>&#123; maxLoan = m; &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ResetRate</span><span class="hljs-params">(<span class="hljs-type">double</span> r)</span> </span>&#123; rate = r; &#125;;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ResetOwes</span><span class="hljs-params">()</span> </span>&#123; owesBank = <span class="hljs-number">0</span>; &#125;<br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br></code></pre></td></tr></table></figure><p>以下是一些对代码和抽象基类的解读：</p><ul><li>纯虚函数在声明时需要再尾部加上”0”。</li><li>ABC的主要作用是为<strong>派生类提供一些共性的纯虚函数接口</strong>。</li></ul><p>我们来看一看函数定义中纯虚函数是怎么定义的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// acctabc.cpp -- bank account class methods</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;acctabc.h&quot;</span></span><br><span class="hljs-keyword">using</span> std::cout;<br><span class="hljs-keyword">using</span> std::ios_base;<br><span class="hljs-keyword">using</span> std::endl;<br><span class="hljs-keyword">using</span> std::string;<br><br><span class="hljs-comment">// Abstract Base Class</span><br>AcctABC::<span class="hljs-built_in">AcctABC</span>(<span class="hljs-type">const</span> string &amp; s, <span class="hljs-type">long</span> an, <span class="hljs-type">double</span> bal)<br>&#123;<br>    fullName = s;<br>    acctNum = an;<br>    balance = bal;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AcctABC::Deposit</span><span class="hljs-params">(<span class="hljs-type">double</span> amt)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (amt &lt; <span class="hljs-number">0</span>)<br>        cout &lt;&lt; <span class="hljs-string">&quot;Negative deposit not allowed; &quot;</span>&lt;&lt; <span class="hljs-string">&quot;deposit is cancelled.\n&quot;</span>;<br>    <span class="hljs-keyword">else</span><br>        balance += amt;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AcctABC::Withdraw</span><span class="hljs-params">(<span class="hljs-type">double</span> amt)</span></span><br><span class="hljs-function"></span>&#123;<br>    balance -= amt;<br>&#125;<br><br><span class="hljs-comment">// protected methods for formatting</span><br><span class="hljs-function">AcctABC::Formatting <span class="hljs-title">AcctABC::SetFormat</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-comment">// set up ###.## format</span><br>    Formatting f;<br>    f.flag = <br>        cout.<span class="hljs-built_in">setf</span>(ios_base::fixed, ios_base::floatfield);<br>    f.pr = cout.<span class="hljs-built_in">precision</span>(<span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">return</span> f; <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AcctABC::Restore</span><span class="hljs-params">(Formatting &amp; f)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>    cout.<span class="hljs-built_in">setf</span>(f.flag, ios_base::floatfield);<br>    cout.<span class="hljs-built_in">precision</span>(f.pr);<br>&#125;<br><br><span class="hljs-comment">// Brass methods</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Brass::Withdraw</span><span class="hljs-params">(<span class="hljs-type">double</span> amt)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (amt &lt; <span class="hljs-number">0</span>)<br>        cout &lt;&lt; <span class="hljs-string">&quot;Withdrawal amount must be positive; &quot;</span><br>             &lt;&lt; <span class="hljs-string">&quot;withdrawal canceled.\n&quot;</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (amt &lt;= <span class="hljs-built_in">Balance</span>())<br>        AcctABC::<span class="hljs-built_in">Withdraw</span>(amt);<br>    <span class="hljs-keyword">else</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;Withdrawal amount of $&quot;</span> &lt;&lt; amt<br>             &lt;&lt; <span class="hljs-string">&quot; exceeds your balance.\n&quot;</span><br>             &lt;&lt; <span class="hljs-string">&quot;Withdrawal canceled.\n&quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Brass::ViewAcct</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>   <br>    Formatting f = <span class="hljs-built_in">SetFormat</span>();<br>    cout &lt;&lt; <span class="hljs-string">&quot;Brass Client: &quot;</span> &lt;&lt; <span class="hljs-built_in">FullName</span>() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Account Number: &quot;</span> &lt;&lt; <span class="hljs-built_in">AcctNum</span>() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Balance: $&quot;</span> &lt;&lt; <span class="hljs-built_in">Balance</span>() &lt;&lt; endl;<br>    <span class="hljs-built_in">Restore</span>(f);<br>&#125;<br><br><span class="hljs-comment">// BrassPlus Methods</span><br>BrassPlus::<span class="hljs-built_in">BrassPlus</span>(<span class="hljs-type">const</span> string &amp; s, <span class="hljs-type">long</span> an, <span class="hljs-type">double</span> bal,<br>           <span class="hljs-type">double</span> ml, <span class="hljs-type">double</span> r) : <span class="hljs-built_in">AcctABC</span>(s, an, bal)<br>&#123;<br>    maxLoan = ml;<br>    owesBank = <span class="hljs-number">0.0</span>;<br>    rate = r; <br>&#125;<br><br>BrassPlus::<span class="hljs-built_in">BrassPlus</span>(<span class="hljs-type">const</span> Brass &amp; ba, <span class="hljs-type">double</span> ml, <span class="hljs-type">double</span> r)<br>           : <span class="hljs-built_in">AcctABC</span>(ba)   <span class="hljs-comment">// uses implicit copy constructor</span><br>&#123;<br>    maxLoan = ml;<br>    owesBank = <span class="hljs-number">0.0</span>;<br>    rate = r;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BrassPlus::ViewAcct</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>    Formatting f = <span class="hljs-built_in">SetFormat</span>();<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;BrassPlus Client: &quot;</span> &lt;&lt; <span class="hljs-built_in">FullName</span>() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Account Number: &quot;</span> &lt;&lt; <span class="hljs-built_in">AcctNum</span>() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Balance: $&quot;</span> &lt;&lt; <span class="hljs-built_in">Balance</span>() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Maximum loan: $&quot;</span> &lt;&lt; maxLoan &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Owed to bank: $&quot;</span> &lt;&lt; owesBank &lt;&lt; endl;<br>    cout.<span class="hljs-built_in">precision</span>(<span class="hljs-number">3</span>);<br>    cout &lt;&lt; <span class="hljs-string">&quot;Loan Rate: &quot;</span> &lt;&lt; <span class="hljs-number">100</span> * rate &lt;&lt; <span class="hljs-string">&quot;%\n&quot;</span>;<br>    <span class="hljs-built_in">Restore</span>(f);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BrassPlus::Withdraw</span><span class="hljs-params">(<span class="hljs-type">double</span> amt)</span></span><br><span class="hljs-function"></span>&#123;<br>    Formatting f = <span class="hljs-built_in">SetFormat</span>();<br><br>    <span class="hljs-type">double</span> bal = <span class="hljs-built_in">Balance</span>();<br>    <span class="hljs-keyword">if</span> (amt &lt;= bal)<br>        AcctABC::<span class="hljs-built_in">Withdraw</span>(amt);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( amt &lt;= bal + maxLoan - owesBank)<br>    &#123;<br>        <span class="hljs-type">double</span> advance = amt - bal;<br>        owesBank += advance * (<span class="hljs-number">1.0</span> + rate);<br>        cout &lt;&lt; <span class="hljs-string">&quot;Bank advance: $&quot;</span> &lt;&lt; advance &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Finance charge: $&quot;</span> &lt;&lt; advance * rate &lt;&lt; endl;<br>        <span class="hljs-built_in">Deposit</span>(advance);<br>        AcctABC::<span class="hljs-built_in">Withdraw</span>(amt);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;Credit limit exceeded. Transaction cancelled.\n&quot;</span>;<br>    <span class="hljs-built_in">Restore</span>(f); <br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="继承和动态内存分配"><a href="#继承和动态内存分配" class="headerlink" title="继承和动态内存分配"></a>继承和动态内存分配</h2><p>在阅读这一部分之前，建议读者先阅读<a href="https://xiyuanyang-code.github.io/posts/Dynamic-Memory-and-Classes/">第十二章</a>了解有关C++中的复制构造函数，析构函数，赋值运算符等等相关知识。本部分将继续围绕在类的继承背景下，如何实现动态内存分配。</p><h3 id="派生类不使用new"><a href="#派生类不使用new" class="headerlink" title="派生类不使用new"></a>派生类不使用<code>new</code></h3><p>先来看这样一个使用动态内存分配的基类：</p><p><img src="https://ooo.0x0.ooo/2025/01/11/OEfJdL.png" alt="baseDMA"></p><p>这个基类动态分配内存给一个指向字符的指针（<strong>涉及到了按址传递，故使用默认的复制构造函数会存在风险</strong>），同时也手动定义了显式的赋值运算符，复制构造函数和析构函数。那么，如果以此为基类的派生类没有使用动态内存分配，便<strong>不需要再为派生类显式地定义显式析构函数，复制构造函数和重载赋值运算符。</strong></p><blockquote><p>为什么？你当然可以显式定义，但没有任何的必要。因为默认的赋值运算符和复制构造函数都是在使用动态内存时会产生冲突，基类的动态内存已经手动显示定义，故不存在隐患。</p><p>在复制类所继承的类组件时，会优先使用被继承类的显式构造函数。（对赋值同样也是如此）</p></blockquote><h3 id="派生类使用new"><a href="#派生类使用new" class="headerlink" title="派生类使用new"></a>派生类使用<code>new</code></h3><p>这便是更加复杂的情况，我们来看一个使用动态内存的派生类：</p><p><img src="https://ooo.0x0.ooo/2025/01/11/OEfJdL.png" alt="Derived Class with DMA.png"></p><div class="note note-danger">            <p><strong>在这种情况下，必须为派生类定义显式析构函数、复制构造函数和赋值运算符 。</strong>因为派生类添加了新的数据成员使用动态内存分配，而基类的方法中并不包含这个成员的操作。因此需要额外定义来防止内存泄漏等严重问题。</p>          </div><h3 id="使用友元"><a href="#使用友元" class="headerlink" title="使用友元"></a>使用友元</h3><p>来看下面的综合代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// dma.h  -- inheritance and dynamic memory allocation</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> DMA_H_</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DMA_H_</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-comment">//  Base Class Using DMA</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">baseDMA</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">char</span> * label;<br>    <span class="hljs-type">int</span> rating;<br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">baseDMA</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> * l = <span class="hljs-string">&quot;null&quot;</span>, <span class="hljs-type">int</span> r = <span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">baseDMA</span>(<span class="hljs-type">const</span> baseDMA &amp; rs);<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">baseDMA</span>();<br>    <span class="hljs-comment">//使用虚函数</span><br>    baseDMA &amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> baseDMA &amp; rs);<br>    <span class="hljs-keyword">friend</span> std::ostream &amp; <span class="hljs-keyword">operator</span>&lt;&lt;(std::ostream &amp; os, <br>                                     <span class="hljs-type">const</span> baseDMA &amp; rs);<br>    <span class="hljs-comment">//友元函数（流输出运算符）</span><br>&#125;;<br><br><span class="hljs-comment">// derived class without DMA</span><br><span class="hljs-comment">// no destructor needed</span><br><span class="hljs-comment">// uses implicit copy constructor</span><br><span class="hljs-comment">// uses implicit assignment operator</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">lacksDMA</span> :<span class="hljs-keyword">public</span> baseDMA<br>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">enum</span> &#123; COL_LEN = <span class="hljs-number">40</span>&#125;;<br>    <span class="hljs-type">char</span> color[COL_LEN];<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">lacksDMA</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> * c = <span class="hljs-string">&quot;blank&quot;</span>, <span class="hljs-type">const</span> <span class="hljs-type">char</span> * l = <span class="hljs-string">&quot;null&quot;</span>,<br>              <span class="hljs-type">int</span> r = <span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">lacksDMA</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> * c, <span class="hljs-type">const</span> baseDMA &amp; rs);<br>    <span class="hljs-keyword">friend</span> std::ostream &amp; <span class="hljs-keyword">operator</span>&lt;&lt;(std::ostream &amp; os, <br>                                     <span class="hljs-type">const</span> lacksDMA &amp; rs);<br>&#125;;<br><br><span class="hljs-comment">// derived class with DMA</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">hasDMA</span> :<span class="hljs-keyword">public</span> baseDMA<br>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">char</span> * style;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">hasDMA</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> * s = <span class="hljs-string">&quot;none&quot;</span>, <span class="hljs-type">const</span> <span class="hljs-type">char</span> * l = <span class="hljs-string">&quot;null&quot;</span>,<br>              <span class="hljs-type">int</span> r = <span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">hasDMA</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> * s, <span class="hljs-type">const</span> baseDMA &amp; rs);<br>    <span class="hljs-built_in">hasDMA</span>(<span class="hljs-type">const</span> hasDMA &amp; hs);<br>    ~<span class="hljs-built_in">hasDMA</span>();<br>    hasDMA &amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> hasDMA &amp; rs);  <br>    <span class="hljs-keyword">friend</span> std::ostream &amp; <span class="hljs-keyword">operator</span>&lt;&lt;(std::ostream &amp; os, <br>                                     <span class="hljs-type">const</span> hasDMA &amp; rs);<br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// dma.cpp --dma class methods</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;dma.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-comment">// baseDMA methods</span><br>baseDMA::<span class="hljs-built_in">baseDMA</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> * l, <span class="hljs-type">int</span> r)<br>&#123;<br>    label = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[std::<span class="hljs-built_in">strlen</span>(l) + <span class="hljs-number">1</span>];<br>    std::<span class="hljs-built_in">strcpy</span>(label, l);<br>    rating = r;<br>&#125;<br><br>baseDMA::<span class="hljs-built_in">baseDMA</span>(<span class="hljs-type">const</span> baseDMA &amp; rs)<br>&#123;<br>    label = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[std::<span class="hljs-built_in">strlen</span>(rs.label) + <span class="hljs-number">1</span>];<br>    std::<span class="hljs-built_in">strcpy</span>(label, rs.label);<br>    rating = rs.rating;<br>&#125;<br><br>baseDMA::~<span class="hljs-built_in">baseDMA</span>()<br>&#123;<br>    <span class="hljs-keyword">delete</span> [] label;<br>&#125;<br><br>baseDMA &amp; baseDMA::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> baseDMA &amp; rs)<br>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;rs)<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    <span class="hljs-keyword">delete</span> [] label;<br>    label = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[std::<span class="hljs-built_in">strlen</span>(rs.label) + <span class="hljs-number">1</span>];<br>    std::<span class="hljs-built_in">strcpy</span>(label, rs.label);<br>    rating = rs.rating;<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br>    <br>std::ostream &amp; <span class="hljs-keyword">operator</span>&lt;&lt;(std::ostream &amp; os, <span class="hljs-type">const</span> baseDMA &amp; rs)<br>&#123;<br>    os &lt;&lt; <span class="hljs-string">&quot;Label: &quot;</span> &lt;&lt; rs.label &lt;&lt; std::endl;<br>    os &lt;&lt; <span class="hljs-string">&quot;Rating: &quot;</span> &lt;&lt; rs.rating &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> os;<br>&#125;<br><br><span class="hljs-comment">// lacksDMA methods</span><br>lacksDMA::<span class="hljs-built_in">lacksDMA</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> * c, <span class="hljs-type">const</span> <span class="hljs-type">char</span> * l, <span class="hljs-type">int</span> r)<br>    : <span class="hljs-built_in">baseDMA</span>(l, r)<br>&#123;<br>    std::<span class="hljs-built_in">strncpy</span>(color, c, <span class="hljs-number">39</span>);<br>    color[<span class="hljs-number">39</span>] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>&#125;<br><br>lacksDMA::<span class="hljs-built_in">lacksDMA</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> * c, <span class="hljs-type">const</span> baseDMA &amp; rs)<br>    : <span class="hljs-built_in">baseDMA</span>(rs)<br>&#123;<br>    std::<span class="hljs-built_in">strncpy</span>(color, c, COL_LEN - <span class="hljs-number">1</span>);<br>    color[COL_LEN - <span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>&#125;<br><br>std::ostream &amp; <span class="hljs-keyword">operator</span>&lt;&lt;(std::ostream &amp; os, <span class="hljs-type">const</span> lacksDMA &amp; ls)<br>&#123;<br>    os &lt;&lt; (<span class="hljs-type">const</span> baseDMA &amp;) ls;<br>    os &lt;&lt; <span class="hljs-string">&quot;Color: &quot;</span> &lt;&lt; ls.color &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> os;<br>&#125;<br><br><span class="hljs-comment">// hasDMA methods</span><br>hasDMA::<span class="hljs-built_in">hasDMA</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> * s, <span class="hljs-type">const</span> <span class="hljs-type">char</span> * l, <span class="hljs-type">int</span> r)<br>         : <span class="hljs-built_in">baseDMA</span>(l, r)<br>&#123;<br>    style = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[std::<span class="hljs-built_in">strlen</span>(s) + <span class="hljs-number">1</span>];<br>    std::<span class="hljs-built_in">strcpy</span>(style, s);<br>&#125;<br><br>hasDMA::<span class="hljs-built_in">hasDMA</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> * s, <span class="hljs-type">const</span> baseDMA &amp; rs)<br>         : <span class="hljs-built_in">baseDMA</span>(rs)<br>&#123;<br>    style = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[std::<span class="hljs-built_in">strlen</span>(s) + <span class="hljs-number">1</span>];<br>    std::<span class="hljs-built_in">strcpy</span>(style, s);<br>&#125;<br><br>hasDMA::<span class="hljs-built_in">hasDMA</span>(<span class="hljs-type">const</span> hasDMA &amp; hs)<br>         : <span class="hljs-built_in">baseDMA</span>(hs)  <span class="hljs-comment">// invoke base class copy constructor</span><br>&#123;<br>    style = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[std::<span class="hljs-built_in">strlen</span>(hs.style) + <span class="hljs-number">1</span>];<br>    std::<span class="hljs-built_in">strcpy</span>(style, hs.style);<br>&#125;<br><br>hasDMA::~<span class="hljs-built_in">hasDMA</span>()<br>&#123;<br>    <span class="hljs-keyword">delete</span> [] style;<br>&#125;<br><br>hasDMA &amp; hasDMA::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> hasDMA &amp; hs)<br>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;hs)<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    baseDMA::<span class="hljs-keyword">operator</span>=(hs);  <span class="hljs-comment">// copy base portion，赋值基类的数据成员</span><br>    <span class="hljs-comment">//这个语句等价于 *this = hs;</span><br>    <span class="hljs-keyword">delete</span> [] style;         <span class="hljs-comment">// prepare for new style</span><br>    style = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[std::<span class="hljs-built_in">strlen</span>(hs.style) + <span class="hljs-number">1</span>];<br>    std::<span class="hljs-built_in">strcpy</span>(style, hs.style);<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br>    <br>std::ostream &amp; <span class="hljs-keyword">operator</span>&lt;&lt;(std::ostream &amp; os, <span class="hljs-type">const</span> hasDMA &amp; hs)<br>&#123;<br>    os &lt;&lt; (<span class="hljs-type">const</span> baseDMA &amp;) hs;<br>    <span class="hljs-comment">//使用强制类型转换，使得该行可以调用基类的友元函数</span><br>    os &lt;&lt; <span class="hljs-string">&quot;Style: &quot;</span> &lt;&lt; hs.style &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> os;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在 C++ 中，<strong>友元函数</strong>的行为与普通成员函数不同。友元函数是 <strong>根据它所声明的类</strong> 来确定是否有权限访问该类的私有和保护成员的，而与对象的动态类型无关。因此，友元函数并不遵循 <strong>多态性</strong> 规则。</p><p>例如有以下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span>;  <span class="hljs-comment">// 前置声明</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> baseValue;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Base</span>() : <span class="hljs-built_in">baseValue</span>(<span class="hljs-number">10</span>) &#123;&#125;<br><br>    <span class="hljs-comment">// 友元函数声明</span><br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">printBaseValue</span><span class="hljs-params">(Base&amp; b)</span></span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> derivedValue;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Derived</span>() : <span class="hljs-built_in">derivedValue</span>(<span class="hljs-number">20</span>) &#123;&#125;<br><br>    <span class="hljs-comment">// 友元函数声明，同名函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">printBaseValue</span><span class="hljs-params">(Derived&amp; d)</span></span>;<br>&#125;;<br><br><span class="hljs-comment">// 基类的友元函数定义</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printValue</span><span class="hljs-params">(Base&amp; b)</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Base Value: &quot;</span> &lt;&lt; b.baseValue &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">// 派生类的友元函数定义</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printValue</span><span class="hljs-params">(Derived&amp; d)</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Derived Value: &quot;</span> &lt;&lt; d.derivedValue &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Derived d;<br>    Base* basePtr = &amp;d;  <span class="hljs-comment">// 基类指针指向派生类对象</span><br>    <span class="hljs-comment">// 使用基类指针调用基类的友元函数</span><br>    <span class="hljs-built_in">printValue</span>(*basePtr);  <span class="hljs-comment">// 将会调用 Base 类的友元函数</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>输出结果：<code>Base Value: 10</code></p><p><code>basePtr</code>指针的类型是基类指针，但是指向了一个派生类对象。对于成员函数使用<strong>虚函数声明</strong>保证了调用的函数与实际指向的对象类型相符。（会调用派生类的函数）<strong>但友元函数虽然有访问私有数据成员的特权</strong>，但他不是成员函数，因此友元函数根据类的声明位置（即函数特征标的匹配程度）来决定调用的。在这里编译器判定<code>basePtr</code>指针的类型是基类指针，因此会调用**基类的<code>printValue()</code>**函数，哪怕它指向的是一个派生类对象。</p><p>这就是为什么派生类指针如果想使用基类的友元函数必须先<strong>强制类型转换成</strong>一个基类的指针（就像代码的第105~110行）。</p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p><strong>恭喜你！你已经掌握OOP的基本知识，可以进行一些实操锻炼了！</strong>笔者自己在阅读10,11,12,13四章时非常的痛苦，感觉非常的不适应，但是一路走来，在掌握了OOP的哲学和最基本的原则之后，一切纷繁复杂的语法原理似乎都有理可依。</p><p>接下来，我们将系统梳理这四章的一些内容，受篇幅限制，本部分主要以思维导图和关键词的形式呈现，详细内容大家可以看原书的13.8节。</p><p>OOP的基本精神：</p><ul><li><p>封装（保证操作的安全性和便利性）</p><ul><li><code>private</code><ul><li>储存私有的数据成员</li></ul></li><li><code>public</code><ul><li>一些方法（函数）<ul><li>构造函数<ul><li>默认构造函数</li><li>复制构造函数</li><li>显示定义的构造函数和复制构造函数（深拷贝）</li></ul></li><li>析构函数（显示定义）<ul><li>在12节重点介绍了这些函数和<strong>动态内存分配</strong></li></ul></li><li>运算符重载<ul><li>使用友元函数，this指针</li><li>显示定义赋值运算符</li></ul></li></ul></li><li>提供了访问私有数据成员的接口</li><li>友元函数的声明</li></ul></li><li><code>protected</code><ul><li>基类成员给予派生类成员的一些特权</li></ul></li></ul></li><li><p>继承与多态</p><ul><li>基类——派生类</li><li>公有继承的<strong>is-a</strong>关系</li><li>继承函数的体系就是这一章节的目录（不再归纳）</li></ul><p><img src="https://ooo.0x0.ooo/2025/01/11/OEf4Et.png" alt="Conclusion"></p></li></ul><p>当然，OOP的精神远不止于此！在接下来的第十四章，我们将更加深入的探寻<strong>C++中的其他继承关系和代码重用问题。</strong></p><div class="note note-info">            <p>无论如何，请你记住，面向对象编程是一种精神，而不是繁文缛节的语法。</p>          </div><blockquote><p>THE END                     ——2024&#x2F;12&#x2F;11</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Code</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tutorial</tag>
      
      <tag>Finished</tag>
      
      <tag>C/C++</tag>
      
      <tag>OOP</tag>
      
      <tag>C++ Primer Plus</tag>
      
      <tag>Inheritance</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linked-List-Implementation-Based-on-Structs</title>
    <link href="/posts/Linked-List-Implementation-Based-on-Structs/"/>
    <url>/posts/Linked-List-Implementation-Based-on-Structs/</url>
    
    <content type="html"><![CDATA[<style>  html, body, .markdown-body {    font-family: Georgia, sans, serif;  }</style><h1 id="Linked-List-Implementation-Based-on-Structs"><a href="#Linked-List-Implementation-Based-on-Structs" class="headerlink" title="Linked List Implementation Based on Structs"></a>Linked List Implementation Based on Structs</h1><p>封面插图截自 <a href="https://www.hello-algo.com/">Hello 算法</a></p><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><blockquote><p>这篇博客从0开始实现了如何<strong>使用结构体完成链表</strong>这一数据结构，并且实现了链表的插入，删除，遍历，查找等基本操作</p><p>This blog starts from scratch to demonstrate how to <strong>implement a linked list data structure using structs</strong>, covering the basic operations including insertion, deletion, traversal, and searching.</p></blockquote><h2 id="Concept"><a href="#Concept" class="headerlink" title="Concept"></a>Concept</h2><p>数组经常用于同类型数据的储存，但是数组规模必须在使用前确定（<strong>连续的顺序数据结构</strong>），这样会带来空间的浪费和诸多不利。但<strong>链表（Linked List）</strong>可以实现在增加元素的时候按需动态分配新的内存，实现了一种<strong>非连续存储</strong>。</p><p><img src="https://www.hello-algo.com/chapter_array_and_linkedlist/array.assets/array_definition.png" alt="数组定义与存储方式"></p><p><img src="https://www.hello-algo.com/chapter_array_and_linkedlist/linked_list.assets/linkedlist_definition.png" alt="链表定义与存储方式"></p><blockquote><p>以上两图节选自 <a href="https://www.hello-algo.com/chapter_array_and_linkedlist/array/">Hello 算法：数组和链表</a></p></blockquote><p>对于数据的存储，最常见的一项操作就是<strong>遍历数据类型中的所有（或者）部分元素</strong>，数组通过指针的<strong>自增操作</strong>实现遍历，但受限于非线性的存储方式，链表无法实现这一点。因此，为了能够达到和数组相同的遍历功能，链表中的每一个元素（或被称为<strong>节点</strong>），都需要一块内存来专门存储<strong>指向下一个元素的节点</strong>。</p><h2 id="Categories"><a href="#Categories" class="headerlink" title="Categories"></a>Categories</h2><ul><li><strong>单向链表</strong>：即前面介绍的普通链表。单向链表的节点包含值和指向下一节点的引用两项数据。我们将首个节点称为头节点，将最后一个节点称为<strong>尾节点</strong>，尾节点指向**空 <code>None</code>**（最后一个节点的节点指针指向空指针） 。</li><li><strong>环形链表</strong>：如果我们令单向链表的尾节点指向头节点（首尾相接），则得到一个环形链表。在环形链表中，任意节点都可以视作头节点。<ul><li>环形列表也可以分为双循环链表和单循环链表</li></ul></li><li><strong>双向链表</strong>：与单向链表相比，双向链表记录了两个方向的引用。<strong>双向链表的节点定义同时包含指向后继节点（下一个节点）和前驱节点（上一个节点）的引用（指针）</strong>。相较于单向链表，双向链表更具灵活性，可以朝两个方向遍历链表，但相应地也需要占用更多的内存空间。</li></ul><p><img src="https://www.hello-algo.com/chapter_array_and_linkedlist/linked_list.assets/linkedlist_common_types.png" alt="Categories"></p><p>图片来源：<a href="https://www.hello-algo.com/chapter_array_and_linkedlist/linked_list/#423">4.2  链表 - Hello 算法</a></p><h2 id="Definition-and-Implementaition"><a href="#Definition-and-Implementaition" class="headerlink" title="Definition and Implementaition"></a>Definition and Implementaition</h2><p>链表的每个节点由两个部分组成：<strong>数据元素本身和指向下一节点的指针。</strong>以下以单链表的相关操作为例：</p><h3 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">linkNode</span>&#123;<br>    datatype data;、<br>    <span class="hljs-comment">//datatype可以为任何一种数据类型，用来描述数据元素的本身的值</span><br>    linkNode* next;<br>&#125;;<br></code></pre></td></tr></table></figure><p>①<code>datatype</code>除了可以是一些<strong>基本数据类型</strong>，例如<code>int</code>，<code>double</code>等之外，也可以是<strong>自定义的非基本数据类型。</strong>例如，可以定义单链表的数据元素为另一个结构体类型的变量，则<code>datatype</code>需要相对应的改变。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node1</span>&#123;<br>    <span class="hljs-type">int</span> thenum;<br>    Node1 *next;<br>&#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node2</span>&#123;<br>    Node1 data;<br>    Node2 *next;<br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    Node1 *linklist1;<br>    <span class="hljs-comment">//定义了一个单链表</span><br>    Node2 *linklist2;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>②next是<strong>指向下一节点的指针</strong>，因此数据类型就是<strong>指向自身类型（自身结构体）</strong>，这种结构被称为<strong>自引用结构</strong>。</p><h3 id="Operations"><a href="#Operations" class="headerlink" title="Operations"></a>Operations</h3><p>对于基本数据结构，我们往往会关注一些基本的“<strong>操作</strong>”，例如插入，修改，删除，排序，访问（遍历）等等。这是数据结构走向算法的具体实现（一个从抽象到具象的过程），同时，由于每一种数据结构实现的底层原理有所不同，其具体的操作的方法和复杂度、优劣势等也各不相同。下文将介绍<strong>链表的创建，插入，访问，删除等基本操作通过结构体实现的底层原理</strong>，并给出一些具体的应用。</p><p>链表由于其自身<strong>非连续的物理结构特征</strong>，<strong>比数组占用更多的内存空间（用来存储下一个节点的地址），但是更加的灵活，扩展性强。</strong>如此结构使链表相比于数组具有更快的插入和删除元素的速度，但是牺牲了访问遍历元素的复杂度。</p><center>表 4-1  数组与链表的效率对比</center><table><thead><tr><th align="center"></th><th align="center">数组</th><th align="center">链表</th></tr></thead><tbody><tr><td align="center">存储方式</td><td align="center">连续内存空间</td><td align="center">分散内存空间</td></tr><tr><td align="center">容量扩展</td><td align="center">长度不可变</td><td align="center">可灵活扩展</td></tr><tr><td align="center">内存效率</td><td align="center">元素占用内存少</td><td align="center">元素占用内存多</td></tr><tr><td align="center">访问元素</td><td align="center">O(1)</td><td align="center">O(n)</td></tr><tr><td align="center">添加元素</td><td align="center">O(n)</td><td align="center">O(1)</td></tr><tr><td align="center">删除元素</td><td align="center">O(n)</td><td align="center">O(1)</td></tr></tbody></table><p>选自 <a href="https://www.hello-algo.com/chapter_array_and_linkedlist/linked_list/#422-vs">Hello算法：数组和链表的比较</a></p><p>接下来，我们一步一步实现自己的链表。</p><p>首先定义<strong>节点</strong>，这是每个链表的基本单元，包括<code>val</code>（储存当前节点的值）和<code>next</code>指向下一个节点地址的指针，在后文笔者习惯把它称为这个节点的<strong>引用</strong>。</p><p>注意到在结构体中增加了一行隐式构造函数，可以在新创建一个节点时设置默认参数（避免指针产生许多奇奇怪怪的问题）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ListNode</span> &#123;<br>    <span class="hljs-type">int</span> val;<br>    ListNode *next;<br>    <span class="hljs-built_in">ListNode</span>(<span class="hljs-type">int</span> value = <span class="hljs-number">0</span>, ListNode *next = <span class="hljs-literal">nullptr</span>) : <span class="hljs-built_in">val</span>(value), <span class="hljs-built_in">next</span>(next) &#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="单链表的创建"><a href="#单链表的创建" class="headerlink" title="单链表的创建"></a>单链表的创建</h4><p>如何初始化一个单链表？难道就是<strong>空空如也？</strong>显然不是，在之后的许多操作时，为了避免指针产生越界的情况，我们经常需要对链表进行<strong>置空检查</strong>（判断链表是否为空）。因此，我们需要再初始化一个新链表时，创建一个<strong>头结点</strong>，并对头节点的指向下一节点的指针初始化为<strong>空指针</strong>。</p><blockquote><p>以下对链表的若干操作都写成函数的形式，方便向OOP的过渡。</p><p>我既然都写析构函数和构造函数了，为什么不直接创建一个类呢（乐）</p></blockquote><p><strong>头结点非常的重要</strong>！！！它代表着链表这一条长蛇的开端，很多操作都是从头结点开始的。</p><p>在之后的操作中，<code>head-&gt;next==nullptr</code>就是对链表的置空检查（可以写成函数封装的形式），如果返回值为<code>true</code>，则代表链表为空，需要对头结点直接操作。</p><p><strong>头结点是链表中额外加入的一个特殊结点，它不存放数据，只是作为链表的开始标记，位于链表的最前面，它的指针部分指向表中的第一个元素，这样就保证了链表中每个结点前面都有一个结点 。</strong></p><blockquote><p>其实头结点也可以指向第一个实际数据，但是这样会导致在后续的链表操作中如果涉及对头结点（也就是首元素）的修改，会变得非常复杂，在这里笔者给出头结点不储存数据的链表实现。</p></blockquote><p>我们定义的第一个函数就是结构体的<strong>默认构造函数</strong>，只有在创建一个新链表的时候才会使用到，其功能是将头结点的引用设置为空指针。同样的，我们也可以设置<strong>析构函数</strong>，在链表结束其生命周期的时候自动调用，通过while循环自动<code>delete</code>所有节点（包括头结点）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">LinkedList</span> &#123;<br>    <span class="hljs-comment">// By default, construct a sentinel node that does not store any value, and its reference points to the first element of the list</span><br>    <span class="hljs-comment">// Initially, it points to nullptr</span><br>    ListNode* sentinel;<br>    <span class="hljs-type">int</span> size = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//size represents the number of nodes in the Linkedlist</span><br><br>    <span class="hljs-comment">// Constructor: Initialize the sentinel node, allocate memory on the heap for it</span><br>    <span class="hljs-built_in">LinkedList</span>(): <span class="hljs-built_in">sentinel</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>()), <span class="hljs-built_in">size</span>(<span class="hljs-number">0</span>) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Created successfully&quot;</span> &lt;&lt; endl;<br>    &#125;;<br><br>    <span class="hljs-comment">// Destructor: Iteratively delete all nodes (including the memory pointed to by the sentinel node initially)</span><br>    <span class="hljs-comment">// Once the sentinel points to a null pointer, the destruction process is complete</span><br>    ~<span class="hljs-built_in">LinkedList</span>() &#123;<br>        <span class="hljs-keyword">while</span> (sentinel != <span class="hljs-literal">nullptr</span>) &#123;<br>            ListNode* temp = sentinel;<br>            sentinel = sentinel-&gt;next;<br>            <span class="hljs-keyword">delete</span> temp;<br>        &#125;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Destroyed successfully&quot;</span> &lt;&lt; endl;<br>    &#125;<br></code></pre></td></tr></table></figure><h4 id="单链表的插入"><a href="#单链表的插入" class="headerlink" title="单链表的插入"></a>单链表的插入</h4><p>我们先来看一种比较原始的插入方式：</p><p><img src="/posts/Linked-List-Implementation-Based-on-Structs/Insert.png" alt="Insert"></p><p>由上图可知，如果要再节点p的后面插入一个新的节点temp，需要完成以下几件事：</p><ul><li>修改节点p中指向下一个节点的指针，使其指向新节点temp的地址</li><li>修改节点temp中指向下一个节点的指针，使其指向原来在p后面的节点的地址</li></ul><blockquote><p>看到了吗？链表的操作本质上就是对指针的操作！</p></blockquote><p>因此，我们可以给出插入新节点的第一个函数 <code>insertAfter</code>，实现在当前节点current后面插入新的节点，节点值是value。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insertAfter</span><span class="hljs-params">(ListNode* current, <span class="hljs-type">int</span> value)</span> </span>&#123;<br>        <span class="hljs-comment">// If the current node is null, return or throw an exception</span><br>        <span class="hljs-keyword">if</span> (current == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">invalid_argument</span>(<span class="hljs-string">&quot;Current node is null&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// Create a new node</span><br>        ListNode* newNode = <span class="hljs-keyword">new</span> ListNode&#123;value, current-&gt;next&#125;;<br>        <span class="hljs-comment">// Insert the new node after the current node</span><br>        current-&gt;next = newNode;<br>        size++;<br>    &#125;<br></code></pre></td></tr></table></figure><h5 id="Modify①插入到第一个节点"><a href="#Modify①插入到第一个节点" class="headerlink" title="Modify①插入到第一个节点"></a>Modify①插入到第一个节点</h5><p>这个问题非常好解决，相当于更换了链表的头结点，只需要更改插入节点的引用即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insertAtHead</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> </span>&#123;<br>        <span class="hljs-comment">// Set the reference of the new node to the reference of the sentinel node</span><br>        ListNode* newNode = <span class="hljs-keyword">new</span> ListNode&#123;value, sentinel-&gt;next&#125;;<br>        <span class="hljs-comment">// Change the reference of the sentinel node because the first element of the list has changed</span><br>        sentinel-&gt;next = newNode;<br>        size++;<br>    &#125;<br></code></pre></td></tr></table></figure><h5 id="Modify②如何更加的高效？（配合查找）"><a href="#Modify②如何更加的高效？（配合查找）" class="headerlink" title="Modify②如何更加的高效？（配合查找）"></a>Modify②如何更加的高效？（配合查找）</h5><p>如果我们现在需要插入一个新节点使新节点的索引为3，应该怎么办？那我们需要先遍历节点直到达到目标节点，然后再调用<code>insertAfter</code>函数进行目标的插入，当然，如果索引为0，直接<code>insertAtHead</code>即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insertAtPosition</span><span class="hljs-params">(<span class="hljs-type">int</span> value, <span class="hljs-type">int</span> position)</span> </span>&#123;<br>        <span class="hljs-comment">// If the position is 0 or the list is empty, insert at the head</span><br>        <span class="hljs-keyword">if</span> (position == <span class="hljs-number">0</span> || sentinel-&gt;next == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-built_in">insertAtHead</span>(value);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        ListNode* current = sentinel-&gt;next;<br>        <span class="hljs-type">int</span> currentPosition = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// Set a pointer to start the traversal</span><br><br>        <span class="hljs-comment">// Find the node before the insertion position</span><br>        <span class="hljs-keyword">while</span> (current-&gt;next != <span class="hljs-literal">nullptr</span> &amp;&amp; currentPosition &lt; position - <span class="hljs-number">1</span>) &#123;<br>            current = current-&gt;next;<br>            currentPosition++;<br>        &#125;<br><br>        <span class="hljs-comment">// If the position exceeds the end of the list, insert at the end</span><br>        <span class="hljs-keyword">if</span> (currentPosition &lt; position - <span class="hljs-number">1</span>) &#123;<br>            ListNode* newNode = <span class="hljs-keyword">new</span> ListNode&#123;value, <span class="hljs-literal">nullptr</span>&#125;;<br>            current-&gt;next = newNode;<br>            size++;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// Insert the new node</span><br>            <span class="hljs-comment">// current represents the node at index n-1, inserting after it achieves the desired index</span><br>            <span class="hljs-built_in">insertAfter</span>(current, value);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h5 id="Modify③直接在尾部插入"><a href="#Modify③直接在尾部插入" class="headerlink" title="Modify③直接在尾部插入"></a>Modify③直接在尾部插入</h5><p>这里提供了一种比较方便的插入函数，当然我们在定义结构体时也定义了size来维护结构体中的节点个数，因此也可以通过<code>insertAtPosition</code>来实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// Insert directly at the end</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insertAtEnd</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (sentinel-&gt;next == <span class="hljs-literal">nullptr</span>) &#123;<br>            ListNode* newNode = <span class="hljs-keyword">new</span> ListNode&#123;value, <span class="hljs-literal">nullptr</span>&#125;;<br>            sentinel-&gt;next = newNode;<br>            size++;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        ListNode* current = sentinel-&gt;next;<br>        <span class="hljs-keyword">while</span> (current-&gt;next != <span class="hljs-literal">nullptr</span>) &#123;<br>            current = current-&gt;next;<br>        &#125;<br>        <span class="hljs-comment">// Traverse to the last node</span><br>        <span class="hljs-comment">// Create a new node</span><br>        ListNode* newNode = <span class="hljs-keyword">new</span> ListNode&#123;value, <span class="hljs-literal">nullptr</span>&#125;;<br>        current-&gt;next = newNode;<br>        size++;<br>    &#125;<br></code></pre></td></tr></table></figure><p>因此，我们实现了链表的插入操作的函数，用于不同的功能：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//插入函数</span><br>    <span class="hljs-comment">// 在链表头部插入节点</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insertAtHead</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> </span>&#123;<br>        Node* newNode = <span class="hljs-keyword">new</span> Node&#123;value, head&#125;; <span class="hljs-comment">// 使用初始化列表来初始化新节点</span><br>        head = newNode;<br>    &#125;<br><br>    <span class="hljs-comment">// 在指定节点之后插入新节点</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insertAfter</span><span class="hljs-params">(Node* current, <span class="hljs-type">int</span> value)</span> </span>&#123;<br>        <span class="hljs-comment">// 如果当前节点为空，直接返回或抛出异常</span><br>        <span class="hljs-keyword">if</span> (current == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">invalid_argument</span>(<span class="hljs-string">&quot;Current node is null&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 创建新节点</span><br>        Node* newNode = <span class="hljs-keyword">new</span> Node&#123;value, current-&gt;next&#125;;<br>        <span class="hljs-comment">// 将新节点插入到当前节点之后</span><br>        current-&gt;next = newNode;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insertAtPosition</span><span class="hljs-params">(<span class="hljs-type">int</span> value, <span class="hljs-type">int</span> position)</span> </span>&#123;<br>        <span class="hljs-comment">// 如果位置是0或链表为空，则在头部插入</span><br>        <span class="hljs-keyword">if</span> (position == <span class="hljs-number">0</span> || head == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-built_in">insertAtHead</span>(value);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        Node* current = head;<br>        <span class="hljs-type">int</span> currentPosition = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//设置一个指针，开始执行遍历</span><br>    <br>    <br>        <span class="hljs-comment">// 找到插入位置的前一个节点</span><br>        <span class="hljs-keyword">while</span> (current-&gt;next != <span class="hljs-literal">nullptr</span> &amp;&amp; currentPosition &lt; position - <span class="hljs-number">1</span>) &#123;<br>            current = current-&gt;next;<br>            currentPosition++;<br>        &#125;<br><br>        <span class="hljs-comment">// 如果位置超出了链表的末尾，则在末尾插入</span><br>        <span class="hljs-keyword">if</span> (currentPosition &lt; position - <span class="hljs-number">1</span>) &#123;<br>            Node* newNode = <span class="hljs-keyword">new</span> Node&#123;value, <span class="hljs-literal">nullptr</span>&#125;;<br>            current-&gt;next = newNode;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 插入新节点</span><br>            <span class="hljs-comment">//current代表的是n-1索引上的节点，插入到他的后面就是需要达到的目标索引</span><br>            <span class="hljs-built_in">insertAfter</span>(current, value);<br>        &#125;<br>    &#125;<br>    <br></code></pre></td></tr></table></figure><h4 id="单链表的删除"><a href="#单链表的删除" class="headerlink" title="单链表的删除"></a>单链表的删除</h4><p><img src="/posts/Linked-List-Implementation-Based-on-Structs/erase.png" alt="erase"></p><p>原理和单链表的插入大同小异：</p><ul><li>将<code>delPtr</code>前面的一个节点p的引用更改，使其直接指向后面的一个节点即可</li><li>但是在删除时，要额外关注头和尾的特殊情况<ul><li>如果是第一个元素，则需要更改头结点的对应的值</li><li>如果是尾部元素，直接将上一个元素的应用设置为空指针即可</li></ul></li><li><strong>一定要注意delete！！！</strong></li></ul><p>我们先来看一下比较基础的功能实现：删除末尾的元素，思路如下：</p><ul><li>首先遍历数组走到最后一个元素<ul><li>由于链表非连续的物理结构的特点，其遍历的过程的复杂度会高于数组，达到了O（n）的时间复杂度。</li></ul></li><li>修改倒数第二个元素的引用为空指针</li><li><code>delete</code>掉最后一个元素的内存</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// Delete the last element of the list</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deletetheend</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (sentinel-&gt;next == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// Empty list</span><br><br>        ListNode* current = sentinel-&gt;next;<br>        ListNode* prev = sentinel;<br><br>        <span class="hljs-keyword">while</span> (current-&gt;next != <span class="hljs-literal">nullptr</span>) &#123;<br>            prev = current;<br>            current = current-&gt;next;<br>        &#125;<br>        <span class="hljs-comment">// At this point, current is the last element of the list</span><br>        prev-&gt;next = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">delete</span> current;<br>        size--;<br>    &#125;<br></code></pre></td></tr></table></figure><p>上面的代码已经实现了链表的遍历功能，因此稍微更改一下，便可以实现更多的删除功能。</p><blockquote><p>万变不离其宗，修改前一个的引用，删除后一个。要做的只有这两件事！</p></blockquote><h5 id="Modify①-根据值删除"><a href="#Modify①-根据值删除" class="headerlink" title="Modify① 根据值删除"></a>Modify① 根据值删除</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deleteNode</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (sentinel-&gt;next == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// Empty list</span><br><br>        ListNode* current = sentinel-&gt;next;<br>        ListNode* prev = sentinel;<br><br>        <span class="hljs-keyword">while</span> (current != <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">if</span> (current-&gt;val == key) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            prev = current;<br>            current = current-&gt;next;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (current == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// Node does not exist</span><br><br>        prev-&gt;next = current-&gt;next;<br>        <span class="hljs-keyword">delete</span> current;<br>        size--;<br>    &#125;<br></code></pre></td></tr></table></figure><h5 id="Modify②-根据索引删除"><a href="#Modify②-根据索引删除" class="headerlink" title="Modify② 根据索引删除"></a>Modify② 根据索引删除</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deletetheplace</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (sentinel-&gt;next == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// Empty list</span><br><br>        ListNode* current = sentinel-&gt;next;<br>        ListNode* prev = sentinel;<br>        <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span> (current != <span class="hljs-literal">nullptr</span> &amp;&amp; count &lt; index) &#123;<br>            prev = current;<br>            current = current-&gt;next;<br>            count++;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (count &lt; index) &#123;<br>            <span class="hljs-comment">// Index is too large, no corresponding index</span><br>            <span class="hljs-keyword">return</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// Then current is the node at the target index</span><br>            prev-&gt;next = current-&gt;next;<br>            <span class="hljs-keyword">delete</span> current;<br>            size--;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h4 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h4><p><strong>遍历，插入和删除是链表基本操作中最基本的三个操作，现在我们可以轻而易举地实现其他对链表的操作了。</strong></p><h5 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h5><p>返回特定索引值的val值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">at</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> </span>&#123;<br>        ListNode* current = sentinel-&gt;next;<br>        <span class="hljs-comment">// At this point, current points to the address of the first element of the list</span><br>        <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (count &gt;= size) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">out_of_range</span>(<span class="hljs-string">&quot;Out of range&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">while</span> (count &lt; index) &#123;<br>                current = current-&gt;next;<br>                count++;<br>            &#125;<br>            <span class="hljs-comment">// At this point, current points to the element at the target index</span><br>            <span class="hljs-keyword">return</span> current-&gt;val;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h5 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h5><p>修改特定索引值的val值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> index,<span class="hljs-type">int</span> replacement)</span></span>&#123;<br>        ListNode* current = sentinel-&gt;next;<br>        <span class="hljs-comment">// At this point, current points to the address of the first element of the list</span><br>        <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (count &gt;= size) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">out_of_range</span>(<span class="hljs-string">&quot;Out of range&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">while</span> (count &lt; index) &#123;<br>                current = current-&gt;next;<br>                count++;<br>            &#125;<br>            <span class="hljs-comment">// At this point, current points to the element at the target index</span><br>            current-&gt;val=replacement;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><blockquote><p>以上两个功能的实现本质上都是先通过链表的遍历找到目标索引所对应的内存（current），然后再在已经找到的内存块上做操作。</p></blockquote><h5 id="按值查找"><a href="#按值查找" class="headerlink" title="按值查找"></a>按值查找</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>        ListNode* current = sentinel-&gt;next;<br>        <span class="hljs-comment">// At this point, current points to the address of the first element of the list</span><br>        <span class="hljs-keyword">while</span> (current != <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">if</span> (current-&gt;val == target) &#123;<br>                <span class="hljs-keyword">return</span> count;<br>            &#125;<br>            count++;<br>            current = current-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><h5 id="打印列表（可视化）"><a href="#打印列表（可视化）" class="headerlink" title="打印列表（可视化）"></a>打印列表（可视化）</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printList</span><span class="hljs-params">()</span> </span>&#123;<br>        ListNode* current = sentinel-&gt;next;<br>        <span class="hljs-keyword">while</span> (current != <span class="hljs-literal">nullptr</span>) &#123;<br>            std::cout &lt;&lt; current-&gt;val &lt;&lt; <span class="hljs-string">&quot; -&gt; &quot;</span>;<br>            current = current-&gt;next;<br>        &#125;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;NULL&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br></code></pre></td></tr></table></figure><h5 id="置空检查"><a href="#置空检查" class="headerlink" title="置空检查"></a>置空检查</h5><p>判断链表是否有元素</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// Check if the list is empty</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isempty</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (sentinel-&gt;next == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="Outlook"><a href="#Outlook" class="headerlink" title="Outlook"></a>Outlook</h3><p>Congratulations！现在你已经实现了链表所有的基本操作，包括<strong>初始化，遍历，插入，删除，索引，修改，按值查找，打印等等</strong>。你可以使用自己写的链表去完成一些更加强大的功能！下面是一些展望和未来可以继续改进的方向：</p><ul><li>优化压缩代码，精简复杂度</li><li>将代码改写成OOP的形势，写成头文件</li><li>实现一些更加高级的功能<ul><li>链表的合并</li><li>链表的翻转</li><li>链表的计数</li><li>It’s up to you!</li></ul></li></ul><h2 id="All-codes"><a href="#All-codes" class="headerlink" title="All codes"></a>All codes</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @Author: Xiyuan Yang   xiyuan_yang@outlook.com</span><br><span class="hljs-comment"> * @Date: 2024-12-08 10:28:07</span><br><span class="hljs-comment"> * @LastEditors: Xiyuan Yang   xiyuan_yang@outlook.com</span><br><span class="hljs-comment"> * @LastEditTime: 2024-12-08 13:48:56</span><br><span class="hljs-comment"> * @FilePath: \CODE_for_Vscode\C++_project\Linked_list_copy.cpp</span><br><span class="hljs-comment"> * @Description: </span><br><span class="hljs-comment"> * Do you code and make progress today?</span><br><span class="hljs-comment"> * Copyright (c) 2024 by Xiyuan Yang, All Rights Reserved. </span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ListNode</span> &#123;<br>    <span class="hljs-type">int</span> val;<br>    ListNode *next;<br>    <span class="hljs-built_in">ListNode</span>(<span class="hljs-type">int</span> value = <span class="hljs-number">0</span>, ListNode *next = <span class="hljs-literal">nullptr</span>) : <span class="hljs-built_in">val</span>(value), <span class="hljs-built_in">next</span>(next) &#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">LinkedList</span> &#123;<br>    <span class="hljs-comment">// By default, construct a sentinel node that does not store any value, and its reference points to the first element of the list</span><br>    <span class="hljs-comment">// Initially, it points to nullptr</span><br>    ListNode* sentinel;<br>    <span class="hljs-type">int</span> size = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// Constructor: Initialize the sentinel node, allocate memory on the heap for it</span><br>    <span class="hljs-built_in">LinkedList</span>(): <span class="hljs-built_in">sentinel</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>()), <span class="hljs-built_in">size</span>(<span class="hljs-number">0</span>) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Created successfully&quot;</span> &lt;&lt; endl;<br>    &#125;;<br><br>    <span class="hljs-comment">// Destructor: Iteratively delete all nodes (including the memory pointed to by the sentinel node initially)</span><br>    <span class="hljs-comment">// Once the sentinel points to a null pointer, the destruction process is complete</span><br>    ~<span class="hljs-built_in">LinkedList</span>() &#123;<br>        <span class="hljs-keyword">while</span> (sentinel != <span class="hljs-literal">nullptr</span>) &#123;<br>            ListNode* temp = sentinel;<br>            sentinel = sentinel-&gt;next;<br>            <span class="hljs-keyword">delete</span> temp;<br>        &#125;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Destroyed successfully&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-comment">// Four insertion functions</span><br>    <span class="hljs-comment">// Insert a node at the head of the list</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insertAtHead</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> </span>&#123;<br>        <span class="hljs-comment">// Set the reference of the new node to the reference of the sentinel node</span><br>        ListNode* newNode = <span class="hljs-keyword">new</span> ListNode&#123;value, sentinel-&gt;next&#125;;<br>        <span class="hljs-comment">// Change the reference of the sentinel node because the first element of the list has changed</span><br>        sentinel-&gt;next = newNode;<br>        size++;<br>    &#125;<br><br>    <span class="hljs-comment">// Insert a new node after the specified node</span><br>    <span class="hljs-comment">// current represents the node after which you want to insert</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insertAfter</span><span class="hljs-params">(ListNode* current, <span class="hljs-type">int</span> value)</span> </span>&#123;<br>        <span class="hljs-comment">// If the current node is null, return or throw an exception</span><br>        <span class="hljs-keyword">if</span> (current == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">invalid_argument</span>(<span class="hljs-string">&quot;Current node is null&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// Create a new node</span><br>        ListNode* newNode = <span class="hljs-keyword">new</span> ListNode&#123;value, current-&gt;next&#125;;<br>        <span class="hljs-comment">// Insert the new node after the current node</span><br>        current-&gt;next = newNode;<br>        size++;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insertAtPosition</span><span class="hljs-params">(<span class="hljs-type">int</span> value, <span class="hljs-type">int</span> position)</span> </span>&#123;<br>        <span class="hljs-comment">// If the position is 0 or the list is empty, insert at the head</span><br>        <span class="hljs-keyword">if</span> (position == <span class="hljs-number">0</span> || sentinel-&gt;next == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-built_in">insertAtHead</span>(value);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        ListNode* current = sentinel-&gt;next;<br>        <span class="hljs-type">int</span> currentPosition = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// Set a pointer to start the traversal</span><br><br>        <span class="hljs-comment">// Find the node before the insertion position</span><br>        <span class="hljs-keyword">while</span> (current-&gt;next != <span class="hljs-literal">nullptr</span> &amp;&amp; currentPosition &lt; position - <span class="hljs-number">1</span>) &#123;<br>            current = current-&gt;next;<br>            currentPosition++;<br>        &#125;<br><br>        <span class="hljs-comment">// If the position exceeds the end of the list, insert at the end</span><br>        <span class="hljs-keyword">if</span> (currentPosition &lt; position - <span class="hljs-number">1</span>) &#123;<br>            ListNode* newNode = <span class="hljs-keyword">new</span> ListNode&#123;value, <span class="hljs-literal">nullptr</span>&#125;;<br>            current-&gt;next = newNode;<br>            size++;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// Insert the new node</span><br>            <span class="hljs-comment">// current represents the node at index n-1, inserting after it achieves the desired index</span><br>            <span class="hljs-built_in">insertAfter</span>(current, value);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// Insert directly at the end</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insertAtEnd</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (sentinel-&gt;next == <span class="hljs-literal">nullptr</span>) &#123;<br>            ListNode* newNode = <span class="hljs-keyword">new</span> ListNode&#123;value, <span class="hljs-literal">nullptr</span>&#125;;<br>            sentinel-&gt;next = newNode;<br>            size++;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        ListNode* current = sentinel-&gt;next;<br>        <span class="hljs-keyword">while</span> (current-&gt;next != <span class="hljs-literal">nullptr</span>) &#123;<br>            current = current-&gt;next;<br>        &#125;<br>        <span class="hljs-comment">// Traverse to the last node</span><br>        <span class="hljs-comment">// Create a new node</span><br>        ListNode* newNode = <span class="hljs-keyword">new</span> ListNode&#123;value, <span class="hljs-literal">nullptr</span>&#125;;<br>        current-&gt;next = newNode;<br>        size++;<br>    &#125;<br><br>    <span class="hljs-comment">// Delete operation</span><br>    <span class="hljs-comment">// Delete the node with the specified value</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deleteNode</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (sentinel-&gt;next == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// Empty list</span><br><br>        ListNode* current = sentinel-&gt;next;<br>        ListNode* prev = sentinel;<br><br>        <span class="hljs-keyword">while</span> (current != <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">if</span> (current-&gt;val == key) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            prev = current;<br>            current = current-&gt;next;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (current == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// Node does not exist</span><br><br>        prev-&gt;next = current-&gt;next;<br>        <span class="hljs-keyword">delete</span> current;<br>        size--;<br>    &#125;<br><br>    <span class="hljs-comment">// Delete the last element of the list</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deletetheend</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (sentinel-&gt;next == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// Empty list</span><br><br>        ListNode* current = sentinel-&gt;next;<br>        ListNode* prev = sentinel;<br><br>        <span class="hljs-keyword">while</span> (current-&gt;next != <span class="hljs-literal">nullptr</span>) &#123;<br>            prev = current;<br>            current = current-&gt;next;<br>        &#125;<br>        <span class="hljs-comment">// At this point, current is the last element of the list</span><br>        prev-&gt;next = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">delete</span> current;<br>        size--;<br>    &#125;<br><br>    <span class="hljs-comment">// Delete the element at a specific index in the list</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deletetheplace</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (sentinel-&gt;next == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// Empty list</span><br><br>        ListNode* current = sentinel-&gt;next;<br>        ListNode* prev = sentinel;<br>        <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span> (current != <span class="hljs-literal">nullptr</span> &amp;&amp; count &lt; index) &#123;<br>            prev = current;<br>            current = current-&gt;next;<br>            count++;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (count &lt; index) &#123;<br>            <span class="hljs-comment">// Index is too large, no corresponding index</span><br>            <span class="hljs-keyword">return</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// Then current is the node at the target index</span><br>            prev-&gt;next = current-&gt;next;<br>            <span class="hljs-keyword">delete</span> current;<br>            size--;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> index,<span class="hljs-type">int</span> replacement)</span></span>&#123;<br>        ListNode* current = sentinel-&gt;next;<br>        <span class="hljs-comment">// At this point, current points to the address of the first element of the list</span><br>        <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (count &gt;= size) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">out_of_range</span>(<span class="hljs-string">&quot;Out of range&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">while</span> (count &lt; index) &#123;<br>                current = current-&gt;next;<br>                count++;<br>            &#125;<br>            <span class="hljs-comment">// At this point, current points to the element at the target index</span><br>            current-&gt;val=replacement;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// List search</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">at</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> </span>&#123;<br>        ListNode* current = sentinel-&gt;next;<br>        <span class="hljs-comment">// At this point, current points to the address of the first element of the list</span><br>        <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (count &gt;= size) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">out_of_range</span>(<span class="hljs-string">&quot;Out of range&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">while</span> (count &lt; index) &#123;<br>                current = current-&gt;next;<br>                count++;<br>            &#125;<br>            <span class="hljs-comment">// At this point, current points to the element at the target index</span><br>            <span class="hljs-keyword">return</span> current-&gt;val;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>        ListNode* current = sentinel-&gt;next;<br>        <span class="hljs-comment">// At this point, current points to the address of the first element of the list</span><br>        <span class="hljs-keyword">while</span> (current != <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">if</span> (current-&gt;val == target) &#123;<br>                <span class="hljs-keyword">return</span> count;<br>            &#125;<br>            count++;<br>            current = current-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// Print list content</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printList</span><span class="hljs-params">()</span> </span>&#123;<br>        ListNode* current = sentinel-&gt;next;<br>        <span class="hljs-keyword">while</span> (current != <span class="hljs-literal">nullptr</span>) &#123;<br>            std::cout &lt;&lt; current-&gt;val &lt;&lt; <span class="hljs-string">&quot; -&gt; &quot;</span>;<br>            current = current-&gt;next;<br>        &#125;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;NULL&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-comment">// Check if the list is empty</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isempty</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (sentinel-&gt;next == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    LinkedList thelklist;<br>    cout &lt;&lt; thelklist.<span class="hljs-built_in">isempty</span>() &lt;&lt; endl;<br>    thelklist.<span class="hljs-built_in">insertAtEnd</span>(<span class="hljs-number">6</span>);<br>    thelklist.<span class="hljs-built_in">insertAtEnd</span>(<span class="hljs-number">5</span>);<br>    thelklist.<span class="hljs-built_in">insertAtEnd</span>(<span class="hljs-number">3</span>);<br>    thelklist.<span class="hljs-built_in">insertAfter</span>(thelklist.sentinel, <span class="hljs-number">2</span>);<br>    thelklist.<span class="hljs-built_in">insertAtHead</span>(<span class="hljs-number">11</span>);<br>    thelklist.<span class="hljs-built_in">insertAtPosition</span>(<span class="hljs-number">7</span>, <span class="hljs-number">4</span>);<br>    thelklist.<span class="hljs-built_in">deleteNode</span>(<span class="hljs-number">2</span>);<br>    thelklist.<span class="hljs-built_in">deletetheend</span>();<br>    thelklist.<span class="hljs-built_in">deletetheplace</span>(<span class="hljs-number">3</span>);<br>    cout &lt;&lt; thelklist.<span class="hljs-built_in">isempty</span>() &lt;&lt; endl;<br>    cout &lt;&lt; thelklist.<span class="hljs-built_in">search</span>(<span class="hljs-number">6</span>) &lt;&lt; endl;<br>    cout &lt;&lt; thelklist.<span class="hljs-built_in">search</span>(<span class="hljs-number">2</span>) &lt;&lt; endl;<br>    thelklist.<span class="hljs-built_in">printList</span>();<br>    cout &lt;&lt; thelklist.size &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><p>改良后的代码将会放在我的github仓库，敬请期待~</p></blockquote><h2 id="Extensions1-Linked-List-of-both-sides"><a href="#Extensions1-Linked-List-of-both-sides" class="headerlink" title="Extensions1 Linked-List-of-both-sides"></a>Extensions1 Linked-List-of-both-sides</h2><p>接下来我们来看双链表。单链表的遍历操作是效率比较低的，达到了O（n）的时间复杂度。同时单链表还有一个致命的缺陷：<strong>单链表只能够实现单向的遍历</strong>，因为节点无法获取其前继节点的地址。</p><p>因此，我们需要对链表进行强化，从单链表延伸出<strong>双向链表</strong>：</p><ul><li>每个节点需要储存<strong>前驱结点</strong>和<strong>后继节点</strong>的地址。</li><li>增加了<strong>尾节点</strong>（和<strong>头结点</strong>异曲同工）<ul><li>头结点的前继指针为<code>nullptr</code></li><li>尾节点的后继指针为<code>nullptr</code></li></ul></li></ul><p>由于篇幅限制，我们不再详细解释双链表的OOP实现（或者结构体实现），下面笔者简单的介绍一下双链表中的<strong>插入</strong>操作如何实现：</p><ul><li>动态分配一个新的节点<code>inserted</code></li><li>遍历到需要插入到的位置，即插入到<code>current</code>这个指针指向的节点后面<ul><li>current也可能是头指针</li></ul></li><li>更新<code>inserted</code>的指针的前驱结点的值（<code>current</code>的地址）</li><li>更新<code>inserted</code>的指针的后继结点的值（<code>current</code>的后继结点）</li><li>更新<code>current</code>的后继结点的值为当前<code>inserted</code>的地址。</li></ul><div class="note note-warning">            <p>在自己构造函数实现的时候，一定要注意<strong>每一步的操作顺序！！！</strong>例如在这里2,3两步的顺序就不可以调换，否则<code>current</code>后继结点的值会被抹去，导致<strong>链表中断</strong>。</p>          </div><p>优化后，双链表便有了双向遍历的能力。同时，双链表在<strong>插入和删除</strong>等操作上也具有更高的便利性。例如，在访问某个节点的时候需要删除该节点，则对应单链表而言，需要<strong>从头开始遍历到这个节点的前驱结点</strong>，然后将后继节点和前驱结点直接建立联系。（<strong>本质原因：单链表的设计只允许单向的遍历操作，不可以走回头路</strong>）</p><p>但是，在双链表中，我可以<strong>直接获取特定节点的前驱结点和后继结点的地址</strong>，可以直接进行删除操作。</p><h2 id="Extensions2-Bidirectional-circular-linked-lists"><a href="#Extensions2-Bidirectional-circular-linked-lists" class="headerlink" title="Extensions2 Bidirectional circular linked lists"></a>Extensions2 Bidirectional circular linked lists</h2><p><strong>循环链表</strong>很大的不同之处在于<strong>不再需要设置头尾节点</strong>。但是，为了保证与双向链表的兼容性，可以保留头尾节点，而是<strong>将头结点的前驱结点的地址设置为尾节点的地址，将尾节点的后继结点的地址设置为头结点的地址</strong>。（这样就进需要修改两个值便可以将双向链表升级为<strong>双向循环链表</strong>）。</p><blockquote><p>但是这种方式有一种弊端就是链表成环后，<strong>头结点和尾节点并不储存有效的信息，比较的冗余</strong>。</p></blockquote><p>因此，一般更通用的做法是不设置头结点和尾节点，这样只要讨论<strong>空链表的特殊性</strong>，其他操作也能够正常的完成。</p><p>[推荐这一篇博客，不过是C语言的](<a href="https://www.cnblogs.com/wyfm/p/18533925">数据结构_链表_单向循环链表 &amp; 双向链表的初始化、插入、删除、修改、查询打印（基于C语言实现） - 逸風明 - 博客园</a>)</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p>《C++程序设计——思想与方法》</p><p>《Hello 算法》</p><p>《数据结构：思想和实现》</p><p><a href="https://www.hello-algo.com/">Hello 算法</a></p><blockquote><p>THE END</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tutorial</tag>
      
      <tag>Finished</tag>
      
      <tag>C/C++</tag>
      
      <tag>Linked list</tag>
      
      <tag>Structs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Dynamic-Memory-and-Classes</title>
    <link href="/posts/Dynamic-Memory-and-Classes/"/>
    <url>/posts/Dynamic-Memory-and-Classes/</url>
    
    <content type="html"><![CDATA[<style>  html, body, .markdown-body {    font-family: Georgia, sans, serif;  }</style><h1 id="C-Primer-Plus-Tutorial-12"><a href="#C-Primer-Plus-Tutorial-12" class="headerlink" title="C++ Primer Plus Tutorial-12"></a>C++ Primer Plus Tutorial-12</h1><h1 id="面向对象编程教程——Section②"><a href="#面向对象编程教程——Section②" class="headerlink" title="面向对象编程教程——Section②"></a>面向对象编程教程——Section②</h1><center><p style="color: red;"><b><font size=6.5>Chapter 12 Dynamic-Memory-and-Classes</font></b></p></center><center><p style="color: red;"><b><font size=6.5>动态内存和类</font></b></p></center><p>【写在前面的话】</p><p><a href="https://xiyuanyang-code.github.io/posts/C-plus-plus-Primer-Plus-tutorial/">C++ Primer Plus Tutorial</a></p><p><a href="https://xiyuanyang-code.github.io/tags/OOP/">系列文章</a></p><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>本章将重点放在如何对<strong>自定义类和对象</strong>谨慎地使用<strong>动态内存分配</strong>，以及内存管理的相关知识。首先从一个代码示例StringBad讲起，分析因为C++自带的隐式复制构造函数导致<strong>按值传递</strong>和<strong>按址传递</strong>发生冲突而导致程序无法正确输出，并以此为教材介绍了如何<strong>显式</strong>地定义<strong>复制构造函数和赋值运算符</strong>，并给出了修改后的String类的类定义和使用示范。接着，文章聚焦于在类中使用动态内存的易错点，包括new和delete的一一对应问题。最后，文章分析了使用动态内存分配在设计类和对象过程中的应用：<strong>设置合理的返回对象</strong>和<strong>使用指向对象的指针</strong>，同时介绍了动态内存管理的一些高级操作，包括<strong>正确地使用析构函数</strong>和<strong>使用定位new运算符</strong>。</p><blockquote><p>This chapter focuses on how to <strong>cautiously use dynamic memory allocation with</strong> <strong>custom classes and objects</strong>, along with related knowledge on memory management. It begins with a code example, StringBad, to analyze how the implicit copy constructor provided by C++ leads to conflicts between <strong>pass-by-value</strong> and <strong>pass-by-reference</strong>, resulting in incorrect program output. Using this example as a teaching tool, the chapter introduces how to <strong>explicitly</strong> define <strong>copy constructors and assignment operators</strong>, and provides an updated class definition and usage demonstration for the String class. Next, the article focuses on common pitfalls when using dynamic memory in classes, including the one-to-one correspondence issue between new and delete. Finally, the chapter discusses the application of dynamic memory allocation in the design of classes and objects: <strong>setting appropriate return objects</strong> and <strong>using pointers to objects</strong>, while also introducing some advanced operations in dynamic memory management, such as <strong>correctly using destructors</strong> and <strong>using placement new operator</strong>.</p><p><strong>Key words: OOP, Dynamic Memory, C++, Classes</strong></p></blockquote><h2 id="Introduction：C-中的特殊成员函数"><a href="#Introduction：C-中的特殊成员函数" class="headerlink" title="Introduction：C++中的特殊成员函数"></a>Introduction：C++中的特殊成员函数</h2><h3 id="示例代码（stringbad类的实现）"><a href="#示例代码（stringbad类的实现）" class="headerlink" title="示例代码（stringbad类的实现）"></a>示例代码（stringbad类的实现）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// strngbad.h -- flawed string class definition</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> STRNGBAD_H_</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> STRNGBAD_H_</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">StringBad</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">char</span> * str;                <span class="hljs-comment">// pointer to string</span><br>    <span class="hljs-type">int</span> len;                   <span class="hljs-comment">// length of string</span><br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> num_strings;    <span class="hljs-comment">// number of objects</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">StringBad</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> * s); <span class="hljs-comment">// constructor</span><br>    <span class="hljs-built_in">StringBad</span>();               <span class="hljs-comment">// default constructor</span><br>    ~<span class="hljs-built_in">StringBad</span>();              <span class="hljs-comment">// destructor</span><br><span class="hljs-comment">// friend function</span><br>    <span class="hljs-keyword">friend</span> std::ostream &amp; <span class="hljs-keyword">operator</span>&lt;&lt;(std::ostream &amp; os, <span class="hljs-type">const</span> StringBad &amp; st);<br>&#125;;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// strngbad.cpp -- StringBad class methods</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span>                    <span class="hljs-comment">// string.h for some</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;strngbad.h&quot;</span></span><br><span class="hljs-keyword">using</span> std::cout;<br><br><span class="hljs-comment">// initializing static class member</span><br><span class="hljs-type">int</span> StringBad::num_strings = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// class methods</span><br><br><span class="hljs-comment">// construct StringBad from C string</span><br>StringBad::<span class="hljs-built_in">StringBad</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> * s)<br>&#123;<br>    len = std::<span class="hljs-built_in">strlen</span>(s);             <span class="hljs-comment">// set size</span><br>    str = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[len + <span class="hljs-number">1</span>];          <span class="hljs-comment">// allot storage</span><br>    std::<span class="hljs-built_in">strcpy</span>(str, s);              <span class="hljs-comment">// initialize pointer</span><br>    num_strings++;                    <span class="hljs-comment">// set object count</span><br>    cout &lt;&lt; num_strings &lt;&lt; <span class="hljs-string">&quot;: \&quot;&quot;</span> &lt;&lt; str<br>         &lt;&lt; <span class="hljs-string">&quot;\&quot; object created\n&quot;</span>;    <span class="hljs-comment">// For Your Information</span><br>&#125;<br><br>StringBad::<span class="hljs-built_in">StringBad</span>()                <span class="hljs-comment">// default constructor</span><br>&#123;<br>    len = <span class="hljs-number">4</span>;<br>    str = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-number">4</span>];<br>    std::<span class="hljs-built_in">strcpy</span>(str, <span class="hljs-string">&quot;C++&quot;</span>);          <span class="hljs-comment">// default string</span><br>    num_strings++;<br>    cout &lt;&lt; num_strings &lt;&lt; <span class="hljs-string">&quot;: \&quot;&quot;</span> &lt;&lt; str<br>         &lt;&lt; <span class="hljs-string">&quot;\&quot; default object created\n&quot;</span>;  <span class="hljs-comment">// FYI</span><br>&#125;<br><br>StringBad::~<span class="hljs-built_in">StringBad</span>()               <span class="hljs-comment">// necessary destructor</span><br>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;\&quot;&quot;</span> &lt;&lt; str &lt;&lt; <span class="hljs-string">&quot;\&quot; object deleted, &quot;</span>;    <span class="hljs-comment">// FYI</span><br>    --num_strings;                    <span class="hljs-comment">// required</span><br>    cout &lt;&lt; num_strings &lt;&lt; <span class="hljs-string">&quot; left\n&quot;</span>; <span class="hljs-comment">// FYI</span><br>    <span class="hljs-keyword">delete</span> [] str;                    <span class="hljs-comment">// required</span><br>&#125;<br><br>std::ostream &amp; <span class="hljs-keyword">operator</span>&lt;&lt;(std::ostream &amp; os, <span class="hljs-type">const</span> StringBad &amp; st)<br>&#123;<br>    os &lt;&lt; st.str;<br>    <span class="hljs-keyword">return</span> os; <br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// vegnews.cpp -- using new and delete with classes</span><br><span class="hljs-comment">// compile with strngbad.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> std::cout;<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;strngbad.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">callme1</span><span class="hljs-params">(StringBad &amp;)</span></span>;  <span class="hljs-comment">// pass by reference</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">callme2</span><span class="hljs-params">(StringBad)</span></span>;    <span class="hljs-comment">// pass by value</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">using</span> std::endl;<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Starting an inner block.\n&quot;</span>;<br>        <span class="hljs-function">StringBad <span class="hljs-title">headline1</span><span class="hljs-params">(<span class="hljs-string">&quot;Celery Stalks at Midnight&quot;</span>)</span></span>;<br>        <span class="hljs-function">StringBad <span class="hljs-title">headline2</span><span class="hljs-params">(<span class="hljs-string">&quot;Lettuce Prey&quot;</span>)</span></span>;<br>        <span class="hljs-function">StringBad <span class="hljs-title">sports</span><span class="hljs-params">(<span class="hljs-string">&quot;Spinach Leaves Bowl for Dollars&quot;</span>)</span></span>;<br>        cout &lt;&lt; <span class="hljs-string">&quot;headline1: &quot;</span> &lt;&lt; headline1 &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">&quot;headline2: &quot;</span> &lt;&lt; headline2 &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">&quot;sports: &quot;</span> &lt;&lt; sports &lt;&lt; endl;<br>        <span class="hljs-built_in">callme1</span>(headline1);<br>        cout &lt;&lt; <span class="hljs-string">&quot;headline1: &quot;</span> &lt;&lt; headline1 &lt;&lt; endl;<br>        <span class="hljs-built_in">callme2</span>(headline2);<br>        cout &lt;&lt; <span class="hljs-string">&quot;headline2: &quot;</span> &lt;&lt; headline2 &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Initialize one object to another:\n&quot;</span>;<br>        StringBad sailor = sports;<br>        cout &lt;&lt; <span class="hljs-string">&quot;sailor: &quot;</span> &lt;&lt; sailor &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Assign one object to another:\n&quot;</span>;<br>        StringBad knot;<br>        knot = headline1;<br>        cout &lt;&lt; <span class="hljs-string">&quot;knot: &quot;</span> &lt;&lt; knot &lt;&lt; endl; <br>        cout &lt;&lt; <span class="hljs-string">&quot;Exiting the block.\n&quot;</span>;<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-string">&quot;End of main()\n&quot;</span>;<br>    <span class="hljs-comment">// std::cin.get();</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">callme1</span><span class="hljs-params">(StringBad &amp; rsb)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;String passed by reference:\n&quot;</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;    \&quot;&quot;</span> &lt;&lt; rsb &lt;&lt; <span class="hljs-string">&quot;\&quot;\n&quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">callme2</span><span class="hljs-params">(StringBad sb)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;String passed by value:\n&quot;</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;    \&quot;&quot;</span> &lt;&lt; sb &lt;&lt; <span class="hljs-string">&quot;\&quot;\n&quot;</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>以上代码实现了一个对字符串类<code>StringBad</code>类的声明与定义，代码示例参见注释，不做解释。</p><p>以下是原书给出的输出示例：</p><p><img src="/posts/Dynamic-Memory-and-Classes/input1.png"></p><p><img src="/posts/Dynamic-Memory-and-Classes/input2.png" alt="Output"></p><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p>通过输出可以大致判断<code>stringbad</code>类出现奇怪问题的原因可能如下：</p><ul><li>静态变量<code>num_strings</code>出现了负值，说明在程序中<strong>使用析构函数的次数</strong>多于<strong>使用构造函数的次数</strong></li><li>出现了<strong>非标准字符</strong>，说明字符串在传递过程中的值出现了问题。</li></ul><h3 id="问题分析1"><a href="#问题分析1" class="headerlink" title="问题分析1"></a>问题分析1</h3><p>在上述代码中，存在<strong>两个构造函数</strong>，分别对应有参数和无参数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++">StringBad::<span class="hljs-built_in">StringBad</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> * s)<br>&#123;<br>    len = std::<span class="hljs-built_in">strlen</span>(s);             <span class="hljs-comment">// set size</span><br>    str = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[len + <span class="hljs-number">1</span>];          <span class="hljs-comment">// allot storage</span><br>    std::<span class="hljs-built_in">strcpy</span>(str, s);              <span class="hljs-comment">// initialize pointer</span><br>    num_strings++;                    <span class="hljs-comment">// set object count</span><br>    cout &lt;&lt; num_strings &lt;&lt; <span class="hljs-string">&quot;: \&quot;&quot;</span> &lt;&lt; str<br>         &lt;&lt; <span class="hljs-string">&quot;\&quot; object created\n&quot;</span>;    <span class="hljs-comment">// For Your Information</span><br>&#125;<br><br>StringBad::<span class="hljs-built_in">StringBad</span>()                <span class="hljs-comment">// default constructor</span><br>&#123;<br>    len = <span class="hljs-number">4</span>;<br>    str = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-number">4</span>];<br>    std::<span class="hljs-built_in">strcpy</span>(str, <span class="hljs-string">&quot;C++&quot;</span>);          <span class="hljs-comment">// default string</span><br>    num_strings++;<br>    cout &lt;&lt; num_strings &lt;&lt; <span class="hljs-string">&quot;: \&quot;&quot;</span> &lt;&lt; str<br>         &lt;&lt; <span class="hljs-string">&quot;\&quot; default object created\n&quot;</span>;  <span class="hljs-comment">// FYI</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这是析构函数的定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++">StringBad::~<span class="hljs-built_in">StringBad</span>()               <span class="hljs-comment">// necessary destructor</span><br>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;\&quot;&quot;</span> &lt;&lt; str &lt;&lt; <span class="hljs-string">&quot;\&quot; object deleted, &quot;</span>;    <span class="hljs-comment">// FYI</span><br>    --num_strings;                    <span class="hljs-comment">// required</span><br>    cout &lt;&lt; num_strings &lt;&lt; <span class="hljs-string">&quot; left\n&quot;</span>; <span class="hljs-comment">// FYI</span><br>    <span class="hljs-keyword">delete</span> [] str;                    <span class="hljs-comment">// required</span><br>&#125;<br></code></pre></td></tr></table></figure><p>以上三个函数定义是都没有忘记对静态成员变量<code>num_strings</code>的操作（++&#x2F;–）。因此，原因①可以被更加规范地表述为：<strong>在程序运行中使用显式定义的构造函数的次数少于使用析构函数的次数</strong>，换句话说，程序使用了<strong>第三种构造函数</strong>，这个“第三种构造函数”为程序自动生成，因此没有对<code>num_strings</code>的++操作，导致负值的出现。（毕竟在作用域中每个对象只能构造一次，析构一次，两者的数量应该是相等的。）</p><p>程序中一共涉及到5个对象，这是他们的构造方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">StringBad <span class="hljs-title">headline1</span><span class="hljs-params">(<span class="hljs-string">&quot;Celery Stalks at Midnight&quot;</span>)</span></span>;<br><span class="hljs-function">StringBad <span class="hljs-title">headline2</span><span class="hljs-params">(<span class="hljs-string">&quot;Lettuce Prey&quot;</span>)</span></span>;<br><span class="hljs-function">StringBad <span class="hljs-title">sports</span><span class="hljs-params">(<span class="hljs-string">&quot;Spinach Leaves Bowl for Dollars&quot;</span>)</span></span>;<br><br>StringBad sailor = sports;<br><br>StringBad knot;<br>knot = headline1;<br></code></pre></td></tr></table></figure><p>前三个对象，<code>headline1</code>，<code>headline2</code>，<code>sports</code>都是有函数定义中<code>StringBad::StringBad(const char * s)</code>的构造函数进行构造；最后一个<code>knot</code>使用默认构造函数<code>StringBad::StringBad()</code>进行构造，因此，问题出现在<code>StringBad sailor = sports</code>上。</p><blockquote><p>sailor和knot的初始化很像，但程序处理的方式完全不同。knot在使用<strong>默认构造函数</strong>构造后用headline1进行赋值；而sailor对象使用了一种名叫<strong>复制构造函数</strong>的构造方式！</p></blockquote><h4 id="复制构造函数：隐藏的“第三者”"><a href="#复制构造函数：隐藏的“第三者”" class="headerlink" title="复制构造函数：隐藏的“第三者”"></a>复制构造函数：隐藏的“第三者”</h4><h5 id="复制构造函数的声明"><a href="#复制构造函数的声明" class="headerlink" title="复制构造函数的声明"></a>复制构造函数的声明</h5><p>sailor的构造函数原型等价于如下语句：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">StringBad sailor = <span class="hljs-built_in">StringBad</span> (sports);<br><span class="hljs-comment">//相当于把sailor的副本拷贝给sailor</span><br></code></pre></td></tr></table></figure><p>这里的<code>StringBad()</code>就是C++自动提供的<strong>复制构造函数</strong>，用于<strong>将一个对象复制到一个新创建的对象的初始化中</strong>，注意，是<strong>初始化不是赋值！！！</strong>knot对象的赋值操作和复制构造函数无关（后文会讲到，使用的是<code>赋值运算符</code>），因为对knot的初始化操作已经在上一行代码使用默认构造函数完成了。</p><p>下面是复制构造函数的原型，它<strong>接受一个指向类对象的常量引用作为参数</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">Class_name</span>(<span class="hljs-type">const</span> Class_name &amp;);<br><br><span class="hljs-built_in">StringBad</span>(<span class="hljs-type">const</span> StringBad &amp;);<br></code></pre></td></tr></table></figure><h5 id="复制构造函数的使用场景"><a href="#复制构造函数的使用场景" class="headerlink" title="复制构造函数的使用场景"></a>复制构造函数的使用场景</h5><p>复制构造函数的使用非常常见，尤其在<strong>将新对象与现有对象之间建立联系的时候</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">StringBad <span class="hljs-title">sailor</span><span class="hljs-params">(sports)</span></span>;<br>StringBad sailor=sports;<br>StringBad sailor = <span class="hljs-built_in">StringBad</span> (sports);<br>StringBad *sailor = <span class="hljs-keyword">new</span> <span class="hljs-built_in">StringBad</span>(sports); <br><span class="hljs-comment">//以上四种初始化方式等价，都会使用复制构造函数</span><br></code></pre></td></tr></table></figure><p>更深入地讲，当函数<strong>按值传递对象或返回对象时</strong>，会使用复制构造函数创建原始对象的一个副本作为临时对象，然后将<strong>临时对象的内容赋给要被初始化的对象</strong>（第四种初始化方式所赋值的是所创建的匿名对象的指针）。</p><p>例如程序中的 <code>callme2()</code>函数使用按值传递，会创建一个副本（<strong>这里和函数的形参实参传递本质是相同的</strong>），因此会使用复制构造函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">callme2</span><span class="hljs-params">(StringBad sb)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;String passed by value:\n&quot;</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;    \&quot;&quot;</span> &lt;&lt; sb &lt;&lt; <span class="hljs-string">&quot;\&quot;\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="复制构造函数的功能"><a href="#复制构造函数的功能" class="headerlink" title="复制构造函数的功能"></a>复制构造函数的功能</h5><p>默认的复制构造函数<strong>逐个复制非静态成员（成员复制也称为浅复制）</strong>，复制的是成员的值。  </p><ul><li><p>补充：显式使用复制构造函数提供了对对象复制行为的精细控制，因此也被称作<strong>深拷贝</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span>* data;<br>    <span class="hljs-built_in">MyClass</span>() &#123; data = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">0</span>); &#125;<br>    ~<span class="hljs-built_in">MyClass</span>() &#123; <span class="hljs-keyword">delete</span> data; &#125;<br>    <br>    <span class="hljs-comment">// 显式的复制构造函数</span><br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">const</span> MyClass&amp; other) &#123;<br>        <span class="hljs-comment">// 深拷贝</span><br>        data = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(*other.data);<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    MyClass a;<br>    *a.data = <span class="hljs-number">10</span>;<br>    MyClass b = a; <span class="hljs-comment">// 调用复制构造函数</span><br>    <span class="hljs-comment">// 现在b.data指向一个新的int，其值为10</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>显式声明</strong>：如果你不希望编译器生成默认的复制构造函数，可以通过在类中声明一个私有的复制构造函数并将其标记为<code>delete</code>来阻止默认复制构造函数的生成。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 其他成员函数和变量...</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">const</span> MyClass&amp;) = <span class="hljs-keyword">delete</span>; <span class="hljs-comment">// 阻止默认复制构造函数的生成</span><br>&#125;;<br></code></pre></td></tr></table></figure></li></ul><h4 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h4><p>在了解的复制构造函数后，就不难理解为何静态变量<code>num_strings</code>出现了负值了。在主程序 <code>vegnews.cpp</code> 中，有一下代码用到了隐式的复制构造函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">callme2</span>(headline2);<br>StringBad sailor = sports;<br><span class="hljs-comment">//使用隐式复制构造函数两次，因此计数器会出现-2，problems solved!</span><br></code></pre></td></tr></table></figure><blockquote><p>问题的解决方式已经在上文给出，构建显式构造函数。</p></blockquote><h3 id="问题分析2"><a href="#问题分析2" class="headerlink" title="问题分析2"></a>问题分析2</h3><p>接下来我们将重点放在 <code>字符串乱码</code>的问题上。</p><h4 id="还是复制构造函数的锅！"><a href="#还是复制构造函数的锅！" class="headerlink" title="还是复制构造函数的锅！"></a>还是复制构造函数的锅！</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">StringBad sailor = sports;<br></code></pre></td></tr></table></figure><p>上文提到，隐式复制构造函数奉行<strong>按值传递</strong>的基本思想，而这对于字符串成员而言是非常危险。因为C风格字符串的本质就是<code>char</code>数组，或者说指向<code>char</code>类型的特殊指针。</p><p>因此，在使用隐式复制构造函数时，<code>sports.str</code>将自己的<strong>值</strong>复制给了<code>sailor.str</code>。<strong>此时这两个字符串（指向char类型的指针）指向了同一块内存！</strong>，因此，当释放其中一个对象时，被调用的析构函数会执行下面的操作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">delete</span> [] str;<br></code></pre></td></tr></table></figure><p>在这个程序中，<code>sailor</code>先于 <code>sports</code>被析构函数调用，因此，<code>sailor.str</code>会先被<code>delete</code>掉，这样，**<code>sports.str</code>就变成了“无家可归”的悬挂指针**，后续生成乱码也就很好理解了。</p><p>更严重地，在后续<code>delete``sports.str</code>的时候，相当于程序对同一块内存连续delete两次，这会导致程序的异常终止。</p><h4 id="solution-1"><a href="#solution-1" class="headerlink" title="solution"></a>solution</h4><p>按值传递更加直观，易于理解，但是，一旦程序涉及于指针和内存管理相关的操作时，<strong>按值传递和按址传递（指针）会产生冲突</strong>。因此，手动构建一个显式的复制构造函数迫在眉睫。</p><p>这是原书给出的显示复制构造函数（深拷贝），手动使用 <code>strcpy</code>函数实现字符串的拷贝（按址拷贝）。</p><p><img src="/posts/Dynamic-Memory-and-Classes/3.png" alt="Explicit Copy Constructor"></p><h3 id="问题还未被解决…"><a href="#问题还未被解决…" class="headerlink" title="问题还未被解决…"></a>问题还未被解决…</h3><p>我们已经解决了因为<strong>隐式复制构造函数</strong>带来的一些问题，其中，问题②主要是因为浅拷贝的<strong>赋值操作</strong>导致的<strong>按值传递与按址传递的冲突</strong>。请看下面的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++">StringBad sailor = sports;<br><br>StringBad knot;<br>knot = headline1;<br></code></pre></td></tr></table></figure><p><code>sailor</code>使用复制构造函数，将<code>sports</code>对象的临时拷贝<strong>赋值</strong>给<code>sailor</code>完成初始化。<code>knot</code>在初始化时使用了默认构造函数，但是也免不了<code>knot = headline1</code>中对其的<strong>赋值操作</strong>，<strong>按值传递与按址传递的冲突</strong>仍然存在！</p><p><img src="/posts/Dynamic-Memory-and-Classes/input2.png" alt="Output"></p><p>输出示例验证了我们的猜想，在析构时，<code>knot</code>先被<code>delete</code>，因此在最后<code>delete</code> <code>headline1</code>时，字符串呈现乱码。也就是说，<strong>C++默认的对对象的赋值运算符依旧使用按值传递</strong>，即<strong>类重载赋值运算符</strong>。下面是这种运算符的函数原型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">Class_name &amp; Class_name::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Class_name &amp;)<br></code></pre></td></tr></table></figure><p>因此，解决问题的方式也显而易见了：手动定义赋值运算符的重载，和复制构造函数的定义基本相同。书中实现了运算符重载的代码示例：</p><p><img src="/posts/Dynamic-Memory-and-Classes/4.png" alt="Explicit Overloading of Assignment Operator"></p><h3 id="特殊成员函数"><a href="#特殊成员函数" class="headerlink" title="特殊成员函数"></a>特殊成员函数</h3><p>StringBad 类的问题是由特殊成员函数引起的。这些成员函数是自动定义的，就 StringBad 而言，这些函数的行为与类设计不符。具体地说， C++自动提供了下面这些成员函数：</p><ul><li><strong>默认构造函数，如果没有定义构造函数；</strong></li><li><strong>默认析构函数，如果没有定义；</strong></li><li><strong>复制构造函数，如果没有定义；</strong></li><li><strong>赋值运算符，如果没有定义；</strong></li><li><strong>地址运算符，如果没有定义。</strong>（读者可以自行查阅，就是取址运算符）</li></ul><p>更准确地说，编译器将生成上述最后三个函数的定义——如果程序使用对象的方式要求这样做。例如，如果您将一个对象赋给另一个对象，编译器将提供赋值运算符的定义。</p><h3 id="From-StringBad-to-String"><a href="#From-StringBad-to-String" class="headerlink" title="From StringBad to String"></a>From StringBad to String</h3><p>这就是C++风格的string类的实现！请阅读教材的12.2节，其简单介绍了string类的相关成员函数的定义，受篇幅限制，本博客不再讨论本节内容。对于使用者而言，只需要了解string类的接口足矣，但对于一位优秀的OOP学习者而言，但阅读书中代码，甚至尝试自己实现是锻炼自己OOP能力的一大有力武器。</p><p>此处只给出书中的源代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// string1.h -- fixed and augmented string class definition</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> STRING1_H_</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> STRING1_H_</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> std::ostream;<br><span class="hljs-keyword">using</span> std::istream;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">char</span> * str;             <span class="hljs-comment">// pointer to string</span><br>    <span class="hljs-type">int</span> len;                <span class="hljs-comment">// length of string</span><br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> num_strings; <span class="hljs-comment">// number of objects</span><br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> CINLIM = <span class="hljs-number">80</span>;  <span class="hljs-comment">// cin input limit</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// constructors and other methods</span><br>    <span class="hljs-built_in">String</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> * s); <span class="hljs-comment">// constructor</span><br>    <span class="hljs-built_in">String</span>();               <span class="hljs-comment">// default constructor</span><br>    <span class="hljs-built_in">String</span>(<span class="hljs-type">const</span> String &amp;); <span class="hljs-comment">// copy constructor</span><br>    ~<span class="hljs-built_in">String</span>();              <span class="hljs-comment">// destructor</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">length</span> <span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> len; &#125;<br><span class="hljs-comment">// overloaded operator methods    </span><br>    String &amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> String &amp;);<br>    String &amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *);<br>    <span class="hljs-type">char</span> &amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> i);<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> &amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> i) <span class="hljs-type">const</span>;<br><span class="hljs-comment">// overloaded operator friends</span><br>    <span class="hljs-keyword">friend</span> <span class="hljs-type">bool</span> <span class="hljs-built_in">operator</span>&lt;(<span class="hljs-type">const</span> String &amp;st, <span class="hljs-type">const</span> String &amp;st2);<br>    <span class="hljs-keyword">friend</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&gt;(<span class="hljs-type">const</span> String &amp;st1, <span class="hljs-type">const</span> String &amp;st2);<br>    <span class="hljs-keyword">friend</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> String &amp;st, <span class="hljs-type">const</span> String &amp;st2);<br>    <span class="hljs-keyword">friend</span> ostream &amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp; os, <span class="hljs-type">const</span> String &amp; st);<br>    <span class="hljs-keyword">friend</span> istream &amp; <span class="hljs-keyword">operator</span>&gt;&gt;(istream &amp; is, String &amp; st);<br><span class="hljs-comment">// static function</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">HowMany</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// string1.cpp -- String class methods</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span>                 <span class="hljs-comment">// string.h for some</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;string1.h&quot;</span>               <span class="hljs-comment">// includes &lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> std::cin;<br><span class="hljs-keyword">using</span> std::cout;<br><br><span class="hljs-comment">// initializing static class member</span><br><br><span class="hljs-type">int</span> String::num_strings = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// static method</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">String::HowMany</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> num_strings;<br>&#125;<br><br><span class="hljs-comment">// class methods</span><br>String::<span class="hljs-built_in">String</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> * s)     <span class="hljs-comment">// construct String from C string</span><br>&#123;<br>    len = std::<span class="hljs-built_in">strlen</span>(s);          <span class="hljs-comment">// set size</span><br>    str = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[len + <span class="hljs-number">1</span>];       <span class="hljs-comment">// allot storage</span><br>    std::<span class="hljs-built_in">strcpy</span>(str, s);           <span class="hljs-comment">// initialize pointer</span><br>    num_strings++;                 <span class="hljs-comment">// set object count</span><br>&#125;<br><br>String::<span class="hljs-built_in">String</span>()                   <span class="hljs-comment">// default constructor</span><br>&#123;<br>    len = <span class="hljs-number">4</span>;<br>    str = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-number">1</span>];<br>    str[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;\0&#x27;</span>;                 <span class="hljs-comment">// default string</span><br>    num_strings++;<br>&#125;<br><br>String::<span class="hljs-built_in">String</span>(<span class="hljs-type">const</span> String &amp; st)<br>&#123;<br>    num_strings++;             <span class="hljs-comment">// handle static member update</span><br>    len = st.len;              <span class="hljs-comment">// same length</span><br>    str = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span> [len + <span class="hljs-number">1</span>];  <span class="hljs-comment">// allot space</span><br>    std::<span class="hljs-built_in">strcpy</span>(str, st.str);  <span class="hljs-comment">// copy string to new location</span><br>&#125;<br><br>String::~<span class="hljs-built_in">String</span>()                     <span class="hljs-comment">// necessary destructor</span><br>&#123;<br>    --num_strings;                    <span class="hljs-comment">// required</span><br>    <span class="hljs-keyword">delete</span> [] str;                    <span class="hljs-comment">// required</span><br>&#125;<br><br><span class="hljs-comment">// overloaded operator methods    </span><br><br>    <span class="hljs-comment">// assign a String to a String</span><br>String &amp; String::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> String &amp; st)<br>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;st)<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    <span class="hljs-keyword">delete</span> [] str;<br>    len = st.len;<br>    str = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[len + <span class="hljs-number">1</span>];<br>    std::<span class="hljs-built_in">strcpy</span>(str, st.str);<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><br>    <span class="hljs-comment">// assign a C string to a String</span><br>String &amp; String::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> <span class="hljs-type">char</span> * s)<br>&#123;<br>    <span class="hljs-keyword">delete</span> [] str;<br>    len = std::<span class="hljs-built_in">strlen</span>(s);<br>    str = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[len + <span class="hljs-number">1</span>];<br>    std::<span class="hljs-built_in">strcpy</span>(str, s);<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><br>    <span class="hljs-comment">// read-write char access for non-const String</span><br><span class="hljs-type">char</span> &amp; String::<span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> i)<br>&#123;<br>    <span class="hljs-keyword">return</span> str[i];<br>&#125;<br><br>    <span class="hljs-comment">// read-only char access for const String</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> &amp; String::<span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> i) <span class="hljs-type">const</span><br>&#123;<br>    <span class="hljs-keyword">return</span> str[i];<br>&#125;<br><br><span class="hljs-comment">// overloaded operator friends</span><br><br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> String &amp;st1, <span class="hljs-type">const</span> String &amp;st2)<br>&#123;<br>    <span class="hljs-keyword">return</span> (std::<span class="hljs-built_in">strcmp</span>(st<span class="hljs-number">1.</span>str, st<span class="hljs-number">2.</span>str) &lt; <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&gt;(<span class="hljs-type">const</span> String &amp;st1, <span class="hljs-type">const</span> String &amp;st2)<br>&#123;<br>    <span class="hljs-keyword">return</span> st2 &lt; st1;<br>&#125;<br><br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> String &amp;st1, <span class="hljs-type">const</span> String &amp;st2)<br>&#123;<br>    <span class="hljs-built_in">return</span> (std::<span class="hljs-built_in">strcmp</span>(st<span class="hljs-number">1.</span>str, st<span class="hljs-number">2.</span>str) == <span class="hljs-number">0</span>);<br>&#125;<br><br>    <span class="hljs-comment">// simple String output</span><br>ostream &amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp; os, <span class="hljs-type">const</span> String &amp; st)<br>&#123;<br>    os &lt;&lt; st.str;<br>    <span class="hljs-keyword">return</span> os; <br>&#125;<br><br>    <span class="hljs-comment">// quick and dirty String input</span><br>istream &amp; <span class="hljs-keyword">operator</span>&gt;&gt;(istream &amp; is, String &amp; st)<br>&#123;<br>    <span class="hljs-type">char</span> temp[String::CINLIM];<br>    is.<span class="hljs-built_in">get</span>(temp, String::CINLIM);<br>    <span class="hljs-keyword">if</span> (is)<br>        st = temp;<br>    <span class="hljs-keyword">while</span> (is &amp;&amp; is.<span class="hljs-built_in">get</span>() != <span class="hljs-string">&#x27;\n&#x27;</span>)<br>        <span class="hljs-keyword">continue</span>;<br>    <span class="hljs-keyword">return</span> is; <br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// sayings1.cpp -- using expanded String class</span><br><span class="hljs-comment">// compile with string1.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;string1.h&quot;</span> </span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> ArSize = <span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MaxLen =<span class="hljs-number">81</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">using</span> std::cout;<br>    <span class="hljs-keyword">using</span> std::cin;<br>    <span class="hljs-keyword">using</span> std::endl;<br>    String name;<br>    cout &lt;&lt;<span class="hljs-string">&quot;Hi, what&#x27;s your name?\n&gt;&gt; &quot;</span>;<br>    cin &gt;&gt; name;<br><br>    cout &lt;&lt; name &lt;&lt; <span class="hljs-string">&quot;, please enter up to &quot;</span> &lt;&lt; ArSize<br>        &lt;&lt; <span class="hljs-string">&quot; short sayings &lt;empty line to quit&gt;:\n&quot;</span>;<br>    String sayings[ArSize];     <span class="hljs-comment">// array of objects</span><br>    <span class="hljs-type">char</span> temp[MaxLen];          <span class="hljs-comment">// temporary string storage</span><br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; ArSize; i++)<br>    &#123;<br>        cout &lt;&lt; i<span class="hljs-number">+1</span> &lt;&lt; <span class="hljs-string">&quot;: &quot;</span>;<br>        cin.<span class="hljs-built_in">get</span>(temp, MaxLen);<br>        <span class="hljs-keyword">while</span> (cin &amp;&amp; cin.<span class="hljs-built_in">get</span>() != <span class="hljs-string">&#x27;\n&#x27;</span>)<br>            <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span> (!cin || temp[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;\0&#x27;</span>)    <span class="hljs-comment">// empty line?</span><br>            <span class="hljs-keyword">break</span>;              <span class="hljs-comment">// i not incremented</span><br>        <span class="hljs-keyword">else</span><br>            sayings[i] = temp;  <span class="hljs-comment">// overloaded assignment</span><br>    &#125;<br>    <span class="hljs-type">int</span> total = i;              <span class="hljs-comment">// total # of lines read</span><br><br>    <span class="hljs-keyword">if</span> ( total &gt; <span class="hljs-number">0</span>)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Here are your sayings:\n&quot;</span>;<br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; total; i++)<br>            cout &lt;&lt; sayings[i][<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-string">&quot;: &quot;</span> &lt;&lt; sayings[i] &lt;&lt; endl;<br><br>        <span class="hljs-type">int</span> shortest = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> first = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; total; i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (sayings[i].<span class="hljs-built_in">length</span>() &lt; sayings[shortest].<span class="hljs-built_in">length</span>())<br>                shortest = i;<br>            <span class="hljs-keyword">if</span> (sayings[i] &lt; sayings[first])<br>                first = i;<br>        &#125;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Shortest saying:\n&quot;</span> &lt;&lt; sayings[shortest] &lt;&lt; endl;;<br>        cout &lt;&lt; <span class="hljs-string">&quot;First alphabetically:\n&quot;</span> &lt;&lt; sayings[first] &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">&quot;This program used &quot;</span>&lt;&lt; String::<span class="hljs-built_in">HowMany</span>() <br>             &lt;&lt; <span class="hljs-string">&quot; String objects. Bye.\n&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;No input! Bye.\n&quot;</span>;<br><span class="hljs-comment">// keep window open </span><br><span class="hljs-comment">/*    if (!cin)</span><br><span class="hljs-comment">        cin.clear();</span><br><span class="hljs-comment">    while (cin.get() != &#x27;\n&#x27;)</span><br><span class="hljs-comment">        continue; */</span> <br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="类中动态内存的使用"><a href="#类中动态内存的使用" class="headerlink" title="类中动态内存的使用"></a>类中动态内存的使用</h2><p>通过string类的实现，我们不难发现<strong>动态内存</strong>在类中的使用既便捷，又危险。下文总结了在类与对象定义过程中应当注意的易错点：</p><ul><li><p>使用<code>new</code>创建指针成员，应该在析构函数中使用<code>delete</code></p><ul><li><p><strong>注意点：尽量不要定义类中的静态指针成员，若需要请额外关注其生命周期！</strong></p></li><li><p>在C++中，如果你在类中定义了一个静态指针成员变量，你需要特别注意其生命周期的管理，因为静态成员变量在程序的整个生命周期内只存在一个实例。这意味着：</p><ol><li><strong>初始化</strong>：静态成员变量需要在类外进行初始化。</li><li><strong>内存管理</strong>：如果你使用了动态分配内存（例如，使用<code>new</code>关键字），你需要确保在程序结束之前手动释放这块内存。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span>* staticPointer;<br>&#125;;<br><br><span class="hljs-comment">// 类外初始化</span><br><span class="hljs-type">int</span>* MyClass::staticPointer = <span class="hljs-literal">nullptr</span>;<br></code></pre></td></tr></table></figure><ul><li><p><strong>程序结束之前</strong>：静态成员变量的生命周期与程序相同，因此在程序结束之前，你应该确保所有动态分配的内存被正确释放。这通常意味着在<code>main</code>函数结束之前或在某个全局清理函数中进行<code>delete</code>操作。</p></li><li><p><strong>自定义的清理函数</strong>：如果你希望在程序结束之前明确地控制删除静态成员变量的时间，你可以创建一个函数来执行清理操作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">cleanup</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">delete</span> MyClass::staticPointer;<br>    MyClass::staticPointer = <span class="hljs-literal">nullptr</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 程序运行...</span><br>    <span class="hljs-built_in">cleanup</span>(); <span class="hljs-comment">// 在程序结束前调用</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>使用智能指针</strong>：为了避免手动管理内存，可以考虑使用智能指针（例如<code>std::unique_ptr</code>或<code>std::shared_ptr</code>）来管理静态成员变量的生命周期。这样，内存管理将由智能指针自动处理：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">static</span> std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; staticPointer;<br>&#125;;<br><br><span class="hljs-comment">// 初始化</span><br>std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; MyClass::staticPointer = std::<span class="hljs-built_in">make_unique</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure><p>在这种情况下，你不需要手动<code>delete</code>，因为<code>unique_ptr</code>会在超出作用域时自动释放内存。</p></li><li><p><strong>避免重复删除</strong>：确保你不会多次<code>delete</code>同一个指针，因为这会导致未定义行为。</p></li><li><p>**检查指针是否为<code>nullptr</code>**：在删除静态指针前，检查它是否已经指向了有效的内存地址，防止对<code>nullptr</code>进行<code>delete</code>操作。</p></li></ul></li><li><p>推荐使用C++中的新的关键字<code>nullptr</code>（来替代C风格的<code>NULL</code>）</p></li></ul></li><li><p>注意C++中自动提供的若干<strong>特殊成员函数</strong></p><ul><li>默认构造函数</li><li>默认析构函数</li><li>（隐式）的复制构造函数</li><li>赋值运算符</li><li>地址运算符</li><li><strong>注意：如果你设计的类成员中存在指针等，请务必手动构建显式的成员函数！！！否则会因为按值传递和按址传递的冲突导致很多奇奇怪怪的问题（尤其在赋值和动态内存的手动管理上）</strong></li></ul></li><li><p><code>new</code>和<code>delete</code>很危险，但请踏出使用他们的第一步！</p></li></ul><p>例如，原书给出了三个定义构造函数的实例：</p><p><img src="/posts/Dynamic-Memory-and-Classes/example1.png"></p><p><img src="/posts/Dynamic-Memory-and-Classes/example2.png" alt="Standard Practices for Using Dynamic Memory"></p><h2 id="返回对象"><a href="#返回对象" class="headerlink" title="返回对象"></a>返回对象</h2><h3 id="返回类的引用"><a href="#返回类的引用" class="headerlink" title="返回类的引用"></a>返回类的引用</h3><p>在C++中，引用同样也是奉行“按址传递”思想的一大有力武器。在类中，返回引用不用拷贝一个类（这会消耗额外的内存），自然也不会调用复制构造函数。下文将介绍在类中返回引用的一些基础知识：</p><ul><li><p>使用<code>const</code>引用，效率更高，但同时需要注意匹配问题：</p><ul><li>如果形式参数是<code>const</code>对象的话，返回值也应该是<code>const</code>对象！</li></ul></li><li><p>返回指向非const对象的引用</p><ul><li>重载赋值运算符</li></ul><p>例如，我想实现一个连续赋值的操作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++">string s1=<span class="hljs-string">&quot;Hello world&quot;</span>;<br>string s2,s3;<br>s3=s2=s1;<br><span class="hljs-comment">//第三行代码等价于</span><br>s3=(s2=s1);<br></code></pre></td></tr></table></figure><p>首先执行赋值语句 <code>s2=s1</code>，问题来了，表达式的返回值是什么？对于基本数据类型而言，赋值表达式的返回类型是左操作数（即被赋值变量）的引用类型。例如，如果<code>a</code>是一个<code>int</code>变量，那么<code>a = b</code>的返回类型就是<code>int&amp;</code>。如果是自定义类，就需要我们 <strong>关注赋值运算符重载的返回类型、即返回一个自定义类的非const引用</strong>，示例代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 其他成员变量和成员函数...</span><br><br>    <span class="hljs-comment">// 赋值运算符重载</span><br>    MyClass&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> MyClass&amp; other) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;other) &#123; <span class="hljs-comment">// 自赋值检查，防止自我复制</span><br>            <span class="hljs-comment">// 执行实际的赋值操作</span><br>            <span class="hljs-comment">// 例如：</span><br>            <span class="hljs-comment">// this-&gt;data = other.data;</span><br>            <span class="hljs-comment">// ...</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>; <span class="hljs-comment">// 返回当前对象的引用</span><br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 私有成员变量</span><br>    <span class="hljs-type">int</span> data;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    MyClass a, b, c;<br>    <span class="hljs-comment">// 链式赋值</span><br>    a = b = c; <span class="hljs-comment">// 这将按预期工作</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><p>为什么是自身类型的非const引用？一方面，为了连续链式赋值的合法性，我们必须保证首先执行的赋值语句的返回值能够作为参数传入下一个赋值语句，例如在上面的代码中，首先执行的<code>s2=s1</code>，返回值是对s2的引用，而这正好能作为参数传入到下一个赋值语句（将<code>s2</code>的值传递给<code>s3</code>，在这里是s2的引用）。另一方面，由于赋值会改变对象的值，因此不可以使用const引用，故返回一个<strong>自身类型的非const引用</strong>。</p></blockquote><ul><li><code>&lt;&lt;</code>运算符</li></ul><p>这其实和赋值运算符的本质差不多，运算符的本质还是一个<strong>函数</strong>，所以运算（表达式）一定会有返回值（<strong>这个观点非常重要，对我们后续学习运算符重载有很大的帮助</strong>）。我们知道，<strong>流输出运算符的返回值是对流对象的引用</strong>，例如<code>cout&lt;&lt;&quot;Hello&quot;&lt;&lt;&quot;World&quot;;</code>返回的对象是<code>std::ostream&amp;</code>。</p><blockquote><p>还记得第一堂C++课的时候笔者接触到cin和cout，感叹其功能强大之处。但在之后的coding过程中，各种花里胡哨的输入输出类型让笔者恼羞成怒，甚至在一段时间内换回了C风格的<code>printf()</code>和<code>scanf()</code>。但是随着学习的深入，当我们对<strong>流</strong>和引用，类，对象等C++的新概念有了更深刻的理解之后，我们便能体会到cin和cout的强大究竟是如何实现的！</p></blockquote></li></ul><h3 id="返回局部变量：返回对象"><a href="#返回局部变量：返回对象" class="headerlink" title="返回局部变量：返回对象"></a>返回局部变量：返回对象</h3><p>考虑到局部变量的作用域，我们不应该在函数中返回一个局部变量的引用（否则会产生悬挂指针等非常严重的问题）。因此，我们需要<strong>返回一个对象</strong>。看下面的代码示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++">Vector Vector::operater+(<span class="hljs-type">const</span> Vector &amp; b) <span class="hljs-type">const</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">Vector</span>(x+b.x,y+b.y);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Vector</code>（向量）相信大家不陌生，在这里重载了算数运算符<code>+</code>，将两个矢量的和储存在一个新的临时对象中，作为函数的返回值之后再进行相关的赋值操作，最后被丢弃。<strong>在这里会不可避免的使用到复制构造函数，所以务必小心。</strong></p><p>为了保证安全性，可以返回一个<strong>const 对象</strong>，这样可以保证生成的临时对象的值不会被赋值运算符修改。</p><h2 id="使用指向对象的指针"><a href="#使用指向对象的指针" class="headerlink" title="使用指向对象的指针"></a>使用指向对象的指针</h2><h3 id="基本用法回顾"><a href="#基本用法回顾" class="headerlink" title="基本用法回顾"></a>基本用法回顾</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++">  <span class="hljs-comment">// use pointers to keep track of shortest, first strings</span><br>      String * shortest = &amp;sayings[<span class="hljs-number">0</span>]; <span class="hljs-comment">// initialize to first object</span><br>      String * first = &amp;sayings[<span class="hljs-number">0</span>];<br>      <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; total; i++)<br>      &#123;<br>          <span class="hljs-keyword">if</span> (sayings[i].<span class="hljs-built_in">length</span>() &lt; shortest-&gt;<span class="hljs-built_in">length</span>())<br>              shortest = &amp;sayings[i];<br>          <span class="hljs-keyword">if</span> (sayings[i] &lt; *first)     <span class="hljs-comment">// compare values</span><br>              first = &amp;sayings[i];     <span class="hljs-comment">// assign address</span><br>      &#125;<br>      cout &lt;&lt; <span class="hljs-string">&quot;Shortest saying:\n&quot;</span> &lt;&lt; * shortest &lt;&lt; endl;<br>      cout &lt;&lt; <span class="hljs-string">&quot;First alphabetically:\n&quot;</span> &lt;&lt; * first &lt;&lt; endl;<br><br>      <span class="hljs-built_in">srand</span>(<span class="hljs-built_in">time</span>(<span class="hljs-number">0</span>));<br>      <span class="hljs-type">int</span> choice = <span class="hljs-built_in">rand</span>() % total; <span class="hljs-comment">// pick index at random</span><br><br><br><br>  <span class="hljs-comment">// use new to create, initialize new String object</span><br>      String * favorite = <span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(sayings[choice]);<br><span class="hljs-comment">//这里会调用相应的构造函数</span><br>      cout &lt;&lt; <span class="hljs-string">&quot;My favorite saying:\n&quot;</span> &lt;&lt; *favorite &lt;&lt; endl;<br>      <span class="hljs-keyword">delete</span> favorite;<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>      cout &lt;&lt; <span class="hljs-string">&quot;Not much to say, eh?\n&quot;</span>;<br>  cout &lt;&lt; <span class="hljs-string">&quot;Bye.\n&quot;</span>;<br></code></pre></td></tr></table></figure><p>代码的第一部分是指向对象指针的常见用法，包括<code>-&gt;</code>运算符，常见的取址和解引用运算。代码的第二部分涉及到<code>new</code>和<code>delete</code>操作。</p><h3 id="一些高级用法"><a href="#一些高级用法" class="headerlink" title="一些高级用法"></a>一些高级用法</h3><h4 id="何时使用析构函数？"><a href="#何时使用析构函数？" class="headerlink" title="何时使用析构函数？"></a>何时使用析构函数？</h4><p><img src="/posts/Dynamic-Memory-and-Classes/%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0.png" alt="析构函数"></p><p>在下述情况下析构函数将被调用（参见图 12.4）。</p><ul><li>如果对象是动态变量，则当<strong>执行完定义该对象的程序块</strong>时，将调用该对象的析构函数。</li><li>如果对象是<strong>静态变量（外部、静态、静态外部或来自名称空间）</strong>，则在程序结束时将调用对象的析构函数。</li><li>如果对象是用 new 创建的，则仅当您<strong>显式使用 delete 删除对象</strong>时，其析构函数才会被调用。</li></ul><p>例如在上面的例子中，一共定义了三个基于<code>Act</code>类的对象：<code>nice</code>（全局变量，与程序共存亡）、<code>pt</code>（使用new定义的一个指向Act类的指针）、<code>up</code>（在一个代码块中定义的自动局部变量）</p><p><strong>注意！</strong></p><ul><li><p>如果析构函数通过对指针类成员使用 delete 来释放内存，则每个构造函数都应当使用 new 来初始化指针，或将它设置为空指针。</p><blockquote><p>如果类的析构函数使用<code>delete</code>来释放指针成员，那么意味着这个指针成员在对象的生命周期内被认为是指向动态分配的内存的。为了确保在对象被销毁时不会尝试删除一个未初始化的指针，每个构造函数都应该使用<code>new</code>来为指针成员分配内存，或者将指针成员初始化为<code>nullptr</code>（在C++11及以后的版本中使用<code>nullptr</code>，之前的版本使用<code>NULL</code>或<code>0</code>）</p></blockquote></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyClass</span>() : <span class="hljs-built_in">data</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">42</span>)) &#123;&#125; <span class="hljs-comment">// 初始化指针成员</span><br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">int</span> val) : <span class="hljs-built_in">data</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(val)) &#123;&#125; <span class="hljs-comment">// 另一种初始化方式</span><br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">MyClass</span><span class="hljs-params">(<span class="hljs-type">bool</span> flag)</span> : data(nullptr) &#123;</span>&#125; <span class="hljs-comment">// 将指针设置为空指针</span><br>    ~<span class="hljs-built_in">MyClass</span>() &#123;<br>        <span class="hljs-keyword">delete</span> data;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span>* data;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h4 id="定位new运算符"><a href="#定位new运算符" class="headerlink" title="定位new运算符"></a>定位new运算符</h4><h5 id="什么是定位new运算符？"><a href="#什么是定位new运算符？" class="headerlink" title="什么是定位new运算符？"></a>什么是定位new运算符？</h5><p><strong>定位new运算符</strong>（Placement New Operator）是C++中一种特殊的<code>new</code>运算符，它允许你将对象构造在预先分配好的内存位置上，而不像常规的<code>new</code>那样动态分配内存。这在某些情况下特别有用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">void</span>* memory = ...; <span class="hljs-comment">// 预先分配好的内存</span><br>SomeType* obj = <span class="hljs-built_in">new</span> (memory) <span class="hljs-built_in">SomeType</span>(arguments); <span class="hljs-comment">// 构造对象在预先分配的内存上</span><br></code></pre></td></tr></table></figure><p>这里的<code>memory</code>是一个指向已经分配好的内存的指针，<code>SomeType</code>是你的类或类型，<code>arguments</code>是传递给构造函数的参数。</p><ol><li><p><strong>不分配内存</strong>：定位new不会分配新的内存，它只是在<strong>给定的内存位置上调用构造函数来初始化对象</strong>。</p></li><li><p><strong>手动内存管理</strong>：使用定位new意味着你必须手动管理内存的生命周期，包括确保内存是在定位new之前分配的，并且在对象不再需要时正确地调用析构函数。</p></li><li><p><strong>异常安全性</strong>：如果构造函数抛出异常，定位new不会自动释放内存，因为它没有分配新的内存。你需要手动处理异常情况。</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">int</span> val) : <span class="hljs-built_in">value</span>(val) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Constructing MyClass with value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;<br>    &#125;<br>    ~<span class="hljs-built_in">MyClass</span>() &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Destructing MyClass with value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-type">int</span> value;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 预先分配一块内存</span><br>    <span class="hljs-type">char</span>* buffer = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-built_in">sizeof</span>(MyClass)];<br>    <br>    <span class="hljs-comment">// 使用定位new在预先分配的内存上构造对象</span><br>    MyClass* obj = <span class="hljs-built_in">new</span> (buffer) <span class="hljs-built_in">MyClass</span>(<span class="hljs-number">42</span>);<br>    <br>    <span class="hljs-comment">// 使用对象</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Object value: &quot;</span> &lt;&lt; obj-&gt;value &lt;&lt; std::endl;<br>    <br>    <span class="hljs-comment">// 手动调用析构函数</span><br>    obj-&gt;~<span class="hljs-built_in">MyClass</span>();<br>    <br>    <span class="hljs-comment">// 释放预先分配的内存</span><br>    <span class="hljs-keyword">delete</span>[] buffer;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="定位new运算符的使用注意事项"><a href="#定位new运算符的使用注意事项" class="headerlink" title="定位new运算符的使用注意事项"></a>定位new运算符的使用注意事项</h5><p>下面的程序对普通的<code>new</code>使用和<code>定位new运算符</code>的使用进行了比较，并归纳出使用<code>定位new运算符</code>的常见易错点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// placenew1.cpp  -- new, placement new, no delete</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;new&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> BUF = <span class="hljs-number">512</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">JustTesting</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>    string words;<br>    <span class="hljs-type">int</span> number;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">JustTesting</span>(<span class="hljs-type">const</span> string &amp; s = <span class="hljs-string">&quot;Just Testing&quot;</span>, <span class="hljs-type">int</span> n = <span class="hljs-number">0</span>) <br>    &#123;words = s; number = n; cout &lt;&lt; words &lt;&lt; <span class="hljs-string">&quot; constructed\n&quot;</span>; &#125;<br>    <span class="hljs-comment">//默认构造函数</span><br>    ~<span class="hljs-built_in">JustTesting</span>() &#123; cout &lt;&lt; words &lt;&lt; <span class="hljs-string">&quot; destroyed\n&quot;</span>;&#125;<br>    <span class="hljs-comment">//析构函数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Show</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; cout &lt;&lt; words &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; number &lt;&lt; endl;&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">char</span> * buffer = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[BUF];       <span class="hljs-comment">// get a block of memory</span><br><br>    JustTesting *pc1, *pc2;<br><br>    pc1 = <span class="hljs-built_in">new</span> (buffer) JustTesting;      <span class="hljs-comment">// place object in buffer</span><br>    pc2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">JustTesting</span>(<span class="hljs-string">&quot;Heap1&quot;</span>, <span class="hljs-number">20</span>);  <span class="hljs-comment">// place object on heap（直接在堆上分配内存）</span><br>    <br>    cout &lt;&lt; <span class="hljs-string">&quot;Memory block addresses:\n&quot;</span> &lt;&lt; <span class="hljs-string">&quot;buffer: &quot;</span>&lt;&lt; (<span class="hljs-type">void</span> *) buffer &lt;&lt; <span class="hljs-string">&quot;    heap: &quot;</span> &lt;&lt; pc2 &lt;&lt;endl;<br>    <span class="hljs-comment">//void*使buffer被强制转换成通用指针使其打印地址而不是字符串的值</span><br>    <br>    cout &lt;&lt; <span class="hljs-string">&quot;Memory contents:\n&quot;</span>;<br>    cout &lt;&lt; pc1 &lt;&lt; <span class="hljs-string">&quot;: &quot;</span>;<br>    pc1-&gt;<span class="hljs-built_in">Show</span>();<br>    cout &lt;&lt; pc2 &lt;&lt; <span class="hljs-string">&quot;: &quot;</span>;<br>    pc2-&gt;<span class="hljs-built_in">Show</span>();<br><br>    JustTesting *pc3, *pc4;<br>    pc3 = <span class="hljs-built_in">new</span> (buffer) <span class="hljs-built_in">JustTesting</span>(<span class="hljs-string">&quot;Bad Idea&quot;</span>, <span class="hljs-number">6</span>);<br>    pc4 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">JustTesting</span>(<span class="hljs-string">&quot;Heap2&quot;</span>, <span class="hljs-number">10</span>);<br>    cout &lt;&lt; <span class="hljs-string">&quot;Memory contents:\n&quot;</span>;<br>    cout &lt;&lt; pc3 &lt;&lt; <span class="hljs-string">&quot;: &quot;</span>;<br>    pc3-&gt;<span class="hljs-built_in">Show</span>();<br>    cout &lt;&lt; pc4 &lt;&lt; <span class="hljs-string">&quot;: &quot;</span>;<br>    pc4-&gt;<span class="hljs-built_in">Show</span>();<br>    <br>    <span class="hljs-keyword">delete</span> pc2;                          <span class="hljs-comment">// free Heap1         </span><br>    <span class="hljs-keyword">delete</span> pc4;                          <span class="hljs-comment">// free Heap2</span><br>    <span class="hljs-keyword">delete</span> [] buffer;                    <span class="hljs-comment">// free buffer</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;Done\n&quot;</span>;<br>    <span class="hljs-comment">// std::cin.get();</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>输出示例：</strong></p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">Just Testing constructed</span><br><span class="hljs-attribute">Heap1 constructed</span><br><span class="hljs-attribute">Memory block addresses</span><span class="hljs-punctuation">:</span><br><span class="hljs-attribute">buffer</span><span class="hljs-punctuation">:</span> <span class="hljs-string">0xf61e80    heap: 0xf62090</span><br><span class="hljs-attribute">Memory contents</span><span class="hljs-punctuation">:</span><br><span class="hljs-attribute">0xf61e80</span><span class="hljs-punctuation">:</span> <span class="hljs-string">Just Testing, 0</span><br><span class="hljs-attribute">0xf62090</span><span class="hljs-punctuation">:</span> <span class="hljs-string">Heap1, 20</span><br><span class="hljs-attribute">Bad Idea constructed</span><br><span class="hljs-attribute">Heap2 constructed</span><br><span class="hljs-attribute">Memory contents</span><span class="hljs-punctuation">:</span><br><span class="hljs-attribute">0xf61e80</span><span class="hljs-punctuation">:</span> <span class="hljs-string">Bad Idea, 6</span><br><span class="hljs-attribute">0xf620c0</span><span class="hljs-punctuation">:</span> <span class="hljs-string">Heap2, 10</span><br>Heap1 destroyed<br>Heap2 destroyed<br>Done<br></code></pre></td></tr></table></figure><p><strong>①覆盖问题</strong></p><p>尝试读懂代码的执行逻辑并观察输出示例，我们不难发现 <code>Just Testing</code>（pc1，调用了默认构造函数）和 <code>Bad Idea</code>（pc3，调用了显式构造函数和复制构造函数）两块存储的内存是相同的，都是 <code>buffer: 0xf61e80</code>的内存。</p><p>这会带来一个比较严重的问题，我们的初衷是在分配好的内存块上同时储存pc1和pc3两个指针指向的对象的内存，但是新对象（pc3指向的对象）<strong>在程序中覆盖掉了原来pc1所指向的对象，导致值的丢失</strong>。例如，如果我在代码的44行后加上<code>pc1-&gt;Show();</code>输出的结果会是<code>Bad Idea, 6</code>，原来pc1指向的对象的值已经被覆盖。</p><p>因此，程序员必须手动管理定位new运算符，使不同的指针指向不同区域的内存，互不冲突。修改方式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">pc1=<span class="hljs-built_in">new</span>(buffer) JustTesting;<br>pc3=<span class="hljs-built_in">new</span>(buffer+<span class="hljs-built_in">sizeof</span>(JustTesting)) <span class="hljs-built_in">JustTesting</span>(<span class="hljs-string">&quot;Better idea&quot;</span>,<span class="hljs-number">6</span>);<br></code></pre></td></tr></table></figure><p>在定义pc3的时候，加上了<code>sizeof(JustTesting)</code>，保证了两块被分配的内存不会产生重叠。</p><p><strong>②何时delete？</strong></p><p><strong>使用定位new运算符分配的内存在delete时要格外的小心！</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">delete</span> pc2;                          <span class="hljs-comment">// free Heap1         </span><br><span class="hljs-keyword">delete</span> pc4;                          <span class="hljs-comment">// free Heap2</span><br><span class="hljs-keyword">delete</span> [] buffer;                    <span class="hljs-comment">// free buffer</span><br>cout &lt;&lt; <span class="hljs-string">&quot;Done\n&quot;</span>;<br></code></pre></td></tr></table></figure><p>源代码中<code>delete</code>掉了所有动态分配的内存，包括p2，p4。p1，p3由于使用了定位new运算符，因此在delete掉buffer的内存指定区域后，p1，p3自然也就被delete掉了。这并不难理解，但是请注意以下操作是非法的！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">delete</span> pc2;                          <span class="hljs-comment">// free Heap1         </span><br><span class="hljs-keyword">delete</span> pc4;                          <span class="hljs-comment">// free Heap2</span><br><span class="hljs-keyword">delete</span> pc1;<span class="hljs-comment">//INVALID!</span><br><span class="hljs-keyword">delete</span> pc3;<span class="hljs-comment">//INVALID!</span><br></code></pre></td></tr></table></figure><p>原书中这一段讲的非常清楚并且直白，直接贴上来：</p><p>原因在于 delete 可与常规 new 运算符配合使用，但<strong>不能与定位 new 运算符配合使用</strong>。例如，指针 pc3 没有收到 new 运算符返回的地址，因此 <strong>delete pc3 将导致运行阶段错误</strong>。在另一方面，指针pc1 指向的地址与 buffer 相同， 但 buffer 是使用 new []初始化的，因此必须使用 delete [ ]而不是 delete来释放。即使 buffer 是使用 new 而不是 new []初始化的， delete pc1 也将释放 buffer，而不是 pc1。这是因为 new&#x2F;delete 系统知道已分配的 512 字节块 buffer，但对定位 new 运算符对该内存块做了何种处理一无所知。  </p><blockquote><p>总之一句话：<strong>不能混着用</strong>！</p></blockquote><p>那么，如何只delete我们定义的pc1和pc3而不delete掉整块buffer内存呢？我们可以<strong>显示地为定位new运算符创建的对象调用析构函数，销毁指定的对象。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++">pc3 = <span class="hljs-built_in">new</span> (buffer + <span class="hljs-built_in">sizeof</span> (JustTesting))<br>            <span class="hljs-built_in">JustTesting</span>(<span class="hljs-string">&quot;Better Idea&quot;</span>, <span class="hljs-number">6</span>);<br>pc4 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">JustTesting</span>(<span class="hljs-string">&quot;Heap2&quot;</span>, <span class="hljs-number">10</span>);<br><br>cout &lt;&lt; <span class="hljs-string">&quot;Memory contents:\n&quot;</span>;<br>cout &lt;&lt; pc3 &lt;&lt; <span class="hljs-string">&quot;: &quot;</span>;<br>pc3-&gt;<span class="hljs-built_in">Show</span>();<br>cout &lt;&lt; pc4 &lt;&lt; <span class="hljs-string">&quot;: &quot;</span>;<br>pc4-&gt;<span class="hljs-built_in">Show</span>();<br><br><span class="hljs-keyword">delete</span> pc2;           <span class="hljs-comment">// free Heap1         </span><br><span class="hljs-keyword">delete</span> pc4;           <span class="hljs-comment">// free Heap2</span><br><span class="hljs-comment">// explicitly destroy placement new objects</span><br>pc3-&gt;~<span class="hljs-built_in">JustTesting</span>();  <span class="hljs-comment">// destroy object pointed to by pc3</span><br>pc1-&gt;~<span class="hljs-built_in">JustTesting</span>();  <span class="hljs-comment">// destroy object pointed to by pc1</span><br><span class="hljs-comment">//这样的操作保证了我可以只delete两个指针指向的动态内存，但不delete掉buffer内存</span><br><span class="hljs-keyword">delete</span> [] buffer;     <span class="hljs-comment">// free buffer</span><br></code></pre></td></tr></table></figure><h2 id="ADT-for-queue"><a href="#ADT-for-queue" class="headerlink" title="ADT for queue"></a>ADT for queue</h2><p>因为篇幅限制，本博客不再转载这部分内容，而将其移动到<code>数据结构和算法部分</code>更新~</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li>《C++ Primer Plus》</li></ul><blockquote><p>THE END 2024&#x2F;12&#x2F;7</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Code</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tutorial</tag>
      
      <tag>Finished</tag>
      
      <tag>C/C++</tag>
      
      <tag>OOP</tag>
      
      <tag>C++ Primer Plus</tag>
      
      <tag>Dynamic Memory</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Introduction-to-OOP</title>
    <link href="/posts/Introduction-to-OOP/"/>
    <url>/posts/Introduction-to-OOP/</url>
    
    <content type="html"><![CDATA[<style>  html, body, .markdown-body {    font-family: Georgia, sans, serif;  }</style><h1 id="Introduction-to-OOP"><a href="#Introduction-to-OOP" class="headerlink" title="Introduction to OOP"></a>Introduction to OOP</h1><h1 id="C-Primer-Plus-Tutorial-10-11"><a href="#C-Primer-Plus-Tutorial-10-11" class="headerlink" title="C++ Primer Plus Tutorial-10&#x2F;11"></a>C++ Primer Plus Tutorial-10&#x2F;11</h1><h1 id="面向对象编程教程——Section①"><a href="#面向对象编程教程——Section①" class="headerlink" title="面向对象编程教程——Section①"></a>面向对象编程教程——Section①</h1><center><p style="color: red;"><b><font size=6.5>Chapter 10/11 Object Oriented Programming</font></b></p></center><center><p style="color: red;"><b><font size=6.5>面向对象编程引论</font></b></p></center><p>【写在前面的话】</p><p><a href="https://xiyuanyang-code.github.io/posts/C-plus-plus-Primer-Plus-tutorial/">C++ Primer Plus Tutorial</a></p><p><a href="https://xiyuanyang-code.github.io/tags/OOP/">系列文章</a></p><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>欢迎来到<strong>面向对象编程</strong>的世界！首先文章将会向你介绍在面向对象编程中四个最核心的精神：<strong>封装、继承、多态和抽象</strong>，并对面向对象所涉及的知识做一个总体性的概览。接下来，你将系统学习到什么是<strong>类和对象</strong>，以及如何创建并使用自己的类和对象。文章的内容涵盖<strong>构造函数</strong>的四种定义、<strong>析构函数</strong>的使用、<strong>静态和动态</strong>数据成员以及成员函数、<strong>友元函数</strong>、<strong>const函数</strong>的用法、<strong>this指针</strong>以及类的自动类型转换等知识。</p><p>Welcome to the world of <strong>Object-Oriented Programming (OOP)</strong>! This article will first introduce you to the four core principles of OOP: <strong>Encapsulation, Inheritance, Polymorphism, and Abstraction</strong>, and provide an overview of the knowledge involved in OOP. Next, you will systematically learn what <strong>classes and objects</strong> are, and how to create and use your own classes and objects. The article covers topics such as the four definitions of <strong>constructors</strong>, the use of <strong>destructors</strong>, <strong>static</strong> and <strong>dynamic</strong> data members and member functions, <strong>friend functions</strong>, the usage of const functions, the <strong><code>this</code></strong> pointer, and <strong>automatic type conversion of classes</strong>, among others.</p><p><strong>Key words: OOP, constructors, destructors, this pointer, friend functions</strong></p><h2 id="常见知识点概览"><a href="#常见知识点概览" class="headerlink" title="常见知识点概览"></a>常见知识点概览</h2><blockquote><p>在这个部分，我们将先对OOP的基本概念做一个系统性的梳理和总结。如果你是第一次接触面向对象，建议看完 <code>The Art of Object Oriented Programming</code>后跳转到对应内容处学习，最后再来看总结。</p></blockquote><h3 id="1-The-Art-of-Object-Oriented-Programming"><a href="#1-The-Art-of-Object-Oriented-Programming" class="headerlink" title="1. The Art of Object Oriented Programming"></a>1. The Art of Object Oriented Programming</h3><p>什么是面向对象编程？这是C++引入的一个<strong>新的特性</strong>。它是一种程序设计范式，它将现实世界的事物抽象成<strong>对象</strong>，通过封装、继承、多态和抽象等机制，使得代码更加模块化、易维护和可扩展。在OOP中，<strong>对象</strong>是类的实例，代表了具体的实体，它包含了属性（数据）和方法（操作）。这些对象通过交互来实现程序的功能。</p><p>初学者在入门OOP时，往往会感觉到非常的不适应，因为面向对象的语法规则艰深晦涩，并且创建类和对象需要注意到很多很多的细节，稍不留神便报错满天飞。<strong>经过2个月的OOP学习</strong>，笔者认为初学OOP最忌讳的就是将重点放在记忆语法规则上，而应该<strong>将重点放在面向对象的四个基本精神：封装、继承、多态、抽象</strong>，以此为出发点，尝试在实践中创建自己的类，并运用的过程中同步熟悉语法规则。</p><div class="note note-primary">            <p><strong>封装（Encapsulation）</strong>：</p><ul><li>封装是将数据和操作数据的方法（成员函数）包装在一个单一的单元（类）中，隐藏类的内部实现细节，只暴露必要的<strong>接口</strong>。</li><li>封装在保证数据安全性的同时，也允许了代码的后续生长。</li></ul><p><strong>继承（Inheritance）</strong>：</p><ul><li>继承允许一个类（子类）获得另一个类（基类或父类）的属性和方法，从而实现代码的复用和层次结构的建立。</li></ul><p><strong>多态（Polymorphism）</strong>：</p><ul><li>多态指的是同一个接口可以有多种不同的实现方式。C++通过虚函数和重载实现多态。</li></ul><p><strong>抽象（Abstraction）</strong>：</p><ul><li>抽象是将复杂的现实世界简化成计算机程序可以处理的模型。通过定义抽象类（含有纯虚函数的类），可以强制子类实现某些方法。</li></ul>          </div><h3 id="2-类和对象"><a href="#2-类和对象" class="headerlink" title="2. 类和对象"></a>2. 类和对象</h3><p><strong>类（Class）</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> m_value; <span class="hljs-comment">// 私有成员变量</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">int</span> val) : <span class="hljs-built_in">m_value</span>(val) &#123;&#125; <span class="hljs-comment">// 构造函数</span><br>    ~<span class="hljs-built_in">MyClass</span>() &#123;&#125; <span class="hljs-comment">// 析构函数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setValue</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> </span>&#123; m_value = val; &#125; <span class="hljs-comment">// 成员函数</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getValue</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> m_value; &#125; <span class="hljs-comment">// const成员函数</span><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><strong>构造函数</strong>：初始化对象的成员变量。</li><li><strong>析构函数</strong>：当对象被销毁时执行清理工作。</li><li><strong>成员函数</strong>：操作类的数据成员。</li></ul><p><strong>对象（Object）</strong>：</p><ul><li>对象是类的实例化。通过类定义来创建对象。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">MyClass <span class="hljs-title">obj</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>; <span class="hljs-comment">// 创建一个MyClass的对象</span><br></code></pre></td></tr></table></figure><h3 id="3-继承"><a href="#3-继承" class="headerlink" title="3. 继承"></a>3. 继承</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Base&quot;</span>; &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123; <span class="hljs-comment">// 公有继承</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Derived&quot;</span>; &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><strong>公有继承</strong>：子类可以继承基类的公有和保护成员。</li><li><strong>私有继承</strong>：子类只能继承基类的保护成员，基类的公有成员变为私有。</li><li><strong>保护继承</strong>：子类可以继承基类的保护成员，基类的公有成员变为保护。</li></ul><h3 id="4-多态"><a href="#4-多态" class="headerlink" title="4. 多态"></a>4. 多态</h3><p><strong>虚函数（Virtual Functions）</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Base&quot;</span>; &#125; <span class="hljs-comment">// 虚函数</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Derived&quot;</span>; &#125; <span class="hljs-comment">// 重写虚函数</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Base* b = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Derived</span>();<br>    b-&gt;<span class="hljs-built_in">display</span>(); <span class="hljs-comment">// 输出：Derived</span><br>    <span class="hljs-keyword">delete</span> b;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>纯虚函数</strong>：<code>virtual void func() = 0;</code> 定义了接口，但不提供实现，必须在派生类中实现。</li></ul><h3 id="5-抽象类和接口"><a href="#5-抽象类和接口" class="headerlink" title="5. 抽象类和接口"></a>5. 抽象类和接口</h3><ul><li>包含纯虚函数的类称为抽象类，不能直接实例化，必须通过继承来实现。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">double</span> <span class="hljs-title">area</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">// 纯虚函数</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> : <span class="hljs-keyword">public</span> Shape &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">double</span> radius;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Circle</span>(<span class="hljs-type">double</span> r) : <span class="hljs-built_in">radius</span>(r) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">area</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-number">3.14159</span> * radius * radius; &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="6-封装和访问控制"><a href="#6-封装和访问控制" class="headerlink" title="6. 封装和访问控制"></a>6. 封装和访问控制</h3><ul><li><strong>公有（public）</strong>：任何代码都可以访问。</li><li><strong>私有（private）</strong>：只能在类内部访问。</li><li><strong>保护（protected）</strong>：在类和派生类中可以访问。</li></ul><h3 id="7-构造函数和析构函数"><a href="#7-构造函数和析构函数" class="headerlink" title="7. 构造函数和析构函数"></a>7. 构造函数和析构函数</h3><ul><li><strong>构造函数</strong>：用于初始化对象。</li><li><strong>析构函数</strong>：用于清理对象资源。</li></ul><h3 id="8-友元（Friend）"><a href="#8-友元（Friend）" class="headerlink" title="8. 友元（Friend）"></a>8. 友元（Friend）</h3><ul><li>友元函数或类可以访问类的私有和保护成员，但这打破了封装性，应谨慎使用。</li></ul><h3 id="9-静态成员"><a href="#9-静态成员" class="headerlink" title="9. 静态成员"></a>9. 静态成员</h3><ul><li><strong>静态成员变量</strong>：共享所有对象的单一实例。</li><li><strong>静态成员函数</strong>：不与任何对象实例关联，只能访问静态成员。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> count;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">incrementCount</span><span class="hljs-params">()</span> </span>&#123; count++; &#125;<br>&#125;;<br><br><span class="hljs-type">int</span> MyClass::count = <span class="hljs-number">0</span>; <span class="hljs-comment">// 静态成员变量的定义和初始化</span><br></code></pre></td></tr></table></figure><h3 id="10-运算符重载"><a href="#10-运算符重载" class="headerlink" title="10. 运算符重载"></a>10. 运算符重载</h3><ul><li>允许自定义类支持标准运算符。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Complex</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">double</span> real, imag;<br>    Complex <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Complex&amp; other) &#123;<br>        <span class="hljs-keyword">return</span> Complex&#123;real + other.real, imag + other.imag&#125;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="Cha-10-对象和类"><a href="#Cha-10-对象和类" class="headerlink" title="Cha 10 对象和类"></a>Cha 10 对象和类</h1><h2 id="数据成员"><a href="#数据成员" class="headerlink" title="数据成员"></a>数据成员</h2><ul><li>一般来说，私有数据成员存储信息，共有成员函数（方法）提供访问数据的唯一途径。（除了<strong>友元函数</strong>）</li></ul><h2 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h2><h3 id="静态成员和静态成员函数"><a href="#静态成员和静态成员函数" class="headerlink" title="静态成员和静态成员函数"></a>静态成员和静态成员函数</h3><div class="note note-primary">            <p>静态成员函数（<code>static</code> member function）是类中的一种特殊成员函数，它与类的对象无关，而是与类本身相关。静态成员函数的主要作用和特点有：</p><ol><li><strong>不依赖于类的对象</strong></li></ol><p>静态成员函数可以在没有实例化对象的情况下调用，因为它不需要访问类的实例成员（非静态成员）。它只能访问类的静态成员变量和其他静态成员函数。静态成员函数不隐式地接收 <code>this</code> 指针，这使得它不能访问非静态成员。</p><ol start="2"><li><strong>访问和操作静态成员</strong></li></ol><p>静态成员函数只能访问静态成员变量和其他静态成员函数。静态成员变量属于类本身，而不是类的某个特定对象。因此，静态成员函数通常用于操作或管理类的静态数据。</p><ol start="3"><li><strong>实例化时不需要对象</strong></li></ol><p>静态成员函数可以通过类名直接调用，而不需要创建类的对象。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> staticVar;<br><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">staticMethod</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Static method called, staticVar = &quot;</span> &lt;&lt; staticVar &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-type">int</span> MyClass::staticVar = <span class="hljs-number">10</span>;<span class="hljs-comment">//静态数据成员需要再类外定义</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    MyClass::<span class="hljs-built_in">staticMethod</span>();  <span class="hljs-comment">// 调用静态成员函数</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>staticMethod()</code> 是静态成员函数，我们通过 <code>MyClass::staticMethod()</code> 直接调用它，而没有创建 <code>MyClass</code> 的对象。</p><ol start="4"><li><strong>用于实现类级别的功能</strong></li></ol><p>静态成员函数适用于那些不依赖于类对象的功能，通常用于实现类级别的操作。例如：</p><ul><li><strong>工具函数</strong>：可以作为与类的对象无关的实用功能，如数学计算、日志记录等。</li><li><strong>工厂方法</strong>：用于创建对象的工厂方法，通常返回类的实例（但不一定需要依赖于实例化对象）。</li><li><strong>共享资源的管理</strong>：静态成员函数可以用于管理类的静态资源，如数据库连接池、缓存等。</li></ul><ol start="5"><li><strong>内存优化</strong></li></ol><p>静态成员函数可以在程序中只存在一个副本，而不需要为每个对象都创建一份。这对内存管理有一定优化作用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Counter</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> count;  <span class="hljs-comment">// 静态成员变量</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Counter</span>() &#123;<br>        count++;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">getCount</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-comment">// 静态成员函数</span><br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 静态成员变量定义</span><br><span class="hljs-type">int</span> Counter::count = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Counter c1, c2;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Object count: &quot;</span> &lt;&lt; Counter::<span class="hljs-built_in">getCount</span>() &lt;&lt; std::endl;  <span class="hljs-comment">// 输出 2</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>count</code> 是一个静态成员变量，它用于记录 <code>Counter</code> 类的对象的数量。<code>getCount()</code> 是静态成员函数，它通过类名调用，返回静态变量 <code>count</code> 的值。</p><p>静态成员函数主要用于：</p><ul><li>不依赖于对象的类级别操作。</li><li>操作和访问静态成员数据。</li><li>在不实例化对象的情况下执行类相关的功能。</li></ul><p>它们是面向类而不是面向实例的，通常用于实现与类的对象无关的逻辑。</p>          </div><div class="note note-primary">            <h3 id="关于const成员函数"><a href="#关于const成员函数" class="headerlink" title="关于const成员函数"></a>关于const成员函数</h3><h5 id="关于const-成员函数的参数问题"><a href="#关于const-成员函数的参数问题" class="headerlink" title="关于const 成员函数的参数问题"></a>关于const 成员函数的参数问题</h5><p>在C++中，<code>const</code>成员函数是一个特别的成员函数，<strong>它保证了该函数不会修改对象的成员变量</strong>。以下是关于<code>const</code>成员函数的一些关键点：</p><ul><li><code>const</code>成员函数在函数声明末尾加上<code>const</code>关键字。例如：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-comment">// 函数体</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>目的</strong></p><ul><li><strong>保证不修改对象状态</strong>：<code>const</code>成员函数确保函数不会修改调用它的对象的非静态数据成员。这有助于确保对象在调用这些函数时保持不变。</li><li><strong>增强代码的可读性和维护性</strong>：通过明确表示函数不会改变对象的状态，提高了代码的清晰度，使开发者更容易理解和使用这些函数。</li><li><strong>支持const对象</strong>：<code>const</code>成员函数可以被<code>const</code>对象调用，因为它保证不会修改对象。</li></ul><p><strong>使用场景</strong></p><ul><li><strong>访问器（Getter）</strong>：通常，<code>const</code>成员函数用于只读访问对象的成员变量。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getValue</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> m_value;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>常量成员函数</strong>：任何不修改对象状态的操作都可以被声明为<code>const</code>。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPositive</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> m_value &gt; <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意事项</strong></p><ul><li><strong>不能修改非静态成员变量</strong>：在<code>const</code>成员函数内，尝试修改非静态成员变量会导致编译错误。</li><li><strong>可以修改<code>mutable</code>成员</strong>：<code>mutable</code>关键字可以用于声明一个成员变量，即使在<code>const</code>成员函数内也可以修改它。</li><li><strong>隐式<code>this</code>指针的类型</strong>：在<code>const</code>成员函数中，<code>this</code>指针的类型是<code>const MyClass*</code>，因此不能通过<code>this</code>来修改对象。</li><li><strong>重载</strong>：<code>const</code>和非<code>const</code>版本的同名成员函数可以共存，编译器会根据调用对象的<code>const</code>性来选择调用哪个版本。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getValue</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> m_value;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span>&amp; <span class="hljs-title">getValue</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> m_value;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> m_value;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    MyClass obj;<br>    <span class="hljs-type">const</span> MyClass constObj;<br><br>    <span class="hljs-comment">// 调用非const版本</span><br>    obj.<span class="hljs-built_in">getValue</span>() = <span class="hljs-number">10</span>;<br><br>    <span class="hljs-comment">// 调用const版本</span><br>    <span class="hljs-type">int</span> val = constObj.<span class="hljs-built_in">getValue</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>指针和引用</strong>：在<code>const</code>成员函数中，返回成员变量的指针或引用也必须是<code>const</code>的，以防止通过这些指针或引用修改对象。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">int</span>* <span class="hljs-title">getPointer</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> &amp;m_value;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>静态成员函数</strong>：<code>static</code>成员函数不涉及<code>this</code>指针，因此它们天生就是<code>const</code>的。</li></ul><p><code>const</code>成员函数是C++中增强代码安全性和可读性的重要工具，通过它们，开发者可以明确地表达函数对对象状态的影响，帮助避免不必要的副作用，同时也使代码更易于维护和使用。</p><p>是的，<code>const</code>成员函数可以有形参。<code>const</code>关键字只影响函数对对象自身状态的修改能力，并不限制函数是否可以接受参数。以下是一些关于<code>const</code>成员函数如何处理参数的说明：</p><h5 id="接受参数的const成员函数"><a href="#接受参数的const成员函数" class="headerlink" title="接受参数的const成员函数"></a>接受参数的<code>const</code>成员函数</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">const</span> std::string&amp; str)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-comment">// 函数体</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>在这个例子中：</p><ul><li><code>doSomething</code>是一个<code>const</code>成员函数。</li><li>它接受两个参数：一个<code>int</code>类型的<code>x</code>和一个<code>const std::string</code>类型的引用<code>str</code>。</li><li>函数体中不能修改<code>MyClass</code>对象的任何非静态成员变量。</li></ul><p><strong>参数的类型</strong></p><ul><li><strong>非<code>const</code>参数</strong>：你可以传递非<code>const</code>类型的参数给<code>const</code>成员函数，因为这些参数是函数的局部副本或引用，不影响对象的状态。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> <span class="hljs-type">const</span> </span>&#123;<br>    x = <span class="hljs-number">10</span>; <span class="hljs-comment">// 修改的是局部变量，不影响对象状态</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>引用和指针参数</strong>：<code>const</code>成员函数可以接受<code>const</code>或非<code>const</code>的引用或指针作为参数，但如果是<code>const</code>引用或指针，则不能通过它们修改所指向的对象。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; str)</span> <span class="hljs-type">const</span> </span>&#123;<br>    <span class="hljs-comment">// str不能被修改，但可以通过非const成员函数修改str指向的对象</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">(std::string* str)</span> <span class="hljs-type">const</span> </span>&#123;<br>    <span class="hljs-comment">// str可以被重新赋值，但不能通过str修改str指向的对象</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="const成员函数的限制"><a href="#const成员函数的限制" class="headerlink" title="const成员函数的限制"></a><code>const</code>成员函数的限制</h5><p>虽然<code>const</code>成员函数可以有形参，但有以下限制：</p><ul><li><strong>不能修改对象的非静态成员变量</strong>：这是<code>const</code>成员函数的核心原则。</li><li><strong>不能调用非<code>const</code>成员函数</strong>：因为非<code>const</code>成员函数可能修改对象的状态。</li><li><strong>可以修改<code>mutable</code>成员变量</strong>：<code>mutable</code>关键字允许在<code>const</code>成员函数中修改特定的成员变量。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        m_mutableVar = <span class="hljs-number">1</span>; <span class="hljs-comment">// 可以修改mutable变量</span><br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">mutable</span> <span class="hljs-type">int</span> m_mutableVar;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><strong>可以修改局部变量</strong>：在<code>const</code>成员函数内定义的局部变量可以被修改，因为它们不影响对象的状态。</li></ul><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p><code>const</code>成员函数可以接受任何类型的参数，包括<code>const</code>和非<code>const</code>的参数。<code>const</code>关键字的作用是确保函数不会修改对象的状态，而不影响函数如何处理其参数。通过这种方式，<code>const</code>成员函数既能提供只读的接口，又能灵活地处理传入的参数。</p>          </div><h2 id="类的构造函数"><a href="#类的构造函数" class="headerlink" title="类的构造函数"></a>类的构造函数</h2><h3 id="构造函数的初始化列表"><a href="#构造函数的初始化列表" class="headerlink" title="构造函数的初始化列表"></a>构造函数的初始化列表</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++">Test::<span class="hljs-built_in">Test</span>(<span class="hljs-type">int</span> lh, <span class="hljs-type">int</span> rh):<span class="hljs-built_in">low</span>(lh),<span class="hljs-built_in">high</span>(rh)&#123;<br><span class="hljs-comment">//其他成员的初始化</span><br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-primary">            <p><strong>必须使用初始化列表的情况：</strong></p><p>在 C++ 中，初始化列表通常用于在类的构造函数中初始化成员变量。虽然可以在构造函数的主体中赋值，但在某些情况下，必须使用初始化列表。以下是几个常见的情况：</p><ol><li><strong>常量成员变量（<code>const</code>）</strong></li></ol><p>常量成员变量必须在对象构造时初始化，并且只能通过初始化列表进行初始化。因为常量成员变量在构造函数体内不能被赋值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> x;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">int</span> val) : <span class="hljs-built_in">x</span>(val) &#123;&#125;  <span class="hljs-comment">// 必须使用初始化列表</span><br>&#125;;<br></code></pre></td></tr></table></figure><ol start="2"><li><strong>引用成员变量</strong></li></ol><p>引用成员变量也只能通过初始化列表来初始化，因为引用一旦绑定到某个对象，就不能再改变。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span>&amp; ref;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">int</span>&amp; r) : <span class="hljs-built_in">ref</span>(r) &#123;&#125;  <span class="hljs-comment">// 引用成员必须通过初始化列表初始化</span><br>&#125;;<br></code></pre></td></tr></table></figure><ol start="3"><li><strong>基类的构造函数</strong></li></ol><p>如果你的类有一个继承自基类的成员，那么在派生类的构造函数中，必须通过初始化列表来调用基类的构造函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Base</span>(<span class="hljs-type">int</span> x) &#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Derived</span>(<span class="hljs-type">int</span> x) : <span class="hljs-built_in">Base</span>(x) &#123;&#125;  <span class="hljs-comment">// 必须通过初始化列表调用基类构造函数</span><br>&#125;;<br></code></pre></td></tr></table></figure><ol start="4"><li><strong>初始化动态分配的资源（如智能指针）</strong></li></ol><p>对于一些成员变量（如<code>std::unique_ptr</code>或<code>std::shared_ptr</code>），你可以在初始化列表中进行初始化，避免多次赋值，保证对象在构造时即拥有正确的资源。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; ptr;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">int</span> val) : <span class="hljs-built_in">ptr</span>(std::<span class="hljs-built_in">make_unique</span>&lt;<span class="hljs-type">int</span>&gt;(val)) &#123;&#125;  <span class="hljs-comment">// 使用初始化列表</span><br>&#125;;<br></code></pre></td></tr></table></figure><ol start="5"><li><strong>成员变量的非默认构造</strong></li></ol><p>如果类的成员变量没有提供默认构造函数，则必须在初始化列表中进行初始化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; v;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyClass</span>() : <span class="hljs-built_in">v</span>(<span class="hljs-number">10</span>, <span class="hljs-number">5</span>) &#123;&#125;  <span class="hljs-comment">// 初始化列表用于指定成员变量的初始化</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>尽管你可以在构造函数体内初始化一些成员变量，但对于常量成员、引用成员、基类构造函数调用以及没有默认构造函数的成员变量，必须通过初始化列表进行初始化。使用初始化列表能提高性能，并且在某些情况下（例如常量或引用成员）是唯一有效的选择。</p>          </div><h3 id="类内初始化"><a href="#类内初始化" class="headerlink" title="类内初始化"></a>类内初始化</h3><p>设置对象的初值是由构造函数完成的。如果类中没有定义构造函数，编译器会提供一个默认构造函数，即用数据成员类型的默认构造函数初始化数据成员，一般情况下都是随机数。</p><p>C++11 提供了一个称为类内初始化的功能，可以在类定义时为数据成员指定初值。如果构造函数没有为这个数据成员赋值，那么该数据成员的初值即为类定义时指定的初值。类内初始化可以使用&#x3D;的初始化形式，也可以使用大括号括起来的直接初始化形式，但不能使用小括号。</p><p><strong>类内初始化只适用于动态成员函数，静态成员函数的定义必须在类外！</strong></p><h3 id="委托构造"><a href="#委托构造" class="headerlink" title="委托构造"></a>委托构造</h3><p>有时某个构造函数的一部分工作与另外一个构造函数完全相同，那么完成这部分工作的语句必须在两个构造函数中都出现。例如，希望 DoubleArray 对象定义时能同时给出数组的初值，则需要增加一个如下的构造函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">DoubleArray</span>(<span class="hljs-type">int</span> lh, <span class="hljs-type">double</span> a[], <span class="hljs-type">int</span> size): <span class="hljs-built_in">low</span>(lh), <span class="hljs-built_in">high</span>(lh + size <span class="hljs-number">-1</span>) <br>&#123;<br>    storage = <span class="hljs-keyword">new</span> <span class="hljs-type">double</span>[size];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; ++i)<br>        storage[i] = a[i];<br>&#125;<br></code></pre></td></tr></table></figure><p>这个构造函数除了 for 语句之外， 其他工作与 DoubleArray(int lh, int rh)完全相同。 为了避免重复写这些语句， C++11 <strong>允许一个构造函数调用另一个构造函数</strong>，即委托构造。</p><p>委托构造函数有一个<strong>初始化列表</strong>和一个<strong>函数体</strong>。初始化列表只有唯一的入口，即被调用的构造函数。函数体完成额外的初始化工作。上面的构造函数可以定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">DoubleArray</span>(<span class="hljs-type">int</span> lh, <span class="hljs-type">double</span> a[], <span class="hljs-type">int</span> size):<span class="hljs-built_in">DoubleArray</span>(lh, lh + size - <span class="hljs-number">1</span>)<br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; ++i)<br>    storage[i] = a[i];<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>在类的继承中，派生类的构造函数的基本原理就是<strong>使用委托构造调用基类的构造函数</strong>。</p></blockquote><h3 id="复制构造函数"><a href="#复制构造函数" class="headerlink" title="复制构造函数"></a>复制构造函数</h3><p>笔者花了一整篇博客的篇幅讲解复制构造函数，包括<strong>隐式</strong>的复制构造函数和<strong>显式定义</strong>的复制构造函数。</p><p><a href="https://xiyuanyang-code.github.io/posts/Dynamic-Memory-and-Classes/">博客地址</a></p><h3 id="移动构造函数"><a href="#移动构造函数" class="headerlink" title="移动构造函数"></a>移动构造函数</h3><div class="note note-primary">            <p><strong>移动构造函数</strong>（Move Constructor）是 C++11 引入的一种特殊构造函数，用于实现对象的”移动语义”。它的作用是通过转移资源所有权，而不是复制资源，来高效地构造一个新对象。移动构造函数通常用于在对象的生命周期结束时，避免不必要的资源复制，从而提高程序的性能。</p><p>移动构造函数的主要任务是将一个<strong>临时对象的资源</strong>（如动态分配的内存、文件句柄等）“转移”到新的对象中，而不是进行深拷贝(<strong>这是复制构造函数的工作</strong>)。通过这种方式，移动构造函数能够避免重复的资源分配和复制操作，从而提高效率。</p><p>移动构造函数通常具有以下形式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyClass</span>(MyClass&amp;&amp; other) <span class="hljs-keyword">noexcept</span> &#123;<br>        <span class="hljs-comment">// 转移资源所有权</span><br>        <span class="hljs-keyword">this</span>-&gt;data = other.data;<br>        other.data = <span class="hljs-literal">nullptr</span>;  <span class="hljs-comment">// 将原对象的资源置为空（防止析构时释放）</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>其中 <code>MyClass&amp;&amp; other</code> 是一个<strong>右值引用</strong>，表示传入的对象是一个临时对象（或可以被安全地移动的对象）。<code>noexcept</code> 表示该函数不会抛出异常，通常对于移动构造函数是一个良好的实践。</p><p> <strong>何时使用移动构造函数</strong></p><ul><li><strong>当对象是临时对象时</strong>：临时对象可以安全地进行资源转移（移动），而不需要进行复制。</li><li><strong>当对象的资源不再需要时</strong>：比如，在函数返回时，一个对象的资源可以被“移走”，避免无谓的复制。</li></ul><p><strong>与拷贝（复制）构造函数的区别</strong></p><ul><li><strong>拷贝构造函数</strong>：会创建新对象并复制源对象的所有数据（深拷贝），这对于某些数据结构（如动态内存分配）可能非常昂贵。</li><li><strong>移动构造函数</strong>：通过转移资源的所有权来构造对象，不需要进行昂贵的复制操作，效率更高。</li></ul><p><strong>移动构造函数的实现细节</strong></p><ul><li>通常，移动构造函数会转移所有资源，并将原对象的资源置为空或有效的”无资源”状态，以防止析构函数错误地释放资源。</li><li>移动构造函数的实现通常需要保证“资源管理”的正确性，避免双重释放等问题。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; data;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyClass</span>() = <span class="hljs-keyword">default</span>;  <span class="hljs-comment">// 默认构造函数</span><br><br>    <span class="hljs-comment">// 移动构造函数</span><br>    <span class="hljs-built_in">MyClass</span>(MyClass&amp;&amp; other) <span class="hljs-keyword">noexcept</span> : <span class="hljs-built_in">data</span>(std::<span class="hljs-built_in">move</span>(other.data)) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Move constructor called!&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addData</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> </span>&#123;<br>        data.<span class="hljs-built_in">push_back</span>(value);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printData</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : data) &#123;<br>            std::cout &lt;&lt; v &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>        std::cout &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    MyClass obj1;<br>    obj<span class="hljs-number">1.</span><span class="hljs-built_in">addData</span>(<span class="hljs-number">1</span>);<br>    obj<span class="hljs-number">1.</span><span class="hljs-built_in">addData</span>(<span class="hljs-number">2</span>);<br><br>    <span class="hljs-comment">// 使用移动构造函数创建新对象</span><br>    MyClass obj2 = std::<span class="hljs-built_in">move</span>(obj1);  <span class="hljs-comment">// 调用移动构造函数</span><br>    obj<span class="hljs-number">2.</span><span class="hljs-built_in">printData</span>();  <span class="hljs-comment">// 打印 obj2 的数据</span><br>    obj<span class="hljs-number">1.</span><span class="hljs-built_in">printData</span>();  <span class="hljs-comment">// obj1 现在是空的</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs delphi">Move <span class="hljs-function"><span class="hljs-keyword">constructor</span> <span class="hljs-title">called</span>!</span><br><span class="hljs-function">1 2</span><br></code></pre></td></tr></table></figure><ul><li>在 <code>obj2 = std::move(obj1)</code> 语句中，<code>obj1</code> 被“移动”到 <code>obj2</code> 中，调用了移动构造函数。</li><li><code>obj1</code> 之后没有持有原来数据的所有权，因此它的内容变为空。</li></ul><p> <strong>使用 <code>std::move</code></strong></p><p><code>std::move</code> 不是一个真正的“移动”操作，它只是将其参数转换为右值引用，使得移动构造函数或移动赋值运算符可以被调用。因此，当你希望使用移动构造函数时，通常会显式调用 <code>std::move</code>。</p><p> <strong>何时自动调用移动构造函数</strong></p><p>移动构造函数通常在以下情况下自动调用：</p><ul><li><strong>返回值优化（RVO）</strong>：函数返回局部对象时。</li><li><strong>标准容器的元素转移</strong>：例如，在将对象插入 <code>std::vector</code>、<code>std::list</code> 等容器时，容器可以通过移动构造函数来高效地管理内存。</li></ul><p><strong>移动构造函数的最佳实践</strong></p><ul><li><strong>确保移动构造函数不会抛出异常</strong>：通常应该声明为 <code>noexcept</code>，以便提高编译器的优化能力。</li><li><strong>使被移动的对象处于有效但空的状态</strong>：例如，将指针置为空或清空容器中的元素。</li></ul>          </div><h3 id="构造函数相关小结"><a href="#构造函数相关小结" class="headerlink" title="构造函数相关小结"></a>构造函数相关小结</h3><ul><li>可以通过函数重载创建多个同名函数，条件是每个函数的特征标（参数列表）都不同。</li><li>构造函数没有声明类型。</li><li>默认构造函数：①无参数（系统默认）② 手动为<strong>每一个形参</strong>添加默认值</li></ul><h2 id="类的析构函数"><a href="#类的析构函数" class="headerlink" title="类的析构函数"></a>类的析构函数</h2><p>析构函数没有返回值也没有返回类型！</p><h3 id="类析构的顺序"><a href="#类析构的顺序" class="headerlink" title="类析构的顺序"></a>类析构的顺序</h3><p>在 C++ 中，对象的析构顺序由其作用域（或生命周期）决定。析构过程通常遵循<strong>逆构造顺序</strong>，即从最内层的局部对象开始，依次向外层对象进行析构。下面是一些常见的情况和详细的析构顺序说明。</p><ol><li><strong>局部对象的析构顺序</strong></li></ol><p>在函数中，局部对象的析构顺序通常遵循<strong>后创建先销毁</strong>的原则。也就是说，局部对象按照它们创建的反向顺序进行析构。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;A created&quot;</span> &lt;&lt; std::endl; &#125;<br>    ~<span class="hljs-built_in">A</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;A destroyed&quot;</span> &lt;&lt; std::endl; &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">B</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;B created&quot;</span> &lt;&lt; std::endl; &#125;<br>    ~<span class="hljs-built_in">B</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;B destroyed&quot;</span> &lt;&lt; std::endl; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">example</span><span class="hljs-params">()</span> </span>&#123;<br>    A a;<br>    B b;<br>    <span class="hljs-comment">// 在这个函数结束时，a 和 b 的析构顺序是：b -&gt; a</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">example</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">A</span> created<br><span class="hljs-selector-tag">B</span> created<br><span class="hljs-selector-tag">B</span> destroyed<br><span class="hljs-selector-tag">A</span> destroyed<br></code></pre></td></tr></table></figure><p><strong>解析</strong>：</p><ul><li>在 <code>example</code> 函数中，<code>a</code> 和 <code>b</code> 是局部对象。<code>a</code> 在 <code>b</code> 之前创建，但 <code>b</code> 在 <code>a</code> 之后被销毁。这是因为析构顺序遵循“后创建，先销毁”的原则。</li></ul><ol start="2"><li><strong>类的成员变量的析构顺序</strong></li></ol><p>类的成员变量的析构顺序遵循它们在类定义中声明的顺序，而<strong>不是在构造函数中初始化的顺序</strong>。也就是说，无论成员变量的初始化顺序如何，它们的析构顺序总是按它们在类定义中的声明顺序进行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    A a;  <span class="hljs-comment">// a 在类中声明顺序较前</span><br>    B b;  <span class="hljs-comment">// b 在类中声明顺序较后</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyClass</span>() &#123;&#125;<br>    ~<span class="hljs-built_in">MyClass</span>() &#123;&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    MyClass obj;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">A</span> created<br><span class="hljs-selector-tag">B</span> created<br><span class="hljs-selector-tag">B</span> destroyed<br><span class="hljs-selector-tag">A</span> destroyed<br></code></pre></td></tr></table></figure><p><strong>解析</strong>：</p><ul><li>在 <code>MyClass</code> 的析构函数中，成员变量 <code>a</code> 会先析构，而 <code>b</code> 后析构，尽管 <code>b</code> 在构造函数中是后初始化的。</li></ul><ol start="3"><li><strong>栈上对象与堆上对象</strong></li></ol><ul><li><strong>栈上对象</strong>：在栈上分配的对象（即局部对象）会在它们的作用域结束时自动析构，顺序遵循“后创建，先销毁”。</li><li><strong>堆上对象</strong>：在堆上通过 <code>new</code> 创建的对象，需要<strong>显式调用 <code>delete</code> 来销毁</strong>。堆上的对象不会自动析构，它们的析构顺序完全取决于程序员手动调用 <code>delete</code> 的时机。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyClass</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;MyClass created&quot;</span> &lt;&lt; std::endl; &#125;<br>    ~<span class="hljs-built_in">MyClass</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;MyClass destroyed&quot;</span> &lt;&lt; std::endl; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    MyClass *ptr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">MyClass</span>();  <span class="hljs-comment">// 堆上对象</span><br>    <span class="hljs-keyword">delete</span> ptr;  <span class="hljs-comment">// 手动销毁堆上对象</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs monkey">My<span class="hljs-keyword">Class</span> <span class="hljs-title class_">created</span><br>My<span class="hljs-keyword">Class</span> <span class="hljs-title class_">destroyed</span><br></code></pre></td></tr></table></figure><p><strong>解析</strong>：</p><ul><li>堆上对象 <code>ptr</code> 只有在调用 <code>delete</code> 时才会被销毁。</li></ul><ol start="4"><li><strong>静态和全局对象的析构顺序</strong></li></ol><ul><li><p><strong>静态变量</strong>：程序中所有静态变量（包括全局静态变量和局部静态变量）会在<strong>程序结束时</strong>析构。它们的析构顺序通常是<strong>与定义顺序相反</strong>，也就是从后定义的静态变量先析构。</p><p>静态对象的析构时机通常由编译器的运行时环境管理（如 C++ 的静态对象析构）。</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;A created&quot;</span> &lt;&lt; std::endl; &#125;<br>    ~<span class="hljs-built_in">A</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;A destroyed&quot;</span> &lt;&lt; std::endl; &#125;<br>&#125;;<br><br>A a;  <span class="hljs-comment">// 静态对象</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Inside main&quot;</span> &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">A</span> created<br>Inside <span class="hljs-selector-tag">main</span><br><span class="hljs-selector-tag">A</span> destroyed<br></code></pre></td></tr></table></figure><p><strong>解析</strong>：</p><ul><li>静态对象 <code>a</code> 在 <code>main</code> 函数执行之前创建，在 <code>main</code> 执行完毕后销毁。静态对象的析构发生在程序退出时，通常在 <code>main</code> 返回之后。</li></ul><ol start="5"><li><strong>全局对象的析构顺序</strong></li></ol><p>全局对象的析构顺序遵循<strong>反向构造顺序</strong>，即程序的最后一个全局对象会最早被销毁。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;A created&quot;</span> &lt;&lt; std::endl; &#125;<br>    ~<span class="hljs-built_in">A</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;A destroyed&quot;</span> &lt;&lt; std::endl; &#125;<br>&#125;;<br><br>A a;  <span class="hljs-comment">// 全局对象</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Inside main&quot;</span> &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">A</span> created<br>Inside <span class="hljs-selector-tag">main</span><br><span class="hljs-selector-tag">A</span> destroyed<br></code></pre></td></tr></table></figure><p><strong>解析</strong>：</p><ul><li><code>a</code> 在 <code>main</code> 执行之前创建，并在程序退出时销毁。</li></ul><ol start="6"><li><strong>局部静态变量的析构顺序</strong></li></ol><p>局部静态变量的析构顺序在程序结束时由运行时系统管理，通常是在 <code>main</code> 执行完毕之后销毁。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">static</span> A a;  <span class="hljs-comment">// 局部静态变量</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">func</span>();  <span class="hljs-comment">// a 在第一次调用 func 时构造</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><ul><li><strong>局部对象</strong>：后创建，先销毁（按作用域顺序）。</li><li><strong>成员变量</strong>：按照类定义中的声明顺序析构，而非构造顺序。</li><li><strong>堆上对象</strong>：需要显式使用 <code>delete</code> 销毁。</li><li><strong>静态&#x2F;全局对象</strong>：按程序退出时的逆构造顺序销毁。</li></ul><p>对象的析构顺序<strong>遵循“后创建，先销毁”的原则</strong>，但具体情况会根据对象的类型（局部对象、成员变量、静态变量等）以及它们的生命周期有所不同。</p><h2 id="this-指针"><a href="#this-指针" class="headerlink" title="this 指针"></a>this 指针</h2><ul><li><p><code>this</code> 指针在 C++ 中是一个非常重要的概念，用于指向当前对象的内存地址。以下是关于 <code>this</code> 指针的一些关键点：</p><ol><li><p><strong>指向当前对象</strong>：</p><ul><li><code>this</code> 是一个指向当前对象的指针。每个非静态成员函数都隐式地包含一个 <code>this</code> 指针，它指向调用该成员函数的对象。</li></ul></li><li><p><strong>隐式传递</strong>：</p><ul><li>当调用一个对象的成员函数时，<code>this</code> 指针会自动作为第一个参数传递给该函数。实际上，编译器会在函数调用时将对象的地址作为参数传递给成员函数的 <code>this</code> 参数。</li></ul></li><li><p><strong>用途</strong>：</p><ul><li><p><strong>区分形参和成员变量</strong>：当成员函数的参数名与成员变量名相同的时候，可以使用 <code>this</code> 来明确地引用成员变量。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>    <span class="hljs-type">int</span> value;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setValue</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>-&gt;value = value; <span class="hljs-comment">// 使用 this 指针来访问成员变量</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p><strong>返回当前对象的引用</strong>：在成员函数中返回 <code>*this</code> 可以返回当前对象的引用，常用于链式调用。</p></li></ul></li><li><p><strong>注意事项</strong>：</p><ul><li><code>this</code> 指针在类内成员函数中是隐式的，不需要显式声明。</li><li><code>this</code> 指针的类型是 <code>类名* const</code>，意味着 <code>this</code> 本身是常量指针，即不能改变 <code>this</code> 指针指向的地址，但可以通过 <code>this</code> 修改对象的内容。</li></ul></li><li><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;The object&#x27;s address is: &quot;</span> &lt;&lt; <span class="hljs-keyword">this</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    A obj;<br>    obj.<span class="hljs-built_in">display</span>(); <span class="hljs-comment">// 打印对象 obj 的内存地址</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>静态成员函数</strong>：</p><ul><li>静态成员函数没有 <code>this</code> 指针，因为它们不与任何对象实例相关联，而是直接与类相关联。</li></ul></li></ol><p><code>this</code> 指针提供了一种方式，使得<strong>成员函数能够访问其所属的对象的成员变量和成员函数</strong>，增强了代码的可读性和可维护性，同时也提供了解决名称冲突的便利方法。</p></li><li><p>例：P297</p></li></ul><p><img src="https://ooo.0x0.ooo/2025/01/23/OG7ceI.png" alt="This pointer"></p><p>即需要一个指向“自身”的隐式指针——<strong>this 指针</strong>！</p><p>故缺失的代码为：<code>return *this</code></p><h3 id="有关this-指针的相关注意点"><a href="#有关this-指针的相关注意点" class="headerlink" title="有关this 指针的相关注意点"></a>有关this 指针的相关注意点</h3><ul><li><p>this指针指向调用对象，也可以使用const限定符</p></li><li><p>在C++中，<code>this</code>并不是一个关键词（keyword），而是一个保留字（reserved word）。这意味着：</p><ul><li><p><strong><code>this</code>的用途</strong>：<code>this</code>是一个指向当前对象的指针。在非静态成员函数中，<code>this</code>隐式地指向调用该函数的对象实例。它的主要用途包括：</p><ul><li>区分局部变量和成员变量。例如，如果成员变量和函数参数同名，可以使用<code>this-&gt;</code>来明确指代成员变量。</li><li>返回当前对象的引用或指针。例如，<code>return *this;</code>用于链式调用。</li></ul></li><li><p><strong>保留字</strong>：虽然<code>this</code>不是关键词，但它是保留给编译器使用的，不能用作其他用途（如变量名或函数名）。这确保了<code>this</code>在C++代码中具有特定的含义和用法。</p></li><li><p><strong>不可重新定义</strong>：由于<code>this</code>是保留字，程序员不能定义一个名为<code>this</code>的变量、函数或其他标识符。</p></li><li><p><strong>编译器支持</strong>：编译器会自动在成员函数中插入<code>this</code>指针的使用，使得成员函数知道它们是哪个对象的成员。</p></li></ul><p>因此，虽然<code>this</code>在C++中不是关键词，但它的用法和保留性质使得它在语言中扮演了一个特殊的角色，确保了面向对象编程中的对象身份的明确性。</p></li></ul><h2 id="对象数组"><a href="#对象数组" class="headerlink" title="对象数组"></a>对象数组</h2><ul><li>创建对象数组的格式和基本数组相同</li></ul><p><img src="https://ooo.0x0.ooo/2025/01/23/OG7s3F.png" alt="Constructor"></p><p>也可以使用不同的构造函数</p><ul><li><strong>要创建类对象数组，必须应有类的默认构造函数（显示&amp;隐式）</strong>，因为在初始化对象数组的时候首先使用默认构造函数创建数组元素，接着再创建临时对象并对值进行覆盖。</li><li>针对对象数组，也可以使用指针</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">top = &amp;(top-&gt;<span class="hljs-built_in">topval</span>(stocks[st]));<br></code></pre></td></tr></table></figure><p>成员访问运算符的优先级高于取址运算符</p><h2 id="类作用域"><a href="#类作用域" class="headerlink" title="类作用域"></a>类作用域</h2><ul><li>要调用共有成员函数，必须通过对象！（静态成员除外）</li><li>可以使用成员访问运算符或作用域解析运算符（主要对于库函数）</li></ul><h3 id="类作用域运算符"><a href="#类作用域运算符" class="headerlink" title="类作用域运算符::"></a>类作用域运算符<code>::</code></h3><p>在C++中，作用域解析运算符（<code>::</code>）用于多种场景，以下是几种常见使用情况：</p><ol><li><p><strong>访问全局变量或函数</strong>：</p><ul><li><p>当局部变量与全局变量同名时，可以使用<code>::</code>来明确指定使用全局变量。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;  <span class="hljs-comment">// 全局变量</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">20</span>;  <span class="hljs-comment">// 局部变量</span><br>    std::cout &lt;&lt; ::a &lt;&lt; std::endl;  <span class="hljs-comment">// 输出全局变量a的值</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>访问命名空间中的成员</strong>：</p><ul><li><p>用于明确指定命名空间中的成员，避免命名冲突。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">namespace</span> MyNamespace &#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myFunction</span><span class="hljs-params">()</span></span>;<br>&#125;<br>MyNamespace::<span class="hljs-built_in">myFunction</span>();<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>访问类的静态成员</strong>：</p><ul><li><p>访问类的静态成员变量或静态成员函数时：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> count;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">staticMethod</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><span class="hljs-type">int</span> MyClass::count = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 定义并初始化静态成员变量</span><br>MyClass::<span class="hljs-built_in">staticMethod</span>();  <span class="hljs-comment">// 调用静态成员函数</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>基类成员的访问</strong>：</p><ul><li><p>当派生类与基类有同名的成员时，使用作用域解析运算符可以明确访问基类的成员：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Base::method()&quot;</span> &lt;&lt; std::endl; &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span> </span>&#123; <br>        Base::<span class="hljs-built_in">method</span>();  <span class="hljs-comment">// 调用基类的同名方法</span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Derived::method()&quot;</span> &lt;&lt; std::endl; <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>模板类中的静态成员</strong>：</p><ul><li><p>在模板类中，静态成员的定义需要使用作用域解析运算符：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TemplateClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">static</span> T value;<br>&#125;;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br>T TemplateClass&lt;T&gt;::value;  <span class="hljs-comment">// 定义静态成员</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>访问外部链接的变量或函数</strong>：</p><ul><li><p>当在不同的源文件中声明和定义变量或函数时，可以使用作用域解析运算符来明确链接到外部定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// file1.cpp</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> globalVar;<br><br><span class="hljs-comment">// file2.cpp</span><br><span class="hljs-type">int</span> ::globalVar = <span class="hljs-number">10</span>;  <span class="hljs-comment">// 定义全局变量</span><br></code></pre></td></tr></table></figure></li></ul></li></ol><p>作用域解析运算符在C++中是一个非常重要的工具，它帮助程序员明确指定变量、函数或类的作用域，避免命名冲突，增强代码的可读性和可维护性。</p><ul><li><p>有关静态成员</p><ul><li><p>访问类的静态成员可以不通过对象进行访问。静态成员是属于类本身而不是类实例的，因此可以直接通过类名访问。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> staticVar;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">staticMethod</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><span class="hljs-type">int</span> MyClass::staticVar = <span class="hljs-number">10</span>;  <span class="hljs-comment">// 静态成员变量的定义</span><br><br>MyClass::staticVar = <span class="hljs-number">20</span>;  <span class="hljs-comment">// 直接通过类名访问静态成员变量</span><br>MyClass::<span class="hljs-built_in">staticMethod</span>();  <span class="hljs-comment">// 直接通过类名调用静态成员函数</span><br><br></code></pre></td></tr></table></figure></li><li><p>静态成员（包括静态成员变量和静态成员函数）在C++中有一些常见的用途：</p></li></ul></li></ul><p>静态成员变量</p><ol><li><p><strong>计数器</strong>：</p><ul><li>用于跟踪类的实例数量。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> instanceCount;<br>    <span class="hljs-built_in">MyClass</span>() &#123; ++instanceCount; &#125;<br>    ~<span class="hljs-built_in">MyClass</span>() &#123; --instanceCount; &#125;<br>&#125;;<br><span class="hljs-type">int</span> MyClass::instanceCount = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 定义并初始化静态成员变量</span><br></code></pre></td></tr></table></figure></li><li><p><strong>共享数据</strong>：</p><ul><li>当需要在所有实例之间共享某些数据时。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Logger</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">static</span> std::string logFile;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">log</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; message)</span> </span>&#123;<br>        <span class="hljs-comment">// 向静态成员变量logFile记录日志</span><br>    &#125;<br>&#125;;<br>std::string Logger::logFile = <span class="hljs-string">&quot;log.txt&quot;</span>;<br></code></pre></td></tr></table></figure></li><li><p><strong>常量数据</strong>：</p><ul><li>定义类相关的常量信息。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MathConstants</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">double</span> PI = <span class="hljs-number">3.14159265358979323846</span>;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ol><h1 id="Cha-11-使用类"><a href="#Cha-11-使用类" class="headerlink" title="Cha 11 使用类"></a>Cha 11 使用类</h1><h2 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h2><p>友元函数（<strong>Friend Function</strong>）是 C++ 中的一种机制，允许一个函数（或类）访问另一个类的私有成员和保护成员。虽然友元函数可以访问类的私有和保护成员，但它本身并不是类的成员函数。友元函数通常用于操作一些类内部的细节，但它可能会引入一些需要注意的问题。</p><ul><li>让函数成为类的友元，可以赋予该函数与类的成员函数相同的访问权限（<strong>访问private</strong>）</li><li>例：将运算符重载编写成一个非成员函数</li><li>友元函数具有成员函数的权限，但<strong>作为非成员函数不能使用成员运算符进行调用</strong><ul><li>使用成员函数，可以使用构造函数，这更加高效</li></ul></li><li><strong>只有在函数声明的时候需要加上friend关键词，在函数定义时不可以</strong></li></ul><p><img src="https://ooo.0x0.ooo/2025/01/23/OG7Yh6.png" alt="Vector"></p><h3 id="友元函数和在成员函数中运算符重载的区别"><a href="#友元函数和在成员函数中运算符重载的区别" class="headerlink" title="友元函数和在成员函数中运算符重载的区别"></a>友元函数和在成员函数中运算符重载的区别</h3><p>在成员函数中实现运算符重载</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Complex</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    Complex <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Complex&amp; other) <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Complex</span>(real + other.real, imag + other.imag);<br>    &#125;<br>    <span class="hljs-comment">//成员函数重载运算符中，所需的参数数目比运算符使用的参数数目少一个，其中一个是被隐式传递的调用对象(this 指针)</span><br>    <span class="hljs-comment">// 其它成员函数和数据成员</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">double</span> real;<br>    <span class="hljs-type">double</span> imag;<br>&#125;;<br><br></code></pre></td></tr></table></figure><p>在非成员函数中实现运算符重载（友元函数）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Complex</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">double</span> real;<br>    <span class="hljs-type">double</span> imag;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Complex</span>(<span class="hljs-type">double</span> r = <span class="hljs-number">0.0</span>, <span class="hljs-type">double</span> i = <span class="hljs-number">0.0</span>) : <span class="hljs-built_in">real</span>(r), <span class="hljs-built_in">imag</span>(i) &#123;&#125;<br><br>    <span class="hljs-comment">// 声明友元函数</span><br>    <span class="hljs-keyword">friend</span> Complex <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Complex&amp; left, <span class="hljs-type">const</span> Complex&amp; right);<br>&#125;;<br><br></code></pre></td></tr></table></figure><h3 id="友元函数相比于成员函数的优势"><a href="#友元函数相比于成员函数的优势" class="headerlink" title="友元函数相比于成员函数的优势"></a>友元函数相比于成员函数的优势</h3><p>友元函数相对于成员函数具有一些特定的优势，尽管它们打破了类的封装原则，但这些优势在某些情境下是非常有用的：</p><ol><li><strong>操作符重载</strong></li></ol><p>友元函数常用于操作符重载，特别是当操作符需要访问两个不同类或类型的对象时。成员函数只能通过 <code>this</code> 指针访问当前对象的成员，而友元函数可以直接访问两个对象的私有成员。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Complex</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">double</span> real;<br>    <span class="hljs-type">double</span> imag;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// ... 其他成员函数 ...</span><br>    <span class="hljs-keyword">friend</span> Complex <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Complex&amp; a, <span class="hljs-type">const</span> Complex&amp; b);<br>&#125;;<br><br><span class="hljs-comment">// 友元函数定义</span><br>Complex <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Complex&amp; a, <span class="hljs-type">const</span> Complex&amp; b) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Complex</span>(a.real + b.real, a.imag + b.imag);<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li><strong>提高代码的可读性和简洁性</strong></li></ol><ul><li><strong>全局函数</strong>：友元函数可以作为全局函数，这在某些情况下可以使代码更易于理解和维护。例如，上面的 <code>operator+</code> 作为友元函数，使得加法操作看起来更自然，不需要通过对象调用。</li><li><strong>避免不必要的成员函数</strong>：有时，某些操作并不适合作为类的一部分，但仍然需要访问类的私有成员。友元函数可以提供这种访问，而不需要增加类的成员函数。</li></ul><ol start="3"><li><strong>对称性</strong></li></ol><ul><li>友元函数可以提供操作的对称性。例如，在 <code>operator==</code> 的情况下，如果是成员函数，<code>a == b</code> 和 <code>b == a</code> 可能需要不同的实现，而友元函数可以使这两个操作等价。</li></ul><ol start="4"><li><strong>减少this指针的使用</strong></li></ol><ul><li>友元函数没有隐式的 <code>this</code> 指针，这在某些情况下可以提高效率，因为不需要额外的参数传递。</li></ul><ol start="5"><li><strong>访问私有成员而不改变类的接口</strong></li></ol><ul><li>如果你需要一个函数访问类的数据，但不想将这个函数作为类的成员（因为它不属于类的逻辑部分），友元函数可以让你实现这一点，而不改变类的公共接口。</li></ul><ol start="6"><li><strong>跨类访问</strong></li></ol><ul><li>友元函数可以被多个类声明为友元，从而允许<strong>这些类之间共享数据，而不需要通过公共接口或继承</strong>。</li></ul><ol start="7"><li><strong>设计模式的实现</strong></li></ol><ul><li>在一些设计模式中，如桥接模式、适配器模式等，友元函数可以帮助实现跨类协作，而无需暴露类的内部实现细节。</li></ul><p><strong>注意事项</strong>：</p><p>尽管友元函数有这些优势，但它们也有一些潜在的缺点：</p><ul><li><strong>打破封装</strong>：友元函数允许非成员函数访问类的私有成员，可能会破坏类的封装性。</li><li><strong>代码维护</strong>：友元关系可能会使代码的维护变得复杂，因为它增加了类的依赖性。</li><li><strong>滥用</strong>：如果不谨慎使用，友元函数可能会导致代码的可读性和结构性下降。</li></ul><p>因此，在使用友元函数时，应该谨慎考虑是否真的需要这种访问权限，并尽量限制友元函数的数量和范围，以保持类的封装性和代码的清晰度。</p><h2 id="友元类"><a href="#友元类" class="headerlink" title="友元类"></a>友元类</h2><p>在 C++ 中，<code>friend</code> 是一种特殊的机制，它允许某些函数或类访问其他类的私有成员。<code>friend</code> 主要有两种形式：<strong>友元函数</strong> 和 <strong>友元类</strong>。这两种机制在设计某些复杂系统时非常有用，可以让不同类之间进行密切的合作，同时保持类内部的封装性。</p><p><strong>友元类</strong> 是一个类，它被声明为某个类的友元类。友元类的成员函数可以访问该类的私有成员。这种机制通常用于设计两个紧密相关的类，它们需要互相访问私有数据，但又不希望暴露给外部。</p><p><strong>友元类的基本语法</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setA</span><span class="hljs-params">(A&amp; obj)</span></span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> x;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> val) : <span class="hljs-built_in">x</span>(val) &#123;&#125;<br><br>    <span class="hljs-comment">// 声明 B 为友元类</span><br>    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>;<br>&#125;;<br><br><span class="hljs-comment">// B 是 A 的友元类，可以访问 A 的私有成员</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">B::setA</span><span class="hljs-params">(A&amp; obj)</span> </span>&#123;<br>    obj.x = <span class="hljs-number">100</span>;  <span class="hljs-comment">// 直接访问 A 的私有成员</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">A <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br>    B b;<br>    b.<span class="hljs-built_in">setA</span>(a);  <span class="hljs-comment">// B 可以访问 A 的私有成员</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>友元类的应用场景</strong></p><ul><li><strong>设计复杂系统</strong>：友元类的使用可以让两个类之间共享数据和功能，而不暴露这些数据给其他类。例如，在某些库中，可能有一个类负责管理资源（如内存管理），另一个类负责使用这些资源。为了实现高效和紧密的合作，这两个类可能需要互相访问对方的私有成员，这时可以将其中一个类声明为友元类。</li><li><strong>实现成员共享</strong>：友元类通常用于需要相互访问成员数据的类，特别是在某些算法和数据结构的实现中，如链表、树、图等。</li></ul><p><strong>友元类的设计示例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Engine</span>;  <span class="hljs-comment">// 前向声明</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    Engine* engine;  <span class="hljs-comment">// Engine 对象是 Car 的私有成员</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Car</span>() : <span class="hljs-built_in">engine</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br><br>    <span class="hljs-comment">// 声明 Engine 为友元类</span><br>    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Engine</span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Engine</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> horsepower;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Engine</span>(<span class="hljs-type">int</span> hp) : <span class="hljs-built_in">horsepower</span>(hp) &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setCarEngine</span><span class="hljs-params">(Car&amp; car)</span> </span>&#123;<br>        car.engine = <span class="hljs-keyword">this</span>;  <span class="hljs-comment">// Engine 可以访问 Car 的私有成员</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showCarEngineInfo</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Car engine horsepower: &quot;</span> &lt;&lt; horsepower &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>Engine</code> 类被声明为 <code>Car</code> 类的友元类，使得 <code>Engine</code> 类能够访问 <code>Car</code> 类的私有成员。</p><h4 id="友元类与继承"><a href="#友元类与继承" class="headerlink" title="友元类与继承"></a><strong>友元类与继承</strong></h4><p>友元类与继承之间有一些特别的关系。虽然子类继承了父类的公共和保护成员，但<strong>友元关系不被继承</strong>。也就是说，如果<strong>某个类是另一个类的友元类，它并不能自动成为其子类的友元类</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> value;<br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> val) : <span class="hljs-built_in">value</span>(val) &#123;&#125;<br>    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>;  <span class="hljs-comment">// B 是 A 的友元类</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> : <span class="hljs-keyword">public</span> A &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">C</span>(<span class="hljs-type">int</span> val) : <span class="hljs-built_in">A</span>(val) &#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showValue</span><span class="hljs-params">(A&amp; obj)</span> </span>&#123;<br>        std::cout &lt;&lt; obj.value &lt;&lt; std::endl;  <span class="hljs-comment">// B 可以访问 A 的私有成员</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">A <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br>    B b;<br>    b.<span class="hljs-built_in">showValue</span>(a);  <span class="hljs-comment">// 正常，B 可以访问 A 的私有成员</span><br><br>    <span class="hljs-function">C <span class="hljs-title">c</span><span class="hljs-params">(<span class="hljs-number">20</span>)</span></span>;<br>    <span class="hljs-comment">// b.showValue(c);  // 错误，C 没有继承 B 对 A 的友元关系</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的例子中，<code>B</code> 是 <code>A</code> 的友元类，但 <code>C</code> 并没有继承 <code>B</code> 对 <code>A</code> 的友元关系，因此 <code>B</code> 无法访问 <code>C</code> 的私有成员。</p><h4 id="友元与封装"><a href="#友元与封装" class="headerlink" title="友元与封装"></a><strong>友元与封装</strong></h4><p>尽管 <code>friend</code> 允许类外部的函数和类访问私有成员，但它仍然保持了一定的封装性。在设计时，应注意不要过度使用友元关系，因为过多的友元可能会破坏类的封装性，增加类之间的耦合度，导致维护困难。</p><ul><li><strong>适度使用友元</strong>：只有在确实需要类之间紧密合作时，才应考虑使用友元关系。尤其是当某些函数需要访问类的内部细节时，友元函数和友元类可以提供非常强大的功能。</li><li><strong>减少友元的使用</strong>：不推荐随意将大量的类或函数声明为友元，尽量保持类的封装性，使其更具独立性和可维护性。</li></ul><blockquote><p>我们会在 <a href="https://xiyuanyang-code.github.io/posts/Code-Reuse-in-OOP/">这篇博客</a> 中花更多的篇幅介绍友元类。</p></blockquote><h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">operator</span>[op](argument-list)&#123;<br>    <span class="hljs-comment">//运算符重载的具体实现细节</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>运算符重载也可以看做是OOP<strong>多态</strong>精神的一部分，标准库中每个运算符都有自己的定义，现在我们在此基础之上新定义新的语法规则。</p></blockquote><p><img src="https://ooo.0x0.ooo/2025/01/23/OG7ftP.png" alt="Operator"></p><ul><li><p>可以实现运算符重载的运算符</p></li><li><p>重载运算符的性质</p><ul><li>必须有一个操作数是用户定义的类型</li><li>不能违反运算符原来的句法规则（包括优先级）</li><li>不能创建新的运算符</li></ul></li></ul><p>下文给出了对<code>Rational</code>类的相关运算符重载：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rational</span> &#123;<br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-type">int</span> num;<br>        <span class="hljs-type">int</span> den;<br>            <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ReductFraction</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">Rational</span>(<span class="hljs-type">int</span> n = <span class="hljs-number">0</span>, <span class="hljs-type">int</span> d = <span class="hljs-number">1</span>) &#123; <br>            num = n; den = d; <br>            <span class="hljs-built_in">ReductFraction</span>();<br>        &#125;<br>        Rational <span class="hljs-keyword">operator</span> + (<span class="hljs-type">const</span> Rational &amp;r1) <span class="hljs-type">const</span>; <span class="hljs-comment">//+运算符重载</span><br>        Rational <span class="hljs-keyword">operator</span> * (<span class="hljs-type">const</span> Rational &amp;r1) <span class="hljs-type">const</span>; <span class="hljs-comment">//*运算符重载</span><br>        <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt; (<span class="hljs-type">const</span> Rational &amp;r1) <span class="hljs-type">const</span>; <span class="hljs-comment">//&lt;运算符重载</span><br>        <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> == (<span class="hljs-type">const</span> Rational &amp;r1) <span class="hljs-type">const</span>; <span class="hljs-comment">//==运算符重载</span><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; cout &lt;&lt; num &lt;&lt; <span class="hljs-string">&#x27;/&#x27;</span> &lt;&lt; den;&#125;<br>&#125;;<br><span class="hljs-comment">//重载了+ *运算，返回一个本类型的对象</span><br><span class="hljs-comment">//这里不用返回一个对本类型对象的引用，因为是临时变量，进行按值传递（如果涉及到指针需要重载赋值运算符，稍后会讲到）</span><br>Rational Rational::<span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Rational &amp;r1) <span class="hljs-type">const</span><br>&#123;<br>    Rational tmp;<br>    tmp.num = num * r<span class="hljs-number">1.</span>den + r<span class="hljs-number">1.</span>num * den;<br>    tmp.den = den * r<span class="hljs-number">1.</span>den;<br>    tmp.<span class="hljs-built_in">ReductFraction</span>();<br>    <span class="hljs-keyword">return</span> tmp;<br>&#125;<br>Rational Rational::<span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Rational &amp;r1) <span class="hljs-type">const</span><br>&#123;<br>    Rational tmp;<br>    tmp.num = num * r<span class="hljs-number">1.</span>num;<br>    tmp.den = den * r<span class="hljs-number">1.</span>den;<br>    tmp.<span class="hljs-built_in">ReductFraction</span>();<br>    <span class="hljs-keyword">return</span> tmp;<br>&#125;<br><span class="hljs-comment">//重载了关系运算符，需要返回一个bool值</span><br><span class="hljs-type">bool</span> Rational::<span class="hljs-keyword">operator</span> &lt; (<span class="hljs-type">const</span> Rational &amp;r1) <span class="hljs-type">const</span><br>&#123;<br>    <span class="hljs-keyword">return</span> num * r<span class="hljs-number">1.</span>den &lt; den * r<span class="hljs-number">1.</span>num;<br>&#125;<br><span class="hljs-type">bool</span> Rational::<span class="hljs-keyword">operator</span> == (<span class="hljs-type">const</span> Rational &amp;r1) <span class="hljs-type">const</span><br>&#123;<br>    <span class="hljs-keyword">return</span> num == r<span class="hljs-number">1.</span>num &amp;&amp; den == r<span class="hljs-number">1.</span>den;<br>&#125;<br></code></pre></td></tr></table></figure><p>运算符重载本质上是一个<strong>函数</strong>，他有对应的返回值。（例如重载赋值运算符需要返回一个bool值，重载加法运算符需要返回一个类）编译时， 编译器将 <code>r3 = r1 + r2</code> 解释成 <code>r3 = r1.operator+(r2)</code>， <code>r3 = r1 * r2</code> 解释成 <code>r3 = r1.operator*(r2)</code>， <code>r1 == r2</code> 解释成 <code>r1.operator==(r2)</code>， <code>r1 &lt; r3</code> 解释成 <code>r1.operator&lt;(r3)</code>。   </p><p>如何理解<code>r3 = r1.operator+(r2)</code>？你可以把<code>operator+</code>当成是一种函数名，对象<code>r1</code>调用自己的方法<code>operator+()</code>函数，函数的参数列表是<code>r2</code>（一个对本类型对象的<code>const</code>引用）。</p><p>这 4 个运算符也可以重载成全局函数。由于重载函数主要是对对象的数据成员进行操作，而在一般的类定义中，数据成员都被定义成私有的。因此，当运算符被重载成全局函数时，通常将<strong>此重载函数设为类的友元函数，便于访问类的私有数据成员</strong>。  （在后文关于友元函数的章节会涉及）</p><p>大多数运算符都可以重载成成员函数或全局函数。但是<strong>赋值运算符（ &#x3D;）、下标运算符（ []）、函数调用运算符（ ()）必须重载成成员函数</strong>，因为这些运算符的<strong>第一个运算对象必须是相应类的对象</strong>，定义成成员函数可以保证第一个运算对象的正确性。如果第一个运算对象不是相应类的对象，编译器能检查出此错误。 具有<strong>赋值意义的运算符（如复合的赋值运算符以及++和–） 不一定非要重载为成员函数，但建议重载为成员函数</strong>。具有两个运算对象且计算结果会产生一个新对象的运算符建议重载为<strong>全局函数</strong>，如 +、 -、 &gt;等，这样可以使应用更加灵活。  </p><h3 id="赋值运算符的重载"><a href="#赋值运算符的重载" class="headerlink" title="赋值运算符的重载"></a>赋值运算符的重载</h3><p>**<a href="https://xiyuanyang-code.github.io/posts/Dynamic-Memory-and-Classes/">类和动态内存分配</a>**，建议阅读以获得更好的上下文体验。</p><p>简单来说，在类中的默认赋值运算符执行的是<strong>浅拷贝</strong>的过程，将每一个数据成员的<strong>值</strong>拷贝给另一个类中对应的数据成员。而对于<strong>指针成员</strong>，指针成员的值是指向的一块<strong>内存地址</strong>，而并非<strong>指向变量的值</strong>！这就会导致赋值的两个对象的指针数据成员指向了同一块内存，都具有对这块内存的<strong>修改权限</strong>。同时，如果使用动态内存分配，很有可能对delete掉同一块内存两次，产生错误。</p><p><strong>因此，赋值运算符的重载本质上就是对指针等特殊情况特殊处理，进行“深拷贝”</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++">MyClass&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> MyClass&amp; other) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;other)  <span class="hljs-comment">// 防止自我赋值</span><br>            <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br><br>        <span class="hljs-comment">// 先释放当前对象的资源</span><br>        <span class="hljs-keyword">delete</span> data;<br><br>        <span class="hljs-comment">// 分配新的内存并复制数据</span><br>        data = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(*(other.data));<br><br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;  <span class="hljs-comment">// 返回左操作数的引用</span><br>    &#125;<br></code></pre></td></tr></table></figure><p>在C++中，<strong>赋值是一种运算</strong>，赋值运算语句的返回值是左边（左值）被赋值的对象的值。因此，<strong>赋值运算符必须返回对左边对象的引用，即返回一个左值。</strong></p><blockquote><p>这样做允许了<code>a=b=c</code>的链式赋值操作，在流输入输出运算过程中也是如此。</p></blockquote><p>与移动构造类似， C++11 提出了<strong>移动赋值</strong>的概念，让左边的对象直接接管右边临时对象的资源，以提高赋值过程的时间性能。移动赋值的右值是临时对象，因此它的<strong>形式参数是同类对象的右值引用</strong>，返回值是<strong>当前对象的引用</strong>。例如，为 DoubleArray 类增加一个移动赋值运算符重载函数，其定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++">DoubleArray &amp;DoubleArray::<span class="hljs-keyword">operator</span>=(DoubleArray &amp;&amp; a) &#123;<br>    <span class="hljs-keyword">delete</span> [] storage;<br>    low = a.low;<br>    high = a.high;<br>    storage = a.storage;<br>    a.storage = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>函数首先释放左边对象的空间，然后直接接管右边对象的空间，就不再需要复制数组元素了。</p><h3 id="下标运算符的重载"><a href="#下标运算符的重载" class="headerlink" title="下标运算符的重载"></a>下标运算符的重载</h3><p>下标运算符是一个二元运算符，第一个运算数是<strong>操作对象</strong>，第二个运算数是<strong>下标值</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdexcept&gt;</span>  <span class="hljs-comment">// 为了抛出异常</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyArray</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span>* data;<span class="hljs-comment">//一个int指针（当数组用）</span><br>    <span class="hljs-type">size_t</span> size;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 构造函数</span><br>    <span class="hljs-built_in">MyArray</span>(<span class="hljs-type">size_t</span> s) : <span class="hljs-built_in">size</span>(s) &#123;<br>        data = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[size];<br>    &#125;<br><br>    <span class="hljs-comment">// 析构函数</span><br>    ~<span class="hljs-built_in">MyArray</span>() &#123;<br>        <span class="hljs-keyword">delete</span>[] data;<br>    &#125;<br><br>    <span class="hljs-comment">// 非常量版本的下标运算符重载（允许修改元素）</span><br>    <span class="hljs-type">int</span>&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">size_t</span> index) &#123;<br>        <span class="hljs-keyword">if</span> (index &gt;= size) &#123;<br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">out_of_range</span>(<span class="hljs-string">&quot;Index out of range&quot;</span>);<br>            <span class="hljs-comment">//进行越界检查</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> data[index];<br>    &#125;<br><br>    <span class="hljs-comment">// 常量版本的下标运算符重载（不允许修改元素）</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">size_t</span> index) <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">if</span> (index &gt;= size) &#123;<br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">out_of_range</span>(<span class="hljs-string">&quot;Index out of range&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> data[index];<br>    &#125;<br><br>    <span class="hljs-comment">// 获取数组大小</span><br>    <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">getSize</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> size;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">MyArray <span class="hljs-title">arr</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span></span>;  <span class="hljs-comment">// 创建一个包含 5 个整数的数组</span><br><br>    <span class="hljs-comment">// 使用下标运算符修改元素</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-built_in">getSize</span>(); ++i) &#123;<br>        arr[i] = i * <span class="hljs-number">10</span>;  <span class="hljs-comment">// 设置 arr[0] = 0, arr[1] = 10, arr[2] = 20, ...</span><br>    &#125;<br><br>    <span class="hljs-comment">// 使用下标运算符读取元素</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-built_in">getSize</span>(); ++i) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;arr[&quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;] = &quot;</span> &lt;&lt; arr[i] &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-comment">// 访问常量对象</span><br>    <span class="hljs-function"><span class="hljs-type">const</span> MyArray <span class="hljs-title">constArr</span><span class="hljs-params">(<span class="hljs-number">3</span>)</span></span>;<br>    <span class="hljs-comment">// constArr[0] = 100;  // 错误：常量对象不能修改</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;constArr[0] = &quot;</span> &lt;&lt; constArr[<span class="hljs-number">0</span>] &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="函数调用运算符的重载"><a href="#函数调用运算符的重载" class="headerlink" title="函数调用运算符的重载"></a>函数调用运算符的重载</h3><p>C++将函数调用也作为一种运算。 函数调用运算符()是一个二元运算符。第一个运算对象是<strong>函数名</strong>，第二个参数是<strong>函数的形式参数表</strong>，运算结果是<strong>函数的返回值</strong>。如果一个类重载了函数调用运算符，就可以把<strong>这个类的对象当作函数</strong>来使用。因为是把当前类的对象当作函数使用，所以()运算的第一个运算数是当前类的对象， C++规定函数调用运算符必须重载成成员函数。</p><p>例如，我有数组类<code>array</code>和数组类对象<code>arr</code>，如果我在<code>array</code>中重载了函数调用运算符，那么<code>arr(1,2)</code>这种操作就是合法的，即<strong>对象名就是函数名！</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Multiplier</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> factor;  <span class="hljs-comment">// 乘数</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 构造函数：初始化 factor</span><br>    <span class="hljs-built_in">Multiplier</span>(<span class="hljs-type">int</span> f) : <span class="hljs-built_in">factor</span>(f) &#123;&#125;<br><br>    <span class="hljs-comment">// 重载函数调用运算符</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> factor * value;  <span class="hljs-comment">// 返回值乘以 factor</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 创建一个 Multiplier 对象，乘数为 5</span><br>    <span class="hljs-function">Multiplier <span class="hljs-title">multiplyBy5</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span></span>;<br><br>    <span class="hljs-comment">// 使用重载的函数调用运算符进行计算</span><br>    <span class="hljs-type">int</span> result = <span class="hljs-built_in">multiplyBy5</span>(<span class="hljs-number">10</span>);  <span class="hljs-comment">// 相当于 multiplyBy5.operator()(10)</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Result: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;  <span class="hljs-comment">// 输出：50</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="和-运算符的重载"><a href="#和-运算符的重载" class="headerlink" title="++和--运算符的重载"></a><code>++</code>和<code>--</code>运算符的重载</h3><p> <code>++</code>和<code>--</code>都是一元运算符，它们可被重载成成员函数或友元函数。但因为这两个运算符改变了运算对象的状态，所以更倾向于将它们作为成员函数。在考虑重载</p><p><code>++</code>和<code>--</code>运算符时，必须注意一个问题。 <code>++</code>和<code>--</code>既可以作为前缀使用，也可以作为后缀使用。而且这两种用法的结果是不一样的：作为前缀使用时，运算结果是修改以后的对象引用；作为后缀使用时，运算结果是修改以前的对象值。为了与内置类型一致，重载后的<code>++</code>和<code>--</code>也应具有这个特性。为此，对于<code>++</code>和<code>--</code>运算，每个运算符必须<strong>提供两个重载函数：一个处理前缀运算；另一个处理后缀运算</strong>。</p><p>但问题是，处理++的两个重载函数的原型除了返回类型不同之外，其他是完全相同的，处理–的两个重载函数也是如此。而仅返回类型不同的两个函数无法形成重载函数。</p><p>为了解决这个问题， C++规定<strong>后缀运算符重载函数接收一个额外的（即无用的） int 型的形式参数</strong>。使用后缀运算符时，编译器用 0 作为这个参数的值。当编译器看到一个前缀表示的++或–时，调用正常重载的这个函数。如果看到的是一个后缀表示的++或–，则<strong>调用有一个额外参数的重载函数</strong>。这样就把前缀和后缀的重载函数区分开了。</p><h4 id="前缀"><a href="#前缀" class="headerlink" title="前缀"></a>前缀</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> value;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 构造函数</span><br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">int</span> v) : <span class="hljs-built_in">value</span>(v) &#123;&#125;<br><br>    <span class="hljs-comment">// 前缀 ++ 运算符重载</span><br>    MyClass&amp; <span class="hljs-keyword">operator</span>++() &#123;<br>        ++value;  <span class="hljs-comment">// 增加成员变量 value</span><br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;  <span class="hljs-comment">// 返回当前对象的引用</span><br>    &#125;<br><br>    <span class="hljs-comment">// 前缀 -- 运算符重载</span><br>    MyClass&amp; <span class="hljs-keyword">operator</span>--() &#123;<br>        --value;  <span class="hljs-comment">// 减少成员变量 value</span><br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;  <span class="hljs-comment">// 返回当前对象的引用</span><br>    &#125;<br><br>    <span class="hljs-comment">// 显示值</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Value: &quot;</span> &lt;&lt; value &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">MyClass <span class="hljs-title">obj</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br>    obj.<span class="hljs-built_in">display</span>();<br><br>    ++obj;  <span class="hljs-comment">// 前缀++ 运算符</span><br>    obj.<span class="hljs-built_in">display</span>();<br><br>    --obj;  <span class="hljs-comment">// 前缀-- 运算符</span><br>    obj.<span class="hljs-built_in">display</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><div class="note note-primary">            <p><strong>注意：前缀运算符的返回值是一个对本对象的引用</strong>，这样可以使运算符在连续调用时进行链式操作（例如：<code>++(++obj)</code>）</p>          </div><h4 id="后缀"><a href="#后缀" class="headerlink" title="后缀"></a>后缀</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> value;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 构造函数</span><br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">int</span> v) : <span class="hljs-built_in">value</span>(v) &#123;&#125;<br><br>    <span class="hljs-comment">// 后缀 ++ 运算符重载</span><br>    MyClass <span class="hljs-keyword">operator</span>++(<span class="hljs-type">int</span>) &#123;<br>        MyClass temp = *<span class="hljs-keyword">this</span>;  <span class="hljs-comment">// 保存当前值</span><br>        ++value;  <span class="hljs-comment">// 增加成员变量 value</span><br>        <span class="hljs-keyword">return</span> temp;  <span class="hljs-comment">// 返回原对象</span><br>    &#125;<br><br>    <span class="hljs-comment">// 后缀 -- 运算符重载</span><br>    MyClass <span class="hljs-keyword">operator</span>--(<span class="hljs-type">int</span>) &#123;<br>        MyClass temp = *<span class="hljs-keyword">this</span>;  <span class="hljs-comment">// 保存当前值</span><br>        --value;  <span class="hljs-comment">// 减少成员变量 value</span><br>        <span class="hljs-keyword">return</span> temp;  <span class="hljs-comment">// 返回原对象</span><br>    &#125;<br><br>    <span class="hljs-comment">// 显示值</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Value: &quot;</span> &lt;&lt; value &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">MyClass <span class="hljs-title">obj</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br>    obj.<span class="hljs-built_in">display</span>();<br><br>    obj++;  <span class="hljs-comment">// 后缀++ 运算符</span><br>    obj.<span class="hljs-built_in">display</span>();<br><br>    obj--;  <span class="hljs-comment">// 后缀-- 运算符</span><br>    obj.<span class="hljs-built_in">display</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><div class="note note-primary">            <p>注意：</p><ul><li>后缀运算符的参数列表多了一个<code>int</code>，这是C++用于区分前缀后缀的方式</li><li>后缀运算符重载的返回类型是<strong>值</strong>（会使用到赋值运算符），因此并不能返回对一个局部变量的<strong>引用</strong>。<ul><li><strong>实际上，编译器在执行<code>i++</code>的时候，也是先创建一个副本作为i的初始值，然后执行自增操作后返回副本的值，接着副本被销毁</strong>。</li><li>这种机制导致了**<code>i++</code>所需的计算开销会高于<code>++i</code>**，尤其当i是自己定义的对象或其他内存占比比较大的数据类型时。</li></ul></li></ul>          </div><h3 id="输入-输出运算符的重载"><a href="#输入-输出运算符的重载" class="headerlink" title="输入&#x2F;输出运算符的重载"></a>输入&#x2F;输出运算符的重载</h3><h4 id="重新认识运算符"><a href="#重新认识运算符" class="headerlink" title="重新认识&lt;&lt;和&gt;&gt;运算符"></a>重新认识<code>&lt;&lt;</code>和<code>&gt;&gt;</code>运算符</h4><p>在笔者的第一堂C++启蒙课上，笔者便体会到了<strong>流操作</strong>的精妙和便捷。（相比于<code>printf()</code>和<code>scanf()</code>的冗长语法）但是，当时笔者只是把<code>cin/cout</code>当做一个普通的函数来使用，并不知道其背后深层次的原理。下面，我们先来重新认识一下cin&#x2F;cout的真面目。</p><h5 id="istream和ostream"><a href="#istream和ostream" class="headerlink" title="istream和ostream"></a><code>istream</code>和<code>ostream</code></h5><p>在 C++ 中，<strong>流类（如 <code>std::istream</code> 和 <code>std::ostream</code>）是处理输入输出操作的核心类</strong>，它们为程序提供了与数据流进行交互的功能。这些类是 C++ 标准库的一部分，用于简化与文件、控制台、字符串等设备的交互。</p><p><img src="https://ooo.0x0.ooo/2025/01/23/OG7l2b.png" alt="IOstream"></p><ol><li><strong><code>std::istream</code> 类</strong></li></ol><p><code>std::istream</code> 类是用于处理输入操作的类，提供了从输入流中读取数据的功能。它是所有输入流类（如 <code>cin</code>）的基类。</p><ul><li><strong>构造函数</strong>：<code>std::istream</code> 的构造函数可以用来打开文件或初始化输入流。</li><li>成员函数<ul><li><code>operator&gt;&gt;</code>：流提取运算符，用于从流中提取数据。</li><li><code>get()</code>：用于读取一个字符或一行数据。</li><li><code>read()</code>：从流中读取特定数量的字符。</li><li><code>eof()</code>：检查是否到达文件结束标志。</li><li><code>fail()</code>：检查流是否进入失败状态。</li></ul></li></ul><ol start="2"><li><strong><code>std::ostream</code> 类</strong></li></ol><p><code>std::ostream</code> 类是用于处理输出操作的类，提供了将数据写入输出流的功能。它是所有输出流类（如 <code>cout</code>）的基类。</p><ul><li><p><strong>构造函数</strong>：<code>std::ostream</code> 的构造函数用于打开输出流或初始化输出流。</p></li><li><p>成员函数</p><ul><li><code>operator&lt;&lt;</code>：流插入运算符，用于将数据插入到流中。</li><li><code>put()</code>：用于向流中写入一个字符。</li><li><code>write()</code>：用于向流中写入特定数量的字符。</li><li><code>flush()</code>：强制输出缓冲区内容，确保数据立即写入流。</li><li><code>endl</code>：插入一个换行符并刷新输出流。</li></ul></li></ul><ol start="3"><li><strong>继承结构</strong></li></ol><p><code>std::istream</code> 和 <code>std::ostream</code> 类本身都继承自 <code>std::ios</code> 类，它们共享一些基本的输入输出功能。<code>std::ios</code> 类提供了管理流状态的功能，比如检查是否处于错误状态、是否已到达文件末尾等。</p><ul><li><strong><code>std::ios</code> 类</strong>：<code>std::ios</code> 是 <code>std::istream</code> 和 <code>std::ostream</code> 的基类，负责流的基本状态管理（如错误标志、格式控制等）。<ul><li><code>std::ios::good()</code>: 检查流是否处于良好状态。</li><li><code>std::ios::eof()</code>: 检查流是否到达文件末尾。</li><li><code>std::ios::fail()</code>: 检查流是否处于失败状态。</li></ul></li></ul><ol start="4"><li><strong>常见的派生类</strong></li></ol><ul><li>**<code>std::ifstream</code>**：<code>std::ifstream</code> 是 <code>std::istream</code> 的派生类，用于处理文件输入。它提供了从文件读取数据的功能。</li><li>**<code>std::ofstream</code>**：<code>std::ofstream</code> 是 <code>std::ostream</code> 的派生类，用于处理文件输出。它提供了将数据写入文件的功能。</li><li>**<code>std::stringstream</code>**：<code>std::stringstream</code> 是 <code>std::istream</code> 和 <code>std::ostream</code> 的派生类，允许在内存中处理字符串流。它既可以用于输入也可以用于输出。</li></ul><h5 id="cin和cout"><a href="#cin和cout" class="headerlink" title="cin和cout"></a><code>cin</code>和<code>cout</code></h5><p><code>cin</code> 和 <code>cout</code> 是 C++ 标准库中<strong>预定义的输入和输出流对象</strong>，它们是由流类（如 <code>istream</code> 和 <code>ostream</code>）创建的全局对象，用于进行数据的输入和输出。</p><ul><li><strong><code>cin</code>（标准输入流对象）</strong>：<code>cin</code> 是一个全局的输入流对象，属于 <code>std::istream</code> 类，通常用于从标准输入（如键盘）获取数据。</li><li><strong><code>cout</code>（标准输出流对象）</strong>：<code>cout</code> 是一个全局的输出流对象，属于 <code>std::ostream</code> 类，通常用于将数据输出到标准输出（如显示器）。</li></ul><div class="note note-danger">            <p><strong>是的，cin&#x2F;cout根本不是函数，而是对象！！！</strong></p>          </div><h5 id="运算符"><a href="#运算符" class="headerlink" title="&lt;&lt;和&gt;&gt;运算符"></a><code>&lt;&lt;</code>和<code>&gt;&gt;</code>运算符</h5><p>这些运算符实际上是被重载的，它们不是内置运算符，而是通过重载来定义流操作的行为。</p><ul><li>**流插入运算符 <code>&lt;&lt;</code>**：被 <code>std::ostream</code> 类重载，用于将数据插入到输出流中。当你写 <code>cout &lt;&lt; x;</code> 时，实际上是调用了 <code>std::ostream</code> 类的 <code>operator&lt;&lt;</code> 函数。</li><li>**流提取运算符 <code>&gt;&gt;</code>**：被 <code>std::istream</code> 类重载，用于从输入流中提取数据。当你写 <code>cin &gt;&gt; x;</code> 时，实际上是调用了 <code>std::istream</code> 类的 <code>operator&gt;&gt;</code> 函数。</li></ul><p>流插入运算符&lt;&lt;是一个二元运算符。例如，表达式 cout &lt;&lt; x 的运算符两侧分别是 cout 和 x， x 是一个整型变量， cout 是输出流类 <code>ostream</code> 的对象。 &lt;&lt;运算符将右边对象的值转换成文本形式插入左边的输出流对象， 执行结果是左边的输出流对象的引用。对于 cout &lt;&lt; x，运算结果为对象 cout。正因为&lt;&lt;运算的结果是左边对象的引用，所以允许执行 <code>cout &lt;&lt; x &lt;&lt; y</code> 等的操作。因为&lt;&lt;是左结合的，所以上述表达式先执行 <code>cout &lt;&lt; x</code>，执行的结果是对象 cout，然后执行 <code>cout &lt;&lt; y</code>。</p><h4 id="在自定义类中重载运算符"><a href="#在自定义类中重载运算符" class="headerlink" title="在自定义类中重载&lt;&lt;和&gt;&gt;运算符"></a>在自定义类中重载<code>&lt;&lt;</code>和<code>&gt;&gt;</code>运算符</h4><p>由于第一个参数是<code>ostream/istream</code> 类的对象，因此<strong>流插入运算符不能重载成成员函数，必须重载成全局函数，流输出运算符也是如此</strong>。</p><p>为什么？在 C++ 中，<strong>成员函数的第一个参数通常是隐式的 <code>this</code> 指针</strong>，指向当前对象。因此，成员函数可以通过 <code>this</code> 指针访问对象的成员变量和其他成员函数。也就是说，只有运算符的第一个参数是可以被<strong>this指针指向的，才能够被定义为类内的成员函数</strong>，否则必须被<strong>定义为友元函数</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> x, y;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 构造函数</span><br>    <span class="hljs-built_in">Point</span>(<span class="hljs-type">int</span> x = <span class="hljs-number">0</span>, <span class="hljs-type">int</span> y = <span class="hljs-number">0</span>) : <span class="hljs-built_in">x</span>(x), <span class="hljs-built_in">y</span>(y) &#123;&#125;<br><br>    <span class="hljs-comment">// 重载 &lt;&lt; 运算符</span><br>    <span class="hljs-keyword">friend</span> ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; os, <span class="hljs-type">const</span> Point&amp; p);<br>    <span class="hljs-comment">//参数中第一个对象是ostream类的对象（相当于cout）</span><br>&#125;;<br><br><span class="hljs-comment">// 重载 &lt;&lt; 运算符</span><br>ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; os, <span class="hljs-type">const</span> Point&amp; p) &#123;<br>    os &lt;&lt; <span class="hljs-string">&quot;(&quot;</span> &lt;&lt; p.x &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; p.y &lt;&lt; <span class="hljs-string">&quot;)&quot;</span>;<br>    <span class="hljs-keyword">return</span> os;  <span class="hljs-comment">// 返回 ostream 引用，以便链式调用</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">Point <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)</span></span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Point: &quot;</span> &lt;&lt; p &lt;&lt; endl;  <span class="hljs-comment">// 调用重载的 &lt;&lt; 运算符</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> x, y;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 构造函数</span><br>    <span class="hljs-built_in">Point</span>(<span class="hljs-type">int</span> x = <span class="hljs-number">0</span>, <span class="hljs-type">int</span> y = <span class="hljs-number">0</span>) : <span class="hljs-built_in">x</span>(x), <span class="hljs-built_in">y</span>(y) &#123;&#125;<br><br>    <span class="hljs-comment">// 重载 &gt;&gt; 运算符</span><br>    <span class="hljs-keyword">friend</span> istream&amp; <span class="hljs-keyword">operator</span>&gt;&gt;(istream&amp; is, Point&amp; p);<br>    <span class="hljs-comment">//参数中第一个对象是istream类的对象（相当于cin）</span><br>&#125;;<br><br><span class="hljs-comment">// 重载 &gt;&gt; 运算符</span><br>istream&amp; <span class="hljs-keyword">operator</span>&gt;&gt;(istream&amp; is, Point&amp; p) &#123;<br>    is &gt;&gt; p.x &gt;&gt; p.y;  <span class="hljs-comment">// 从输入流中读取数据到成员变量</span><br>    <span class="hljs-keyword">return</span> is;  <span class="hljs-comment">// 返回 istream 引用，以便链式调用</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">Point <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)</span></span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Enter coordinates for the point (x y): &quot;</span>;<br>    cin &gt;&gt; p;  <span class="hljs-comment">// 调用重载的 &gt;&gt; 运算符</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;You entered point: &quot;</span> &lt;&lt; p &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>相关注意点：</strong></p><ul><li>注意返回类型是对<code>istream</code>或<code>ostream</code>的引用。</li></ul><h2 id="矢量类的实现"><a href="#矢量类的实现" class="headerlink" title="矢量类的实现"></a>矢量类的实现</h2><p>在下文给出了<strong>矢量类vector</strong>的实现（不是STL的那个vector）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// vect.h -- Vector class with &lt;&lt;, mode state</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> VECTOR_H_</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> VECTOR_H_</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">namespace</span> VECTOR<br>&#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Vector</span><br>    &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Mode</span> &#123;RECT, POL&#125;;<br>    <span class="hljs-comment">// RECT for rectangular, POL for Polar modes</span><br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-type">double</span> x;          <span class="hljs-comment">// horizontal value</span><br>        <span class="hljs-type">double</span> y;          <span class="hljs-comment">// vertical value</span><br>        <span class="hljs-type">double</span> mag;        <span class="hljs-comment">// length of vector</span><br>        <span class="hljs-type">double</span> ang;        <span class="hljs-comment">// direction of vector in degrees</span><br>        Mode mode;         <span class="hljs-comment">// RECT or POL</span><br>        <span class="hljs-comment">//状态成员</span><br>    <span class="hljs-comment">// private methods for setting values</span><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set_mag</span><span class="hljs-params">()</span></span>;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set_ang</span><span class="hljs-params">()</span></span>;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set_x</span><span class="hljs-params">()</span></span>;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set_y</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">Vector</span>();<br>        <span class="hljs-built_in">Vector</span>(<span class="hljs-type">double</span> n1, <span class="hljs-type">double</span> n2, Mode form = RECT);<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reset</span><span class="hljs-params">(<span class="hljs-type">double</span> n1, <span class="hljs-type">double</span> n2, Mode form = RECT)</span></span>;<br>        ~<span class="hljs-built_in">Vector</span>();<br>        <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">xval</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<span class="hljs-keyword">return</span> x;&#125;       <span class="hljs-comment">// report x value</span><br>        <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">yval</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<span class="hljs-keyword">return</span> y;&#125;       <span class="hljs-comment">// report y value</span><br>        <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">magval</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<span class="hljs-keyword">return</span> mag;&#125;   <span class="hljs-comment">// report magnitude</span><br>        <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">angval</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<span class="hljs-keyword">return</span> ang;&#125;   <span class="hljs-comment">// report angle</span><br>        <span class="hljs-comment">//这四个报告函数是内联函数</span><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">polar_mode</span><span class="hljs-params">()</span></span>;                    <span class="hljs-comment">// set mode to POL</span><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rect_mode</span><span class="hljs-params">()</span></span>;                     <span class="hljs-comment">// set mode to RECT</span><br>    <span class="hljs-comment">// operator overloading</span><br>        Vector <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Vector &amp; b) <span class="hljs-type">const</span>;<br>        Vector <span class="hljs-keyword">operator</span>-(<span class="hljs-type">const</span> Vector &amp; b) <span class="hljs-type">const</span>;<br>        Vector <span class="hljs-keyword">operator</span>-() <span class="hljs-type">const</span>;<br>        Vector <span class="hljs-keyword">operator</span>*(<span class="hljs-type">double</span> n) <span class="hljs-type">const</span>;<br>    <span class="hljs-comment">// friends</span><br>        <span class="hljs-keyword">friend</span> Vector <span class="hljs-keyword">operator</span>*(<span class="hljs-type">double</span> n, <span class="hljs-type">const</span> Vector &amp; a);<br>        <span class="hljs-keyword">friend</span> std::ostream &amp; <span class="hljs-keyword">operator</span>&lt;&lt;(std::ostream &amp; os, <span class="hljs-type">const</span> Vector &amp; v);<br>    &#125;;<br><br>&#125;   <span class="hljs-comment">// end namespace VECTOR</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// vect.cpp -- methods for the Vector class</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;vect.h&quot;</span>   <span class="hljs-comment">// includes &lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> std::sqrt;<br><span class="hljs-keyword">using</span> std::sin;<br><span class="hljs-keyword">using</span> std::cos;<br><span class="hljs-keyword">using</span> std::atan;<br><span class="hljs-keyword">using</span> std::atan2;<br><span class="hljs-keyword">using</span> std::cout;<br><br><span class="hljs-keyword">namespace</span> VECTOR<br>&#123;<br>    <span class="hljs-comment">// compute degrees in one radian</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">double</span> Rad_to_deg = <span class="hljs-number">45.0</span> / <span class="hljs-built_in">atan</span>(<span class="hljs-number">1.0</span>);<br>    <span class="hljs-comment">// should be about 57.2957795130823</span><br><br>    <span class="hljs-comment">// private methods</span><br>    <span class="hljs-comment">// calculates magnitude from x and y</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Vector::set_mag</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        mag = <span class="hljs-built_in">sqrt</span>(x * x + y * y);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Vector::set_ang</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (x == <span class="hljs-number">0.0</span> &amp;&amp; y == <span class="hljs-number">0.0</span>)<br>            ang = <span class="hljs-number">0.0</span>;<br>        <span class="hljs-keyword">else</span><br>            ang = <span class="hljs-built_in">atan2</span>(y, x);<br>    &#125;<br><br>    <span class="hljs-comment">// set x from polar coordinate</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Vector::set_x</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        x = mag * <span class="hljs-built_in">cos</span>(ang);<br>    &#125;<br><br>    <span class="hljs-comment">// set y from polar coordinate</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Vector::set_y</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        y = mag * <span class="hljs-built_in">sin</span>(ang);<br>    &#125;<br><br>    <span class="hljs-comment">// public methods</span><br>    Vector::<span class="hljs-built_in">Vector</span>()             <span class="hljs-comment">// default constructor</span><br>    &#123;<br>        x = y = mag = ang = <span class="hljs-number">0.0</span>;<br>        mode = RECT;<br>    &#125;<br><br>    <span class="hljs-comment">// construct vector from rectangular coordinates if form is r</span><br>    <span class="hljs-comment">// (the default) or else from polar coordinates if form is p</span><br>    Vector::<span class="hljs-built_in">Vector</span>(<span class="hljs-type">double</span> n1, <span class="hljs-type">double</span> n2, Mode form)<br>    &#123;<br>        mode = form;<br>        <span class="hljs-keyword">if</span> (form == RECT)<br>         &#123;<br>             x = n1;<br>             y = n2;<br>             <span class="hljs-built_in">set_mag</span>();<br>             <span class="hljs-built_in">set_ang</span>();<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (form == POL)<br>        &#123;<br>             mag = n1;<br>             ang = n2 / Rad_to_deg;<br>             <span class="hljs-built_in">set_x</span>();<br>             <span class="hljs-built_in">set_y</span>();<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>             cout &lt;&lt; <span class="hljs-string">&quot;Incorrect 3rd argument to Vector() -- &quot;</span>;<br>             cout &lt;&lt; <span class="hljs-string">&quot;vector set to 0\n&quot;</span>;<br>             x = y = mag = ang = <span class="hljs-number">0.0</span>;<br>             mode = RECT;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// reset vector from rectangular coordinates if form is</span><br>    <span class="hljs-comment">// RECT (the default) or else from polar coordinates if</span><br>    <span class="hljs-comment">// form is POL</span><br>    <span class="hljs-type">void</span> Vector:: <span class="hljs-built_in">reset</span>(<span class="hljs-type">double</span> n1, <span class="hljs-type">double</span> n2, Mode form)<br>    &#123;<br>        mode = form;<br>        <span class="hljs-keyword">if</span> (form == RECT)<br>         &#123;<br>             x = n1;<br>             y = n2;<br>             <span class="hljs-built_in">set_mag</span>();<br>             <span class="hljs-built_in">set_ang</span>();<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (form == POL)<br>        &#123;<br>             mag = n1;<br>             ang = n2 / Rad_to_deg;<br>             <span class="hljs-built_in">set_x</span>();<br>             <span class="hljs-built_in">set_y</span>();<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>             cout &lt;&lt; <span class="hljs-string">&quot;Incorrect 3rd argument to Vector() -- &quot;</span>;<br>             cout &lt;&lt; <span class="hljs-string">&quot;vector set to 0\n&quot;</span>;<br>             x = y = mag = ang = <span class="hljs-number">0.0</span>;<br>             mode = RECT;<br>        &#125;<br>    &#125;<br><br>    Vector::~<span class="hljs-built_in">Vector</span>()    <span class="hljs-comment">// destructor</span><br>    &#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Vector::polar_mode</span><span class="hljs-params">()</span>    <span class="hljs-comment">// set to polar mode</span></span><br><span class="hljs-function">    </span>&#123;<br>        mode = POL;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Vector::rect_mode</span><span class="hljs-params">()</span>     <span class="hljs-comment">// set to rectangular mode</span></span><br><span class="hljs-function">    </span>&#123;<br>        mode = RECT;<br>    &#125;<br><br>    <span class="hljs-comment">// operator overloading</span><br>    <span class="hljs-comment">// add two Vectors</span><br>    Vector Vector::<span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Vector &amp; b) <span class="hljs-type">const</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Vector</span>(x + b.x, y + b.y);<br>    &#125;<br><br>    <span class="hljs-comment">// subtract Vector b from a</span><br>    Vector Vector::<span class="hljs-keyword">operator</span>-(<span class="hljs-type">const</span> Vector &amp; b) <span class="hljs-type">const</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Vector</span>(x - b.x, y - b.y);<br>    &#125;<br><br>    <span class="hljs-comment">// reverse sign of Vector</span><br>    Vector Vector::<span class="hljs-keyword">operator</span>-() <span class="hljs-type">const</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Vector</span>(-x, -y);<br>    &#125;<br><br>    <span class="hljs-comment">// multiply vector by n</span><br>    Vector Vector::<span class="hljs-keyword">operator</span>*(<span class="hljs-type">double</span> n) <span class="hljs-type">const</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Vector</span>(n * x, n * y);<br>    &#125;<br><br>    <span class="hljs-comment">// friend methods</span><br>    <span class="hljs-comment">// multiply n by Vector a</span><br>    Vector <span class="hljs-keyword">operator</span>*(<span class="hljs-type">double</span> n, <span class="hljs-type">const</span> Vector &amp; a)<br>    &#123;<br>        <span class="hljs-keyword">return</span> a * n;<br>    &#125;<br><br>    <span class="hljs-comment">// display rectangular coordinates if mode is RECT,</span><br>    <span class="hljs-comment">// else display polar coordinates if mode is POL</span><br>    std::ostream &amp; <span class="hljs-keyword">operator</span>&lt;&lt;(std::ostream &amp; os, <span class="hljs-type">const</span> Vector &amp; v)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (v.mode == Vector::RECT)<br>             os &lt;&lt; <span class="hljs-string">&quot;(x,y) = (&quot;</span> &lt;&lt; v.x &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; v.y &lt;&lt; <span class="hljs-string">&quot;)&quot;</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (v.mode == Vector::POL)<br>        &#123;<br>             os &lt;&lt; <span class="hljs-string">&quot;(m,a) = (&quot;</span> &lt;&lt; v.mag &lt;&lt; <span class="hljs-string">&quot;, &quot;</span><br>                 &lt;&lt; v.ang * Rad_to_deg &lt;&lt; <span class="hljs-string">&quot;)&quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>             os &lt;&lt; <span class="hljs-string">&quot;Vector object mode is invalid&quot;</span>;<br>        <span class="hljs-keyword">return</span> os; <br>    &#125;<br><br>&#125;  <span class="hljs-comment">// end namespace VECTOR</span><br><br></code></pre></td></tr></table></figure><h2 id="类的自动转换和强制类型转换"><a href="#类的自动转换和强制类型转换" class="headerlink" title="类的自动转换和强制类型转换"></a>类的自动转换和强制类型转换</h2><p>对于基本数据类型：使用自动转换和强制类型转换。</p><h3 id="类的自动类型转换"><a href="#类的自动类型转换" class="headerlink" title="类的自动类型转换"></a>类的自动类型转换</h3><p>类之间的自动类型转换通常通过 <strong>构造函数</strong> 或 <strong>转换运算符</strong> 来实现。这种转换在 C++ 中是自动发生的，当目标类型的构造函数或转换运算符能接收源类型时，编译器会自动进行转换。</p><p>例如，如果一个类具有一个接受 <code>int</code> 类型的构造函数或转换运算符，当你尝试将 <code>int</code> 类型的对象赋值给该类的对象时，编译器会自动调用该构造函数或转换运算符。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> value;<br><br>    <span class="hljs-comment">// 构造函数，可以从 int 转换为 MyClass</span><br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">int</span> val) : <span class="hljs-built_in">value</span>(val) &#123;&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    MyClass obj = <span class="hljs-number">10</span>;  <span class="hljs-comment">// 自动调用 MyClass(int) 构造函数</span><br>    cout &lt;&lt; obj.value &lt;&lt; endl;  <span class="hljs-comment">// 输出 10</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的代码中，<code>int</code> 被自动转换为 <code>MyClass</code> 对象，这依赖于 <code>MyClass</code> 的构造函数。</p><ul><li><p><strong>可以将类定义成基本类型或与另一个类相关，使得从一种类型强制转换到另一种类型是有意义的</strong></p><ul><li>例：利用构造函数（但只有一个参数，其余均默认）</li></ul></li><li><p>类的隐式转换</p><ul><li>int可以先转换成double类型，再被转换成自定义的类（可能会带来安全隐患）：<strong>二步转换</strong>（<strong>无二义性</strong>）</li></ul></li><li><p>使用<code>exlpicit</code>关键词可以关闭自动转换（只允许显示转换）</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Stonewt</span><span class="hljs-params">(<span class="hljs-type">double</span> lbs)</span></span><br></code></pre></td></tr></table></figure><p><img src="https://ooo.0x0.ooo/2025/01/23/OG7jWl.png" alt="Explicit"></p><ul><li><p>转换函数：将类转换为基本的数据类型</p><ul><li><p>声明：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">typeName</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">int</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">double</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure></li><li><p>定义</p></li></ul><p><img src="https://ooo.0x0.ooo/2025/01/23/OG72gg.png" alt="Definition"></p><ul><li>优化：进行显示转换</li></ul><p><img src="https://ooo.0x0.ooo/2025/01/23/OG76VB.png" alt="Modofication"></p><ul><li><strong>警告：使用过多的转换函数可能会导致二义性冲突</strong>。</li></ul></li></ul><div class="note note-info">            <h3 id="补充知识：五种强制类型转换"><a href="#补充知识：五种强制类型转换" class="headerlink" title="补充知识：五种强制类型转换"></a>补充知识：五种强制类型转换</h3><p>在 C++ 中，强制类型转换（也称为显式类型转换）允许程序员显式地转换一种类型到另一种类型。强制类型转换提供了比自动类型转换更大的灵活性，但也带来一定的风险，因为不当的转换可能会导致程序出错或行为未定义。</p><p>C++ 提供了 <strong>四种类型转换操作符</strong>，它们比传统的 C 风格转换更具类型安全性和可维护性。具体来说，C++ 强制类型转换包括：</p><ol><li><strong>C 风格类型转换</strong>（<code>(type)expression</code>）</li><li><strong><code>static_cast</code></strong></li><li><strong><code>dynamic_cast</code></strong></li><li><strong><code>const_cast</code></strong></li><li><strong><code>reinterpret_cast</code></strong></li></ol><p>下面分别介绍这五种类型转换方式。</p><h4 id="1-C-风格类型转换（C-style-Cast）"><a href="#1-C-风格类型转换（C-style-Cast）" class="headerlink" title="1. C 风格类型转换（C-style Cast）"></a>1. <strong>C 风格类型转换（C-style Cast）</strong></h4><p><strong>语法</strong>：<code>(new_type)expression</code></p><p>这是最基本、最传统的类型转换方式，类似于 C 语言中的类型转换方式。它可以进行大多数类型转换，包括基本类型之间的转换和类类型之间的转换。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">double</span> b = (<span class="hljs-type">double</span>)a;  <span class="hljs-comment">// 强制将 int 转换为 double</span><br>std::cout &lt;&lt; b &lt;&lt; std::endl;  <span class="hljs-comment">// 输出 10.0</span><br></code></pre></td></tr></table></figure><ul><li><strong>优点</strong>：语法简单，易于使用。</li><li><strong>缺点</strong>：没有类型安全检查，不容易发现错误。由于它能进行多种转换（例如基本类型转换、类类型转换等），可能会导致意外的转换行为。</li></ul><hr><h4 id="2-static-cast"><a href="#2-static-cast" class="headerlink" title="2. static_cast"></a>2. <strong><code>static_cast</code></strong></h4><p><strong>语法</strong>：<code>static_cast&lt;new_type&gt;(expression)</code></p><p><code>static_cast</code> 是 C++ 提供的一种类型安全的强制类型转换方式。它通常用于：</p><ul><li>基本类型之间的转换。</li><li><strong>类层次结构中，向上或向下转换（在没有多态的情况下）</strong>；</li><li>其他兼容类型之间的转换。</li></ul><p><code>static_cast</code> 是 <strong>类型安全的</strong>，它会在编译时检查类型是否兼容，因此可以避免一些常见的转换错误。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">double</span> a = <span class="hljs-number">3.14</span>;<br><span class="hljs-type">int</span> b = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(a);  <span class="hljs-comment">// 强制将 double 转换为 int</span><br>std::cout &lt;&lt; b &lt;&lt; std::endl;  <span class="hljs-comment">// 输出 3</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Base&quot;</span> &lt;&lt; std::endl; &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Derived&quot;</span> &lt;&lt; std::endl; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Base* basePtr = <span class="hljs-keyword">new</span> Derived;<br>    Derived* derivedPtr = <span class="hljs-built_in">static_cast</span>&lt;Derived*&gt;(basePtr);  <span class="hljs-comment">// 向下转型</span><br>    derivedPtr-&gt;<span class="hljs-built_in">show</span>();  <span class="hljs-comment">// 输出 &quot;Derived&quot;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>优点</strong>：类型检查在编译时完成，能确保类型兼容性。</li><li><strong>缺点</strong>：如果转换不合理，<code>static_cast</code> 会导致编译错误。</li></ul><hr><h4 id="3-dynamic-cast"><a href="#3-dynamic-cast" class="headerlink" title="3. dynamic_cast"></a>3. <strong><code>dynamic_cast</code></strong></h4><p><strong>语法</strong>：<code>dynamic_cast&lt;new_type&gt;(expression)</code></p><p><code>dynamic_cast</code> 用于<strong>处理类类型的转换，尤其是在类之间存在继承关系时</strong>。它通常用于：</p><ul><li>向下转型（从基类指针或引用转换为派生类指针或引用）。</li><li>进行 <strong>RTTI（运行时类型识别）</strong> 检查，用于多态类（具有虚函数的类）之间的转换。</li><li>对于指针或引用，<code>dynamic_cast</code> 会在运行时检查类型是否安全，如果类型不兼容，则会返回 <code>nullptr</code>（对于指针）或抛出 <code>std::bad_cast</code> 异常（对于引用）。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Base&quot;</span> &lt;&lt; std::endl; &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Derived&quot;</span> &lt;&lt; std::endl; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Base* basePtr = <span class="hljs-keyword">new</span> Derived;<br>    Derived* derivedPtr = <span class="hljs-built_in">dynamic_cast</span>&lt;Derived*&gt;(basePtr);  <span class="hljs-comment">// 向下转型</span><br>    <span class="hljs-keyword">if</span> (derivedPtr) &#123;<br>        derivedPtr-&gt;<span class="hljs-built_in">show</span>();  <span class="hljs-comment">// 输出 &quot;Derived&quot;</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Conversion failed&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于不安全的转换，<code>dynamic_cast</code> 会返回 <code>nullptr</code>（指针转换）或抛出异常（引用转换）。</p><ul><li><strong>优点</strong>：提供了运行时类型检查，避免不安全的类型转换。</li><li><strong>缺点</strong>：只能用于类类型（具有虚函数的类），并且运行时有一定的性能开销。</li></ul><hr><h4 id="4-const-cast"><a href="#4-const-cast" class="headerlink" title="4. const_cast"></a>4. <strong><code>const_cast</code></strong></h4><p><strong>语法</strong>：<code>const_cast&lt;new_type&gt;(expression)</code></p><p><code>const_cast</code> 用于添加或移除对象的 <strong>const</strong> 属性。它允许程序修改一个原本是 <code>const</code> 的对象，或者从 <code>const</code> 类型的指针&#x2F;引用获取非 <code>const</code> 类型的指针&#x2F;引用。</p><ul><li>移除 <code>const</code> 属性：通常用于修改本来是常量的对象，或者修改 <code>const</code> 指针所指向的内容。</li><li>添加 <code>const</code> 属性：较少使用，通常用于将非 <code>const</code> 对象传递给接受 <code>const</code> 类型参数的函数。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span>* p = <span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">int</span>*&gt;(&amp;a);  <span class="hljs-comment">// 移除 const 属性</span><br>*p = <span class="hljs-number">20</span>;  <span class="hljs-comment">// 修改常量对象的值</span><br>std::cout &lt;&lt; a &lt;&lt; std::endl;  <span class="hljs-comment">// 输出 20</span><br></code></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：这种转换非常危险，因为它绕过了 <code>const</code> 修饰符的保护，可能会导致未定义行为。如果原对象是 <code>const</code>，通过 <code>const_cast</code> 进行修改是不合法的。</p></blockquote><ul><li><strong>优点</strong>：可以显式地修改 <code>const</code> 对象的 <code>const</code> 属性，满足特殊需求。</li><li><strong>缺点</strong>：滥用 <code>const_cast</code> 可能会破坏程序的 <strong>const-correctness</strong>，导致潜在的 bug 和未定义行为。</li></ul><hr><h4 id="5-reinterpret-cast"><a href="#5-reinterpret-cast" class="headerlink" title="5. reinterpret_cast"></a>5. <strong><code>reinterpret_cast</code></strong></h4><p><strong>语法</strong>：<code>reinterpret_cast&lt;new_type&gt;(expression)</code></p><p><code>reinterpret_cast</code> 用于极低级别的转换，它允许程序员强制转换几乎任何类型到任何其他类型，甚至是完全不相关的类型。它是最强大的类型转换方式，但也最危险，因为它可能破坏内存布局并导致未定义行为。</p><ul><li>常用于指针类型的转换。</li><li>对于完全不相关的类型，<code>reinterpret_cast</code> 可能会导致程序崩溃。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">void</span>* ptr = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">void</span>*&gt;(&amp;a);  <span class="hljs-comment">// 将 int* 转换为 void*</span><br>std::cout &lt;&lt; *<span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">int</span>*&gt;(ptr) &lt;&lt; std::endl;  <span class="hljs-comment">// 输出 10</span><br></code></pre></td></tr></table></figure><ul><li><strong>优点</strong>：极其灵活，能够在底层进行类型转换，适用于底层操作和与硬件、操作系统接口的交互。</li><li><strong>缺点</strong>：几乎没有类型安全保障，可能导致程序崩溃，或者出现未定义行为，使用时要非常小心。</li></ul><hr><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h4><p>C++ 提供了五种类型转换方式，各自有其特定的使用场景和优缺点：</p><ol><li><strong>C 风格类型转换</strong>：简单但缺乏类型安全，适合快速开发，但不推荐用于复杂的程序中。</li><li>**<code>static_cast</code>**：类型安全，适用于基本类型和兼容类型的转换，是常见的类型转换方式。</li><li>**<code>dynamic_cast</code>**：主要用于类类型转换，并进行运行时类型检查，确保安全，适合多态类型。</li><li>**<code>const_cast</code>**：用于移除或添加 <code>const</code> 属性，通常在需要修改 <code>const</code> 对象时使用，但要小心避免滥用。</li><li>**<code>reinterpret_cast</code>**：低级别的转换，允许对几乎所有类型进行转换，但极其危险，应该谨慎使用。</li></ol><p>在实际开发中，尽量避免过度使用强制类型转换，特别是 <code>reinterpret_cast</code> 和 <code>const_cast</code>，它们可能破坏类型安全。更推荐使用 <code>static_cast</code> 和 <code>dynamic_cast</code>，它们提供了更好的类型安全性和可维护性。</p>          </div><h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>终于结束啦！本章主要聚焦在类和对象的使用上，在下一篇博客中，我们将会将重点转移到一个令人又爱又恨的东西上：<strong>动态内存分配</strong>！</p>]]></content>
    
    
    <categories>
      
      <category>Code</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tutorial</tag>
      
      <tag>Finished</tag>
      
      <tag>C/C++</tag>
      
      <tag>OOP</tag>
      
      <tag>C++ Primer Plus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C-Plus-Plus-Primer-Plus-Tutorial</title>
    <link href="/posts/C-plus-plus-Primer-Plus-tutorial/"/>
    <url>/posts/C-plus-plus-Primer-Plus-tutorial/</url>
    
    <content type="html"><![CDATA[<style>  html, body, .markdown-body {    font-family: Georgia, sans, serif;  }</style><h1 id="C-Primer-Plus-tutorial"><a href="#C-Primer-Plus-tutorial" class="headerlink" title="C++ Primer Plus tutorial"></a>C++ Primer Plus tutorial</h1><h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>笔者又来开新坑啦！</p><p>之前看到一个很讽刺的笑话：<strong>大多数国内高校学生学到的C++只是C语言+cin&#x2F;cout</strong>。这当然只是一句玩笑话，但很深刻地反映出对于C++精髓<strong>面向对象编程</strong>的忽视。</p><p>这是有理可依的：<strong>编程语言的学习本身就和传统的课堂授课模式存在较大的出入</strong>，编程重视实践，枯燥的语法讲解如同天书一般晦涩难懂，更不用提OOP所涉及的都是比较大规模的项目工程，如果只是在课堂上乏味地讲解“什么是析构函数，什么是继承，什么是多态···”，很容易将C++学成死记硬背的无聊学科。</p><p>因此，笔者在课堂学习之余，<strong>同步学习了世界经典C++教材——《C++ Primer Plus》的相关内容</strong>。经典不愧为经典！</p><p>但是，针对我个人而言，我认为C++ Primer Plus有以下问题：（其实也不算是问题啦，就是和普通在校大学生存在一些“冲突”）</p><ul><li>一共678页，并且全是密密麻麻的字，阅读周期长，读完需要很大的意志力（对于自学者）。</li><li>由于翻译等种种的原因，在很多地方的解释并不清晰（作为一本C++的入门书籍体量有些大了，而且涉及到很多专业的名词，看得让人头大）</li></ul><p>因此，笔者希望通过博客的方式，记录自己的C++ Primer Plus学习笔记，并上传到网络上供一同学习的小伙伴参考。</p><p>博客立志于：</p><ul><li>记录自己的C++学习过程</li><li>对本人认为的C++学习中的一些重难点做一些额外的解释</li><li>尝试用简单清晰的语言梳理逻辑脉络</li></ul><h2 id="更新内容范围"><a href="#更新内容范围" class="headerlink" title="更新内容范围"></a>更新内容范围</h2><ul><li><strong>Chapter10 对象和类</strong></li><li><strong>Chapter11 使用类</strong></li><li><strong>Chapter12 类和动态内存分配</strong></li><li><strong>Chapter13 类继承</strong></li><li><strong>Chapter14 代码重用</strong></li><li><strong>Chapter15 友元，异常和其他</strong></li><li><strong>Chapter16 string类的标准模板库</strong></li></ul><p>（目前更新计划主要分布在OOP的章节，之后的其他章节看情况更新~）</p><h2 id="实际更新的目录"><a href="#实际更新的目录" class="headerlink" title="实际更新的目录"></a>实际更新的目录</h2><p><a href="https://xiyuanyang-code.github.io/tags/OOP/">系列文章</a></p><div class="note note-info">            <h3 id="Introduction-to-OOP"><a href="#Introduction-to-OOP" class="headerlink" title="Introduction to OOP"></a>Introduction to OOP</h3><p>欢迎来到<strong>面向对象编程</strong>的世界！首先文章将会向你介绍在面向对象编程中四个最核心的精神：<strong>封装、继承、多态和抽象</strong>，并对面向对象所涉及的知识做一个总体性的概览。接下来，你将系统学习到什么是<strong>类和对象</strong>，以及如何创建并使用自己的类和对象。文章的内容涵盖<strong>构造函数</strong>的四种定义、<strong>析构函数</strong>的使用、<strong>静态和动态</strong>数据成员以及成员函数、<strong>友元函数</strong>、<strong>const函数</strong>的用法、<strong>this指针</strong>以及类的自动类型转换等知识。</p><p>Welcome to the world of <strong>Object-Oriented Programming (OOP)</strong>! This article will first introduce you to the four core principles of OOP: <strong>Encapsulation, Inheritance, Polymorphism, and Abstraction</strong>, and provide an overview of the knowledge involved in OOP. Next, you will systematically learn what <strong>classes and objects</strong> are, and how to create and use your own classes and objects. The article covers topics such as the four definitions of <strong>constructors</strong>, the use of <strong>destructors</strong>, <strong>static</strong> and <strong>dynamic</strong> data members and member functions, <strong>friend functions</strong>, the usage of const functions, the <strong><code>this</code></strong> pointer, and <strong>automatic type conversion of classes</strong>, among others.</p><p><strong>Key words: OOP, constructors, destructors, this pointer, friend functions</strong></p><h3 id="Dynamic-Memory-and-Class"><a href="#Dynamic-Memory-and-Class" class="headerlink" title="Dynamic Memory and Class"></a>Dynamic Memory and Class</h3><p>本章将重点放在如何对<strong>自定义类和对象</strong>谨慎地使用<strong>动态内存分配</strong>，以及内存管理的相关知识。首先从一个代码示例StringBad讲起，分析因为C++自带的隐式复制构造函数导致<strong>按值传递</strong>和<strong>按址传递</strong>发生冲突而导致程序无法正确输出，并以此为教材介绍了如何<strong>显式</strong>地定义<strong>复制构造函数和赋值运算符</strong>，并给出了修改后的String类的类定义和使用示范。接着，文章聚焦于在类中使用动态内存的易错点，包括new和delete的一一对应问题。最后，文章分析了使用动态内存分配在设计类和对象过程中的应用：<strong>设置合理的返回对象</strong>和<strong>使用指向对象的指针</strong>，同时介绍了动态内存管理的一些高级操作，包括<strong>正确地使用析构函数</strong>和<strong>使用定位new运算符</strong>。</p><p>This chapter focuses on how to <strong>cautiously use dynamic memory allocation with</strong> <strong>custom classes and objects</strong>, along with related knowledge on memory management. It begins with a code example, StringBad, to analyze how the implicit copy constructor provided by C++ leads to conflicts between <strong>pass-by-value</strong> and <strong>pass-by-reference</strong>, resulting in incorrect program output. Using this example as a teaching tool, the chapter introduces how to <strong>explicitly</strong> define <strong>copy constructors and assignment operators</strong>, and provides an updated class definition and usage demonstration for the String class. Next, the article focuses on common pitfalls when using dynamic memory in classes, including the one-to-one correspondence issue between new and delete. Finally, the chapter discusses the application of dynamic memory allocation in the design of classes and objects: <strong>setting appropriate return objects</strong> and <strong>using pointers to objects</strong>, while also introducing some advanced operations in dynamic memory management, such as <strong>correctly using destructors</strong> and <strong>using placement new operator</strong>.</p><p><strong>Key words: OOP, Dynamic Memory, C++, Classes</strong></p><h3 id="Class-Inheritance"><a href="#Class-Inheritance" class="headerlink" title="Class Inheritance"></a>Class Inheritance</h3><p>在本文中，你将学到面向对象编程中的又一个核心思想：<strong>继承与多态</strong>。本文从一个基本的基类讲起并延伸到派生类的定义和基本使用，探讨<strong>派生类和基类的特殊关系</strong>。接下来本文深入继承的原理，介绍在多态公有继承中的<strong>is-a</strong>关系和虚函数，已经动态联编和静态联编的基本知识。接着本文介绍了<strong>抽象基类</strong>的使用以及在派生类中使用<strong>动态内存分配</strong>的注意事项。最后本文对OOP的基本精神——封装、继承与多态和相关基础知识做了梳理。</p><p>In this article, you will learn another core concept in object-oriented programming: <strong>inheritance and polymorphism</strong>. The article begins with a basic base class and extends to the definition and basic usage of derived classes, <strong>exploring the special relationship between derived and base classes</strong>. Next, the article delves into the principles of inheritance, introducing the <strong>is-a</strong> relationship in polymorphic public inheritance, virtual functions, and the basics of dynamic and static binding. Then, the article discusses the use of <strong>abstract base classes</strong> to improve efficiency, as well as considerations for using <strong>dynamic memory allocation in derived classes</strong>. Finally, the article summarizes the fundamental principles of OOP—encapsulation, inheritance, and polymorphism—along with related foundational knowledge.</p><p><strong>Key words: OOP, Class Inheritance, Abstract Base Classes, Polymorphism</strong></p><h3 id="Code-Reuse-in-OOP"><a href="#Code-Reuse-in-OOP" class="headerlink" title="Code Reuse in OOP"></a>Code Reuse in OOP</h3><p>C++的一个主要目标是促进代码重用。公有继承是实现这种目标的机制之一，但并不是唯一的机制。本章将介绍其他方法，其中之一是使用这样的类成员：本身是另一个类的对象。这种方法称为<strong>包含（containment）、组合（composition）或层次化（layering）</strong>。另一种方法是使用私有或保护继承。通常，<strong>包含、私有继承和保护继承</strong>用于实现 <strong>has-a</strong> 关系，即新的类将包含另一个类的对象。多重继承使得能够使用两个或更多的基类派生出新的类，将基类的功能组合在一起。同时，本章将介绍<strong>类模板</strong>——另一种重用代码的方法。类模板使我们能够使用通用术语定义类，然后使用模板来创建针对特定类型定义的特殊类。</p><p>One of the main goals of C++ is to promote code reuse. <strong>Public inheritance</strong> is one of the mechanisms to achieve this goal, but not the only one. This chapter will introduce other methods, one of which is to use class members that are themselves objects of another class. This method is called <strong>containment</strong>, <strong>composition, or layering</strong>. Another method is to use <strong>private or protected inheritance</strong>. Generally, containment, private inheritance, and protected inheritance are used to implement the <strong>has - a relationship</strong>, that is, the new class will contain an object of another class. Multiple inheritance enables new classes to be derived from two or more base classes, combining the functionality of the base classes.At the same time, this chapter will introduce <strong>class templates</strong> - another method of reusing code. Class templates enable us to define classes in general terms and then use the templates to create special classes defined for specific types.</p><p><strong>Key words: Public Inheritance, Containment, class template, composition</strong></p>          </div><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>本博客系列使用的大部分代码都摘自《C++ Primer Plus》。</p>]]></content>
    
    
    <categories>
      
      <category>Code</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Announcement</tag>
      
      <tag>Finished</tag>
      
      <tag>C/C++</tag>
      
      <tag>OOP</tag>
      
      <tag>C++ Primer Plus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Above-All</title>
    <link href="/posts/Above-All/"/>
    <url>/posts/Above-All/</url>
    
    <content type="html"><![CDATA[<style>  html, body, .markdown-body {    font-family: Georgia, sans, serif;  }</style><h1 id="Welcome-To-My-Blog"><a href="#Welcome-To-My-Blog" class="headerlink" title="Welcome To My Blog !"></a>Welcome To My Blog !</h1><h2 id="写在前面的话"><a href="#写在前面的话" class="headerlink" title="写在前面的话"></a>写在前面的话</h2><p>这部分的内容和 <a href="https://xiyuanyang-code.github.io/above/">Intro</a> 的部分相同，主要是对本人博客的更新动机，更新目标和更新内容做一个总体性的概览~可自行跳转观看。</p><h2 id="Before-The-Blog"><a href="#Before-The-Blog" class="headerlink" title="Before The Blog"></a>Before The Blog</h2><p>三个月前，我通过偶然的机会了解到前 OpenAI 研究副总裁，主管GPT模型安全的杰出华人女性，<strong>翁荔(Lilian Weng)<strong>。她提出了著名的</strong>Agent 配方：Agent&#x3D;LLM+Memory+planning skills+tool use</strong>。在当今的GPT时代，她可谓是功不可没。</p><p>在OpenAI对她的独家专访<a href="https://openai.com/index/the-power-of-continuous-learning/">The power of continuous learning</a>中，她提到：</p><blockquote><p>I believe in the power of learning and it is never too late to learn. Maintaining my personal blog is a good way to keep this curiosity going and learn about new progress in the deep learning community regularly. I also encourage my team to keep on learning, whether related or unrelated to their current projects. Ideas in different topics or fields can often inspire new ideas and broaden the potential solution space.</p><p>I’m also a strong believer in teamwork. If everyone shines in their best strength, we will get 1+1 &gt; 2. Meanwhile, we might often run into “dirty” work and personally I’m very willing to take on those tasks, because as long as that’s the biggest blocker or that task can add the biggest value into the project, nothing should be considered “dirty” or “trivial.” I encourage people around me to do the same, being a team player and working together to expedite the team productivity.</p><p>我相信学习的力量，学习永远不会太迟。维护个人博客是一个保持好奇心，定期了解深度学习社区新进展的好方法。我也鼓励我的团队不断学习，无论是否与他们当前的项目相关。不同主题或领域的想法常常能激发新的灵感，并拓宽潜在的解决方案空间。</p><p>我也是团队合作的坚定信徒。如果每个人都能在自己最擅长的领域发光，我们就能实现1+1大于2。同时，我们可能会碰到一些“脏活”，而我个人非常愿意承担这些任务，因为只要那是最大的障碍，或者那项任务能为项目带来最大的价值，就没有什么是“脏活”或“琐事”。我鼓励周围的人也这样做，成为团队的一员，共同努力提高团队的生产力。</p></blockquote><p>图源：<a href="https://openai.com/index/the-power-of-continuous-learning/">The power of continuous learning | OpenAI</a>   Photo: Jake Stangel</p><p>这与<strong>费曼学习法（Feynman Technique）</strong>可谓是不谋而合：</p><blockquote><p>1.Identify the subject. Write down everything you know about the topic.</p><p>2.Teach it to a child. If you can teach a concept to a child, you’re way ahead of the game.</p><p>3.Identify your knowledge gaps. This is the point where the real learning happens.</p><p>4.Organize + simplify + Tell a story. Start to tell your story.</p></blockquote><p>此时，刚刚步入大学校园3个月的笔者，由于深受高中优绩主义和应试思想的遗风荼毒，对大学生活和计算机学科的学习颇具不适应的疲态。学习的知识如此海量，却无法依靠应试和做题进行巩固，该如何是好？</p><p>或许<strong>上文已经给出了答案。</strong></p><center><p><font size=6><b><p style="color:red;">我要创建自己的博客!</p></b></font></p></center><p>无论是传统的做题刷卷，还是博客，亦或是“费曼学习法”，本质上都是<strong>强化训练人脑在吸收新知识后的有效输出过程</strong>：当你能很流畅地给出一道数学题的若干种证明方法时，能逻辑清晰地将所学的知识穿成逻辑链条或思维导图，呈现在博客中为他人所吸收时，你便通过<strong>有效的对外做功输出</strong>很好地巩固了所学的知识。同时，知识的不断沉淀也带来了莫大的成就感。</p><p>但是，写一篇博客，可不仅仅是打打字那么简单。</p><p>不知各位在高中写议论文的时候有没有一种“咬牙切齿”的感觉，就是<strong>我想到的≠我实际构思好的≠我输出的≠我希望所表达的</strong>，甚至于，很多时候我们心中所谓的灵感只是<strong>乍现的只言片语的碎片</strong>，距离成为一篇逻辑清晰，内容详实且有创新性的博客文章还有很长的路要走。这便是博客写作的难点，也是<strong>我希望通过个人博客来训练的最重要的内容：将心里的灵感进行有效的输出，力求逻辑性和学术的专业性。</strong></p><h2 id="About-the-Blog"><a href="#About-the-Blog" class="headerlink" title="About the Blog"></a>About the Blog</h2><p><strong>Xiyuan Yang’s Blog</strong>，创建于<strong>2024年11月19日</strong>。</p><p>以下是自我简介（摘自<a href="https://xiyuanyang-code.github.io/about/">About - Xiyuan Yang’s Blog</a>）：</p><blockquote><p>Greetings! I am <strong>Xiyuan Yang (杨希渊)</strong>, currently pursuing an undergraduate degree in Artificial Intelligence at Shanghai Jiao Tong University. With a longstanding aspiration to become a programmer, I am passionate about leveraging technology to make a meaningful impact on the world. Through my personal website, I aim to share a collection of my blogs and learning notes with you. Some of these entries will be presented as a series, updated at irregular intervals. Additionally, I will offer insights into my personal observations and reflections on life. I hope your visit here is both enjoyable and enriching!</p></blockquote><blockquote><p><strong>My email:</strong></p><ul><li><p><a href="mailto:xiyuan__yang@outlook.com">xiyuan__yang@outlook.com</a></p></li><li><p><a href="mailto:yangxiyuan@sjtu.edu.cn">yangxiyuan@sjtu.edu.cn</a></p><p>Feel free to contact me!</p></li></ul></blockquote><blockquote><p>VENI VIDI VICI</p></blockquote><p>这个博客的更新内容将随着笔者后续的专业课程的学习同步进行，<strong>旨在分享笔者在学习过程中学到的有意思的专业知识，力求在博客输出的过程中培养自己的逻辑思维和表达能力</strong>，不过更新时间，更新内容，更新篇幅<strong>将会完全随机</strong>。</p><p>本博客部署在github的静态网站上，轮子使用<code>Hexo</code>的<code>Fluid</code>的模版，配置环境还是比较简单的，下面贴出一些相关的网址，有相同爱好的童鞋可以参考借鉴一下：</p><ul><li><a href="https://github.com/xiyuanyang-code">xiyuanyang-code (Xiyuan Yang)我的Github主页</a></li><li><a href="https://github.com/xiyuanyang-code/xiyuanyang-code.github.io">xiyuanyang-code&#x2F;xiyuanyang-code.github.io我的博客Github仓库</a></li><li><a href="https://github.com/fluid-dev/hexo-theme-fluid">fluid-dev&#x2F;hexo-theme-fluid-Design theme for Hexo Fluid的Github官方仓库</a></li><li><a href="https://fluid-dev.github.io/hexo-fluid-docs/guide/">配置指南 | Hexo Fluid 用户手册</a></li><li><a href="https://fluid-dev.github.io/hexo-fluid-docs/start/">开始使用 | Hexo Fluid 用户手册</a></li></ul><p>有关博客的具体更新内容，请详见<code>Goals and Plans of Updates</code>部分~</p><h2 id="Goals-and-Plans-of-Updates"><a href="#Goals-and-Plans-of-Updates" class="headerlink" title="Goals and Plans of Updates"></a>Goals and Plans of Updates</h2><h3 id="更新的主要内容"><a href="#更新的主要内容" class="headerlink" title="更新的主要内容"></a>更新的主要内容</h3><p>笔者更新的主要内容包括：（<strong>草拟</strong>）</p><ul><li>编程语言的语法学习<ul><li>C&#x2F;C++</li><li>Python<ul><li>语法</li><li>Anaconda</li><li>一些常见的库</li></ul></li><li>HTML&#x2F;Javascript</li><li>Bash&#x2F;Shell</li></ul></li><li>一些常用的工具教程<ul><li>LaTeX</li><li>命令行</li><li>Git</li><li>Vim编辑器</li><li>Linux和服务器（主要和深度学习相关）<ul><li>Linux常见命令</li><li>Tmux</li><li>SSH远程连接</li></ul></li></ul></li><li>[CS]算法<ul><li>数据结构</li><li>算法</li><li>计算机四大件</li></ul></li><li>AI专业课<ul><li>机器学习</li><li>强化学习</li><li>深度学习<ul><li>Pytorch</li></ul></li></ul></li><li>AI前沿&amp;经典论文精读</li><li><del>一些晦涩难懂的</del>数学课</li><li>发发牢骚</li></ul><h3 id="具体的分类（实时更新）"><a href="#具体的分类（实时更新）" class="headerlink" title="具体的分类（实时更新）"></a>具体的分类（实时更新）</h3><ul><li><strong>Code</strong></li><li><strong>Math</strong></li><li><strong>Efficient Tools</strong></li><li><strong>Algorithm</strong></li><li><strong>Frontier and Classic Papers in AI</strong></li><li><strong>AI Core Courses</strong></li></ul><h3 id="具体的标签（实时更新）"><a href="#具体的标签（实时更新）" class="headerlink" title="具体的标签（实时更新）"></a>具体的标签（实时更新）</h3><p>见 <a href="https://xiyuanyang-code.github.io/tags/">Tags</a> 页。</p><h2 id="Several-Pages"><a href="#Several-Pages" class="headerlink" title="Several Pages"></a>Several Pages</h2><p>以下是对本博客若干基本页面的介绍：</p><ul><li><h4 id="Home"><a href="#Home" class="headerlink" title="Home"></a>Home</h4></li><li><h4 id="Intro（你现在在的地方）"><a href="#Intro（你现在在的地方）" class="headerlink" title="Intro（你现在在的地方）"></a><strong>Intro</strong>（你现在在的地方）</h4></li><li><h4 id="Archives（文章）"><a href="#Archives（文章）" class="headerlink" title="Archives（文章）"></a>Archives（文章）</h4></li><li><h4 id="Categories（分类页）"><a href="#Categories（分类页）" class="headerlink" title="Categories（分类页）"></a>Categories（分类页）</h4></li><li><h4 id="Tags（标签页）"><a href="#Tags（标签页）" class="headerlink" title="Tags（标签页）"></a>Tags（标签页）</h4></li><li><h4 id="About（关于作者）"><a href="#About（关于作者）" class="headerlink" title="About（关于作者）"></a>About（关于作者）</h4></li><li><h4 id="FAQ（一些常见的问题）"><a href="#FAQ（一些常见的问题）" class="headerlink" title="FAQ（一些常见的问题）"></a>FAQ（一些常见的问题）</h4></li><li><h4 id="Resume（Academic-CV-of-the-Author）"><a href="#Resume（Academic-CV-of-the-Author）" class="headerlink" title="Resume（Academic CV of the Author）"></a>Resume（<strong>Academic CV of the Author</strong>）</h4></li></ul><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p><a href="https://github.com/lilianweng">lilianweng (Lilian)的github主页</a></p><p> <a href="https://lilianweng.github.io/">Lil’Log（翁荔的博客）</a></p><p><a href="https://openai.com/index/the-power-of-continuous-learning/">The power of continuous learning | OpenAI</a></p><p><a href="https://github.com/xiyuanyang-code">https://github.com/xiyuanyang-code</a></p><p><a href="https://github.com/xiyuanyang-code/xiyuanyang-code.github.io">https://github.com/xiyuanyang-code/xiyuanyang-code.github.io</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Announcement</tag>
      
      <tag>Updating</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Algorithm-Introduction</title>
    <link href="/posts/Algorithm-Introduction/"/>
    <url>/posts/Algorithm-Introduction/</url>
    
    <content type="html"><![CDATA[<style>  html, body, .markdown-body {    font-family: Georgia, sans, serif;  }</style><h1 id="Algorithm-tutorial-section1"><a href="#Algorithm-tutorial-section1" class="headerlink" title="Algorithm_tutorial_section1"></a>Algorithm_tutorial_section1</h1><p>【写在前面的话】</p><p>​    本文是笔者自己算法课程的学习笔记，目前的学习内容主要是算法和数据结构基础（提前自学，笔者会在大一下学期系统学习），学习途径和资源主要是 <a href="https://www.hello-algo.com/">Hello 算法</a>（一本非常易入门的算法书！非常推荐！）。因此，<strong>此文章是Algorithm_tutorial的第一篇博客~，且大部分内容来自Hello算法原书，原创部分属于少数，笔者在此处只是按照自己的知识体系进行归纳总结并且尝试记录下来。</strong>希望大家都能愉快地开启自己的算法学习之旅~</p><h1 id="Algorithm-Section1-Introduction"><a href="#Algorithm-Section1-Introduction" class="headerlink" title="Algorithm.Section1 Introduction"></a>Algorithm.Section1 Introduction</h1><p>Introduction：</p><ul><li>迭代与递归</li><li>时间复杂度</li><li>空间复杂度</li><li>数据结构的物理结构</li></ul><h2 id="一、算法-复杂度分析"><a href="#一、算法-复杂度分析" class="headerlink" title="一、算法 复杂度分析"></a>一、算法 复杂度分析</h2><p>​    由于实际测试具有较大的局限性，因此我们可以考虑仅通过一些计算来评估算法的效率。这种估算方法被称为渐近复杂度分析（asymptotic complexity analysis），简称复杂度分析。</p><p>​    复杂度分析能够体现算法运行所需的时间和空间资源与输入数据大小之间的关系。<strong>它描述了随着输入数据大小的增加，算法执行所需时间和空间的增长趋势</strong>。这个定义有些拗口，我们可以将其分为三个重点来理解。</p><ul><li>“<strong>时间和空间资源</strong>”分别对应时间复杂度（time complexity）和空间复杂度（space complexity）。</li><li>“随着输入数据大小的增加”意味着复杂度反映了算法运行效率与输入数据体量之间的关系。</li><li>“<strong>时间和空间的增长趋势</strong>”表示复杂度分析关注的不是运行时间或占用空间的具体值，而是时间或空间增长的“快慢”。（<strong>一种趋势！</strong>）</li></ul><h3 id="迭代与递归"><a href="#迭代与递归" class="headerlink" title="@迭代与递归"></a>@迭代与递归</h3><p><strong>迭代：自下而上，小问题积累成大问题</strong></p><p><strong>递归：自上而下，大问题拆解成小问题</strong></p><p>程序实现重复代码块执行的两种方式：</p><ul><li><p>迭代（for循环，while循环）</p></li><li><p>递归</p></li></ul><p>​    递归（recursion）是一种算法策略，通过函数调用自身来解决问题。它主要包含两个阶段。</p><ol><li><strong>递</strong>：程序不断深入地调用自身，通常传入更小或更简化的参数，直到达到“终止条件”。</li><li><strong>归</strong>：触发“终止条件”后，程序从最深层的递归函数开始逐层返回，汇聚每一层的结果。</li></ol><p>​    而从实现的角度看，递归代码主要包含三个要素。</p><ol><li><strong>终止条件</strong>：用于决定什么时候由“递”转“归”。</li><li><strong>递归调用</strong>：对应“递”，函数调用自身，通常输入更小或更简化的参数。</li><li><strong>返回结果</strong>：对应“归”，将当前递归层级的结果返回至上一层。</li></ol><p><strong>有关递归的时间问题和空间问题</strong></p><p>​    递归函数每次调用自身时，系统都会为新开启的函数分配内存，以存储局部变量、调用地址和其他信息等。这将导致两方面的结果。</p><ul><li><p>函数的上下文数据都存储在称为“<strong>栈帧空间</strong>”的内存区域中，直至函数返回后才会被释放。因此，<strong>递归通常比迭代更加耗费内存空间</strong>。（需要控制递归深度，否则过深的递归会导致栈的溢出错误）</p></li><li><p><strong>有关栈帧空间</strong>：</p></li><li><p>栈帧空间是指在程序执行过程中，为每个函数调用分配的一块内存区域，用于存储该函数的局部变量、参数、返回地址以及其他控制信息。每次函数被调用时，都会在调用栈上创建一个新的栈帧，这个栈帧的生命周期与函数的执行周期相同。</p><ol><li><strong>返回地址</strong>：当函数调用完成后，程序需要知道从哪里继续执行，因此返回地址会被压入栈帧中。</li><li><strong>参数</strong>：函数调用时传递给被调用函数的参数也会存储在栈帧中。</li><li><strong>局部变量</strong>：函数内部定义的局部变量会占用栈帧空间。</li><li><strong>控制信息</strong>：包括指向上一个栈帧的指针（帧指针），用于维护调用链。</li></ol><p><strong>栈帧的工作机制</strong></p><ul><li><strong>入栈</strong>：当一个函数被调用时，首先将参数和返回地址压入栈中，然后分配空间给局部变量，形成新的栈帧。</li><li><strong>出栈</strong>：当函数执行完毕时，局部变量和参数的空间被释放，返回地址被弹出，程序控制流转回调用该函数的位置。</li></ul><p><strong>栈帧的优点</strong></p><ul><li><strong>自动管理</strong>：栈帧由系统自动管理，无需手动分配和释放内存。</li><li><strong>高效性</strong>：由于栈的后进先出特性，内存分配和释放速度非常快。</li></ul></li><li><p>递归调用函数会产生额外的开销。<strong>因此递归通常比循环的时间效率更低</strong>。</p></li><li><p><strong>使用尾递归</strong>可以优化递归的效率（系统无需保存函数上一级的上下文）</p></li></ul><p><strong>有关递归树</strong></p><p>我们在函数内递归调用了两个函数，<strong>这意味着从一个调用产生了两个调用分支</strong>。如图 2-6 所示，这样不断递归调用下去，最终将产生一棵层数为 n 的递归树（recursion tree）。</p><p><img src="https://www.hello-algo.com/chapter_computational_complexity/iteration_and_recursion.assets/recursion_tree.png" alt="斐波那契数列的递归树"></p><blockquote><p>这种递归树可以达到指数阶的时间复杂度。</p></blockquote><p><strong>一定要理解递归的核心思想：分治！</strong></p><p>从本质上看，递归体现了“将问题分解为更小子问题”的思维范式，这种分治策略至关重要。</p><ul><li>从算法角度看，<strong>搜索、排序、回溯、分治、动态规划</strong>等许多重要算法策略直接或间接地应用了这种思维方式。</li><li>从数据结构角度看，<strong>递归天然适合处理链表、树和图的相关问题</strong>，因为它们非常适合用分治思想进行分析。</li></ul><p><strong>迭代和递归的本质与内在联系</strong></p><p>以上述递归函数为例，求和操作在递归的“归”阶段进行。这意味着<strong>最初被调用的函数实际上是最后完成其求和操作</strong>的，<strong>这种工作机制与栈的“先入后出”原则异曲同工</strong>。</p><p>事实上，“<strong>调用栈</strong>”和“<strong>栈帧空间</strong>”这类递归术语已经暗示了递归与栈之间的密切关系。</p><ol><li><strong>递</strong>：当函数被调用时，系统会在“调用栈”上为该函数分配新的栈帧，用于<strong>存储函数的局部变量、参数、返回地址</strong>等数据。</li><li><strong>归</strong>：当函数完成执行并返回时，对应的栈帧会被从“调用栈”上移除，恢复之前函数的执行环境。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">for_loop_recur</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;使用迭代模拟递归&quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 使用一个显式的栈来模拟系统调用栈</span><br>    stack = []<br>    res = <span class="hljs-number">0</span><br>    <span class="hljs-comment"># 递：递归调用</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>):<br>        <span class="hljs-comment"># 通过“入栈操作”模拟“递”</span><br>        stack.append(i)<br>    <span class="hljs-comment"># 归：返回结果</span><br>    <span class="hljs-keyword">while</span> stack:<br>        <span class="hljs-comment"># 通过“出栈操作”模拟“归”</span><br>        res += stack.pop()<br>    <span class="hljs-comment"># res = 1+2+3+...+n</span><br>    <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="@时间复杂度"></a>@时间复杂度</h3><ul><li><strong>常数</strong>时间复杂度</li><li><strong>线性</strong>时间复杂度</li><li><strong>平方</strong>时间复杂度</li><li><strong>指数阶</strong>时间复杂度<ul><li>递归树的一分为二</li></ul></li><li><strong>对数阶</strong>时间复杂度<ul><li>每轮缩减到一半</li><li>也会出现在递归树中（经典例题：快速幂计算）</li></ul></li><li><strong>线性对数阶</strong>时间复杂度（<code>O(nlogn)</code>）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">linear_log_recur</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;线性对数阶&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">if</span> n &lt;= <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    <span class="hljs-comment"># 一分为二，子问题的规模减小一半</span><br>    count = linear_log_recur(n // <span class="hljs-number">2</span>) + linear_log_recur(n // <span class="hljs-number">2</span>)<br>    <span class="hljs-comment"># 与C++不同，//表示地板出发（整数截断）</span><br>    <span class="hljs-comment"># 当前子问题包含 n 个操作</span><br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>        count += <span class="hljs-number">1</span><br>    <span class="hljs-comment"># 代表当前需要执行的n次操作</span><br>    <span class="hljs-keyword">return</span> count<br></code></pre></td></tr></table></figure><p><img src="https://www.hello-algo.com/chapter_computational_complexity/time_complexity.assets/time_complexity_logarithmic_linear.png" alt="线性对数阶的时间复杂度"></p><ul><li><strong>阶乘阶</strong>时间复杂度</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">factorial_recur</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;阶乘阶（递归实现）&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    count = <span class="hljs-number">0</span><br>    <span class="hljs-comment"># 从 1 个分裂出 n 个</span><br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>        count += factorial_recur(n - <span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> count<br></code></pre></td></tr></table></figure><p><img src="https://www.hello-algo.com/chapter_computational_complexity/time_complexity.assets/time_complexity_factorial.png" alt="阶乘阶的时间复杂度"></p><p>时间复杂度的分类：</p><ul><li>最差时间复杂度</li><li>最佳时间复杂度</li></ul><blockquote><p>以上两个时间复杂度均与数据的分布存在联系，具有偶然性</p></blockquote><ul><li>平均时间复杂度</li></ul><p>符号表示：</p><p>时间复杂度的符号表示法主要有三种：<code>O</code>、<code>Ω</code> 和 <code>Θ</code>，它们分别表示算法在不同情况下的性能表现。</p><ol><li><p><strong>大 O 表示法 (O(f(n)))</strong>：</p><ul><li>描述：表示算法在<strong>最坏情况下的时间复杂度</strong>。</li><li>用途：用于描述算法的上界，即算法的执行时间不会超过某个函数的增长速度。</li><li>示例：如果一个算法的时间复杂度是 (O(n^2))，意味着在最坏情况下，算法的执行时间最多是输入规模的平方。</li></ul></li><li><p><strong>大 Ω 表示法 (Ω(f(n)))</strong>：</p><ul><li>描述：表示算法在<strong>最好情况下的时间复杂度</strong>。</li><li>用途：用于描述算法的下界，即算法的执行时间至少是某个函数的增长速度。</li><li>示例：如果一个算法的时间复杂度是 (Ω(n))，意味着在最好情况下，算法的执行时间至少是输入规模的线性增长。</li></ul></li><li><p><strong>大 Θ 表示法 (Θ(f(n)))</strong>：</p><ul><li>描述：表示算法在<strong>平均情况下的时间复杂度</strong>。</li><li>用途：用于描述算法的确界，即算法的执行时间既不会超过某个函数的上界，也不会低于某个函数的下界。</li><li>示例：如果一个算法的时间复杂度是 (Θ(n \log n))，意味着在所有情况下，算法的执行时间大致是输入规模的 (n \log n) 级别。</li></ul></li></ol><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="@空间复杂度"></a>@空间复杂度</h3><p>算法在运行过程中使用的内存空间主要包括以下几种。</p><ul><li><strong>输入空间</strong>：用于存储算法的输入数据。</li><li><strong>暂存空间</strong>：用于存储算法在运行过程中的变量、对象、函数上下文等数据。</li><li><strong>输出空间</strong>：用于存储算法的输出数据。</li></ul><p>一般情况下，空间复杂度的统计范围是“<strong>暂存空间”加上“输出空间”</strong>。</p><p>暂存空间可以进一步划分为三个部分。</p><ul><li><strong>暂存数据</strong>：用于保存算法运行过程中的各种常量、变量、对象等。</li><li><strong>栈帧空间</strong>：用于保存调用函数的上下文数据。系统在每次调用函数时都会在栈顶部创建一个栈帧，函数返回后，栈帧空间会被释放。</li><li><strong>指令空间</strong>：用于保存编译后的程序指令，在实际统计中通常忽略不计。</li></ul><p>在分析一段程序的空间复杂度时，<strong>我们通常统计暂存数据、栈帧空间和输出数据三部分</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;类&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, x: <span class="hljs-built_in">int</span></span>):<br>        <span class="hljs-variable language_">self</span>.val: <span class="hljs-built_in">int</span> = x              <span class="hljs-comment"># 节点值</span><br>        <span class="hljs-variable language_">self</span>.<span class="hljs-built_in">next</span>: Node | <span class="hljs-literal">None</span> = <span class="hljs-literal">None</span>  <span class="hljs-comment"># 指向下一节点的引用</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">function</span>() -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;函数&quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 执行某些操作...</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">algorithm</span>(<span class="hljs-params">n</span>) -&gt; <span class="hljs-built_in">int</span>:  <span class="hljs-comment"># 输入数据</span><br>    A = <span class="hljs-number">0</span>                 <span class="hljs-comment"># 暂存数据（常量，一般用大写字母表示）</span><br>    b = <span class="hljs-number">0</span>                 <span class="hljs-comment"># 暂存数据（变量）</span><br>    node = Node(<span class="hljs-number">0</span>)        <span class="hljs-comment"># 暂存数据（对象）</span><br>    c = function()        <span class="hljs-comment"># 栈帧空间（调用函数）</span><br>    <span class="hljs-keyword">return</span> A + b + c      <span class="hljs-comment"># 输出数据</span><br></code></pre></td></tr></table></figure><p>​    而与时间复杂度不同的是，<strong>我们通常只关注最差空间复杂度</strong>。这是因为内存空间是一项硬性要求，我们必须确保在所有输入数据下都有足够的内存空间预留。</p><ul><li>以最差输入数据为准</li><li>以算法运行的<strong>峰值内存</strong>（注意不是累积量）为准</li></ul><p>一些常见的空间复杂度：</p><ul><li><p>常数阶空间复杂度</p><ul><li>在循环中初始化变量或调用函数而占用的内存，在进入下一循环后就会被释放，因此不会累积占用空间，空间复杂度还是<code>O(1)</code>。</li></ul></li><li><p>线性阶空间复杂度</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">linear</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span></span>):<br>    <span class="hljs-string">&quot;&quot;&quot;线性阶&quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 长度为 n 的列表占用 O(n) 空间</span><br>    nums = [<span class="hljs-number">0</span>] * n<br>    <span class="hljs-comment"># 长度为 n 的哈希表占用 O(n) 空间</span><br>    hmap = <span class="hljs-built_in">dict</span>[<span class="hljs-built_in">int</span>, <span class="hljs-built_in">str</span>]()<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>        hmap[i] = <span class="hljs-built_in">str</span>(i)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">linear_recur</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span></span>):<br>    <span class="hljs-string">&quot;&quot;&quot;线性阶（递归实现）&quot;&quot;&quot;</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;递归 n =&quot;</span>, n)<br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span><br>    linear_recur(n - <span class="hljs-number">1</span>)<br>    <span class="hljs-comment"># 在达到最深的递归深度的时候，会有n个变量n（涉及到局部变量）</span><br></code></pre></td></tr></table></figure></li><li><p>平方阶空间复杂度</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">quadratic</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span></span>):<br>    <span class="hljs-string">&quot;&quot;&quot;平方阶&quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 二维列表占用 O(n^2) 空间</span><br>    num_matrix = [[<span class="hljs-number">0</span>] * n <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br></code></pre></td></tr></table></figure><ul><li><p><code>num_matrix</code>：这是一个变量名，用于存储生成的二维矩阵。</p><p><code>[[0] * n for _ in range(n)]</code>：这是一个列表生成式，用于创建一个包含 <code>n</code> 个子列表的列表，每个子列表包含 <code>n</code> 个元素。</p><ul><li><code>[0] * n</code>：这一部分创建一个包含 <code>n</code> 个 <code>0</code> 的列表。例如，如果 <code>n</code> 是 <code>3</code>，则生成 <code>[0, 0, 0]</code>。</li><li><code>for _ in range(n)</code>：这一部分用于重复创建上述的子列表 <code>n</code> 次。<code>_</code> 是一个惯用的变量名，表示循环变量在循环体内未被使用。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">quadratic_recur</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;平方阶（递归实现）&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">if</span> n &lt;= <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    <span class="hljs-comment"># 数组 nums 长度为 n, n-1, ..., 2, 1</span><br>    nums = [<span class="hljs-number">0</span>] * n<br>    <span class="hljs-keyword">return</span> quadratic_recur(n - <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure></li></ul></li><li><p>指数阶空间复杂度（二叉树）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">build_tree</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span></span>) -&gt; TreeNode | <span class="hljs-literal">None</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;指数阶（建立满二叉树）&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>    root = TreeNode(<span class="hljs-number">0</span>)<br>    root.left = build_tree(n - <span class="hljs-number">1</span>)<br>    root.right = build_tree(n - <span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> root<br></code></pre></td></tr></table></figure><p><img src="https://www.hello-algo.com/chapter_computational_complexity/space_complexity.assets/space_complexity_exponential.png" alt="满二叉树产生的指数阶空间复杂度"></p></li><li><p>对数阶空间复杂度</p></li></ul><p>对数阶空间复杂度（(O(\log n))）在算法中并不如其他复杂度（如常数、线性、平方等）常见，因为对数阶通常与递归深度相关联。以下是一些可能具有对数阶空间复杂度的常见算法和场景：</p><ol><li><p><strong>递归算法</strong>：</p><ul><li><strong>二分查找</strong>：在递归实现中，二分查找的空间复杂度是 (O(\log n))，因为递归调用栈的深度是对数级别的。</li><li><strong>快速排序</strong>：在最优情况下（即每次分区都能将数组均匀分割），快速排序的递归深度是 (O(\log n))，因此空间复杂度也是 (O(\log n))。</li><li><strong>归并排序</strong>：尽管归并排序的时间复杂度是 (O(n \log n))，其递归实现的空间复杂度可以是 (O(\log n))（不包括用于存储结果的额外数组）。</li></ul><h3 id="快速排序（Quick-Sort）"><a href="#快速排序（Quick-Sort）" class="headerlink" title="快速排序（Quick Sort）"></a>快速排序（Quick Sort）</h3><p>快速排序是一种分而治之的排序算法。它的基本思想是选择一个基准元素（pivot），然后将数组分成两个子数组，一个包含所有小于基准元素的元素，另一个包含所有大于基准元素的元素，然后递归地对这两个子数组进行排序。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">quick_sort</span>(<span class="hljs-params">arr</span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(arr) &lt;= <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span> arr<br>    <span class="hljs-keyword">else</span>:<br>        pivot = arr[<span class="hljs-built_in">len</span>(arr) // <span class="hljs-number">2</span>]<br>        left = [x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> arr <span class="hljs-keyword">if</span> x &lt; pivot]<br>        middle = [x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> arr <span class="hljs-keyword">if</span> x == pivot]<br>        right = [x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> arr <span class="hljs-keyword">if</span> x &gt; pivot]<br>        <span class="hljs-keyword">return</span> quick_sort(left) + middle + quick_sort(right)<br><br><span class="hljs-comment"># 示例使用</span><br>arr = [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">10</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Original array:&quot;</span>, arr)<br>sorted_arr = quick_sort(arr)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Sorted array:&quot;</span>, sorted_arr)<br></code></pre></td></tr></table></figure><h3 id="归并排序（Merge-Sort）"><a href="#归并排序（Merge-Sort）" class="headerlink" title="归并排序（Merge Sort）"></a>归并排序（Merge Sort）</h3><p>归并排序也是一种分而治之的排序算法。它的基本思想是将数组分成两个子数组，对这两个子数组分别进行排序，然后将排序后的子数组合并成一个有序的数组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">merge_sort</span>(<span class="hljs-params">arr</span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(arr) &lt;= <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span> arr<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">merge</span>(<span class="hljs-params">left, right</span>):<br>        result = []<br>        i = j = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> i &lt; <span class="hljs-built_in">len</span>(left) <span class="hljs-keyword">and</span> j &lt; <span class="hljs-built_in">len</span>(right):<br>            <span class="hljs-keyword">if</span> left[i] &lt; right[j]:<br>                result.append(left[i])<br>                i += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                result.append(right[j])<br>                j += <span class="hljs-number">1</span><br>        result.extend(left[i:])<br>        result.extend(right[j:])<br>        <span class="hljs-keyword">return</span> result<br><br>    mid = <span class="hljs-built_in">len</span>(arr) // <span class="hljs-number">2</span><br>    left = merge_sort(arr[:mid])<br>    right = merge_sort(arr[mid:])<br>    <span class="hljs-keyword">return</span> merge(left, right)<br><br><span class="hljs-comment"># 示例使用</span><br>arr = [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">10</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Original array:&quot;</span>, arr)<br>sorted_arr = merge_sort(arr)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Sorted array:&quot;</span>, sorted_arr)<br></code></pre></td></tr></table></figure><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><ul><li><p><strong>快速排序</strong>：</p><ul><li>选择一个基准元素（pivot）。</li><li>将数组分成三个部分：小于基准的部分、等于基准的部分和大于基准的部分。</li><li>递归地对小于基准和大于基准的部分进行排序。</li><li>合并结果。</li></ul></li><li><p><strong>归并排序</strong>：</p><ul><li>将数组分成两半。</li><li>递归地对每一半进行排序。</li><li>合并两个排序后的子数组。</li></ul></li></ul><p>这两种排序算法都是经典的分而治之算法，具有较好的性能和广泛的应用。</p></li><li><p><strong>平衡树的数据结构</strong>：</p><ul><li><strong>平衡二叉搜索树（如 AVL 树、红黑树）</strong>：这些数据结构在执行插入、删除和查找操作时的递归深度通常是 (O(\log n))，因此在某些实现中，可能会有 (O(\log n)) 的空间复杂度，主要用于递归调用栈。</li></ul></li><li><p><strong>迭代算法</strong>：</p><ul><li>某些迭代算法在实现中可能会使用一个栈来模拟递归，从而使得其空间复杂度为 (O(\log n))。例如，某些树遍历算法在深度优先搜索时可能使用栈来存储路径信息。</li></ul></li></ol><p>需要注意的是，空间复杂度为 (O(\log n)) 的算法通常涉及递归调用或需要存储某些对数数量的信息。这种复杂度通常与算法的递归深度或树结构的高度相关。</p><p><strong>循环与递归在空间复杂度上的差异</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">function</span>() -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-comment"># 执行某些操作</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">loop</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span></span>):<br>    <span class="hljs-string">&quot;&quot;&quot;循环的空间复杂度为 O(1)&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>        function()<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">recur</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span></span>):<br>    <span class="hljs-string">&quot;&quot;&quot;递归的空间复杂度为 O(n)&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span><br>    <span class="hljs-keyword">return</span> recur(n - <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>函数 <code>loop()</code> 和 <code>recur()</code> 的时间复杂度都为 O(n) ，但空间复杂度不同。</p><ul><li>函数 <code>loop()</code> 在循环中调用了 n 次 <code>function()</code> ，每轮中的 <code>function()</code> 都返回并释放了栈帧空间，因此空间复杂度仍为 O(1) 。</li><li>递归函数 <code>recur()</code> 在运行过程中会同时存在 n 个未返回的 <code>recur()</code> ，从而占用 O(n) 的栈帧空间。</li></ul><h2 id="二、数据结构"><a href="#二、数据结构" class="headerlink" title="二、数据结构"></a>二、数据结构</h2><p>数组，链表，栈，队列，哈希表，树，堆，图</p><h3 id="数据结构的物理结构"><a href="#数据结构的物理结构" class="headerlink" title="@数据结构的物理结构"></a>@数据结构的物理结构</h3><p>如图 3-3 所示，<strong>物理结构反映了数据在计算机内存中的存储方式</strong>，可分为连续空间存储（数组）和分散空间存储（链表）。物理结构从底层决定了数据的访问、更新、增删等操作方法，两种物理结构在时间效率和空间效率方面呈现出互补的特点。</p><p><img src="https://www.hello-algo.com/chapter_data_structure/classification_of_data_structure.assets/classification_phisical_structure.png" alt="连续空间存储与分散空间存储"></p><p>连续空间存储（数组）</p><ul><li><strong>定义</strong>：连续空间存储是指数据元素在内存中连续排列，数组是这种存储方式的典型代表。</li><li><strong>优点</strong>：<ul><li><strong>快速访问</strong>：由于数组元素是连续存储的，可以通过索引直接访问任意元素，时间复杂度为 O(1)。</li><li><strong>空间局部性</strong>：连续存储有助于缓存命中率，因为访问一个元素后，后续访问相邻元素时，可能已经在缓存中。</li></ul></li><li><strong>缺点</strong>：<ul><li><strong>插入和删除操作效率低</strong>：在数组中插入或删除元素通常需要移动其他元素以保持数据的连续性，时间复杂度为 <em>O</em>(<em>n</em>)。</li><li><strong>固定大小</strong>：数组的大小在创建时确定，扩展数组的大小需要重新分配内存并复制数据。</li></ul></li></ul><p>分散空间存储（链表）</p><ul><li><strong>定义</strong>：分散空间存储是指数据元素在内存中不必连续排列，链表是这种存储方式的典型代表。</li><li><strong>优点</strong>：<ul><li><strong>动态大小</strong>：链表可以方便地进行动态内存分配，允许在运行时灵活地增加或减少元素。</li><li><strong>高效插入和删除</strong>：在链表中，插入和删除元素只需调整指针，而不需要移动其他元素，时间复杂度为 <em>O</em>(1)（在已知位置的情况下）。</li></ul></li><li><strong>缺点</strong>：<ul><li><strong>访问速度慢</strong>：由于链表元素存储在非连续的内存位置，访问某个特定元素需要从头遍历链表，时间复杂度为 <em>O</em>(<em>n</em>)。</li><li><strong>额外空间开销</strong>：链表需要额外的存储空间来存储指针（如前驱和后继指针），这增加了内存使用量。</li></ul></li></ul><p>互补特点</p><ul><li><strong>数组</strong>适合需要频繁随机访问的场景，如需要快速读取大量数据但不经常修改数据的情况。</li><li><strong>链表</strong>适合需要频繁插入和删除操作的场景，如实现动态数据结构（例如队列、栈）时。</li></ul><p>值得说明的是，<strong>所有数据结构都是基于数组、链表或二者的组合实现的</strong>。例如，栈和队列既可以使用数组实现，也可以使用链表实现；而哈希表的实现可能同时包含数组和链表。</p><ul><li><strong>基于数组可实现</strong>：栈、队列、哈希表、树、堆、图、矩阵、张量（维度 ≥3 的数组）等。</li><li><strong>基于链表可实现</strong>：栈、队列、哈希表、树、堆、图等。</li></ul><p>​    哈希表底层是数组，而为了解决哈希冲突，我们可能会使用“链式地址”（后续“哈希冲突”章节会讲）：数组中每个桶指向一个链表，当链表长度超过一定阈值时，又可能被转化为树（通常为红黑树）。</p><p>​    从存储的角度来看，哈希表的底层是数组，其中每一个桶槽位可能包含一个值，也可能包含一个链表或一棵树。因此，哈希表可能同时包含线性数据结构（数组、链表）和非线性数据结构（树）。</p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tutorial</tag>
      
      <tag>Finished</tag>
      
      <tag>C/C++</tag>
      
      <tag>Time and Space Complexity</tag>
      
      <tag>Recursion</tag>
      
      <tag>Hello-algorithm-tutorial</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LaTeX-Tutorial</title>
    <link href="/posts/LaTeX-tutorial/"/>
    <url>/posts/LaTeX-tutorial/</url>
    
    <content type="html"><![CDATA[<style>  html, body, .markdown-body {    font-family: Georgia, sans, serif;  }</style><blockquote><p>好稚嫩的文笔，笔者自己都看不下去… 仅留作纪念。</p></blockquote><h1 id="About-LaTeX"><a href="#About-LaTeX" class="headerlink" title="About LaTeX"></a>About LaTeX</h1><p>​听说过LaTeX吗？亦或是老师突然要求你们使用LaTeX进行写论文，自己面对奇奇怪怪的复杂代码毫无头绪，下不去手？</p><p><strong>需要提前准备的内容</strong>：</p><ul><li>无</li></ul><p><strong>如果你是</strong>：</p><ul><li>纯LaTeX新手，从零开始接触LaTeX；</li><li>纯路人，想学习LaTeX技巧；</li><li>想要支持作者的帅哥美女❥(^_-)；</li></ul><p>那恭喜你来对地方了！在这篇文章中，<strong>你将学习到以下内容</strong>：</p><ul><li>一段LaTeX的历史和一位伟人；</li><li>掌握LaTeX的最基本原理；</li><li>如何从零开始构建第一篇LaTeX文档，并按需进行个性化的修改；</li><li>尝试接触一些LaTeX的高级功能（Optional）；</li><li>获得一些精进LaTeX技能包的方法和途径；</li></ul><p><strong>准备好了吗？</strong> 在接下来的时光里，就让我们一起走进LaTeX的世界。</p><p><img src="/posts/LaTeX-tutorial/LaTeX.png" alt="LaTeX"></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://en.wikipedia.org/wiki/TeX">TeX - Wikipedia</a></p><p><a href="https://en.wikipedia.org/wiki/LaTeX">LaTeX - Wikipedia</a></p><p><a href="https://www.overleaf.com/">Overleaf, Online LaTeX Editor</a></p><p><a href="https://www.latex-project.org/">LaTeX - A document preparation system</a></p><h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1 Introduction"></a>1 Introduction</h2><p><strong>又来到了讲故事环节，可跳过</strong></p><p>​在开始我们今天的话题之前，我想先向各位介绍一位老先生，<a href="https://en.wikipedia.org/wiki/Donald_Knuth">Donald Knuth</a>。</p><p><img src="/posts/LaTeX-tutorial/Knuth.jpg" alt="Donald Knuth"></p><p>​先来看看他到底有多牛逼，这是维基百科对这位老爷爷（还没有去世哦）的评价：He is the 1974 recipient of <strong>the <a href="https://en.wikipedia.org/wiki/Acm_Turing_award">ACM Turing Award</a></strong>, informally considered the <a href="https://en.wikipedia.org/wiki/Nobel_Prize">Nobel Prize</a> of computer science. Knuth has been called the “<strong>father of the <a href="https://en.wikipedia.org/wiki/Analysis_of_algorithms">analysis of algorithms</a></strong>“。 <a href="https://en.wikipedia.org/wiki/Donald_Knuth">原文</a></p><p>​ACM图灵奖不必多说，能拿奖的都是计算机科学领域大牛中的大牛，他甚至还有第二个称号，<strong>the father of the analysis of algorithms</strong>, 算法分析之父！更不可思议的是，他的主要贡献竟然是一系列至今尚未完篇的鸿篇巨著：*<a href="https://en.wikipedia.org/wiki/The_Art_of_Computer_Programming">The Art of Computer Programming</a>*。<strong>计算机程序设计艺术</strong>，简称TAOCP，是关于计算机程序设计之七卷本著作。作者并因此获得美国计算机协会1974年<a href="https://zh.wikipedia.org/wiki/%E5%9B%BE%E7%81%B5%E5%A5%96">图灵奖</a>。</p><blockquote><p>对我来说，读完这本书不仅花了好几个月，而且还要求我有极高的自律性。如果你能读完这本书，不妨给我发个简历。——Bill Gates</p></blockquote><p>​这一套书涵盖了计算机领域几乎所有的底层知识，目录如下：</p><p><img src="/posts/LaTeX-tutorial/theartofprogramming.png" alt="TAOCP"></p><p><a href="https://zh.wikipedia.org/zh-cn/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%89%BA%E6%9C%AF">链接指路：计算机程序设计艺术</a></p><p>​这本书的具体内容我们不做过多的介绍，那这位老者和LaTeX有什么关系呢？<strong>他是LaTeX的前身——TeX的发明者！</strong></p><p>​维基百科在这一块写的比较含蓄哈哈哈：</p><blockquote><p>In 1977, he decided to spend some time <strong>creating something more suitable</strong>. Eight years later, he returned with <a href="https://en.wikipedia.org/wiki/TeX">TEX</a>, which is currently used for all volumes.</p></blockquote><p>什么是<strong>something more suitable</strong>？Maybe the LaTeX！</p><h2 id="2-LaTeX"><a href="#2-LaTeX" class="headerlink" title="2 LaTeX"></a>2 LaTeX</h2><p>​举一个非常简单的例子，你想在word文档中输入这样一个公式：</p><p><img src="/posts/LaTeX-tutorial/QianJianTec1732279187844.png" alt="Gradient Descent"></p><blockquote><p>这是机器学习中梯度下降的基本数学原理。</p></blockquote><p>​我们来看看word是怎么编辑公式的：</p><p><img src="/posts/LaTeX-tutorial/word.png" alt="How does Microsoft Word handle it?"></p><p>​Word等文字编辑器始终秉持着一种<strong>所见即所得</strong>的思想，我打出一个字符，这个字符就实时的反映在我的文本文档中，至于图片缩放，表格插入，文字大小，排版，以及以上所涉及的数学符号等等，在word中虽然能实现，但是调试的时间成本非常高，难度非常大，而且十分的低效！笔者在高中时期曾经有过写数学小论文卡在编辑公式和统一插入图片的格式等细枝末节的小事上的惨痛的回忆。(不过好像现在word也支持LaTeX了)</p><p>​但是在LaTeX中，我们可以利用下面的代码生成：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\begin</span>&#123;aligned&#125;<br><span class="hljs-keyword">\theta</span><span class="hljs-built_in">_</span>&#123;j&#125;:=<span class="hljs-keyword">\theta</span><span class="hljs-built_in">_</span>&#123;j&#125;- <span class="hljs-built_in">&amp;</span> <span class="hljs-keyword">\alpha</span> <span class="hljs-keyword">\frac</span>&#123;<span class="hljs-keyword">\partial</span>&#125;&#123;<span class="hljs-keyword">\partial</span> <span class="hljs-keyword">\theta</span><span class="hljs-built_in">_</span>&#123;j&#125;&#125; J(<span class="hljs-keyword">\theta</span>) <span class="hljs-keyword">\\</span><br><span class="hljs-keyword">\frac</span>&#123;<span class="hljs-keyword">\partial</span>&#125;&#123;<span class="hljs-keyword">\partial</span> <span class="hljs-keyword">\theta</span><span class="hljs-built_in">_</span>&#123;j&#125;&#125; J(<span class="hljs-keyword">\theta</span>) <span class="hljs-built_in">&amp;</span> =<span class="hljs-keyword">\frac</span>&#123;<span class="hljs-keyword">\partial</span>&#125;&#123;<span class="hljs-keyword">\partial</span> <span class="hljs-keyword">\theta</span><span class="hljs-built_in">_</span>&#123;j&#125;&#125; <span class="hljs-keyword">\frac</span>&#123;1&#125;&#123;2&#125;<span class="hljs-keyword">\left</span>(h<span class="hljs-built_in">_</span>&#123;<span class="hljs-keyword">\theta</span>&#125;(x)-y<span class="hljs-keyword">\right</span>)<span class="hljs-built_in">^</span>&#123;2&#125; <span class="hljs-keyword">\\</span><br><span class="hljs-built_in">&amp;</span> =2 <span class="hljs-keyword">\cdot</span> <span class="hljs-keyword">\frac</span>&#123;1&#125;&#123;2&#125;<span class="hljs-keyword">\left</span>(h<span class="hljs-built_in">_</span>&#123;<span class="hljs-keyword">\theta</span>&#125;(x)-y<span class="hljs-keyword">\right</span>) <span class="hljs-keyword">\cdot</span> <span class="hljs-keyword">\frac</span>&#123;<span class="hljs-keyword">\partial</span>&#125;&#123;<span class="hljs-keyword">\partial</span> <span class="hljs-keyword">\theta</span><span class="hljs-built_in">_</span>&#123;j&#125;&#125;<span class="hljs-keyword">\left</span>(h<span class="hljs-built_in">_</span>&#123;<span class="hljs-keyword">\theta</span>&#125;(x)-y<span class="hljs-keyword">\right</span>) <span class="hljs-keyword">\\</span><br><span class="hljs-built_in">&amp;</span> =<span class="hljs-keyword">\left</span>(h<span class="hljs-built_in">_</span>&#123;<span class="hljs-keyword">\theta</span>&#125;(x)-y<span class="hljs-keyword">\right</span>) <span class="hljs-keyword">\cdot</span> <span class="hljs-keyword">\frac</span>&#123;<span class="hljs-keyword">\partial</span>&#125;&#123;<span class="hljs-keyword">\partial</span> <span class="hljs-keyword">\theta</span><span class="hljs-built_in">_</span>&#123;j&#125;&#125;<span class="hljs-keyword">\left</span>(<span class="hljs-keyword">\sum</span><span class="hljs-built_in">_</span>&#123;i=0&#125;<span class="hljs-built_in">^</span>&#123;n&#125; <span class="hljs-keyword">\theta</span><span class="hljs-built_in">_</span>&#123;i&#125; x<span class="hljs-built_in">_</span>&#123;i&#125;-y<span class="hljs-keyword">\right</span>) <span class="hljs-keyword">\\</span><br><span class="hljs-built_in">&amp;</span> =<span class="hljs-keyword">\left</span>(h<span class="hljs-built_in">_</span>&#123;<span class="hljs-keyword">\theta</span>&#125;(x)-y<span class="hljs-keyword">\right</span>) x<span class="hljs-built_in">_</span>&#123;j&#125;<br><span class="hljs-keyword">\end</span>&#123;aligned&#125;<br></code></pre></td></tr></table></figure><p>​完全看不懂是不是？没关系，这就是<strong>LaTeX的精髓</strong>：<strong>将可视化的文本编辑转化成一种严谨的代码语言</strong>，当你学会并且快速上手之后，你便会越来越体会到LaTeX在学术写作上的强大之处。</p><h2 id="3-LaTeX-入门"><a href="#3-LaTeX-入门" class="headerlink" title="3 LaTeX 入门"></a>3 LaTeX 入门</h2><p>​由上面的示例我们可以看出，<strong>LaTeX可以生成极为精美的文档，涵盖公式，表格，图片等等各种形式（你甚至可以用来做PPT！后面会讲到）</strong>，但代价就是<strong>LaTeX牺牲了市面上主流文本编辑器的”所见即所得”的思想</strong>，将所有文字和图片的生成都转化为了一种规则和<strong>编程语言</strong>，初学者入门可能会很吃力，但相信我，熟练后你会爱上他的！</p><h3 id="3-1-开始你的第一篇LaTeX文档！"><a href="#3-1-开始你的第一篇LaTeX文档！" class="headerlink" title="3.1 开始你的第一篇LaTeX文档！"></a>3.1 开始你的第一篇LaTeX文档！</h3><p>​万事万物第一步：配环境！一般来说有两种方式：</p><ul><li>本地环境配置：<a href="https://www.tug.org/texlive/">TeX Live - TeX Users Group</a>。需要安装textlive，后续可以集成在vscode中使用，具体的操作方法比较繁琐，读者可以自行搜索，网上有很多保姆级的环境搭建教程。（<strong>不推荐，个人建议是等上手熟悉了之后再考虑是否安装，配环境报错真的能把人给烦死</strong>）</li><li><strong>推荐在线LaTeX网站：</strong>使用LaTeX在线网站，例如<a href="https://www.overleaf.com/">Overleaf</a>，国内有些高校也会开通自己的LaTeX平台。在线网站更加轻量化，隐藏了配置环境的细节，注册一个账号就可以使用，<strong>非常推荐新手小白使用！</strong></li><li>在接下来的新手教程中，我们将全程在<a href="https://www.overleaf.com/">Overleaf</a>上进行演示，请登录网站并注册好你的账号。（使用免费版即可）</li></ul><h3 id="3-2-建立一个模版LaTeX"><a href="#3-2-建立一个模版LaTeX" class="headerlink" title="3.2 建立一个模版LaTeX"></a>3.2 建立一个模版LaTeX</h3><p>​对新手而言，<strong>快速上手熟悉LaTeX比了解LaTeX背后的原理重要的多</strong>。因此，我们将会从一个模版LaTeX出发，从实操慢慢过渡到原理的讲解。</p><p><img src="/posts/LaTeX-tutorial/s1.png" alt="Choose a template"></p><p>​点击左上角的new project——然后有四个选项：</p><ul><li><p>Blank project（完全的空文本）</p></li><li><p>Example Project（模版）</p></li><li><p>Upload Project（上传本地项目，通常是压缩包形式）</p></li><li><p>Import Project（从Github引入）</p><p>在这里我们选择Example Project。输入自己的Project Name(建议英文)。我在这里输入的是Hello world。</p></li></ul><h3 id="3-3-探索LaTeX模版！"><a href="#3-3-探索LaTeX模版！" class="headerlink" title="3.3 探索LaTeX模版！"></a>3.3 探索LaTeX模版！</h3><p><img src="/posts/LaTeX-tutorial/image_9.png" alt="Hello world!"></p><p>​当你看到一只经典的绿色小青蛙时，恭喜你，你已经成功创建了第一个LaTeX文档！</p><blockquote><p>没有看到？试试点一下右上侧绿色的<strong>Recompile</strong>按钮试试看，可能要等一会。</p></blockquote><p>​简单介绍一下各模块都是干啥用的：</p><ul><li>最左边：文件栏和<strong>File Outline</strong><ul><li>文件栏可以理解为<strong>一个存放这个LaTeX文档所有资源的文件夹</strong>。我们现在中间所打开的就是文件夹中的<strong>main.tex</strong>文件，这也是LaTeX文档的核心部分。还有一些附属的资源也会存放在文件栏中，包括插入的图片，还有参考文献(.bib)。目前大家知道这些就足够了。</li><li>File Outline 不必多说，展示文章大纲的地方。</li></ul></li><li>正中间：文本编辑区，也就是敲代码的地方。</li><li>最右边：视图区：当你点击<strong>Recompile</strong>的按钮之后，<strong>编译器</strong>（点击左上方的menu可以查看，<strong>新手不要随便改变这一项！</strong>）会根据main.tex的代码以及一些附属文件（例如frog.jpg）生成最终的LaTeX文档（PDF），在右侧可以预览，也可以导出保存。</li></ul><p><img src="/posts/LaTeX-tutorial/image_11.png" alt="The Compiler"></p><ul><li>上方一栏的一些工具看名字应该就知道是干什么的了，和普通的文本编辑器差不太多，都是一些附加功能，读者可以自己来探索。</li></ul><h3 id="3-4-进入main-tex"><a href="#3-4-进入main-tex" class="headerlink" title="3.4 进入main.tex"></a>3.4 进入main.tex</h3><p>​接下来，让我们把重点放在main.tex的代码上。</p><h4 id="3-4-1-整体架构"><a href="#3-4-1-整体架构" class="headerlink" title="3.4.1 整体架构"></a>3.4.1 整体架构</h4><p>​一篇标准的LaTeX代码架构如下：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-comment">% 这是一行注释，不会对代码产生任何影响</span><br><span class="hljs-keyword">\documentclass</span>&#123;article&#125;<br><span class="hljs-comment">%导言区（相当于前期的准备工作）</span><br><span class="hljs-keyword">\begin</span>&#123;document&#125;<br><span class="hljs-comment">%正文（文章内容）</span><br><span class="hljs-keyword">\end</span>&#123;document&#125;<br><span class="hljs-comment">% \end&#123;document&#125;代表着main.tex的结尾，相当于C++的return 0;这个语句后面不要加上任何的东西！（因为加了也没有任何意义）</span><br></code></pre></td></tr></table></figure><p>​<code>\</code>在LaTeX中是非常重要的一个字符，类似于C&#x2F;C++中的转义字符，在后面跟着的都是<strong>LaTeX的关键词和命令</strong>（会有代码高亮），我们<strong>重点学习的内容</strong>就是<strong>这些命令代表什么意思，以及如何使用这些命令</strong>。</p><p>​首先，我们来介绍LaTeX中的<strong>导言区</strong>，即<code>\begin&#123;document&#125;</code>之前的部分。</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\documentclass</span>&#123;article&#125;<br><span class="hljs-comment">%这行代码指定了文档的类型为 article，即文章类型。LaTeX 中有几种文档类型（如 report、book 等），article 是最常用的一种，适用于论文、报告、演讲稿等。</span><br></code></pre></td></tr></table></figure><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs LaTeX"><span class="hljs-comment">% Language setting</span><br><span class="hljs-comment">% Replace `english&#x27; with e.g. `spanish&#x27; to change the document language</span><br><span class="hljs-keyword">\usepackage</span>[english]&#123;babel&#125;<br><span class="hljs-comment">% Useful packages</span><br><span class="hljs-keyword">\usepackage</span>&#123;amsmath&#125;<br><span class="hljs-keyword">\usepackage</span>&#123;graphicx&#125;<br><span class="hljs-keyword">\usepackage</span>[colorlinks=true, allcolors=blue]&#123;hyperref&#125;<br></code></pre></td></tr></table></figure><p>​在LaTeX，几乎所有的高级操作都是建立在<strong>导入宏包</strong>的基础之上的，类似于C++中的#include和Python中的import，导入宏包可以让你的LaTeX代码变的更加强大。在此处导入的三个常用宏包分别用于数学公式(amsmath)，图形处理(graphix)和引用(hyperref)。<br>​在之后的学习过程中，你可以根据需求自己导入特定的宏包，不过别担心，后面会具体教你怎么做的。</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\title</span>&#123;Your Paper&#125;<br><span class="hljs-keyword">\author</span>&#123;You&#125;<br><span class="hljs-comment">% 作者的信息和文章标题，这一块也可以自己魔改（属于高级功能）</span><br></code></pre></td></tr></table></figure><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\begin</span>&#123;document&#125;<br><span class="hljs-comment">%正文</span><br><span class="hljs-keyword">\end</span>&#123;document&#125;<br></code></pre></td></tr></table></figure><p>​夹在<code>\begin&#123;document&#125;</code>和<code>\end&#123;document&#125;</code>之间的是文章的正文部分，<strong>任何你想在最后PDF出现的内容，无论是图片，文字，都需要在<code>\begin&#123;document&#125;</code>和<code>\end&#123;document&#125;</code>之间通过命令表达出来！</strong>接下来我们来重点介绍正文部分。</p><h4 id="3-4-2-正文部分①——文字"><a href="#3-4-2-正文部分①——文字" class="headerlink" title="3.4.2 正文部分①——文字"></a>3.4.2 正文部分①——文字</h4><blockquote><p>在这里为了方便演示，我创建了一个新的空白文档，所以和LaTeX模版之间存在差异。读者可以先尝试理解这些指令都代表着什么功能，然后回到自己的template中尝试“读懂”他！也可以自己尝试修改一些内容看看最后生成的文档有什么不同~</p></blockquote><p>正文的代码开始看不懂了？别着急，先来看看我写的简化版的</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\begin</span>&#123;document&#125;<br><span class="hljs-keyword">\maketitle</span><br><br><span class="hljs-keyword">\begin</span>&#123;abstract&#125;<br>Your abstract.<br><span class="hljs-keyword">\end</span>&#123;abstract&#125;<br><span class="hljs-keyword">\section</span>&#123;introducccction&#125;<br><span class="hljs-keyword">\section</span>&#123;Part1&#125;<br><span class="hljs-keyword">\subsection</span>&#123;hello&#125;<br>Hello, this is a test file.<br>is this a new paragraph?<br><br>is this a new paragraph?<br><span class="hljs-keyword">\subsection</span>&#123;world!&#125;<br><span class="hljs-keyword">\subsubsection</span>&#123;hahah&#125;<br><span class="hljs-keyword">\subsubsection</span>&#123;hahahahahah&#125;<br>i know you are very smart!<br><span class="hljs-keyword">\section</span>&#123;Part22&#125;<br><span class="hljs-keyword">\begin</span>&#123;enumerate&#125;<br>    <span class="hljs-keyword">\item</span> this is the firrst point<br>    <span class="hljs-keyword">\item</span> this is the 2nd points<br><span class="hljs-keyword">\end</span>&#123;enumerate&#125;<br><span class="hljs-keyword">\section</span>&#123;p3&#125;<br><span class="hljs-keyword">\section</span>&#123;Conclusion&#125;<br><br><span class="hljs-keyword">\end</span>&#123;document&#125;<br></code></pre></td></tr></table></figure><p>包含一些必要的文件准备工作，这份PDF输出如下：</p><p><img src="/posts/LaTeX-tutorial/image_12.png" alt="The Output"></p><blockquote><p>为了让展示变得更加清晰，我故意拼错了许多单词，请勿模仿！</p></blockquote><ul><li><p><code>\maketitle</code>命令首先输出文章的标题（包括作者信息和时间），不要删除。</p></li><li><p>摘要（abstract）</p><ul><li>论文的一个组成部分，由<code>\begin&#123;abstract&#125;</code>和<code>\end&#123;abstract&#125;</code>包裹。</li></ul></li><li><p><code>\section</code>,<code>\subsection</code>,<code>\subsubsection</code></p><ul><li>类似于论文中1,2,3级小标题的概念，读者可以将代码中的文字和最终输出在PDF中的位置对应起来，应该很快就能够理解。</li><li>这就是LaTeX的强大之处，可能用起来没有word可视化，但是他省去了很多文字排版以及大小调整优化的工作，实际上大大地提高了工作效率。</li></ul></li><li><p>正文</p><ul><li><p>文章中<em>i know you are very smart!</em> 和<em>Hello, this is a test file. is this a new paragraph?</em> 都是正文语句。</p></li><li><p><strong>缩进</strong>：LaTeX默认模版中首段不缩进，第二段才缩进，如果想更改这个设置，可以在导言区加入命令：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\usepackage</span>&#123;indentfirst&#125;<br><span class="hljs-comment">% 这是你加入的第一个宏包！快来compile一下看看有什么变化吧！</span><br></code></pre></td></tr></table></figure><p><img src="/posts/LaTeX-tutorial/image_13.png" alt="Indient"></p><p>你会发现，第一段也缩进啦！</p></li><li><p><strong>换行</strong>：</p><ul><li><p>第一个雷点：<strong>在源代码中换行并不代表真的换行了！</strong>比如第一个is this a new paragraph和Hello, this is a test file.分属两行，但他们实际输出上只在一行上面。</p></li><li><p>最简单的换行方法：<strong>直接在段落中添加一个空行，即按下两个回车键</strong>，这样就能成功实现换行。</p><p><strong>以下内容新手自动跳过！</strong></p></li><li><p>使用<code>\\</code>换行，一种更紧凑的写法（但有风险）</p></li></ul><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs LaTeX">This is the first line.<span class="hljs-keyword">\\</span><br>This is the second line.<br></code></pre></td></tr></table></figure><ul><li>其他换行方法：都是通过一些命令实现，可以作补充了解</li></ul><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs latex">This is the first line.<br><span class="hljs-keyword">\newline</span><br>This is the second line.<br><span class="hljs-comment">% 类比的，你应该就知道命令</span><br><span class="hljs-keyword">\newpage</span><br><span class="hljs-comment">% 是什么意思了吧！</span><br></code></pre></td></tr></table></figure><p>注意，使用<code>\\</code>和<code>\newline</code>进行强制换行时，两行之间没有额外的垂直间距！格式会有差异，<strong>建议非必要不要使用强制换行符</strong>。</p><p><img src="/posts/LaTeX-tutorial/image_14.png" alt="Using Newline Carefully"></p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-comment">% 一些补充命令：</span><br><br><span class="hljs-comment">%有垂直间距的换行</span><br>This is the first line.<br><span class="hljs-keyword">\vspace</span>&#123;1cm&#125;<br><br>This is the second line.<br><br><span class="hljs-comment">%无垂直间距的换行</span><br>This is the first line.<br><span class="hljs-keyword">\noindent</span><br><br>This is the second line without extra space.<br><br></code></pre></td></tr></table></figure><p><img src="/posts/LaTeX-tutorial/image_15.png" alt="Some advanced techniques"></p></li></ul></li><li><p><code>enumerate</code></p><ul><li>中文翻译“枚举”，用于文章中生成小标号，不作为小标题出现</li></ul><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\section</span>&#123;Part22&#125;<br><span class="hljs-keyword">\begin</span>&#123;enumerate&#125;<br>    <span class="hljs-keyword">\item</span> this is the firrst point<br>    <span class="hljs-keyword">\item</span> this is the 2nd points<br><span class="hljs-keyword">\end</span>&#123;enumerate&#125;<br><span class="hljs-comment">% 注意一个begin对应一个end，不然会报错！</span><br></code></pre></td></tr></table></figure><p><img src="/posts/LaTeX-tutorial/image_16.png" alt="Enumerate"></p><ul><li>可以和一些指令搭配使用，例如加粗<code>\textbf&#123;&#125;</code>等等。</li></ul></li><li><p>文本美化：</p><blockquote><p>这里的命令都是比较简单的，大家可以自行尝试~</p></blockquote><ul><li>加粗命令</li></ul><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\textbf</span>&#123;This text is bold.&#125;<br></code></pre></td></tr></table></figure><ul><li>斜线命令</li></ul><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\textit</span>&#123;This text is italic.&#125;<br></code></pre></td></tr></table></figure><ul><li>下划线命令</li></ul><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\underline</span>&#123;This text is underlined.&#125;<br></code></pre></td></tr></table></figure><ul><li>等宽字体</li></ul><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\texttt</span>&#123;This text is in typewriter font.&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="3-4-3-正文部分②——图片和图表"><a href="#3-4-3-正文部分②——图片和图表" class="headerlink" title="3.4.3 正文部分②——图片和图表"></a>3.4.3 正文部分②——图片和图表</h4><ul><li>插入图片</li><li>插入统计图</li><li>插入统计表</li></ul><h4 id="3-4-4-正文部分③——数学公式"><a href="#3-4-4-正文部分③——数学公式" class="headerlink" title="3.4.4 正文部分③——数学公式"></a>3.4.4 正文部分③——数学公式</h4><h2 id="4-LaTeX精进"><a href="#4-LaTeX精进" class="headerlink" title="4 LaTeX精进"></a>4 LaTeX精进</h2><h3 id="4-1-坏了，报错了！"><a href="#4-1-坏了，报错了！" class="headerlink" title="4.1 坏了，报错了！"></a>4.1 坏了，报错了！</h3><h3 id="4-2-导入特定的宏包"><a href="#4-2-导入特定的宏包" class="headerlink" title="4.2 导入特定的宏包"></a>4.2 导入特定的宏包</h3><h3 id="4-3-Advanced-Methods"><a href="#4-3-Advanced-Methods" class="headerlink" title="4.3 Advanced Methods"></a>4.3 Advanced Methods</h3><h3 id="4-4-自定义？"><a href="#4-4-自定义？" class="headerlink" title="4.4 自定义？"></a>4.4 自定义？</h3><h3 id="4-5-网站指南"><a href="#4-5-网站指南" class="headerlink" title="4.5 网站指南"></a>4.5 网站指南</h3><h2 id="5-Conclusion-and-Outlook"><a href="#5-Conclusion-and-Outlook" class="headerlink" title="5 Conclusion and Outlook"></a>5 Conclusion and Outlook</h2><p>（2024.11.22）笔者累啦，之后会更新的！</p>]]></content>
    
    
    <categories>
      
      <category>Efficient Tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tutorial</tag>
      
      <tag>LaTeX</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Life-Musings</title>
    <link href="/posts/Life-musings/"/>
    <url>/posts/Life-musings/</url>
    
    <content type="html"><![CDATA[<style>  html, body, .markdown-body {    font-family: Georgia, sans, serif;  }</style><h1 id="Life-Musings"><a href="#Life-Musings" class="headerlink" title="Life-Musings"></a>Life-Musings</h1><p><strong>生活随想录</strong></p><h2 id="2024-11-19"><a href="#2024-11-19" class="headerlink" title="2024.11.19"></a>2024.11.19</h2><p>第一篇文章！</p><h2 id="2024-12-4"><a href="#2024-12-4" class="headerlink" title="2024.12.4"></a>2024.12.4</h2><p>数分期中考试</p><p>好难好难呜呜呜</p><h2 id="2024-12-18"><a href="#2024-12-18" class="headerlink" title="2024.12.18"></a>2024.12.18</h2><p>临近期末周，workload确实上来了。</p><p>心心念念一学期的导师分配终于尘埃落定了，也算是分配上心仪的导师了。欣喜之中又带着一点焦虑…</p><p>之后继续努力吧~</p><h2 id="2025-1-13"><a href="#2025-1-13" class="headerlink" title="2025.1.13"></a>2025.1.13</h2><p>还没考完期末🤡🤡🤡成绩已经陆续出来了</p><p>分享今天看到的梗图</p><p><img src="https://ooo.0x0.ooo/2025/01/13/OE6g06.jpg" alt="RTFM"></p><h2 id="2025-2-16"><a href="#2025-2-16" class="headerlink" title="2025.2.16"></a>2025.2.16</h2><p>开学啦！</p><p><strong>《别折腾你的Ubuntu了！》</strong></p><h2 id="2025-3-16"><a href="#2025-3-16" class="headerlink" title="2025.3.16"></a>2025.3.16</h2><p>竟然已经开学一个月了！</p><p>又学习了好多好多新知识。加油！！！</p><h2 id="2025-3-17"><a href="#2025-3-17" class="headerlink" title="2025.3.17"></a>2025.3.17</h2><p>配环境是这个世界上最无聊的事情。</p><p>不过，我也有服务器啦！<del>AutoDL再见</del></p><p><img src="https://s1.imagehub.cc/images/2025/03/17/c248c233aca1ed9143d5ec073db75b92.png" alt="image"></p><p>保证<code>zsh</code>的环境一致性。</p><h2 id="2025-3-22"><a href="#2025-3-22" class="headerlink" title="2025.3.22"></a>2025.3.22</h2><p><code>streamlit</code> 简直是开发的神。无痛避免了HTML和CSS的学习成本。</p><p><strong>学计算机</strong>，就是要站在前人的肩膀上看问题！</p><h2 id="2025-4-1"><a href="#2025-4-1" class="headerlink" title="2025.4.1"></a>2025.4.1</h2><p>愚人节快乐！</p><p>不知不觉，写博客竟然已经快小半年了，经历过一日三更的疯狂，也经历过两周不更一篇的冷淡。写博客慢慢也成为了我生活的一部分。</p><p><strong>今天终于把服务器scp连接搞成功了</strong>，千算万算竟然没算到时<code>zsh</code>的问题，把终端改成bash瞬间就好了，难绷。</p><p>超级感谢陪我查错误的学长！！！很耐心！！！</p><p>（最近好忙，加油加油！</p><h2 id="2025-4-9"><a href="#2025-4-9" class="headerlink" title="2025.4.9"></a>2025.4.9</h2><p>感觉最近进入一个非常忙的阶段。。。但体感上其实没有前几周那么紧张，可能是物理和数据结构终于跟上进度了😋。</p><p>期中周感觉写博客的欲望暴增啊。。。 Anyway, try my best!</p><h2 id="2025-4-14"><a href="#2025-4-14" class="headerlink" title="2025.4.14"></a>2025.4.14</h2><p>非常喜欢的一篇文章。虽然躺在我的<strong>todolist</strong>里面很久了。。。</p><p>链接：</p><ul><li><p><a href="https://mp.weixin.qq.com/s/sVRUa1pHPPaV0_c12im66Q">新智元：AI正在培养文盲程序员</a></p></li><li><p><a href="https://nmn.gl/blog/ai-and-learning">原文</a></p></li></ul><p>代码还是得自己写。。。这是亘古不变的道理。</p>]]></content>
    
    
    
    <tags>
      
      <tag>life</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/posts/hello-world/"/>
    <url>/posts/hello-world/</url>
    
    <content type="html"><![CDATA[<style>  html, body, .markdown-body {    font-family: Georgia, sans, serif;  }</style><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
  
  
  <entry>
    <title>FAQ</title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[<style>  html, body, .markdown-body {    font-family: Georgia, sans, serif;  }</style><div class="markdown-body"><center><p><font size=6><b>FAQ~&#128512&#128516&#128513</b></p></font></p></center><p><strong>Found some issues or bugs in the blog? Feel free to contact the author.</strong></p><p><strong>My email:</strong></p><ul><li><p><a href="mailto:xiyuan__yang@outlook.com">xiyuan__yang@outlook.com</a></p></li><li><p><a href="mailto:yangxiyuan@sjtu.edu.cn">yangxiyuan@sjtu.edu.cn</a></p></li></ul><h1 id="FAQs"><a href="#FAQs" class="headerlink" title="FAQs"></a>FAQs</h1><h2 id="全是烂尾文章？"><a href="#全是烂尾文章？" class="headerlink" title="全是烂尾文章？"></a>全是烂尾文章？</h2><p>呜呜呜别骂了。。。博客的更新真的好花时间。。。一般来说，笔者会努力把前面的就坑全部填上再开新坑哒。</p><ul><li>一般在<code>Home</code>页写好摘要，设置好封面，Tags中标上<code>Finished</code>的文章就是已经完成不会大改的文章，可放心食用~</li><li>如果Tags标注是<code>Updating</code>，一般是一些声明性的文章，表示内容会时不时地更新。</li><li>如果是光秃秃的一片，说明亟需完工。🤡🤡🤡</li></ul><h2 id="关于评论系统"><a href="#关于评论系统" class="headerlink" title="关于评论系统"></a>关于评论系统</h2><p>评论系统算是笔者踩过的大坑之一，前后换了四五个评论系统，最后选择了强大的<code>giscus</code>提供支持。</p><p>相关网站：<a href="https://giscus.app/zh-CN">Giscus</a></p><p><strong>有关评论系统的使用：</strong></p><ul><li><p>需要自己的github账号</p><ul><li><a href="https://giscus.app/zh-CN">Giscus</a>的网站好像会被墙，导致评论区加载失败，请自行解决。</li></ul></li><li><p>之后使用就和正常的评论区没什么区别了，轻点喷~</p></li><li><p>相关的评论内容可以在我博客仓库的 <a href="https://github.com/xiyuanyang-code/xiyuanyang-code.github.io/discussions">Discussion</a> 页面找到。</p></li><li><p>目前只有文章页可以发表评论哦，有什么奇奇怪怪的问题可以给我发 <a href="https://github.com/xiyuanyang-code/xiyuanyang-code.github.io/issues">issue</a> 或者email 我。</p></li><li><p><strong>好像手机端没办法发表评论（我也不知道为什么）。</strong></p></li></ul><h2 id="更新频率？更新内容？"><a href="#更新频率？更新内容？" class="headerlink" title="更新频率？更新内容？"></a>更新频率？更新内容？</h2><p><a href="https://xiyuanyang-code.github.io/above/">参见这里</a></p><h2 id="有关博客的照片"><a href="#有关博客的照片" class="headerlink" title="有关博客的照片"></a>有关博客的照片</h2><p>在博客正文中使用的图片都会储存在<strong>图床</strong>中（除了引用别人的图片），网站 <strong><a href="https://img.tg/yangxiyuan/albums">IMG.TG</a></strong></p><blockquote><p>最后引用一下我的偶像的博客的FAQ的最后一个问题：</p><p>相关网址：<a href="https://lilianweng.github.io/faq/">lilianweng</a></p><p><strong>Q: How can you keep up blogging?</strong></p><p><strong>A:</strong> “Pain is inevitable but suffering is optional” — this is the first sentence of Haruki Murakami’s book <a href="https://www.goodreads.com/book/show/2195464.What_I_Talk_About_When_I_Talk_About_Running">“What I Talk About When I Talk About Running”</a>. I love that book. His altitude towards running is pretty much aligned with how I feel about maintaining this blog.</p></blockquote><div/><hr><h1 id="English-Version-FAQs"><a href="#English-Version-FAQs" class="headerlink" title="English Version FAQs"></a>English Version FAQs</h1><h2 id="Are-all-your-posts-incomplete"><a href="#Are-all-your-posts-incomplete" class="headerlink" title="Are all your posts incomplete?"></a>Are all your posts incomplete?</h2><p>Please don’t scold me… 😭 Maintaining and updating a blog takes a lot of time. Generally, I strive to finish old posts before starting new ones.</p><ul><li>Posts marked with <code>Finished</code> in the <em>Tags</em> section on the <code>Home</code> page, along with summaries and cover images, are complete and won’t undergo major changes. Feel free to enjoy them with peace of mind!</li><li>Posts marked with <code>Updating</code> in <em>Tags</em> are generally declarative in nature and are updated from time to time.</li><li>If a post has no tags at all, it’s a work in urgent need of completion. 🤡🤡🤡</li></ul><h2 id="About-the-Comment-System"><a href="#About-the-Comment-System" class="headerlink" title="About the Comment System"></a>About the Comment System</h2><p>The comment system has been one of the biggest challenges I’ve faced. After trying four or five systems, I finally settled on the robust support provided by <code>giscus</code>.</p><p>Relevant website: <a href="https://giscus.app/zh-CN">Giscus</a></p><p><strong>How to use the comment system:</strong></p><ul><li><p>You need your own GitHub account </p><ul><li>The <a href="https://giscus.app/">Giscus</a> website seems to be blocked, causing the comment section to fail to load. Please resolve this issue independently.</li></ul></li><li><p>Once logged in, using the comment section is no different from a regular comments platform—please be gentle with your critiques. 😉</p></li><li><p>Comments are linked to the <a href="https://github.com/xiyuanyang-code/xiyuanyang-code.github.io/discussions">Discussions</a> page in my blog’s GitHub repository.</p></li><li><p>Currently, only article pages allow comments. For unusual issues, you can send me an <a href="https://github.com/xiyuanyang-code/xiyuanyang-code.github.io/issues">issue</a> or email me.</p></li><li><p><strong>It seems that comments don’t work on mobile devices (I have no idea why).</strong></p></li></ul><h2 id="How-often-do-you-update-What-do-you-post"><a href="#How-often-do-you-update-What-do-you-post" class="headerlink" title="How often do you update? What do you post?"></a>How often do you update? What do you post?</h2><p><a href="https://xiyuanyang-code.github.io/above/">See this page</a> for more details.</p><h2 id="Pictures"><a href="#Pictures" class="headerlink" title="Pictures"></a>Pictures</h2><p>All images used in the body of the blog will be stored on the <strong>image hosting platform</strong> (except for images referenced from others), on the website <strong><a href="https://img.tg/yangxiyuan/albums">IMG.TG</a></strong>.</p><blockquote><p>Finally, here’s a quote from my idol’s FAQ page:</p><p>Relevant website: <a href="https://lilianweng.github.io/faq/">lilianweng</a></p><p><strong>Q: How can you keep up blogging?</strong></p><p><strong>A:</strong> “Pain is inevitable but suffering is optional” — This is the first sentence of Haruki Murakami’s book <a href="https://www.goodreads.com/book/show/2195464.What_I_Talk_About_When_I_Talk_About_Running">“What I Talk About When I Talk About Running”</a>. I love that book. His attitude toward running aligns closely with how I feel about maintaining this blog.</p></blockquote>]]></content>
    
  </entry>
  
  
  
  <entry>
    <title>All_posts</title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[<style>  html, body, .markdown-body {    font-family: Georgia, sans, serif;  }</style><p><img src="https://s1.imagehub.cc/images/2025/02/07/329668c81128e08f84c1d1ea140bc31b.jpg" alt="Welcome to Xiyuan Yang&#39;s Blog!"></p><p>This article systematically summarizes the previously published articles by categorizing them into topics.</p><p>This passage will be updated permanently, adding new posts every two weeks.</p><div class="note note-primary">            <p><strong>Last Update Time: 2025&#x2F;03&#x2F;25</strong></p>          </div><h1 id="About-the-author"><a href="#About-the-author" class="headerlink" title="About the author"></a>About the author</h1><p><a href="https://xiyuanyang-code.github.io/about/">About - Xiyuan Yang’s Blog</a> You can Jump to this link for more information.</p><h1 id="All-posts"><a href="#All-posts" class="headerlink" title="All posts!"></a>All posts!</h1><p>The posts can be divided into several <a href="https://xiyuanyang-code.github.io/categories/">categories</a> below:</p><ul><li><p>Code Basis: <strong>Basic Syntax of several programming language</strong></p><ul><li>Category Link: <a href="https://xiyuanyang-code.github.io/categories/Code/">Categories - Code - Xiyuan Yang’s Blog</a></li></ul></li><li><p>Algorithms: <strong>Advanced Learning of Algorithms and Data Structures</strong></p><ul><li>Category Link: <a href="https://xiyuanyang-code.github.io/categories/Algorithm/">Categories - Algorithm - Xiyuan Yang’s Blog</a></li></ul></li><li><p>Efficient Tools: <strong>Tool usage for Computer Science and AI</strong></p><ul><li>Category Link: <a href="https://xiyuanyang-code.github.io/categories/Efficient-Tools/">Categories - Efficient Tools - Xiyuan Yang’s Blog</a></li></ul></li><li><p>Project: <strong>Demonstration and Introduction of My Github Project</strong></p><ul><li>Category Link: <a href="https://xiyuanyang-code.github.io/categories/Project/">Categories - Project - Xiyuan Yang’s Blog</a></li></ul></li><li><p>Artificial Intelligence: <strong>Research Paper Reading</strong></p><ul><li>Category Link: <a href="https://xiyuanyang-code.github.io/categories/Artificial-Intelligence/">Categories - Artificial Intelligence - Xiyuan Yang’s Blog</a></li></ul></li></ul><br><p>Moreover, all posts ca be divided into three categories based on the <strong>completion progress</strong>.</p><ul><li><p><strong>Finished</strong>😃: Posts that have been finished writing and will not be modified in a short term unless some mistakes are caught.</p></li><li><p><strong>Updating</strong>🫡: Mostly blogs with announcements, which will be updated in real time.</p></li><li><p><strong>Not yet Finished</strong>🤡: Posts that have not yet been finished.</p></li></ul><h2 id="Total-demonstration"><a href="#Total-demonstration" class="headerlink" title="Total demonstration"></a>Total demonstration</h2><blockquote><p>Updated: 2025.4.12</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs bash">❌AI-Paper-2024<br>❌AI-indepth-reading-AlexNet<br>❌AIBasis-Neural-Networks<br>❌AINN-GAN<br>✅Above-All<br>✅Algorithm-BFS-DFS<br>✅Algorithm-BinaryTree<br>❌Algorithm-Chunking<br>✅Algorithm-Introduction<br>✅Algorithm-MCTS<br>✅Algorithm-Memo<br>✅Algorithm-Sorting<br>❌AutoGen-automatic-essay-modification<br>✅Bash-commands<br>✅Bash-exercises<br>✅Blog-Update-Fetching-Script<br>✅C-plus-plus-Primer-Plus-tutorial<br>✅CMake-tutorial-episode2<br>✅CMake-tutorial1<br>✅CS294-1-LLM-Reasoning<br>✅CS294-3-Autogen<br>✅Class-Inheritance<br>✅Code-Reuse-in-OOP<br>✅DataStructure-AVL-Tree<br>✅DataStructure-Fenwick-Tree<br>✅DataStructure-LCA<br>✅DataStructure-LinearList<br>✅DataStructure-Queue<br>❌DataStructure-RBT-Tree<br>✅DataStructure-Set<br>✅DataStructure-Sparse-Table<br>✅DataStructure-Stack<br>✅DataStructure-Stack-Queue-Advanced<br>✅DataStructure-String<br>✅DataStructure-Tree<br>✅DataStructure-Tree-Binary-Heap<br>✅DataStructure-Tree-Binary-Search-Tree<br>✅DataStructure-Tree-Binary-Tree<br>❌DataStructure-Trie<br>✅DataStructure-Tutorial<br>✅Deep-Learning-Memo<br>✅Dynamic-Memory-and-Classes<br>✅Exception-Handling-in-C-plus-plus<br>✅Input-and-Output-in-C-plus-plus<br>✅Introduction-to-OOP<br>✅Jotting-References-and-Encapsulation-in-OOP<br>✅LaTeX-tutorial<br>✅Leetcode-Mistake-collection<br>✅Leetcode-Mistake-collection-1-10<br>✅Leetcode-Mistake-collection-11-20<br>✅Leetcode-Mistake-collection-21-30<br>✅Leetcode-Mistake-collection-31-40<br>✅Life-musings<br>✅Linked-List-Implementation-Based-on-Structs<br>✅Linux-Bash-Introduction<br>✅MYGITHUB-Lightweight-speech-recognition-conversion-model<br>✅Math-Multivariable-Calculus<br>✅Missing-Semester-Notes<br>✅My-Posts<br>✅My-WorkFlow<br>✅Pointers-Arrays-and-Functions<br>✅Pre-training-Is-Dead<br>✅Python-Update-Learning<br>✅Python-advanced-File-Management<br>✅Python-cheatsheet<br>✅Python-numpy-cheatsheet<br>✅Python-tutorial<br>✅Python-visualization<br>✅RAG-Blog-Content-Retrieval<br>✅RAG-tutorial<br>✅RL-speeches<br>✅Regular-Expression<br>❌Taking-Notes<br>❌Tools-Tutorial<br>✅Torch-memo<br>✅Vim-tutorial<br></code></pre></td></tr></table></figure><h2 id="Code-Basis"><a href="#Code-Basis" class="headerlink" title="Code Basis"></a>Code Basis</h2><ul><li><strong>Python Grammar Tutorial</strong></li><li><strong>C++ Primer Plus Tutorial</strong></li></ul><h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><ul><li><strong>Data Structure</strong></li><li><strong>Algorithms from MIT 6.006</strong></li><li><strong>Leetcode Mistake Collection</strong></li></ul><h2 id="Project"><a href="#Project" class="headerlink" title="Project"></a>Project</h2><ul><li><strong>My Github Projects</strong></li></ul><h2 id="Efficient-Tools"><a href="#Efficient-Tools" class="headerlink" title="Efficient Tools"></a>Efficient Tools</h2><ul><li><strong>Bash&#x2F;Linux</strong></li><li><strong>Methodologies</strong></li><li><strong>Other developer’s Tools</strong> <ul><li>Missing semester Notes</li></ul></li></ul><h2 id="Artificial-Intelligence"><a href="#Artificial-Intelligence" class="headerlink" title="Artificial Intelligence"></a>Artificial Intelligence</h2><ul><li><p><strong>CS294: LLM Agents</strong></p></li><li><p><strong>Celebrity Speeches</strong></p></li></ul>]]></content>
    
  </entry>
  
  
  
  <entry>
    <title>Recordings</title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[<style>  html, body, .markdown-body {    font-family: Georgia, sans, serif;  }</style><div class="markdown-body"><p><img src="https://s1.imagehub.cc/images/2025/02/07/329668c81128e08f84c1d1ea140bc31b.jpg" alt="Welcome to Xiyuan Yang&#39;s Blog!"></p><h1 id="Recordings"><a href="#Recordings" class="headerlink" title="Recordings"></a>Recordings</h1><div class="note note-info">            <p>After entering university, the author realized that the new knowledge to be learned was vast like the ocean. Sometimes, one can even be overwhelmed by this sea of knowledge and lose oneself. Therefore, the author will update this blog in real-time with new knowledge learned each day, making it easier for self-review and reflection, and to <strong>encourage the habit of being a lifelong learner</strong>.</p><p><strong>Learn something, yield something</strong>.</p>          </div><blockquote><p>Site updated: 20250324</p></blockquote><h2 id="My-records"><a href="#My-records" class="headerlink" title="My records"></a>My records</h2><ul><li><p><code>2025/03/25</code></p><ul><li>物理：狭义相对论（洛伦兹变换）</li><li>LaTeX 中文模版 + 确定人工智能基础课的大作业选题</li><li>离散：一阶逻辑</li><li>数据结构：<code>list</code>大作业的大部分实现</li></ul></li><li><p><code>2025/03/26</code>:</p><ul><li>听了科研学长的讲座，对<strong>科研，学业等精力分配的问题又有了更深的了解</strong></li><li>离散数学：学习一阶逻辑</li><li>数据结构：完成了<code>list</code>大作业的大部分实现，现在进入最后的debug阶段</li><li>数据结构：完成对<strong>Binary Tree</strong>的博客更新和代码复习（到Huffman 树和 Huffman 编码）</li></ul></li><li><p><code>2025/04/01</code>:</p><ul><li><strong>不能断更。。。</strong></li><li>大学物理：角动量守恒定律（但还没有学完）</li><li><strong>数据结构</strong>：完成了树状数组和ST表全部内容的学习：（理论知识复习&amp;博客写作&amp;模版代码+测试&amp;OJ题目练手）</li><li><strong>实验室</strong>：和学长reach out，终于配置好了远程服务器的所有流程（包括之前<code>scp</code>链接失效的debug）</li><li><strong>RAG</strong> 学习完成了 <strong>Query Translation</strong>的所有博客更新和代码学习，但是还没有应用到实战</li><li><strong>Pytorch</strong> 学习<code>Tensorboard</code>的基本使用方式</li></ul></li><li><p><code>2025/04/02</code>:</p><ul><li><strong>数学分析</strong>：<strong>三重积分</strong> &amp; 完成对应的作业</li><li><strong>离散数学</strong>：一节逻辑： Quantifiers in specific domains.</li><li><strong>AI</strong>：完成了人工智能基础课程的CNN刷榜（暂居第一😋）</li><li><strong>数据结构</strong>：debug list大作业的过程真的好漫长。。。无语了</li></ul></li><li><p><code>2025/04/03</code>:</p><ul><li><strong>AI</strong>：学习GAN、diffusion等新型网络结构 &amp; 继续炼丹ing</li><li><strong>数据结构</strong>：完成堆和BST的学习</li></ul></li><li><p><code>2025/04/08</code>：</p><ul><li><strong>物理</strong>：补上了角动量和刚体的课程进度，并且刷完了第二章和第三章的系列化习题（累死我了，物理真难）</li><li><strong>数据结构</strong>：学习蒙特卡洛算法并做好PPT</li></ul></li><li><p><code>2025/04/09</code>:</p><ul><li><strong>离散数学</strong>：学习在自然语言下的逻辑构建方法（这个东西上一堂课就没听懂，这下一听就听懂了）</li><li><strong>数学分析</strong>：复习<strong>偏微分方程</strong></li><li><strong>数据结构</strong>：再次回顾蒙特卡洛搜索树算法并完成博客的更新</li><li><strong>数据结构</strong>：博客更新 <strong>MIT6.006 Lec9 BFS算法</strong>（图论初步）、</li><li><strong>大学物理</strong>：继续刷系列化习题（刷完了第二章和第三章的全部内容）</li></ul></li><li><p><code>2024/04/10</code>:</p><ul><li><strong>大学物理</strong>：第五章刚体基本知识学习完成</li><li><strong>数据结构</strong>：复习AVL树，学习红黑树和AA树，但是红黑树代码的实现debug还未完成</li><li><strong>人工智能</strong>：学习LSTM（循环神经网络）&amp; 学习Transformer</li><li><strong>离散数学</strong>：完成周三离散数学内容的复习和作业</li></ul></li><li><p><code>2024/04/11</code>:</p><ul><li><strong>离散数学</strong>：完成<strong>逻辑</strong>部分的学习</li><li><strong>大学物理</strong>：学习第六章简谐运动</li><li><strong>大学英语</strong>：完成第二份议论文</li><li><strong>人工智能</strong>：尝试使用<code>autogen</code>开发出一个简单的博客多智能体对话框架</li><li><strong>数学分析</strong>：复习数学分析寒假学习的内容 &amp; 刷题</li></ul></li><li><p><code>2024/04/12</code>:</p><ul><li><p><strong>数据结构</strong>：学习<strong>LCA算法</strong>和<strong>DFS的图论基础算法</strong>（MIT6.006）</p></li><li><p><strong>人工智能</strong>：修改<code>autogen</code>的框架，优化文件管理和工作流</p><ul><li>最后思来想去还是决定使用**Camel…**，autogen的设计还是有一点死板，虽然快速上手的模版确实惊艳到我了。</li></ul></li><li><p><strong>数学分析</strong>：回看了多元函数极限与连续 &amp; 多元函数微分学的笔记 &amp; 复习寒假小册子上做过发题目。</p></li></ul></li><li><p><code>2024/04/13</code>:</p><ul><li><strong>数据结构</strong>：上机课学习modern cpp &amp; 博客完善</li><li><strong>数学分析</strong>：数学分析补课 &amp; 继续学习</li><li><strong>大学物理</strong>：复习大学物理Cha4：角动量</li><li><strong>人工智能</strong>：<ul><li>进一步学习Transformer理论 </li><li>完善提示词 &amp; 加入日志记录的功能</li></ul></li><li><strong>离散数学</strong>：完成星期五离散数学课程的作业和复习。</li></ul></li><li><p><code>2024/04/14</code>:</p><ul><li><strong>数学分析</strong>：终于把记的所有笔记全部看完了。。。</li><li><strong>数学分析</strong>：往年期中试卷刷题。<ul><li>刷题真的好无聊。。。</li></ul></li><li><strong>人工智能</strong>：学习卷积的数学原理。</li></ul></li></ul><h2 id="My-feelings"><a href="#My-feelings" class="headerlink" title="My feelings"></a>My feelings</h2><ul><li><code>2025/03/26</code>:<ul><li>一定要去线下上课！！！线下的效率才是最高的。</li><li>不要把自己想的太完美主义，贴合实际情况才会达到最高的效率。</li><li>要休息好。</li></ul></li><li><h2 id="2025-04-10-最近很忙，但也要努力不放弃！"><a href="#2025-04-10-最近很忙，但也要努力不放弃！" class="headerlink" title="2025/04/10:- 最近很忙，但也要努力不放弃！"></a><code>2025/04/10</code>:<br>- 最近很忙，但也要努力不放弃！</h2></li></ul></div>]]></content>
    
  </entry>
  
  
  
  <entry>
    <title>About</title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[<style>  html, body, .markdown-body {    font-family: Georgia, sans, serif;  }</style><p>Greetings! I am <strong>Xiyuan Yang (杨希渊)</strong>, currently pursuing an undergraduate degree in Artificial Intelligence at Shanghai Jiao Tong University. With a longstanding aspiration to become a programmer, I am passionate about leveraging technology to make a meaningful impact on the world. Through my personal website, I aim to share a collection of my blogs and learning notes with you. Some of these entries will be presented as a series, updated at irregular intervals. Additionally, I will offer insights into my personal observations and reflections on life. I hope your visit here is both enjoyable and enriching!</p><p><strong>My orcid</strong>: <a href="https://orcid.org/0009-0004-8979-7892">https://orcid.org/0009-0004-8979-7892</a></p><p><strong>My email:</strong></p><ul><li><p><a href="mailto:&#120;&#x69;&#x79;&#117;&#97;&#x6e;&#95;&#x5f;&#121;&#97;&#x6e;&#103;&#64;&#x6f;&#x75;&#x74;&#x6c;&#x6f;&#111;&#x6b;&#x2e;&#99;&#111;&#x6d;">&#120;&#x69;&#x79;&#117;&#97;&#x6e;&#95;&#x5f;&#121;&#97;&#x6e;&#103;&#64;&#x6f;&#x75;&#x74;&#x6c;&#x6f;&#111;&#x6b;&#x2e;&#99;&#111;&#x6d;</a></p></li><li><p><a href="mailto:&#121;&#97;&#x6e;&#x67;&#x78;&#105;&#x79;&#x75;&#x61;&#x6e;&#64;&#x73;&#x6a;&#116;&#x75;&#x2e;&#101;&#x64;&#117;&#x2e;&#99;&#110;">&#121;&#97;&#x6e;&#x67;&#x78;&#105;&#x79;&#x75;&#x61;&#x6e;&#64;&#x73;&#x6a;&#116;&#x75;&#x2e;&#101;&#x64;&#117;&#x2e;&#99;&#110;</a></p><p>Feel free to contact me!</p></li></ul><blockquote><p>VENI VIDI VICI</p></blockquote><p></br><h1 align="center">Welcome to Xiyuan Yang’s Coding Space!</h1></p><h3 align="center"><a href="https://git.io/typing-svg"><img src="https://readme-typing-svg.herokuapp.com?font=Fira+Code&pause=1000&random=false&width=650&lines=Keep+it+simple+and+stupid." alt="Typing SVG" /></a></h3><p align="left"> <img src="https://komarev.com/ghpvc/?username=xiyuanyang-code&label=Profile%20views&color=0e75b6&style=flat" alt="xiyuanyang-code" /> </p><h3 id="About-Me"><a href="#About-Me" class="headerlink" title="About Me"></a>About Me</h3><p>Hi there! I’m <strong>Xiyuan Yang</strong>, a passionate programmer and lifelong learner. I love exploring new technologies and solving challenging problems.</p><h3 id="Connect-with-Me"><a href="#Connect-with-Me" class="headerlink" title="Connect with Me"></a>Connect with Me</h3><ul><li><a href="https://xiyuanyang-code.github.io/">My personal Blog</a></li><li><a href="xiyuan__yang@outlook.com">My email</a></li></ul><h3 id="Currently-Learning"><a href="#Currently-Learning" class="headerlink" title="Currently Learning"></a>Currently Learning</h3><p>I’m currently diving into:</p><ul><li>Advanced C++</li><li>Machine Learning and Deep Learning</li><li>LLM reasoning and LLM agents</li></ul><h3 id="Fun-Facts"><a href="#Fun-Facts" class="headerlink" title="Fun Facts"></a>Fun Facts</h3><ul><li>🌱 I’m currently learning new programming languages.</li><li>🎯 I aim to become a full-stack developer. (Maybe?)</li><li>📚 I love reading tech blogs and books.</li></ul><p align="left"> <a href="https://github.com/ryo-ma/github-profile-trophy"><img src="https://github-profile-trophy.vercel.app/?username=xiyuanyang-code" alt="xiyuanyang-code" /></a> </p><h3 id="Languages-and-Tools"><a href="#Languages-and-Tools" class="headerlink" title="Languages and Tools"></a>Languages and Tools</h3><div style="text-align: center;">    <a href="https://en.wikipedia.org/wiki/C_(programming_language)" target="_blank" rel="noreferrer">        <img src="https://raw.githubusercontent.com/devicons/devicon/master/icons/c/c-original.svg" alt="c" width="40" height="40"/>    </a>    <a href="https://www.w3schools.com/cpp/" target="_blank" rel="noreferrer">        <img src="https://raw.githubusercontent.com/devicons/devicon/master/icons/cplusplus/cplusplus-original.svg" alt="cplusplus" width="40" height="40"/>    </a>    <a href="https://www.w3schools.com/html/" target="_blank" rel="noreferrer">        <img src="https://raw.githubusercontent.com/devicons/devicon/master/icons/html5/html5-original.svg" alt="html" width="40" height="40"/>    </a>    <a href="https://www.python.org" target="_blank" rel="noreferrer">        <img src="https://raw.githubusercontent.com/devicons/devicon/master/icons/python/python-original.svg" alt="python" width="40" height="40"/>    </a>    <a href="https://www.linux.org/" target="_blank" rel="noreferrer">    <img src="https://raw.githubusercontent.com/devicons/devicon/master/icons/linux/linux-original.svg" alt="linux" width="40" height="40"/></a></br></br><div style="text-align: center;">    <img src="https://github-readme-stats.vercel.app/api?username=xiyuanyang-code&show_icons=true&locale=en" alt="xiyuanyang-code" /></div>]]></content>
    
  </entry>
  
  
  
  <entry>
    <title>Above</title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[<div class="markdown-body">    <style>  html, body, .markdown-body {    font-family: Georgia, sans, serif;  }</style><h1 id="Welcome-To-My-Blog"><a href="#Welcome-To-My-Blog" class="headerlink" title="Welcome To My Blog !"></a>Welcome To My Blog !</h1><h2 id="Before-The-Blog"><a href="#Before-The-Blog" class="headerlink" title="Before The Blog"></a>Before The Blog</h2><p>三个月前，我通过偶然的机会了解到前 OpenAI 研究副总裁，主管GPT模型安全的杰出华人女性，<strong>翁荔(Lilian Weng)<strong>。她提出了著名的</strong>Agent 配方：Agent&#x3D;LLM+Memory+planning skills+tool use</strong>。在当今的GPT时代，她可谓是功不可没。</p><p>在OpenAI对她的独家专访<a href="https://openai.com/index/the-power-of-continuous-learning/">The power of continuous learning</a>中，她提到：</p><blockquote><p>I believe in the power of learning and it is never too late to learn. Maintaining my personal blog is a good way to keep this curiosity going and learn about new progress in the deep learning community regularly. I also encourage my team to keep on learning, whether related or unrelated to their current projects. Ideas in different topics or fields can often inspire new ideas and broaden the potential solution space.</p><p>I’ m also a strong believer in teamwork. If everyone shines in their best strength, we will get 1+1 &gt; 2. Meanwhile, we might often run into “dirty” work and personally I’m very willing to take on those tasks, because as long as that’s the biggest blocker or that task can add the biggest value into the project, nothing should be considered “dirty” or “trivial.” I encourage people around me to do the same, being a team player and working together to expedite the team productivity.</p><p>我相信学习的力量，学习永远不会太迟。维护个人博客是一个保持好奇心，定期了解深度学习社区新进展的好方法。我也鼓励我的团队不断学习，无论是否与他们当前的项目相关。不同主题或领域的想法常常能激发新的灵感，并拓宽潜在的解决方案空间。</p><p>我也是团队合作的坚定信徒。如果每个人都能在自己最擅长的领域发光，我们就能实现1+1大于2。同时，我们可能会碰到一些“脏活”，而我个人非常愿意承担这些任务，因为只要那是最大的障碍，或者那项任务能为项目带来最大的价值，就没有什么是“脏活”或“琐事”。我鼓励周围的人也这样做，成为团队的一员，共同努力提高团队的生产力。</p></blockquote><p><img src="https://images.ctfassets.net/kftzwdyauwt9/e3357d5a-b177-4b3a-1edf79a7f2dc/ca1f3418cd72b4eb84c9d1a09dfffc7f/stangel-2022-0421.jpg?w=3840&q=90&fm=webp" alt="Lilian Weng&#39;s interview"></p><p>图源：<a href="https://openai.com/index/the-power-of-continuous-learning/">The power of continuous learning | OpenAI</a>   Photo: Jake Stangel</p><p>这与<strong>费曼学习法（Feynman Technique）</strong>可谓是不谋而合：</p><blockquote><p>1.Identify the subject. Write down everything you know about the topic.</p><p>2.Teach it to a child. If you can teach a concept to a child, you’re way ahead of the game.</p><p>3.Identify your knowledge gaps. This is the point where the real learning happens.</p><p>4.Organize + simplify + Tell a story. Start to tell your story.</p></blockquote><p>此时，刚刚步入大学校园3个月的笔者，由于深受高中优绩主义和应试思想的遗风荼毒，对大学生活和计算机学科的学习颇具不适应的疲态。学习的知识如此海量，却无法依靠应试和做题进行巩固，该如何是好？</p><p>或许<strong>上文已经给出了答案。</strong></p><center><p><font size=6><b><p style="color:red;">我要创建自己的博客!</p></b></font></p></center><p>无论是传统的做题刷卷，还是博客，亦或是“费曼学习法”，本质上都是<strong>强化训练人脑在吸收新知识后的有效输出过程</strong>：当你能很流畅地给出一道数学题的若干种证明方法时，能逻辑清晰地将所学的知识穿成逻辑链条或思维导图，呈现在博客中为他人所吸收时，你便通过<strong>有效的对外做功输出</strong>很好地巩固了所学的知识。同时，知识的不断沉淀也带来了莫大的成就感。</p><p>但是，写一篇博客，可不仅仅是打打字那么简单。</p><p>不知各位在高中写议论文的时候有没有一种“咬牙切齿”的感觉，就是<strong>我想到的≠我实际构思好的≠我输出的≠我希望所表达的</strong>，甚至于，很多时候我们心中所谓的灵感只是<strong>乍现的只言片语的碎片</strong>，距离成为一篇逻辑清晰，内容详实且有创新性的博客文章还有很长的路要走。这便是博客写作的难点，也是<strong>我希望通过个人博客来训练的最重要的内容：将心里的灵感进行有效的输出，力求逻辑性和学术的专业性。</strong></p><h2 id="About-the-Blog"><a href="#About-the-Blog" class="headerlink" title="About the Blog"></a>About the Blog</h2><p><strong>Xiyuan Yang’s Blog</strong>，创建于<strong>2024年11月19日</strong>。</p><p>以下是自我简介（摘自<a href="https://xiyuanyang-code.github.io/about/">About - Xiyuan Yang’s Blog</a>）：</p><blockquote><p>Greetings! I am <strong>Xiyuan Yang (杨希渊)</strong>, currently pursuing an undergraduate degree in Artificial Intelligence at Shanghai Jiao Tong University. With a longstanding aspiration to become a programmer, I am passionate about leveraging technology to make a meaningful impact on the world. Through my personal website, I aim to share a collection of my blogs and learning notes with you. Some of these entries will be presented as a series, updated at irregular intervals. Additionally, I will offer insights into my personal observations and reflections on life. I hope your visit here is both enjoyable and enriching!</p></blockquote><blockquote><p><strong>My email:</strong></p><ul><li><p><a href="mailto:xiyuan__yang@outlook.com">xiyuan__yang@outlook.com</a></p></li><li><p><a href="mailto:yangxiyuan@sjtu.edu.cn">yangxiyuan@sjtu.edu.cn</a></p><p>Feel free to contact me!</p></li></ul></blockquote><blockquote><p>VENI VIDI VICI</p></blockquote><p>这个博客的更新内容将随着笔者后续的专业课程的学习同步进行，<strong>旨在分享笔者在学习过程中学到的有意思的专业知识，力求在博客输出的过程中培养自己的逻辑思维和表达能力</strong>，不过更新时间，更新内容，更新篇幅<strong>将会完全随机</strong>。</p><p>本博客部署在github的静态网站上，轮子使用<code>Hexo</code>的<code>Fluid</code>的模版，配置环境还是比较简单的，下面贴出一些相关的网址，有相同爱好的童鞋可以参考借鉴一下：</p><ul><li><a href="https://github.com/xiyuanyang-code">xiyuanyang-code (Xiyuan Yang)我的Github主页</a></li><li><a href="https://github.com/xiyuanyang-code/xiyuanyang-code.github.io">xiyuanyang-code&#x2F;xiyuanyang-code.github.io我的博客Github仓库</a></li><li><a href="https://github.com/fluid-dev/hexo-theme-fluid">fluid-dev&#x2F;hexo-theme-fluid-Design theme for Hexo Fluid的Github官方仓库</a></li><li><a href="https://fluid-dev.github.io/hexo-fluid-docs/guide/">配置指南 | Hexo Fluid 用户手册</a></li><li><a href="https://fluid-dev.github.io/hexo-fluid-docs/start/">开始使用 | Hexo Fluid 用户手册</a></li></ul><p>有关博客的具体更新内容，请详见<code>Goals and Plans of Updates</code>部分~</p><h2 id="Goals-and-Plans-of-Updates"><a href="#Goals-and-Plans-of-Updates" class="headerlink" title="Goals and Plans of Updates"></a>Goals and Plans of Updates</h2><h3 id="更新的主要内容"><a href="#更新的主要内容" class="headerlink" title="更新的主要内容"></a>更新的主要内容</h3><p>笔者更新的主要内容包括：（<strong>草拟</strong>）</p><ul><li>编程语言的语法学习<ul><li>C&#x2F;C++</li><li>Python<ul><li>语法</li><li>Anaconda</li><li>一些常见的库</li></ul></li><li>HTML&#x2F;Javascript</li><li>Bash&#x2F;Shell</li></ul></li><li>一些常用的工具教程<ul><li>LaTeX</li><li>命令行</li><li>Git</li><li>Vim编辑器</li><li>Linux和服务器（主要和深度学习相关）<ul><li>Linux常见命令</li><li>Tmux</li><li>SSH远程连接</li></ul></li></ul></li><li>[CS]算法<ul><li>数据结构</li><li>算法</li><li>计算机四大件</li></ul></li><li>AI专业课<ul><li>机器学习</li><li>强化学习</li><li>深度学习<ul><li>Pytorch</li></ul></li></ul></li><li>AI前沿&amp;经典论文精读</li><li><del>一些晦涩难懂的</del>数学课</li><li>发发牢骚</li></ul><h3 id="具体的分类（实时更新）"><a href="#具体的分类（实时更新）" class="headerlink" title="具体的分类（实时更新）"></a>具体的分类（实时更新）</h3><ul><li><strong>Code</strong></li><li><strong>Math</strong></li><li><strong>Efficient Tools</strong></li><li><strong>Algorithm</strong></li><li><strong>Frontier and Classic Papers in AI</strong></li><li><strong>AI Core Courses</strong></li></ul><h3 id="具体的标签（实时更新）"><a href="#具体的标签（实时更新）" class="headerlink" title="具体的标签（实时更新）"></a>具体的标签（实时更新）</h3><p>见 <a href="https://xiyuanyang-code.github.io/tags/">Tags</a> 页。</p><h2 id="Several-Pages"><a href="#Several-Pages" class="headerlink" title="Several Pages"></a>Several Pages</h2><p>以下是对本博客若干基本页面的介绍：</p><ul><li><h4 id="Home"><a href="#Home" class="headerlink" title="Home"></a>Home</h4></li><li><h4 id="Intro（你现在在的地方）"><a href="#Intro（你现在在的地方）" class="headerlink" title="Intro（你现在在的地方）"></a><strong>Intro</strong>（你现在在的地方）</h4></li><li><h4 id="Archives（文章）"><a href="#Archives（文章）" class="headerlink" title="Archives（文章）"></a>Archives（文章）</h4></li><li><h4 id="Categories（分类页）"><a href="#Categories（分类页）" class="headerlink" title="Categories（分类页）"></a>Categories（分类页）</h4></li><li><h4 id="Tags（标签页）"><a href="#Tags（标签页）" class="headerlink" title="Tags（标签页）"></a>Tags（标签页）</h4></li><li><h4 id="About（关于作者）"><a href="#About（关于作者）" class="headerlink" title="About（关于作者）"></a>About（关于作者）</h4></li><li><h4 id="FAQ（一些常见的问题）"><a href="#FAQ（一些常见的问题）" class="headerlink" title="FAQ（一些常见的问题）"></a>FAQ（一些常见的问题）</h4></li><li><h4 id="Resume（Academic-CV-of-the-Author）"><a href="#Resume（Academic-CV-of-the-Author）" class="headerlink" title="Resume（Academic CV of the Author）"></a>Resume（<strong>Academic CV of the Author</strong>）</h4></li></ul><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p><a href="https://github.com/lilianweng">lilianweng (Lilian)的github主页</a></p><p> <a href="https://lilianweng.github.io/">Lil’Log（翁荔的博客）</a></p><p><a href="https://openai.com/index/the-power-of-continuous-learning/">The power of continuous learning | OpenAI</a></p><p><a href="https://github.com/xiyuanyang-code">https://github.com/xiyuanyang-code</a></p><p><a href="https://github.com/xiyuanyang-code/xiyuanyang-code.github.io">https://github.com/xiyuanyang-code/xiyuanyang-code.github.io</a></p><center><p><font size=6><b>欢迎大家常常来玩~&#128512&#128516&#128513</p></font></p></center><div/>]]></content>
    
  </entry>
  
  
  
  <entry>
    <title>Resume</title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[<style>  html, body, .markdown-body {    font-family: Georgia, sans, serif;  }</style><p><strong>My orcid</strong>: </p><p></br><h1 align="center">Welcome to Xiyuan Yang’s Coding Space!</h1></p><h3 align="center"><a href="https://git.io/typing-svg"><img src="https://readme-typing-svg.herokuapp.com?font=Fira+Code&pause=1000&random=false&width=650&lines=Keep+it+simple+and+stupid." alt="Typing SVG" /></a></h3><p align="left"> <img src="https://komarev.com/ghpvc/?username=xiyuanyang-code&label=Profile%20views&color=0e75b6&style=flat" alt="xiyuanyang-code" /> </p><h3 id="About-Me"><a href="#About-Me" class="headerlink" title="About Me"></a>About Me</h3><p>Hi there! I’m <strong>Xiyuan Yang</strong>, a passionate programmer and lifelong learner. I love exploring new technologies and solving challenging problems.</p><h3 id="Connect-with-Me"><a href="#Connect-with-Me" class="headerlink" title="Connect with Me"></a>Connect with Me</h3><ul><li><a href="https://xiyuanyang-code.github.io/">My personal Blog</a></li><li><a href="xiyuan__yang@outlook.com">My email</a></li></ul><h3 id="Currently-Learning"><a href="#Currently-Learning" class="headerlink" title="Currently Learning"></a>Currently Learning</h3><p>I’m currently diving into:</p><ul><li>Advanced C++</li><li>Machine Learning and Deep Learning</li><li>LLM reasoning and LLM agents</li></ul><h3 id="Fun-Facts"><a href="#Fun-Facts" class="headerlink" title="Fun Facts"></a>Fun Facts</h3><ul><li>🌱 I’m currently learning new programming languages.</li><li>🎯 I aim to become a full-stack developer. (Maybe?)</li><li>📚 I love reading tech blogs and books.</li></ul><p align="left"> <a href="https://github.com/ryo-ma/github-profile-trophy"><img src="https://github-profile-trophy.vercel.app/?username=xiyuanyang-code" alt="xiyuanyang-code" /></a> </p><h3 id="Languages-and-Tools"><a href="#Languages-and-Tools" class="headerlink" title="Languages and Tools"></a>Languages and Tools</h3><div style="text-align: center;">    <a href="https://en.wikipedia.org/wiki/C_(programming_language)" target="_blank" rel="noreferrer">        <img src="https://raw.githubusercontent.com/devicons/devicon/master/icons/c/c-original.svg" alt="c" width="40" height="40"/>    </a>    <a href="https://www.w3schools.com/cpp/" target="_blank" rel="noreferrer">        <img src="https://raw.githubusercontent.com/devicons/devicon/master/icons/cplusplus/cplusplus-original.svg" alt="cplusplus" width="40" height="40"/>    </a>    <a href="https://www.w3schools.com/html/" target="_blank" rel="noreferrer">        <img src="https://raw.githubusercontent.com/devicons/devicon/master/icons/html5/html5-original.svg" alt="html" width="40" height="40"/>    </a>    <a href="https://www.python.org" target="_blank" rel="noreferrer">        <img src="https://raw.githubusercontent.com/devicons/devicon/master/icons/python/python-original.svg" alt="python" width="40" height="40"/>    </a>    <a href="https://www.linux.org/" target="_blank" rel="noreferrer">    <img src="https://raw.githubusercontent.com/devicons/devicon/master/icons/linux/linux-original.svg" alt="linux" width="40" height="40"/></a></br></br><div style="text-align: center;">    <img src="https://github-readme-stats.vercel.app/api?username=xiyuanyang-code&show_icons=true&locale=en" alt="xiyuanyang-code" /></div>]]></content>
    
  </entry>
  
  
  
</search>
