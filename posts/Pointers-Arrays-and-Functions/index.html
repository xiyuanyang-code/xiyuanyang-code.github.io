

<!DOCTYPE html>
<html lang="en" >



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/YXY.png">
  <link rel="icon" href="/img/YXY.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#c30000">
  <meta name="author" content="Xiyuan Yang">
  <meta name="keywords" content="Code">
  
    <meta name="description" content="This article will primarily focus on pointers, delving deep into the essence of memory and, based on this foundation, exploring some advanced functionalities of pointers.">
<meta property="og:type" content="article">
<meta property="og:title" content="Pointers-Arrays-and-Functions">
<meta property="og:url" content="https://xiyuanyang-code.github.io/posts/Pointers-Arrays-and-Functions/index.html">
<meta property="og:site_name" content="Xiyuan Yang&#39;s Blog">
<meta property="og:description" content="This article will primarily focus on pointers, delving deep into the essence of memory and, based on this foundation, exploring some advanced functionalities of pointers.">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://xiyuanyang-code.github.io/img/cover/pointers.png">
<meta property="article:published_time" content="2024-12-14T15:45:20.000Z">
<meta property="article:modified_time" content="2025-02-17T11:46:46.484Z">
<meta property="article:author" content="Xiyuan Yang">
<meta property="article:tag" content="tutorial">
<meta property="article:tag" content="C&#x2F;C++">
<meta property="article:tag" content="Finished">
<meta property="article:tag" content="pointers">
<meta property="article:tag" content="functions">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://xiyuanyang-code.github.io/img/cover/pointers.png">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>Pointers-Arrays-and-Functions - Xiyuan Yang&#39;s Blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"xiyuanyang-code.github.io","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":50,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":"❡"},"progressbar":{"enable":true,"height_px":3,"color":"red","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":2},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":"L7r0uGb0fafbzNvmBADCMH42-gzGzoHsz","app_key":"2Lr1fQ2rjhwRiUrDx0VOQyUm","server_url":null,"path":"window.location.pathname","ignore_local":true},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  

  

  

  
    
  



  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Xiyuan Yang&#39;s Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>Home</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/above/" target="_self">
                <i class="iconfont icon-bookmark-fill"></i>
                <span>Intro</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>Archive</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>Category</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>Tag</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>About</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/resume/" target="_self">
                <i class="iconfont icon-code"></i>
                <span>Resume</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/FAQ/" target="_self">
                <i class="iconfont icon-bug"></i>
                <span>FAQ</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/" target="_self">
                <i class="iconfont icon-link-fill"></i>
                <span>Links</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/place.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Pointers-Arrays-and-Functions"></span>
          
        </div>

        
          
  <div class="mt-3">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-author" aria-hidden="true"></i>
        Xiyuan Yang
      </span>
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-12-14 23:45" pubdate>
          December 14, 2024 pm
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          11k words
        
      </span>
    

    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> views
        </span>
        

      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar category-bar" style="margin-right: -1rem">
    





<div class="category-list">
  
  
    
    
    
    <div class="category row nomargin-x">
      <a class="category-item 
          list-group-item category-item-action col-10 col-md-11 col-xm-11" title="Code"
        id="heading-ca0dbad92a874b2f69b549293387925e" role="tab" data-toggle="collapse" href="#collapse-ca0dbad92a874b2f69b549293387925e"
        aria-expanded="true"
      >
        Code
        <span class="list-group-count">(14)</span>
        <i class="iconfont icon-arrowright"></i>
      </a>
      
      <div class="category-collapse collapse show" id="collapse-ca0dbad92a874b2f69b549293387925e"
           role="tabpanel" aria-labelledby="heading-ca0dbad92a874b2f69b549293387925e">
        
        
          
  <div class="category-post-list">
    
    
      
      
        <a href="/posts/C-plus-plus-Primer-Plus-tutorial/" title="C-Plus-Plus-Primer-Plus-Tutorial"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">C-Plus-Plus-Primer-Plus-Tutorial</span>
        </a>
      
    
      
      
        <a href="/posts/Introduction-to-OOP/" title="Introduction-to-OOP"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">Introduction-to-OOP</span>
        </a>
      
    
      
      
        <a href="/posts/Dynamic-Memory-and-Classes/" title="Dynamic-Memory-and-Classes"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">Dynamic-Memory-and-Classes</span>
        </a>
      
    
      
      
        <a href="/posts/Class-Inheritance/" title="Class-Inheritance"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">Class-Inheritance</span>
        </a>
      
    
      
      
        <a href="/posts/Code-Reuse-in-OOP/" title="Code-Reuse-in-OOP"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">Code-Reuse-in-OOP</span>
        </a>
      
    
      
      
        <a href="/posts/Exception-Handling-in-C-plus-plus/" title="Exception-Handling-in-C-Plus-Plus"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">Exception-Handling-in-C-Plus-Plus</span>
        </a>
      
    
      
      
        <a href="/posts/Pointers-Arrays-and-Functions/" title="Pointers-Arrays-and-Functions"
           class="list-group-item list-group-item-action
           active">
          <span class="category-post">Pointers-Arrays-and-Functions</span>
        </a>
      
    
      
      
        <a href="/posts/Input-and-Output-in-C-plus-plus/" title="Input-and-Output-in-C-Plus-Plus"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">Input-and-Output-in-C-Plus-Plus</span>
        </a>
      
    
      
      
        <a href="/posts/Jotting-References-and-Encapsulation-in-OOP/" title="Jotting-References-and-Encapsulation-in-OOP"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">Jotting-References-and-Encapsulation-in-OOP</span>
        </a>
      
    
      
      
        <a href="/posts/Python-tutorial/" title="Python-Tutorial"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">Python-Tutorial</span>
        </a>
      
    
      
      
        <a href="/posts/Python-cheatsheet/" title="Python-Cheatsheet"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">Python-Cheatsheet</span>
        </a>
      
    
      
      
        <a href="/posts/Python-advanced-File-Management/" title="Python-Advanced-File-Management"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">Python-Advanced-File-Management</span>
        </a>
      
    
      
      
        <a href="/posts/Python-Update-Learning/" title="Python-Update-Learning"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">Python-Update-Learning</span>
        </a>
      
    
      
      
        <a href="/posts/Regular-Expression/" title="Regular-Expression"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">Regular-Expression</span>
        </a>
      
    
  </div>

        
      </div>
    </div>
  
</div>


  </aside>


    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">Pointers-Arrays-and-Functions</h1>
            
            
              <div class="markdown-body">
                
                <style>
  html, body, .markdown-body {
    font-family: Georgia, sans, serif;
  }
</style>

<h1 id="函数、数组和指针"><a href="#函数、数组和指针" class="headerlink" title="函数、数组和指针"></a>函数、数组和指针</h1><p>封面来源：<a target="_blank" rel="noopener" href="https://knowyourmeme.com/photos/2214241-two-soyjaks-pointing">Pointers</a></p>
<blockquote>
<p>对不起真的太好笑了哈哈哈哈哈哈</p>
</blockquote>
<h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>在C++中，函数，数组和指针是三个非常重要的概念，他们是C++实现许多高级功能（例如STL，OOP）的基石。同时，这三者之间又有着密不可分的联系。本文将主要从<strong>指针</strong>的角度出发，深入探究<strong>内存</strong>的本质，并在此基础之上探寻一些指针的高级功能。</p>
<blockquote>
<p>In C++, functions, arrays, and pointers are three essential concepts that serve as the cornerstone for implementing many advanced features, such as the Standard Template Library (STL) and Object-Oriented Programming (OOP). At the same time, these three elements are intricately interconnected. This article will primarily focus on <strong>pointers</strong>, delving deep into the essence of <strong>memory</strong> and, based on this foundation, exploring some advanced functionalities of pointers.</p>
</blockquote>
<h2 id="Before-the-article-begins"><a href="#Before-the-article-begins" class="headerlink" title="Before the article begins"></a>Before the article begins</h2><p>在文章开始前，请务必确保你已经掌握了<strong>指针，数组，函数三者分别的基本用法和一些初步的内存管理的知识</strong>。本文对相关基础代码不再过多赘述。</p>
<h2 id="Table-of-Contents"><a href="#Table-of-Contents" class="headerlink" title="Table of Contents"></a>Table of Contents</h2><ul>
<li>Pointers and Memories</li>
<li>Types of Pointers matters</li>
<li>Array of an Pointer and Pointer of an array</li>
<li>Rvalue</li>
<li>parameters in the main function</li>
<li>Lambda expression</li>
<li>Smart Pointer</li>
</ul>
<h2 id="Pointers-and-Memories"><a href="#Pointers-and-Memories" class="headerlink" title="Pointers and Memories"></a>Pointers and Memories</h2><p>在这一节，我们将从内存的视角重新认识指针。</p>
<p><strong>内存是什么？</strong>通俗来说，内存就是计算机<strong>存储数据的地方</strong>（这个定义非常的不严谨，甚至是一派胡言。但是这篇文章不会涉及硬件的太多知识，大家只要认识到这一步就行了）。第二个问题，<strong>如何存储数据？</strong>我们知道，数据存储的最小单元是<strong>位（bit）</strong>，代表一个二进制位。因此，我们会把内存进行<strong>编码</strong>，每一个bit都会拿到自己的编号，代表自己的具体位置。</p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> a=<span class="hljs-number">100</span>;<br>    <span class="hljs-type">int</span> *p=&amp;a;<br>    cout&lt;&lt;p;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//输出结果：0x61fe14(变量a的值，变量a的内存块第一个bit的编号，指针p所储存的值)</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>内存的硬件知识有兴趣的可以看这篇 <a target="_blank" rel="noopener" href="https://blog.csdn.net/hellojoy/article/details/102933809">博客</a>，讲的比较清楚。</p>
</blockquote>
<p>接下来，回到指针。指针存储了一个<strong>变量</strong>的<strong>地址（内存）</strong>，这是指针的功能。但是，指针本身其实<strong>也是一种变量</strong>，在内存中有相对应的地址。一般来说，在64位的系统上，指针在内存中占<strong>8个字节（64bit）</strong>，在大小上和<code>unsigned long long</code>类型是一样的。（不过指针的值是十六进制的存储方式）</p>
<div class="note note-success">
            <p><strong>因此，指针也是一种数据类型！和int，double，char等等一样，在内存中占一定空间，并且储存对应的值。（只不过指针储存的值就是内存的编号罢了）</strong></p>
          </div>

<h2 id="Types-of-pointers-matters"><a href="#Types-of-pointers-matters" class="headerlink" title="Types of pointers matters"></a>Types of pointers matters</h2><p>指针有着<strong>解引用</strong>的操作，这是如何实现的？</p>
<p>我们来看下面的代码示范：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> num=<span class="hljs-number">4758843763784</span>;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span>* p1=&amp;num;<br>    <span class="hljs-type">int</span>* p2=(<span class="hljs-type">int</span>*)p1;<br>    <span class="hljs-type">double</span>* p3=(<span class="hljs-type">double</span>*)p1;<br>    <span class="hljs-type">char</span>* p4=(<span class="hljs-type">char</span>*)p2;<br>    <span class="hljs-type">float</span>* p5=(<span class="hljs-type">float</span>*)p1;<br>    <span class="hljs-comment">//对指针进行强制类型转换</span><br>    cout&lt;&lt;<span class="hljs-string">&quot;the size of each pointers:&quot;</span>&lt;&lt;endl;<br>    cout&lt;&lt;<span class="hljs-built_in">sizeof</span>(p1)&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;<span class="hljs-built_in">sizeof</span>(p2)&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;<span class="hljs-built_in">sizeof</span>(p3)&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;<span class="hljs-built_in">sizeof</span>(p4)&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;<span class="hljs-built_in">sizeof</span>(p5)&lt;&lt;endl;<br>    cout&lt;&lt;<span class="hljs-string">&quot;The memory:&quot;</span>&lt;&lt;endl;<br>    cout&lt;&lt;p1&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;p2&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;p3&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;(<span class="hljs-type">void</span>*)p4&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;p5&lt;&lt;endl;<br>    <span class="hljs-comment">//强制类型转换字符指针，否则会输出实际字符的值。</span><br>    cout&lt;&lt;<span class="hljs-string">&quot;Dereferencing Various Pointers&quot;</span>&lt;&lt;endl;<br>    cout&lt;&lt;*p1&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;*p2&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;*p3&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;*p4&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;*p5&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">the</span> size of each pointers:<br><span class="hljs-attribute">8</span> <span class="hljs-number">8</span> <span class="hljs-number">8</span> <span class="hljs-number">8</span> <span class="hljs-number">8</span><br><span class="hljs-attribute">The</span> memory:<br><span class="hljs-attribute">0x61fdf0</span> <span class="hljs-number">0</span>x61fdf0 <span class="hljs-number">0</span>x61fdf0 <span class="hljs-number">0</span>x61fdf0 <span class="hljs-number">0</span>x61fdf0<br><span class="hljs-attribute">Dereferencing</span> Various Pointers<br><span class="hljs-attribute">4758843763784</span> <span class="hljs-number">19999816</span> <span class="hljs-number">2</span>.<span class="hljs-number">35118</span>e-<span class="hljs-number">311</span> H <span class="hljs-number">3</span>.<span class="hljs-number">25415</span>e-<span class="hljs-number">38</span><br></code></pre></td></tr></table></figure>

<p>这个代码告诉了我们以下几点：</p>
<ul>
<li>指针在内存中存储的大小和<strong>指针指向数据类型的大小无关</strong>。（这一点很重要，稍后会解释）</li>
<li><strong>指向不同数据类型的指针，对于同一块内存解引用所得到的是完全不同的值</strong>！</li>
</ul>
<p>换句话说，指针的类型不会改变指针在内存中的存储和指针的值，只会影响指针在<strong>解引用时</strong>对内存的解释（即如何将0&#x2F;1的比特位转换成有效数据）。</p>
<p>因此，<strong>Types of pointers matters！</strong>实际上，如果不进行强制类型的转换，编译器面对不匹配的指针类型的时候也会报错。</p>
<p>以上两个章节是对指针和内存一些基础知识的回顾，接下来，我们将介绍<strong>数组，指针和函数</strong>三者在C++中一些高级的操作。</p>
<h2 id="Advanced-Technique-1-Array-of-pointers-and-Pointer-to-an-array"><a href="#Advanced-Technique-1-Array-of-pointers-and-Pointer-to-an-array" class="headerlink" title="Advanced Technique 1  Array of pointers and Pointer to an array"></a>Advanced Technique 1  Array of pointers and Pointer to an array</h2><p><strong>Definition</strong></p>
<p>数组指针：数组指针是<strong>指向数组的指针</strong>。</p>
<p>指针数组：是一个数组，数组的每个元素都是<strong>指针</strong>。</p>
<p>定义还是非常直白的，<strong>数组指针是指针，指针数组是数组。</strong></p>
<p><strong>Usage</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">int</span> (*ptr)[size];<br><span class="hljs-comment">//声明一个数组指针</span><br></code></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> *ptr[size];<br><span class="hljs-comment">//声明一个指针数组</span><br></code></pre></td></tr></table></figure>

<div class="note note-warning">
            <p>在 C++ 中，<code>*</code> 运算符用于声明指针，而 <code>[]</code> 运算符用于声明数组。因为<strong>运算符的优先级不同</strong>（<code>[]</code> 运算符的优先级高于<code>*</code> 运算符），直接写 <code>*ptr[size]</code> 会让编译器理解为声明一个数组 <code>ptr</code>，每个元素是一个指向 <code>type</code> 的指针，而不是声明一个指向数组的指针。</p>
          </div>

<p><strong>使用方法</strong></p>
<p>如果是数组指针：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> arr[<span class="hljs-number">3</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>    <span class="hljs-built_in">int</span> (*ptr)[<span class="hljs-number">3</span>] = &amp;arr;  <span class="hljs-comment">// ptr 是指向包含 3 个整数的数组的指针</span><br><br>    <span class="hljs-comment">// 访问数组元素</span><br>    std::cout &lt;&lt; (*ptr)[<span class="hljs-number">0</span>] &lt;&lt; std::endl;  <span class="hljs-comment">// 输出 1</span><br>    std::cout &lt;&lt; (*ptr)[<span class="hljs-number">1</span>] &lt;&lt; std::endl;  <span class="hljs-comment">// 输出 2</span><br>    std::cout &lt;&lt; (*ptr)[<span class="hljs-number">2</span>] &lt;&lt; std::endl;  <span class="hljs-comment">// 输出 3</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在这个例子中，<code>ptr</code> 是指向一个包含 3 个整数的数组的指针。可以通过 <code>(*ptr)[i]</code> 的方式来访问数组元素。</p>
<p>如果是指针数组：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">1</span>, b = <span class="hljs-number">2</span>, c = <span class="hljs-number">3</span>;<br>    <span class="hljs-type">int</span> *ptr[<span class="hljs-number">3</span>];  <span class="hljs-comment">// ptr 是一个指针数组，包含 3 个指向整数的指针</span><br><br>    ptr[<span class="hljs-number">0</span>] = &amp;a;<br>    ptr[<span class="hljs-number">1</span>] = &amp;b;<br>    ptr[<span class="hljs-number">2</span>] = &amp;c;<br><br>    <span class="hljs-comment">// 访问数组元素</span><br>    std::cout &lt;&lt; *ptr[<span class="hljs-number">0</span>] &lt;&lt; std::endl;  <span class="hljs-comment">// 输出 1</span><br>    std::cout &lt;&lt; *ptr[<span class="hljs-number">1</span>] &lt;&lt; std::endl;  <span class="hljs-comment">// 输出 2</span><br>    std::cout &lt;&lt; *ptr[<span class="hljs-number">2</span>] &lt;&lt; std::endl;  <span class="hljs-comment">// 输出 3</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在这个例子中，<code>ptr</code> 是一个包含 3 个指针的数组，每个指针指向不同的整数变量。通过 <code>*ptr[i]</code> 可以访问指针所指向的值。</p>
<p><strong>Applications</strong></p>
<p><strong>数组指针和指针数组都可以用来操作二维数组</strong>。</p>
<p>假设你有一个二维数组 <code>arr[3][4]</code>，它有 3 行 4 列，你可以通过以下两种方式来使用指针来访问它。</p>
<p>使用数组指针：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">int</span> (*ptr)[<span class="hljs-number">4</span>] = arr;  <span class="hljs-comment">// ptr 是指向数组中每一行的指针</span><br></code></pre></td></tr></table></figure>

<p>在这种情况下，<code>ptr</code> 是指向数组中每一行的指针。你可以通过 <code>ptr[i]</code> 来访问第 <code>i</code> 行的数据。</p>
<p>使用指针数组：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> *ptr[<span class="hljs-number">3</span>];  <span class="hljs-comment">// ptr 是一个指针数组，包含 3 个指向整数的指针</span><br>ptr[<span class="hljs-number">0</span>] = arr[<span class="hljs-number">0</span>];  <span class="hljs-comment">// ptr[0] 指向 arr 的第一行</span><br>ptr[<span class="hljs-number">1</span>] = arr[<span class="hljs-number">1</span>];  <span class="hljs-comment">// ptr[1] 指向 arr 的第二行</span><br>ptr[<span class="hljs-number">2</span>] = arr[<span class="hljs-number">2</span>];  <span class="hljs-comment">// ptr[2] 指向 arr 的第三行</span><br></code></pre></td></tr></table></figure>

<p>在这种情况下，<code>ptr</code> 是一个数组，每个元素都是一个指向数组行的指针。你可以通过 <code>ptr[i][j]</code> 来访问数组中的元素。</p>
<div class="note note-warning">
            <p><strong>使用二级指针不可以直接指向一个二维数组！（因为类型并不匹配）</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> ** testptr=<span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-type">int</span> a[<span class="hljs-number">5</span>][<span class="hljs-number">5</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br>    testptr=a;  <span class="hljs-comment">//INVALID!</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">会报错：</span><br><span class="hljs-comment">testcode_1.cpp: In function &#x27;int main()&#x27;:</span><br><span class="hljs-comment">testcode_1.cpp:40:13: error: cannot convert &#x27;int [5][5]&#x27; to &#x27;int**&#x27; in assignment</span><br><span class="hljs-comment">     testptr=a;</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> ** testptr=<span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-built_in">int</span> (*testptr2)[<span class="hljs-number">5</span>]=<span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-type">int</span> a[<span class="hljs-number">5</span>][<span class="hljs-number">5</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br>    testptr2=a;<br>    cout&lt;&lt;*testptr2&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;**testptr2;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">程序可以正常运行：</span><br><span class="hljs-comment">输出结果：0x61fd90 0</span><br><span class="hljs-comment">解释：*testptr2代表数组指针的首元素的值，是一个指向int的指针，再解引用一次才得到a[0][0]的值。</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>但是可以使用<strong>动态内存分配</strong>的方式，也可以让一个二级指针与二维数组相关联。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> rows = <span class="hljs-number">3</span>;<br>    <span class="hljs-type">int</span> cols = <span class="hljs-number">4</span>;<br><br>    <span class="hljs-comment">// 使用 new 动态分配二维数组</span><br>    <span class="hljs-type">int</span> **arr = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>*[rows];  <span class="hljs-comment">// 创建一个指针数组，每个元素指向一行</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; rows; i++) &#123;<br>        arr[i] = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[cols];  <span class="hljs-comment">// 每一行分配 cols 个 int</span><br>    &#125;<br><br>    <span class="hljs-comment">// 给二维数组赋值</span><br>    arr[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    arr[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">2</span>;<br>    arr[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>] = <span class="hljs-number">3</span>;<br>    arr[<span class="hljs-number">0</span>][<span class="hljs-number">3</span>] = <span class="hljs-number">4</span>;<br><br>    arr[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">5</span>;<br>    arr[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">6</span>;<br>    arr[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>] = <span class="hljs-number">7</span>;<br>    arr[<span class="hljs-number">1</span>][<span class="hljs-number">3</span>] = <span class="hljs-number">8</span>;<br><br>    arr[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">9</span>;<br>    arr[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">10</span>;<br>    arr[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>] = <span class="hljs-number">11</span>;<br>    arr[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>] = <span class="hljs-number">12</span>;<br><br>    <span class="hljs-comment">// 使用二级指针访问元素</span><br>    std::cout &lt;&lt; arr[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] &lt;&lt; std::endl;  <span class="hljs-comment">// 输出 1</span><br>    std::cout &lt;&lt; arr[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>] &lt;&lt; std::endl;  <span class="hljs-comment">// 输出 7</span><br>    std::cout &lt;&lt; arr[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>] &lt;&lt; std::endl;  <span class="hljs-comment">// 输出 12</span><br><br>    <span class="hljs-comment">// 释放内存</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; rows; i++) &#123;<br>        <span class="hljs-keyword">delete</span>[] arr[i];  <span class="hljs-comment">// 释放每行的内存</span><br>    &#125;<br>    <span class="hljs-keyword">delete</span>[] arr;  <span class="hljs-comment">// 释放指针数组</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>
          </div>

<h2 id="Advanced-Technique-2-Rvalue"><a href="#Advanced-Technique-2-Rvalue" class="headerlink" title="Advanced Technique 2 Rvalue"></a>Advanced Technique 2 Rvalue</h2><p><strong>左值（Lvalue）</strong>：可以表示一个对象的内存位置，并且可以获取其地址。通常是变量、对象或数组元素。</p>
<p><strong>右值（Rvalue）</strong>：通常是临时对象、字面值或表达式的结果。右值不能获取地址，代表的是一个不再需要的值。</p>
<p>例如在<code>x=y+z</code>这个表达式中，x,y,z都是变量（左值），在内存中有对应的空间，可以进行取址运算，但是编译器会先计算<code>y+z</code>的值（<strong>这是一个表达式是右值</strong>），将这个值赋给x后，y+z的结果就消失了。</p>
<p>C++3 中引用类型的变量只能是左值，除非声明的是 const 的引用，因而称之为左值引用。而C++11 引入了右值引用。右值引用以<code>&amp;&amp;</code>来表示，它的初值只能是一个将要被销毁的对象。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> x = <span class="hljs-number">10</span>; <br><span class="hljs-type">int</span> &amp;&amp;y = x + <span class="hljs-number">9</span>; <br><span class="hljs-type">int</span> &amp;&amp;z = <span class="hljs-number">8</span> * <span class="hljs-number">9</span> % <span class="hljs-number">4</span>;<br></code></pre></td></tr></table></figure>

<p>由于<strong>右值引用只能绑定到临时对象</strong>，即该对象将要被销毁，这意味着<strong>右值引用的变量可以接管所引用的对象的资源</strong>。定义 y 和 z 时都没有分配空间，而是接管了存储右边表达式计算结果的临时变量的空间。 y 接管了存放 x+9 结果值的临时变量的空间。 z 接管了存放 8 * 9 % 4 结果值的临时变量的空间。 </p>
<blockquote>
<p>右值引用相当于给一个即将要消亡的值续了一口命让他一直存在。</p>
</blockquote>
<p>通过右值引用，C++ 能够实现<strong>移动语义</strong>，即当对象的资源不再需要时，可以直接将资源“移动”到另一个对象中，而不是进行昂贵的拷贝操作。例如，<code>std::vector</code>和<code>std::string</code>等容器类会利用右值引用来避免不必要的内存分配和数据复制。</p>
<p><strong>移动语义的核心思想是避免不必要的拷贝</strong>。例如，当我们将一个临时对象传递给容器时，容器可以通过移动构造而不是拷贝构造来获取该对象的资源。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LargeObject</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span>* data;<br>    <br>    <span class="hljs-built_in">LargeObject</span>(<span class="hljs-type">int</span> value) : <span class="hljs-built_in">data</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(value)) &#123;&#125;<br>    ~<span class="hljs-built_in">LargeObject</span>() &#123; <span class="hljs-keyword">delete</span> data; &#125;<br>    <br>    <span class="hljs-comment">// 移动构造函数</span><br>    <span class="hljs-built_in">LargeObject</span>(LargeObject&amp;&amp; other) <span class="hljs-keyword">noexcept</span> : <span class="hljs-built_in">data</span>(other.data) &#123;<br>        other.data = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 移动赋值运算符</span><br>    LargeObject&amp; <span class="hljs-keyword">operator</span>=(LargeObject&amp;&amp; other) <span class="hljs-keyword">noexcept</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;other) &#123;<br>            <span class="hljs-keyword">delete</span> data;<br>            data = other.data;<br>            other.data = <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    vector&lt;LargeObject&gt; vec;<br>    vec.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">LargeObject</span>(<span class="hljs-number">42</span>));  <span class="hljs-comment">// 移动构造而非拷贝构造</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<blockquote>
<p>简单来说，赋值构造函数是将对象的所有值拷贝一份赋给一个新的对象（无论是浅拷贝还是深拷贝），如果我只是希望实现值的移动，我还需要将原来的对象删除，这样的效率十分低下。有了移动语义（移动构造函数），我们便可以实现<strong>不拷贝直接实现值的转移</strong>。</p>
</blockquote>
<div class="note note-primary">
            <h3 id="const引用和右值引用的区别"><a href="#const引用和右值引用的区别" class="headerlink" title="const引用和右值引用的区别"></a><code>const</code>引用和右值引用的区别</h3><p><strong>什么是 <code>const</code> 引用？</strong></p><p><code>const</code> 引用是一种引用类型，它允许<strong>你通过引用来访问对象，但不允许修改对象的值</strong>。通过 <code>const</code> 引用，你可以<strong>避免复制对象，同时确保引用的对象不会被修改</strong>。这通常用于传递大对象或需要确保数据不被修改的场合。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> Type&amp; ref = object;<br></code></pre></td></tr></table></figure><p>这里的 <code>const Type&amp;</code> 表示一个常量引用，<code>object</code> 可以是左值或右值。</p><blockquote><p><code>const</code>引用经常出现在函数参数的传递过程中，即保证了<strong>高效</strong>，又保证了安全性。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printValue</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; value)</span> </span>&#123;<br>    std::cout &lt;&lt; value &lt;&lt; std::endl;  <span class="hljs-comment">// 不能修改 value，因为它是 const 引用</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">10</span>;<br>    <span class="hljs-built_in">printValue</span>(x);  <span class="hljs-comment">// 传递左值</span><br>    <span class="hljs-built_in">printValue</span>(<span class="hljs-number">20</span>); <span class="hljs-comment">// 传递右值</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong><code>const</code> 引用与右值引用的区别：</strong></p><ol><li><strong><code>const</code> 引用</strong>：</li></ol><ul><li><strong>允许绑定左值和右值</strong>：<code>const</code> 引用可以<strong>绑定到左值或右值。对于右值，它的作用是将其延长生命周期，保证在函数中可以安全地使用。</strong>当我们希望通过引用传递一个右值并延长其生命周期时。通过 <code>const</code> 引用绑定到右值，可以避免不必要的拷贝，同时又不会修改该对象。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">processConstRef</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; vec)</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Size of vector (const ref): &quot;</span> &lt;&lt; vec.<span class="hljs-built_in">size</span>() &lt;&lt; std::endl;<br>    <span class="hljs-comment">// vec.push_back(4); // 错误！不能修改 const 引用绑定的对象</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 创建一个右值（临时对象）</span><br>    <span class="hljs-built_in">processConstRef</span>(std::vector&lt;<span class="hljs-type">int</span>&gt;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;);  <span class="hljs-comment">// 这里传递的是一个右值</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">输出：Size of vector (const ref): 3</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p><code>std::vector&lt;int&gt;{1, 2, 3}</code> 是一个 <strong>右值</strong>，它是一个临时对象。我们通过 <code>const std::vector&lt;int&gt;&amp;</code> 将右值传递给 <code>processConstRef</code> 函数，<code>const</code> 确保了我们在函数内部不能修改这个对象。在 <code>processConstRef</code> 中，<code>vec</code> 是一个 <strong><code>const</code> 引用</strong>，它绑定到这个临时对象上，并延长了这个临时对象的生命周期。这样，直到 <code>processConstRef</code> 函数结束，右值才会被销毁。</p><blockquote><p>如果删除const关键词，会有报错：<code>cannot bind non-const lvalue reference of type &#39;std::vector&lt;int&gt;&amp;&#39; to an rvalue of type &#39;std::vector&lt;int&gt;&#39;</code></p></blockquote><ol start="2"><li><strong>右值引用（<code>Type&amp;&amp;</code>）</strong>：</li></ol><ul><li><strong>只能绑定到右值</strong>：右值引用是 C++11 引入的，它主要用于“移动语义”，只能绑定到右值（例如临时对象、函数返回值等）。</li><li><strong>允许移动资源</strong>：右值引用允许转移对象的资源，避免不必要的复制（例如通过 <code>std::move</code>），提高性能。</li><li><strong>可以修改原对象</strong>：通过右值引用，我们可以修改被移动的对象（例如，置为空）。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">processConstRef</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; vec)</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Size of vector (const ref): &quot;</span> &lt;&lt; vec.<span class="hljs-built_in">size</span>() &lt;&lt; std::endl;<br>    <span class="hljs-comment">// vec.push_back(4); // 错误！不能修改 const 引用绑定的对象</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">processRvalueRef</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt;&amp;&amp; vec)</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Size of vector (rvalue ref): &quot;</span> &lt;&lt; vec.<span class="hljs-built_in">size</span>() &lt;&lt; std::endl;<br>    vec.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">4</span>);  <span class="hljs-comment">// 可以修改 vec，因为它是右值引用</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; vec1 = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br><br>    <span class="hljs-comment">// 使用 const 引用</span><br>    <span class="hljs-built_in">processConstRef</span>(vec1);  <span class="hljs-comment">// 传递左值</span><br><br>    <span class="hljs-comment">// 使用右值引用</span><br>    <span class="hljs-built_in">processRvalueRef</span>(std::<span class="hljs-built_in">move</span>(vec1));  <span class="hljs-comment">// 传递右值，vec1 资源被“移动”</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;vec1 size after move: &quot;</span> &lt;&lt; vec<span class="hljs-number">1.</span><span class="hljs-built_in">size</span>() &lt;&lt; std::endl;  <span class="hljs-comment">// vec1 现在为空</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">Size of vector (const ref): 3</span><br><span class="hljs-comment">Size of vector (rvalue ref): 3</span><br><span class="hljs-comment">vec1 size after move: 0</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><ol><li><strong><code>const&amp;</code> 引用</strong>：<code>processConstRef</code> 函数使用了 <code>const</code> 引用，它可以接收左值或右值，但无法修改 <code>vec</code> 的内容。</li><li><strong>右值引用（<code>&amp;&amp;</code>）</strong>：<code>processRvalueRef</code> 函数使用了右值引用，它只能接收右值，并且**可以修改 <code>vec</code>**（在本例中就是将数据“移动”到 <code>processRvalueRef</code>，并且通过 <code>push_back</code> 添加数据）。</li></ol><p><strong>总结一下，const引用和右值引用都可以绑定到右值上，但是两者的具体功能是不一样的：const引用重点在<code>const</code>上，而右值引用主要在移动语义等方面提供了更高的效率（避免了不必要的复制过程）。</strong></p>
          </div>

<h2 id="Advanced-Technique-3-parameters-in-the-main-function"><a href="#Advanced-Technique-3-parameters-in-the-main-function" class="headerlink" title="Advanced Technique 3 parameters in the main function"></a>Advanced Technique 3 parameters in the main function</h2><p>在我们之前写的C++程序中，main函数是<strong>没有参数且返回值为0</strong>的，程序能够正常退出。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cout&lt;&lt;<span class="hljs-string">&quot;Hello world&quot;</span>&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-comment">//如果更改为return 1,那么程序仍能运行，但是会显示异常退出。</span><br></code></pre></td></tr></table></figure>

<p><strong>带参数的 <code>main</code> 函数</strong>：它接受命令行参数，允许程序在启动时接收外部输入。这种形式在处理用户输入或命令行参数时非常有用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span> </span>&#123;<br>    <span class="hljs-comment">// 程序代码</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<ol>
<li>**<code>argc</code>**：<code>argc</code> 是 <strong>argument count</strong>（参数计数）的缩写，表示传递给程序的命令行参数的个数。它的值至少为 1，因为程序名称本身也算作一个参数。</li>
<li>**<code>argv</code>**：<code>argv</code> 是 <strong>argument vector</strong>（参数向量）的缩写，它是一个指向字符指针数组的指针，数组的每个元素都是一个命令行参数（字符串）。<code>argv[0]</code> 通常是程序的名称，<code>argv[1]</code>、<code>argv[2]</code> 等依次是传递给程序的其他参数。</li>
</ol>
<p>例如下面的程序：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;程序名称: &quot;</span> &lt;&lt; argv[<span class="hljs-number">0</span>] &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;传递的参数个数: &quot;</span> &lt;&lt; argc - <span class="hljs-number">1</span> &lt;&lt; endl;  <span class="hljs-comment">// 不算程序名称</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;传递的参数: &quot;</span>;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; argc; ++i) &#123;  <span class="hljs-comment">// 从1开始，跳过程序名称</span><br>        cout &lt;&lt; argv[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<ul>
<li>**<code>argv[0]</code>**：程序名称，通常是执行程序时给出的文件名（例如 <code>&quot;./my_program&quot;</code>）。</li>
<li>**<code>argv[1]</code>、<code>argv[2]</code>**：这些是用户传递给程序的额外命令行参数。</li>
<li>**<code>argc</code>**：命令行参数的个数。对于上述程序，<code>argc</code> 至少为 1，因为 <code>argv[0]</code> 是程序名称。</li>
</ul>
<p><strong>编译与运行</strong>：</p>
<p>假设程序的文件名为 <code>program.cpp</code>，你可以按以下方式编译和运行它：</p>
<ol>
<li><p>编译程序：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">g++ program.cpp -o program<br></code></pre></td></tr></table></figure>
</li>
<li><p>运行程序，并传递一些命令行参数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./program arg1 arg2 arg3<br></code></pre></td></tr></table></figure>

<p>输出将是：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">程序名称: ./program</span><br><span class="hljs-section">传递的参数个数: 3</span><br><span class="hljs-section">传递的参数: arg1 arg2 arg3</span><br></code></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p>在一些第三方库的使用中，带参数的main函数是非常强大的。</p>
</blockquote>
<h2 id="Advanced-Technique-4-Function-Pointer"><a href="#Advanced-Technique-4-Function-Pointer" class="headerlink" title="Advanced Technique 4 Function Pointer"></a>Advanced Technique 4 Function Pointer</h2><div class="note note-info">
            <p><strong>问题引入：函数在内存中有自己的地址？</strong></p><p><strong>函数在内存中是有地址的</strong>。每个函数在程序加载到内存时，都会被分配一个唯一的内存地址，通常这个地址是指向函数代码开始位置的地址。在 C++ 中，我们可以通过<strong>函数指针</strong>来获取这个地址，从而间接地访问和调用函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myFunction</span><span class="hljs-params">()</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Hello, this is myFunction!&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cout &lt;&lt; (<span class="hljs-type">void</span>*)myFunction &lt;&lt; endl;  <span class="hljs-comment">// 输出函数的地址</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>函数名</strong>和数组名类似，代表了函数在内存中的地址。</p><blockquote><p>这里用到<code>(void*)</code>进行指针的强制类型转换，因为函数指针在cout中会被隐式转换成布尔值（即输出1）。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myFunction</span><span class="hljs-params">()</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Hello, this is myFunction!&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 获取函数的地址，并将其赋给一个函数指针</span><br>    <span class="hljs-built_in">void</span> (*funcPtr)() = myFunction;<br><br>    <span class="hljs-comment">// 通过函数指针调用函数</span><br>    <span class="hljs-built_in">funcPtr</span>();  <span class="hljs-comment">// 等同于 myFunction()</span><br>    <br>    <span class="hljs-comment">// 输出函数的内存地址</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;Function address: &quot;</span> &lt;&lt; (<span class="hljs-type">void</span>*)funcPtr &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">输出：</span><br><span class="hljs-comment">Hello, this is myFunction!</span><br><span class="hljs-comment">Function address: 0x401550</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>在上面的例子中，<code>funcPtr</code> 是一个指向 <code>myFunction</code> 函数的指针。<code>funcPtr</code> 存储了 <code>myFunction</code> 函数的内存地址。通过这个指针，我们可以调用函数。</p><ul><li><strong>函数名</strong>本身在 C++ 中是一个<strong>常量指针</strong>，指向函数的内存地址。例如，<code>myFunction</code> 就代表了 <code>myFunction</code> 函数的地址。</li><li>通过 <code>(void*)funcPtr</code> 可以将函数指针转为 <code>void*</code> 类型，进而打印出函数的内存地址。</li></ul>
          </div>

<p>在 C++ 中，<strong>函数指针</strong>（Function Pointer）是一个指向函数的指针变量，类似于指向普通数据类型的指针。通过函数指针，我们可以动态地调用函数，而不需要直接调用它们的名称。函数指针在实现回调机制、事件驱动编程、以及某些设计模式（如策略模式）时非常有用。</p>
<ol>
<li><strong>函数指针的声明</strong></li>
</ol>
<p>函数指针的声明需要指定函数的返回类型、参数类型以及指针本身的类型。声明的形式与函数的声明很相似，关键在于指针的符号 <code>*</code> 和 <code>&amp;</code> 的使用。</p>
<p>假设有一个返回 <code>int</code> 类型，参数为 <code>int</code> 和 <code>float</code> 的函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">my_function</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">float</span>)</span></span>;<br></code></pre></td></tr></table></figure>

<p>那么，指向该函数的函数指针应该这样声明：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">int</span> (*func_ptr)(<span class="hljs-type">int</span>, <span class="hljs-type">float</span>);<br></code></pre></td></tr></table></figure>

<ul>
<li><code>int (*func_ptr)(int, float)</code>：表示 <code>func_ptr</code> 是一个指向函数的指针，函数的返回类型是 <code>int</code>，参数类型是 <code>int</code> 和 <code>float</code>。</li>
<li><code>(*func_ptr)</code> 表示 <code>func_ptr</code> 是一个指针，指向的内容是一个函数。</li>
</ul>
<ol start="2">
<li><strong>函数指针的初始化</strong></li>
</ol>
<p>函数指针可以通过将它指向某个具体的函数来初始化。你可以将函数名赋给函数指针，因为函数名本身就是指向函数的指针。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">my_function</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">float</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">int</span> (*func_ptr)(<span class="hljs-type">int</span>, <span class="hljs-type">float</span>);  <span class="hljs-comment">// 函数指针声明</span><br>    func_ptr = my_function;       <span class="hljs-comment">// 初始化指针，指向 my_function</span><br><br>    <span class="hljs-comment">// 通过函数指针调用函数</span><br>    <span class="hljs-type">int</span> result = <span class="hljs-built_in">func_ptr</span>(<span class="hljs-number">5</span>, <span class="hljs-number">3.2</span>); <span class="hljs-comment">// 等价于 my_function(5, 3.2)</span><br>    std::cout &lt;&lt; result &lt;&lt; std::endl;  <span class="hljs-comment">// 输出 8</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在上面的代码中，<code>func_ptr</code> 是一个指向 <code>my_function</code> 函数的指针。通过 <code>func_ptr</code> 调用函数，功能与直接调用 <code>my_function</code> 一样。</p>
<ol start="3">
<li><strong>通过函数指针调用函数</strong></li>
</ol>
<p>一旦函数指针被正确初始化，你可以使用该指针来调用函数。通过 <code>*</code> 解引用函数指针，然后传递参数来调用目标函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">int</span> (*func_ptr)(<span class="hljs-type">int</span>, <span class="hljs-type">float</span>);  <span class="hljs-comment">// 函数指针声明</span><br>func_ptr = my_function;       <span class="hljs-comment">// 函数指针初始化</span><br><br><span class="hljs-comment">// 使用函数指针调用函数</span><br><span class="hljs-type">int</span> result = (*func_ptr)(<span class="hljs-number">10</span>, <span class="hljs-number">5.5</span>);  <span class="hljs-comment">// 等同于 my_function(10, 5.5)</span><br>std::cout &lt;&lt; <span class="hljs-string">&quot;Result: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;<br></code></pre></td></tr></table></figure>

<p>你也可以直接用 <code>func_ptr(10, 5.5)</code> 来调用函数，因为 <code>func_ptr</code> 本身就代表了一个函数。</p>
<ol start="4">
<li><strong>函数指针数组</strong></li>
</ol>
<p>你可以创建一个指向多个函数的数组。这样的数组允许你根据索引动态选择不同的函数进行调用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123; <span class="hljs-keyword">return</span> a + b; &#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">subtract</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123; <span class="hljs-keyword">return</span> a - b; &#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">multiply</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123; <span class="hljs-keyword">return</span> a * b; &#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 创建函数指针数组，数组元素是指向函数的指针</span><br>    <span class="hljs-built_in">int</span> (*operations[<span class="hljs-number">3</span>])(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>) = &#123;add, subtract, multiply&#125;;<br><br>    <span class="hljs-comment">// 动态调用不同的操作</span><br>    <span class="hljs-type">int</span> x = <span class="hljs-number">5</span>, y = <span class="hljs-number">3</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Add: &quot;</span> &lt;&lt; operations[<span class="hljs-number">0</span>](x, y) &lt;&lt; endl;        <span class="hljs-comment">// add(5, 3)</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;Subtract: &quot;</span> &lt;&lt; operations[<span class="hljs-number">1</span>](x, y) &lt;&lt; endl;   <span class="hljs-comment">// subtract(5, 3)</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;Multiply: &quot;</span> &lt;&lt; operations[<span class="hljs-number">2</span>](x, y) &lt;&lt; endl;   <span class="hljs-comment">// multiply(5, 3)</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在这个例子中，<code>operations</code> 是一个函数指针数组，其中每个元素都指向一个函数。你可以使用数组的索引来选择要调用的函数。</p>
<blockquote>
<p>可以用于菜单选择。</p>
</blockquote>
<div class="note note-warning">
            <p>注意，函数指针数组要求<strong>数组中的每一个函数的返回值和特征表都要相同！</strong></p><ul><li>例如，如果修改add函数为<code>int add(int a, double b) { return a + b; }</code>，会产生报错：<code>invalid conversion from &#39;int (*)(int, double)&#39; to &#39;int (*)(int, int)&#39; [-fpermissive]</code></li><li>修改<code>int add(int a) { return a; }</code>，会产生报错：<code>invalid conversion from &#39;int (*)(int)&#39; to &#39;int (*)(int, int)&#39; [-fpermissive]</code></li><li>修改<code>double add(int a ,int b) { return a+b; }</code>，会产生报错：<code>invalid conversion from &#39;double (*)(int, int)&#39; to &#39;int (*)(int, int)&#39; [-fpermissive]</code><ul><li>你当然可以用指针的<strong>强制类型转换</strong>来实现这一点，但是这又会带来更大的隐患。</li></ul></li></ul>
          </div>

<ol start="5">
<li><strong>作为函数参数的函数指针</strong></li>
</ol>
<p>函数指针常常作为参数传递给其他函数，允许在运行时选择不同的函数进行调用。这是一种典型的<strong>回调机制</strong>。</p>
<p>示例：<strong>回调函数</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 定义一个函数类型</span><br><span class="hljs-keyword">using</span> FuncPtr = <span class="hljs-built_in">void</span>(*)(<span class="hljs-type">int</span>);  <span class="hljs-comment">// 函数指针类型，指向接受 int 参数并返回 void 的函数</span><br><br><span class="hljs-comment">// 函数 1</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print_square</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Square: &quot;</span> &lt;&lt; x * x &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">// 函数 2</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print_cube</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Cube: &quot;</span> &lt;&lt; x * x * x &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">// 一个函数，它接受一个函数指针作为参数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">process_number</span><span class="hljs-params">(<span class="hljs-type">int</span> num, FuncPtr callback)</span> </span>&#123;<br>    <span class="hljs-built_in">callback</span>(num);  <span class="hljs-comment">// 调用回调函数</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> num = <span class="hljs-number">5</span>;<br>    <br>    <span class="hljs-comment">// 使用不同的回调函数</span><br>    <span class="hljs-built_in">process_number</span>(num, print_square);  <span class="hljs-comment">// 调用 print_square</span><br>    <span class="hljs-built_in">process_number</span>(num, print_cube);    <span class="hljs-comment">// 调用 print_cube</span><br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在这个例子中，<code>process_number</code> 函数接收一个函数指针 <code>callback</code>，它指向一个接受 <code>int</code> 参数并返回 <code>void</code> 的函数。你可以传递不同的函数来处理同一个数字，这样就实现了动态的行为。</p>
<p>举个实际的例子：<strong>函数指针和冒泡排序</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(T a[],<span class="hljs-type">int</span> size,<span class="hljs-type">bool</span>(*f)(T,T))</span> </span>&#123;<br>    <span class="hljs-type">bool</span> flag;<br>    <span class="hljs-type">int</span> i,j;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;size;++i) &#123;<br>        flag=<span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;size-i<span class="hljs-number">-1</span>;++j) &#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">f</span>(a[j],a[j<span class="hljs-number">+1</span>])) &#123;<br>                T temp=a[j];<br>                a[j]=a[j<span class="hljs-number">+1</span>];<br>                a[j<span class="hljs-number">+1</span>]=temp;<br>                flag=<span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(!flag)<span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">increaseInt</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<span class="hljs-keyword">return</span> x&gt;y;&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">decreaseInt</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<span class="hljs-keyword">return</span> x&lt;y;&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">increaseString</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* x,<span class="hljs-type">const</span> <span class="hljs-type">char</span>* y)</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">strcmp</span>(x,y)&gt;<span class="hljs-number">0</span>;&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">decreaseString</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* x,<span class="hljs-type">const</span> <span class="hljs-type">char</span>* y)</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">strcmp</span>(x,y)&lt;<span class="hljs-number">0</span>;&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> a[]=&#123;<span class="hljs-number">92</span>,<span class="hljs-number">73</span>,<span class="hljs-number">36</span>,<span class="hljs-number">63</span>,<span class="hljs-number">13</span>&#125;;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>*b[]=&#123;<span class="hljs-string">&quot;hsc&quot;</span>,<span class="hljs-string">&quot;cbs&quot;</span>,<span class="hljs-string">&quot;abx&quot;</span>,<span class="hljs-string">&quot;bcj&quot;</span>&#125;;<br>    <span class="hljs-comment">//cout&lt;&lt;strcmp(b[1],b[2]);</span><br>    <span class="hljs-built_in">sort</span>&lt;<span class="hljs-type">int</span>&gt;(a,<span class="hljs-number">5</span>,increaseInt);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++) cout&lt;&lt;a[i]&lt;&lt;<span class="hljs-string">&quot;\t&quot;</span>;<br>    cout&lt;&lt;endl;<br>    <span class="hljs-built_in">sort</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">char</span>*&gt;(b,<span class="hljs-number">4</span>,decreaseString);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++) cout&lt;&lt;b[i]&lt;&lt;<span class="hljs-string">&quot;\t&quot;</span>;<br>    cout&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">输出结果:</span><br><span class="hljs-comment">13      36      63      73      92</span><br><span class="hljs-comment">hsc     cbs     bcj     abx</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>

<p><code>bool(*f)(T,T))</code>就是函数指针作为函数参数的用法（<strong>回调函数</strong>）。类似于<code>sort</code>函数的<code>compare</code>函数一样，在冒泡排序算法中，搭配不同的<code>bool(*f)(T,T))</code>可以实现自定义的排序顺序。</p>
<ol start="6">
<li><strong>函数指针和 <code>const</code> 修饰符</strong></li>
</ol>
<p>如果你想确保函数指针指向的函数不被修改，可以使用 <code>const</code> 修饰符。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123; <span class="hljs-keyword">return</span> a + b; &#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">subtract</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123; <span class="hljs-keyword">return</span> a - b; &#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 定义一个常量函数指针，指向不修改函数的函数</span><br>    <span class="hljs-built_in">int</span> (*<span class="hljs-type">const</span> func_ptr)(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>) = add;<br>    <br>    <span class="hljs-comment">// func_ptr = subtract;  // 错误，不能改变指针的值</span><br>    <span class="hljs-type">int</span> result = <span class="hljs-built_in">func_ptr</span>(<span class="hljs-number">10</span>, <span class="hljs-number">5</span>);  <span class="hljs-comment">// 正确，调用 add</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;Result: &quot;</span> &lt;&lt; result &lt;&lt; endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在这里，<code>func_ptr</code> 是一个常量函数指针，意味着它一旦指向 <code>add</code> 函数，就不能再改变指向其他函数。</p>
<h2 id="Advanced-Technique-5-Lambda-expression"><a href="#Advanced-Technique-5-Lambda-expression" class="headerlink" title="Advanced Technique 5 Lambda expression"></a>Advanced Technique 5 Lambda expression</h2><p>C++ 中的 <strong>Lambda 表达式</strong> 是一种轻量级的匿名函数，它允许在代码中定义和使用一个函数对象，而不需要事先为其命名。Lambda 表达式使得 C++ 代码更加简洁和灵活，特别是在需要临时传递函数作为参数时非常有用。</p>
<p>C++11 引入了 Lambda 表达式，基本语法如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">[捕获列表](参数列表) -&gt; 返回类型 &#123; 函数体 &#125;<br></code></pre></td></tr></table></figure>

<p>其中各部分的含义如下：</p>
<ul>
<li><strong>捕获列表</strong>（Capture list）：指定 Lambda 表达式访问外部变量的方式。捕获列表允许 Lambda 表达式“捕获”<strong>外部作用域中的变量</strong>，并可以在函数体内使用这些变量。</li>
<li><strong>参数列表</strong>（Parameter list）：指定 Lambda 表达式的输入参数，类似于普通函数的参数。</li>
<li><strong>返回类型</strong>（Return type）：指定 Lambda 表达式的返回类型，可以省略，编译器会根据返回值推导类型。</li>
<li><strong>函数体</strong>（Function body）：Lambda 表达式的实际代码，包含执行的语句。</li>
</ul>
<ol>
<li><strong>捕获列表（Capture List）</strong></li>
</ol>
<p>捕获列表定义了 Lambda 表达式如何访问外部作用域的变量。捕获方式有以下几种：</p>
<ul>
<li><p>按值捕获：捕获外部变量的副本</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">[x] &#123; std::cout &lt;&lt; x; &#125;  <span class="hljs-comment">// 捕获 x 的副本</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>按引用捕获：捕获外部变量的引用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">[&amp;x] &#123; x = <span class="hljs-number">10</span>; &#125;  <span class="hljs-comment">// 捕获 x 的引用，允许修改 x</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>捕获所有变量按值：捕获所有外部变量的副本</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">[=] &#123; std::cout &lt;&lt; x &lt;&lt; y; &#125;  <span class="hljs-comment">// 捕获所有外部变量的副本</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>捕获所有变量按引用：捕获所有外部变量的引用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">[&amp;] &#123; x = <span class="hljs-number">10</span>; y = <span class="hljs-number">20</span>; &#125;  <span class="hljs-comment">// 捕获所有外部变量的引用</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>按值和引用混合捕获：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">[=, &amp;x] &#123; x = <span class="hljs-number">10</span>; &#125;  <span class="hljs-comment">// 捕获所有外部变量按值，x 按引用</span><br></code></pre></td></tr></table></figure></li>
</ul>
<ol start="2">
<li><strong>参数列表</strong></li>
</ol>
<p>Lambda 表达式的参数列表与普通函数类似，可以定义输入参数。如果没有参数，参数列表可以省略。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">[]() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Hello, World!&quot;</span> &lt;&lt; std::endl; &#125;<br></code></pre></td></tr></table></figure>

<ol start="3">
<li><strong>返回类型</strong></li>
</ol>
<p><strong>Lambda 表达式的返回类型通常可以省略</strong>，编译器会根据函数体中的返回语句推导出返回类型。如果需要显式指定返回类型，可以使用 <code>-&gt;</code> 语法。</p>
<blockquote>
<p>这怎么那么像python的语法？？？</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> lambda = []() -&gt; <span class="hljs-type">int</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>; &#125;;<br>std::cout &lt;&lt; <span class="hljs-built_in">lambda</span>() &lt;&lt; std::endl;  <span class="hljs-comment">// 输出 42</span><br></code></pre></td></tr></table></figure>

<ol start="4">
<li><strong>Lambda 表达式的实际例子</strong></li>
</ol>
<ul>
<li>按值捕获</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">auto</span> lambda = [x]() &#123; cout &lt;&lt; <span class="hljs-string">&quot;x = &quot;</span> &lt;&lt; x &lt;&lt; endl; &#125;;<br>    <span class="hljs-built_in">lambda</span>();  <span class="hljs-comment">// 输出: x = 5</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里的 Lambda 捕获了变量 <code>x</code> 的值，并输出它。</p>
<ul>
<li>按引用捕获</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">auto</span> lambda = [&amp;x]() &#123; x = <span class="hljs-number">10</span>; &#125;;  <span class="hljs-comment">// 捕获 x 的引用</span><br>    <span class="hljs-built_in">lambda</span>();<br>    cout &lt;&lt; <span class="hljs-string">&quot;x = &quot;</span> &lt;&lt; x &lt;&lt; endl;  <span class="hljs-comment">// 输出: x = 10</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这段代码通过按引用捕获，Lambda 表达式能够修改外部变量 <code>x</code>。</p>
<ul>
<li>带参数的 Lambda</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> add = [](<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b) &#123; <span class="hljs-keyword">return</span> a + b; &#125;;<br>    cout &lt;&lt; <span class="hljs-built_in">add</span>(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>) &lt;&lt; endl;  <span class="hljs-comment">// 输出: 8</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这是一个带有两个整型参数的 Lambda 表达式，用于计算两个数的和。</p>
<ol start="5">
<li><strong>Lambda 表达式的高级用法</strong></li>
</ol>
<ul>
<li>Lambda <strong>表达式作为参数</strong></li>
</ul>
<p>Lambda 表达式常用于 STL 算法中作为参数，尤其是像 <code>std::sort</code> 这样的函数，它允许你提供自定义的排序规则。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; vec = &#123;<span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>&#125;;<br>    <br>    <span class="hljs-comment">// 使用 Lambda 表达式自定义排序规则</span><br>    <span class="hljs-built_in">sort</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b) &#123; <span class="hljs-keyword">return</span> a &gt; b; &#125;);<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> val : vec) &#123;<br>        cout &lt;&lt; val &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <span class="hljs-comment">// 输出: 5 4 3 2 1</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在这个例子中，Lambda 表达式 <code>[ ]</code> 用于指定排序的比较规则。</p>
<ul>
<li><strong>使用 <code>mutable</code> 修改捕获变量</strong></li>
</ul>
<p>默认情况下，捕获的变量在 Lambda 中是 <strong>常量</strong>，不能修改。如果你需要在 Lambda 内部修改捕获的变量，可以使用 <code>mutable</code> 关键字。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">auto</span> lambda = [x]() <span class="hljs-keyword">mutable</span> &#123; x = <span class="hljs-number">10</span>; cout &lt;&lt; <span class="hljs-string">&quot;x inside lambda: &quot;</span> &lt;&lt; x &lt;&lt; endl; &#125;;<br>    <span class="hljs-built_in">lambda</span>();<br>    cout &lt;&lt; <span class="hljs-string">&quot;x outside lambda: &quot;</span> &lt;&lt; x &lt;&lt; endl;  <span class="hljs-comment">// 输出: x outside lambda: 5</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>使用 <code>mutable</code> 后，捕获的变量 <code>x</code> 在 Lambda 内部变成可修改的副本，但是外部的 <code>x</code> 不会受到影响。</p>
<ul>
<li><strong>返回 Lambda 表达式</strong></li>
</ul>
<p><strong>Lambda 表达式也可以返回 Lambda</strong>。例如，返回一个根据输入参数变化的 Lambda：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">createAdder</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> [x](<span class="hljs-type">int</span> y) &#123; <span class="hljs-keyword">return</span> x + y; &#125;;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> add5 = <span class="hljs-built_in">createAdder</span>(<span class="hljs-number">5</span>);<br>    <span class="hljs-comment">//在这里add5是一个函数指针，相当于createAdder的返回值，可以继续进行操作。</span><br>    cout &lt;&lt; <span class="hljs-built_in">add5</span>(<span class="hljs-number">10</span>) &lt;&lt; endl;  <span class="hljs-comment">// 输出: 15</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在这个例子中，<code>createAdder</code> 返回一个 Lambda 表达式，它会将传入的 <code>x</code> 与每次调用时传入的 <code>y</code> 相加。</p>
<ol start="6">
<li><strong>总结</strong></li>
</ol>
<ul>
<li><strong>Lambda 表达式</strong> 是 C++ 中一种轻量级的匿名函数，可以捕获外部变量并在局部上下文中使用。</li>
<li>捕获方式有按值捕获、按引用捕获、按值或按引用混合捕获等。</li>
<li>Lambda 表达式可以带有参数和返回类型，可以通过 <code>mutable</code> 关键字修改捕获的外部变量。</li>
<li>Lambda 表达式常用于 STL 算法、回调函数、事件处理等场景，提供了更高的灵活性和代码简洁性。</li>
</ul>
<h2 id="Advanced-Technique-6-Smart-Pointer"><a href="#Advanced-Technique-6-Smart-Pointer" class="headerlink" title="Advanced Technique 6 Smart Pointer"></a>Advanced Technique 6 Smart Pointer</h2><p>在之前的学习过程中我们知道，使用<code>new</code>命令动态分配内存，需要手动<code>delete</code>来释放分配在<strong>堆</strong>的内存，否则会发生严重的内存泄漏，导致程序崩溃。在C++98中，**引入了<code>auto_ptr</code>，来自动实现内存回收的功能（所以被称作智能指针）。但是，在C++11的新标准中，<code>auto_ptr</code>被摒弃，取而代之的是三种新的智能指针：<code>unique_ptr</code>,<code>shared_ptr</code>,<code>weak_ptr</code>**。</p>
<h3 id="为什么需要智能指针"><a href="#为什么需要智能指针" class="headerlink" title="为什么需要智能指针"></a>为什么需要智能指针</h3><p>​	我们希望智能指针能够在程序终止时<strong>自动回收为指针所分配的内存而非手动删除</strong>，看下面的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cassert&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">testfunction</span><span class="hljs-params">(string &amp;str,<span class="hljs-type">int</span> n)</span></span>&#123;<br>    str=<span class="hljs-string">&quot;Hello world&quot;</span>;<br>    string *pd=<span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>(str);<br>    <span class="hljs-built_in">assert</span>(n==<span class="hljs-number">0</span>);<br>    pd=&amp;str;<br>    cout&lt;&lt;pd&lt;&lt;endl;<br>    cout&lt;&lt;*pd&lt;&lt;endl;<br>    cout&lt;&lt;&amp;str&lt;&lt;endl&lt;&lt;str&lt;&lt;endl;<br>    <span class="hljs-keyword">delete</span> pd;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    string str;<br>    <span class="hljs-built_in">testfunction</span>(str,<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-number">0x61fd20</span><br>Hello world<br><span class="hljs-number">0x61fd20</span><br>Hello world<br></code></pre></td></tr></table></figure>

<p>​	我们不难发现<strong>手动删除内存是一件效率十分低下的事情！</strong>，如果我没有正确的通过<code>assert</code>断言，我就不会执行<code>delete</code>语句实现内存的回收。因此，<strong>我们希望pd指针有着更强大的功能——在程序终止时自动回收</strong>。如何在类中实现对象的回收与销毁？<strong>析构函数！</strong></p>
<blockquote>
<p><code>auto_ptr</code>的类定义(确实是有析构函数的！)</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Tp&gt;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">auto_ptr</span><br>    &#123;<br>    <span class="hljs-keyword">private</span>:<br>      _Tp* _M_ptr;<br>        <span class="hljs-comment">//声明了一个私有成员变量 _M_ptr，它是一个指向模板类型 _Tp 的指针，用于存储 auto_ptr 管理的对象的地址</span><br>    <span class="hljs-keyword">public</span>:<br>      <span class="hljs-comment">/// The pointed-to type.</span><br>      <span class="hljs-keyword">typedef</span> _Tp element_type;<br>      <span class="hljs-comment">//定义了一个类型别名 element_type，它是 _Tp 的同义词，用于表示 auto_ptr 所管理的对象类型。</span><br>      <span class="hljs-function"><span class="hljs-keyword">explicit</span></span><br><span class="hljs-function">      <span class="hljs-title">auto_ptr</span><span class="hljs-params">(element_type* __p = <span class="hljs-number">0</span>)</span> <span class="hljs-title">throw</span><span class="hljs-params">()</span> : _M_ptr(__p) &#123;</span> &#125;<br>      <span class="hljs-comment">/*</span><br><span class="hljs-comment">        这是 auto_ptr 的构造函数：</span><br><span class="hljs-comment">          explicit 关键字意味着这个构造函数不能用于隐式类型转换。</span><br><span class="hljs-comment">          构造函数接受一个指向 element_type 类型的指针  __p 作为参数，默认值为 0（即 NULL）。</span><br><span class="hljs-comment">          throw() 表示这个构造函数不会抛出异常（在C++98中，异常规范已弃用）。</span><br><span class="hljs-comment">          构造函数体通过初始化列表将传入的指针赋值给 _M_ptr</span><br><span class="hljs-comment">          </span><br><span class="hljs-comment">      */</span><br>      ~<span class="hljs-built_in">auto_ptr</span>() &#123; <span class="hljs-keyword">delete</span> _M_ptr; &#125;<br>        <span class="hljs-comment">//当 auto_ptr 对象被销毁时，析构函数被调用。</span><br>        <span class="hljs-comment">//它使用 delete 来释放 _M_ptr 所指向的内存，从而自动管理资源。</span><br>      <span class="hljs-comment">//other members.............</span><br>    &#125;;<br></code></pre></td></tr></table></figure>

<h3 id="auto-ptr"><a href="#auto-ptr" class="headerlink" title="auto_ptr"></a><code>auto_ptr</code></h3><p>​	这就是<code>auto_ptr</code>的基本思想，<strong>通过析构函数在指针结束其生命周期的时候自动释放内存</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">auto_ptr&lt;<span class="hljs-type">double</span>&gt; <span class="hljs-title">pd</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">double</span>)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>智能指针和普通的动态内存分配在使用上还有哪些差异？</strong>请看下面的两组程序的对比：在程序中实现了相同的<code>MyClass</code>类，包含数据成员<code>value</code>以及对应的构造函数，析构函数和<code>showMessage()</code>函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs Cpp"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span>  <span class="hljs-comment">// 引入 auto_ptr 需要的头文件</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>    <span class="hljs-type">int</span> value;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">int</span> n):<span class="hljs-built_in">value</span>(n)&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;MyClass constructor&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    ~<span class="hljs-built_in">MyClass</span>() &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;MyClass destructor&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showMessage</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Hello from MyClass!&quot;</span> &lt;&lt; std::endl;<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;The value is&quot;</span>&lt;&lt;value&lt;&lt;std::endl;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demonotAutoPtr</span><span class="hljs-params">()</span> </span>&#123;<br>    MyClass* ptr1=<span class="hljs-keyword">new</span> <span class="hljs-built_in">MyClass</span>(<span class="hljs-number">4</span>);<br>    ptr1-&gt;<span class="hljs-built_in">showMessage</span>();<br>    MyClass *ptr2;<br>    ptr2=ptr1;<br>    ptr2-&gt;<span class="hljs-built_in">showMessage</span>();<br>    ptr1-&gt;<span class="hljs-built_in">showMessage</span>();<br>    <span class="hljs-keyword">delete</span> ptr1;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">demonotAutoPtr</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">MyClass constructor</span><br><span class="hljs-comment">Hello from MyClass!</span><br><span class="hljs-comment">The value is4</span><br><span class="hljs-comment">Hello from MyClass!</span><br><span class="hljs-comment">The value is4</span><br><span class="hljs-comment">Hello from MyClass!</span><br><span class="hljs-comment">The value is4</span><br><span class="hljs-comment">MyClass destructor</span><br><span class="hljs-comment">(这里程序正常运行并且正常退出)</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span>  <span class="hljs-comment">// 引入 auto_ptr 需要的头文件</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>    <span class="hljs-type">int</span> value;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">int</span> n):<span class="hljs-built_in">value</span>(n)&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;MyClass constructor&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    ~<span class="hljs-built_in">MyClass</span>() &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;MyClass destructor&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showMessage</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Hello from MyClass!&quot;</span> &lt;&lt; std::endl;<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;The value is&quot;</span>&lt;&lt;value&lt;&lt;std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demoAutoPtr</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 创建一个 auto_ptr，并初始化为指向动态分配的 MyClass 对象</span><br>    <span class="hljs-function">std::auto_ptr&lt;MyClass&gt; <span class="hljs-title">ptr1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> MyClass(<span class="hljs-number">4</span>))</span></span>;<br>    ptr1-&gt;<span class="hljs-built_in">showMessage</span>();  <span class="hljs-comment">// 使用 auto_ptr 指向的对象</span><br><br>    <span class="hljs-comment">// 将 ptr1 转移给 ptr2，这样 ptr1 变为空，ptr2 拥有 MyClass 的所有权</span><br>    std::auto_ptr&lt;MyClass&gt; ptr2 = ptr1;<br>    <span class="hljs-comment">// 此时 ptr1 不再持有对象，只有 ptr2 拥有 MyClass 对象</span><br>    ptr2-&gt;<span class="hljs-built_in">showMessage</span>();<br>    ptr1-&gt;<span class="hljs-built_in">showMessage</span>();<br>    <span class="hljs-comment">// ptr2 会在超出作用域时自动销毁，并调用 MyClass 的析构函数</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">demoAutoPtr</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">MyClass constructor</span><br><span class="hljs-comment">Hello from MyClass!</span><br><span class="hljs-comment">The value is 4</span><br><span class="hljs-comment">Hello from MyClass!</span><br><span class="hljs-comment">The value is 4</span><br><span class="hljs-comment">Hello from MyClass!</span><br><span class="hljs-comment">The value is</span><br><span class="hljs-comment">(最后程序会异常退出)</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>

<p>通过对比可以发现，两者唯一的不同是在函数<code>demoAutoPtr()</code>中一个使用<strong>动态内存</strong>，另一个使用<strong>智能指针</strong>。两者实现的操作都是一样的，创建<code>ptr1</code>后将<code>ptr1</code>的值转移给<code>ptr2</code>。但是程序在最后调用<code>ptr1-&gt;showMessage();</code>这条语句的时候出现了差异：<strong>基于动态内存实现的指针保留的原来的value值，但是基于智能指针实现的指针在此处value值丢失了，导致程序的异常终止。</strong></p>
<p>在 <code>auto_ptr</code> 的赋值操作中，资源的所有权被转移给了目标 <code>auto_ptr</code>，而源 <code>auto_ptr</code> 被置为空。具体来说，这种行为是通过以下方式实现的：</p>
<ol>
<li>当你将一个 <code>auto_ptr</code> 赋值给另一个 <code>auto_ptr</code> 时，源对象的指针会被转移到目标对象，而源对象的指针则被置为 <code>nullptr</code>。这种行为是通过“<strong>转移所有权</strong>”来避免多次删除相同的资源。</li>
<li>这种转移的目的是确保动态分配的内存在程序结束时被释放，但是如果没有进行所有权转移，可能会发生<strong>双重删除</strong>的错误。</li>
</ol>
<p>因此，我们可以发现，在智能指针的使用上，仅仅依靠<code>auto_ptr</code>似乎是不够的：上文的<strong>转移所有权</strong>的特性确实能够避免内存泄漏的问题出现，但是我们有时也需要进行<strong>指针拷贝</strong>的操作。实际上，在C++的新标准中，**<code>auto_ptr</code>已经被弃用**，主要有以下原因：</p>
<ol>
<li><p><strong>不安全的转移语义</strong>： <code>auto_ptr</code> 在赋值或传递给另一个 <code>auto_ptr</code> 时，进行的是“<strong>浅拷贝</strong>”，即将指针转移到另一个 <code>auto_ptr</code>，并将原来的 <code>auto_ptr</code> 设置为 <code>nullptr</code>。这种行为会导致潜在的资源管理问题，尤其是多个 <code>auto_ptr</code> 管理同一内存时，容易发生重复释放内存。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">auto_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">10</span>))</span></span>;<br>auto_ptr&lt;<span class="hljs-type">int</span>&gt; p2 = p1;  <span class="hljs-comment">// 现在 p1 为空，p2 拥有该内存</span><br>std::cout &lt;&lt; *p2 &lt;&lt; std::endl;  <span class="hljs-comment">// p2 仍然有效，但 p1 不再持有该内存</span><br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>不一致的所有权语义</strong>： <code>auto_ptr</code> 的所有权语义比较模糊。它使得传递和返回指针时，所有权的转移比较不直观，容易造成内存管理的混乱。</p>
</li>
<li><p><strong>不支持移动语义</strong>： <code>auto_ptr</code> 不支持现代 C++ 中引入的“移动语义”。C++11 引入了 <code>std::move</code> 和 <code>std::unique_ptr</code>，使得可以安全高效地转移所有权，而无需担心意外的复制和删除。</p>
</li>
</ol>
<h3 id="other-smart-pointers"><a href="#other-smart-pointers" class="headerlink" title="other smart pointers"></a>other smart pointers</h3><p>现代 C++ 中有<strong>三种常见的智能指针</strong>，它们分别是：</p>
<ol>
<li><strong><code>std::unique_ptr</code><strong>：用于表示</strong>独占所有权</strong>。每个 <code>unique_ptr</code> 只能有一个所有者，当它超出作用域时会自动释放资源。</li>
<li><strong><code>std::shared_ptr</code><strong>：用于表示</strong>共享所有权</strong>。多个 <code>shared_ptr</code> 可以共享同一块资源，当所有指向该资源的 <code>shared_ptr</code> 都被销毁时，资源才会被释放。</li>
<li>**<code>std::weak_ptr</code>**：用于表示对某个资源的“非拥有”引用。它不会影响资源的生命周期，但可以用来观察 <code>shared_ptr</code> 所管理的对象，避免循环引用。</li>
</ol>
<blockquote>
<p>智能指针的关键在于对<strong>内存地址的所有权</strong>进行自动管理。</p>
</blockquote>
<h4 id="1-std-unique-ptr"><a href="#1-std-unique-ptr" class="headerlink" title="1. std::unique_ptr"></a>1. <strong><code>std::unique_ptr</code></strong></h4><p><code>std::unique_ptr</code> 是 C++11 引入的，适用于确保资源的独占所有权。<strong>一个 <code>unique_ptr</code> 不能被复制，只能被移动</strong>。</p>
<div class="note note-info">
            <p><strong>就相当于原来的<code>auto_ptr</code>一样。</strong></p>
          </div>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyClass</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;MyClass constructor&quot;</span> &lt;&lt; std::endl; &#125;<br>    ~<span class="hljs-built_in">MyClass</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;MyClass destructor&quot;</span> &lt;&lt; std::endl; &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showMessage</span><span class="hljs-params">()</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Hello from MyClass!&quot;</span> &lt;&lt; std::endl; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demoUniquePtr</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 创建一个 unique_ptr，指向 MyClass 对象</span><br>    std::unique_ptr&lt;MyClass&gt; ptr1 = std::<span class="hljs-built_in">make_unique</span>&lt;MyClass&gt;();<br>    ptr1-&gt;<span class="hljs-built_in">showMessage</span>();<br><br>    <span class="hljs-comment">// 转移所有权</span><br>    std::unique_ptr&lt;MyClass&gt; ptr2 = std::<span class="hljs-built_in">move</span>(ptr1);  <span class="hljs-comment">// 这里发生了所有权的转移</span><br>    <span class="hljs-keyword">if</span> (!ptr1) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;ptr1 is now empty (nullptr)&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    ptr2-&gt;<span class="hljs-built_in">showMessage</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">demoUniquePtr</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs delphi">MyClass <span class="hljs-function"><span class="hljs-keyword">constructor</span></span><br><span class="hljs-function"><span class="hljs-title">Hello</span> <span class="hljs-title">from</span> <span class="hljs-title">MyClass</span>!</span><br><span class="hljs-function"><span class="hljs-title">ptr1</span> <span class="hljs-title">is</span> <span class="hljs-title">now</span> <span class="hljs-title">empty</span> <span class="hljs-params">(nullptr)</span></span><br><span class="hljs-function"><span class="hljs-title">Hello</span> <span class="hljs-title">from</span> <span class="hljs-title">MyClass</span>!</span><br><span class="hljs-function"><span class="hljs-title">MyClass</span> <span class="hljs-title">destructor</span></span><br></code></pre></td></tr></table></figure>

<h4 id="2-std-shared-ptr"><a href="#2-std-shared-ptr" class="headerlink" title="2. std::shared_ptr"></a>2. <strong><code>std::shared_ptr</code></strong></h4><p><code>std::shared_ptr</code> 是 C++11 引入的，用于表示共享所有权。<strong>多个 <code>shared_ptr</code> 可以同时管理一个资源</strong>，资源只有在所有 <code>shared_ptr</code> 被销毁时才会释放。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>    <span class="hljs-type">int</span> value;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">int</span> n):<span class="hljs-built_in">value</span>(n) &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;MyClass constructor&quot;</span> &lt;&lt; std::endl; &#125;<br>    ~<span class="hljs-built_in">MyClass</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;MyClass destructor&quot;</span> &lt;&lt; std::endl; &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showMessage</span><span class="hljs-params">()</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Hello from MyClass!&quot;</span> &lt;&lt; std::endl; &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showValue</span><span class="hljs-params">()</span></span>&#123; std::cout&lt;&lt;<span class="hljs-string">&quot;the value: &quot;</span>&lt;&lt;value&lt;&lt;std::endl;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modifyValue</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123; value=n;&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demoSharedPtr</span><span class="hljs-params">()</span> </span>&#123;<br>    std::shared_ptr&lt;MyClass&gt; ptr1 = std::<span class="hljs-built_in">make_shared</span>&lt;MyClass&gt;(<span class="hljs-number">4</span>);<br>    ptr1-&gt;<span class="hljs-built_in">showMessage</span>();<br><br>    <span class="hljs-comment">// 创建第二个 shared_ptr，指向同一资源</span><br>    std::shared_ptr&lt;MyClass&gt; ptr2 = ptr1;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Use count: &quot;</span> &lt;&lt; ptr<span class="hljs-number">1.</span><span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl;  <span class="hljs-comment">// 输出共享计数</span><br><br>    ptr1-&gt;<span class="hljs-built_in">showValue</span>();<br>    ptr2-&gt;<span class="hljs-built_in">showValue</span>();<br>    <br>    ptr1-&gt;<span class="hljs-built_in">modifyValue</span>(<span class="hljs-number">3</span>);<br>    ptr2-&gt;<span class="hljs-built_in">showValue</span>();<br><br>    ptr2-&gt;<span class="hljs-built_in">modifyValue</span>(<span class="hljs-number">2</span>);<br>    ptr1-&gt;<span class="hljs-built_in">showValue</span>();<br>    <span class="hljs-comment">// ptr2 和 ptr1 都指向同一对象，资源不会被释放直到两个都超出作用域</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">demoSharedPtr</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs powershell">MyClass constructor<br>Hello from MyClass!<br>Use count: <span class="hljs-number">2</span><br>the value: <span class="hljs-number">4</span><br>the value: <span class="hljs-number">4</span><br>the value: <span class="hljs-number">3</span><br>the value: <span class="hljs-number">2</span><br>MyClass destructor<br></code></pre></td></tr></table></figure>

<h4 id="3-std-weak-ptr"><a href="#3-std-weak-ptr" class="headerlink" title="3. std::weak_ptr"></a>3. <strong><code>std::weak_ptr</code></strong></h4><p><code>std::weak_ptr</code> 是 C++11 引入的，通常与 <code>shared_ptr</code> 配合使用，用来观察由 <code>shared_ptr</code> 管理的对象。<code>weak_ptr</code> 不增加对象的引用计数，因此<strong>它不会影响对象的生命周期</strong>。</p>
<blockquote>
<p>在某些场景下，<code>shared_ptr</code> 之间可能会相互引用，导致引用计数永远不为零，从而导致内存泄漏。这时可以使用 <code>weak_ptr</code> 来避免这种循环引用的问题。</p>
</blockquote>
<p>想象你有一个 <code>shared_ptr</code> 管理的对象 <code>A</code>，同时，你有另一个对象 <code>B</code>，它想引用 <code>A</code>，但不想干扰 <code>A</code> 的生命周期。你就可以用 <code>weak_ptr</code> 来观察 <code>A</code> 是否存在。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span>  <span class="hljs-comment">// 引入 shared_ptr 和 weak_ptr</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyClass</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;MyClass constructor&quot;</span> &lt;&lt; std::endl; &#125;<br>    ~<span class="hljs-built_in">MyClass</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;MyClass destructor&quot;</span> &lt;&lt; std::endl; &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showMessage</span><span class="hljs-params">()</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Hello from MyClass!&quot;</span> &lt;&lt; std::endl; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demoWeakPtr</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 创建一个 shared_ptr，指向 MyClass 对象</span><br>    std::shared_ptr&lt;MyClass&gt; ptr1 = std::<span class="hljs-built_in">make_shared</span>&lt;MyClass&gt;();<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Use count before weak_ptr: &quot;</span> &lt;&lt; ptr<span class="hljs-number">1.</span><span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 创建一个 weak_ptr，指向同一个对象，但不增加引用计数</span><br>    std::weak_ptr&lt;MyClass&gt; weakPtr = ptr1;<br><br>    <span class="hljs-comment">// 使用 weak_ptr 时，我们需要“锁定”它，检查它是否仍然有效</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">auto</span> sharedPtr = weakPtr.<span class="hljs-built_in">lock</span>()) &#123;  <span class="hljs-comment">// lock() 方法返回一个 shared_ptr，如果对象仍然存在</span><br>        sharedPtr-&gt;<span class="hljs-built_in">showMessage</span>();  <span class="hljs-comment">// 如果 weak_ptr 指向的对象仍然存在，就可以使用它</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Object is no longer available&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-comment">// 释放 ptr1，MyClass 对象的引用计数变为 0，对象会被销毁</span><br>    ptr<span class="hljs-number">1.</span><span class="hljs-built_in">reset</span>();  <span class="hljs-comment">// 释放 ptr1 指向的对象</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Use count after reset: &quot;</span> &lt;&lt; weakPtr.<span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 尝试再次锁定 weak_ptr</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">auto</span> sharedPtr = weakPtr.<span class="hljs-built_in">lock</span>()) &#123;<br>        sharedPtr-&gt;<span class="hljs-built_in">showMessage</span>();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Object is no longer available&quot;</span> &lt;&lt; std::endl;  <span class="hljs-comment">// 此时对象已经被销毁</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">demoWeakPtr</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs delphi">MyClass <span class="hljs-function"><span class="hljs-keyword">constructor</span></span><br><span class="hljs-function"><span class="hljs-title">Use</span> <span class="hljs-title">count</span> <span class="hljs-title">before</span> <span class="hljs-title">weak_ptr</span>:</span> <span class="hljs-number">1</span><br>Hello from MyClass!<br>Use count after reset: <span class="hljs-number">0</span><br><span class="hljs-keyword">Object</span> <span class="hljs-keyword">is</span> no longer available<br>MyClass <span class="hljs-function"><span class="hljs-keyword">destructor</span></span><br></code></pre></td></tr></table></figure>

<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li>**<code>std::unique_ptr</code>**：表示独占所有权，只能转移所有权，不支持拷贝。常用于资源的独占管理。</li>
<li>**<code>std::shared_ptr</code>**：表示共享所有权，多个 <code>shared_ptr</code> 可以共同拥有一个资源，直到最后一个 <code>shared_ptr</code> 被销毁，资源才会被释放。</li>
<li>**<code>std::weak_ptr</code>**：不增加引用计数，仅用于观察由 <code>shared_ptr</code> 管理的对象，防止出现循环引用的问题。</li>
</ul>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Code/" class="category-chain-item">Code</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/tutorial/" class="print-no-link">#tutorial</a>
      
        <a href="/tags/C-C/" class="print-no-link">#C/C++</a>
      
        <a href="/tags/Finished/" class="print-no-link">#Finished</a>
      
        <a href="/tags/pointers/" class="print-no-link">#pointers</a>
      
        <a href="/tags/functions/" class="print-no-link">#functions</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Pointers-Arrays-and-Functions</div>
      <div>https://xiyuanyang-code.github.io/posts/Pointers-Arrays-and-Functions/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>Author</div>
          <div>Xiyuan Yang</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>Posted on</div>
          <div>December 14, 2024</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>Updated on</div>
          <div>February 17, 2025</div>
        </div>
      
      
        <div class="license-meta-item">
          <div>Licensed under</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - Attribution">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/posts/CMake-tutorial1/" title="CMake-Tutorial1">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">CMake-Tutorial1</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/posts/Exception-Handling-in-C-plus-plus/" title="Exception-Handling-in-C-Plus-Plus">
                        <span class="hidden-mobile">Exception-Handling-in-C-Plus-Plus</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
    <div id="giscus" class="giscus"></div>
    <script type="text/javascript">
      Fluid.utils.loadComments('#giscus', function() {
        var options = {"repo":"xiyuanyang-code/xiyuanyang-code.github.io","repo-id":"R_kgDONRhvHQ","category":"Announcements","category-id":"DIC_kwDONRhvHc4ClBnp","theme-light":"light","theme-dark":"dark","mapping":"pathname","reactions-enabled":1,"emit-metadata":0,"input-position":"top","lang":"zh-CN"};
        var attributes = {};
        for (let option in options) {
          if (!option.startsWith('theme-')) {
            var key = option.startsWith('data-') ? option : 'data-' + option;
            attributes[key] = options[option];
          }
        }
        var light = 'light';
        var dark = 'dark';
        window.GiscusThemeLight = light;
        window.GiscusThemeDark = dark;
        attributes['data-theme'] = document.documentElement.getAttribute('data-user-color-scheme') === 'dark' ? dark : light;
        for (let attribute in attributes) {
          var value = attributes[attribute];
          if (value === undefined || value === null || value === '') {
            delete attributes[attribute];
          }
        }
        var s = document.createElement('script');
        s.setAttribute('src', 'https://giscus.app/client.js');
        s.setAttribute('crossorigin', 'anonymous');
        for (let attribute in attributes) {
          s.setAttribute(attribute, attributes[attribute]);
        }
        var ss = document.getElementsByTagName('script');
        var e = ss.length > 0 ? ss[ss.length - 1] : document.head || document.documentElement;
        e.parentNode.insertBefore(s, e.nextSibling);
      });
    </script>
    <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>Table of Contents</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">Keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://github.com/xiyuanyang-code" target="_blank" rel="nofollow noopener"><span>YXY</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/Siyan-Li" target="_blank" rel="nofollow noopener"><span>LSY</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script defer src="/js/leancloud.js" ></script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">Blog works best with JavaScript enabled</div>
  </noscript>
</body>
</html>
