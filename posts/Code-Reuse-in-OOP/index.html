

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=light>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/YXY.png">
  <link rel="icon" href="/img/YXY.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Xiyuan Yang">
  <meta name="keywords" content="Code">
  
    <meta name="description" content="In this article, you will learn several efficient ways to implement code reuse in C++, including Containment, composition, and Class templates. This chapter also involves several advanced techniques o">
<meta property="og:type" content="article">
<meta property="og:title" content="Code-Reuse-in-OOP">
<meta property="og:url" content="https://xiyuanyang-code.github.io/posts/Code-Reuse-in-OOP/index.html">
<meta property="og:site_name" content="Xiyuan Yang&#39;s Blog">
<meta property="og:description" content="In this article, you will learn several efficient ways to implement code reuse in C++, including Containment, composition, and Class templates. This chapter also involves several advanced techniques o">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://xiyuanyang-code.github.io/img/cover/Stack.jpg">
<meta property="article:published_time" content="2024-12-12T02:13:03.000Z">
<meta property="article:modified_time" content="2024-12-13T09:33:05.856Z">
<meta property="article:author" content="Xiyuan Yang">
<meta property="article:tag" content="tutorial">
<meta property="article:tag" content="C&#x2F;C++">
<meta property="article:tag" content="OOP">
<meta property="article:tag" content="C++ Primer Plus">
<meta property="article:tag" content="Inheritance">
<meta property="article:tag" content="Code Reuse">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://xiyuanyang-code.github.io/img/cover/Stack.jpg">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>Code-Reuse-in-OOP - Xiyuan Yang&#39;s Blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"xiyuanyang-code.github.io","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":60,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":"❡"},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":"L7r0uGb0fafbzNvmBADCMH42-gzGzoHsz","app_key":"2Lr1fQ2rjhwRiUrDx0VOQyUm","server_url":null,"path":"window.location.pathname","ignore_local":true},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  

  

  

  
    
  



  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Xiyuan Yang&#39;s Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>Home</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/above/" target="_self">
                <i class="iconfont icon-bookmark-fill"></i>
                <span>Intro</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>Archive</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>Category</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>Tag</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>About</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/resume/" target="_self">
                <i class="iconfont icon-code"></i>
                <span>Resume</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/FAQ/" target="_self">
                <i class="iconfont icon-bug"></i>
                <span>FAQ</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Code-Reuse-in-OOP"></span>
          
        </div>

        
          
  <div class="mt-3">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-author" aria-hidden="true"></i>
        Xiyuan Yang
      </span>
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-12-12 10:13" pubdate>
          December 12, 2024 am
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          6.9k words
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          58 mins
        
      </span>
    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> views
        </span>
        

      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">Code-Reuse-in-OOP</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="Code-Reuse-in-OOP"><a href="#Code-Reuse-in-OOP" class="headerlink" title="Code Reuse in OOP"></a>Code Reuse in OOP</h1><p>C++的一个主要目标是促进代码重用。公有继承是实现这种目标的机制之一，但并不是唯一的机制。本章将介绍其他方法，其中之一是使用这样的类成员：本身是另一个类的对象。这种方法称为<strong>包含（containment）、组合（composition）或层次化（layering）</strong>。另一种方法是使用私有或保护继承。通常，<strong>包含、私有继承和保护继承</strong>用于实现 <strong>has-a</strong> 关系，即新的类将包含另一个类的对象。多重继承使得能够使用两个或更多的基类派生出新的类，将基类的功能组合在一起。</p>
<p>同时，本章将介绍<strong>类模板</strong>——另一种重用代码的方法。类模板使我们能够使用通用术语定义类，然后使用模板来创建针对特定类型定义的特殊类。</p>
<blockquote>
<p>One of the main goals of C++ is to promote code reuse. Public inheritance is one of the mechanisms to achieve this goal, but not the only one. This chapter will introduce other methods, one of which is to use class members that are themselves objects of another class. This method is called containment, composition, or layering. Another method is to use private or protected inheritance. Generally, containment, private inheritance, and protected inheritance are used to implement the has - a relationship, that is, the new class will contain an object of another class. Multiple inheritance enables new classes to be derived from two or more base classes, combining the functionality of the base classes.</p>
<p>At the same time, this chapter will introduce class templates - another method of reusing code. Class templates enable us to define classes in general terms and then use the templates to create special classes defined for specific types.</p>
</blockquote>
<h2 id="Table-of-Contents"><a href="#Table-of-Contents" class="headerlink" title="Table of Contents"></a>Table of Contents</h2><h2 id="Containment-Composition-Layering"><a href="#Containment-Composition-Layering" class="headerlink" title="Containment Composition Layering"></a>Containment Composition Layering</h2><h3 id="valarray"><a href="#valarray" class="headerlink" title="valarray"></a><code>valarray</code></h3><p><code>valarray</code>被定义为一个模板类，能够处理不同的数据类型。</p>
<p>下面来看<code>valarray</code>的基本操作：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;valarray&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">valarray&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">list</span><span class="hljs-params">(<span class="hljs-number">10</span>,<span class="hljs-number">8</span>)</span></span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> num:list)&#123;<br>        cout&lt;&lt;num&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出结果：8个10</p>
<p><code>valarray</code>的基本使用和数组完全一样，但是<code>valarray</code>在数值计算方面具有更大的优势。</p>
<div class="note note-info">
            <ol><li>构造函数<ul><li><strong>默认构造函数</strong>：可以创建一个空的<code>valarray</code>。例如<code>std::valarray&lt;int&gt; va;</code>，这样就创建了一个空的<code>valarray</code>，其中元素类型为<code>int</code>。</li><li><strong>大小指定构造函数</strong>：可以指定<code>valarray</code>的大小和初始值。例如<code>std::valarray&lt;double&gt; va1(10, 3.14);</code>，这个构造函数创建了一个包含 10 个元素的<code>valarray</code>，每个元素初始值为 3.14。</li><li><strong>拷贝构造函数</strong>：用于从另一个<code>valarray</code>创建一个新的<code>valarray</code>。例如<code>std::valarray&lt;int&gt; va2(va1);</code>，这里<code>va2</code>是<code>va1</code>的一个拷贝，它们具有相同的元素个数和对应位置相同的元素。</li><li><strong>初始化列表构造函数</strong>：可以使用花括号初始化列表来创建<code>valarray</code>。例如<code>std::valarray&lt;int&gt; va3 = {1, 2, 3, 4, 5};</code>，这种方式方便快捷地创建并初始化一个<code>valarray</code>。</li></ul></li><li>元素访问方法<ul><li><strong><code>[]</code>操作符</strong>：用于访问<code>valarray</code>中的单个元素。例如：</li></ul></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::valarray&lt;<span class="hljs-type">int</span>&gt; va = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><span class="hljs-type">int</span> element = va[<span class="hljs-number">2</span>];  <span class="hljs-comment">// 访问第三个元素，element的值为3</span><br></code></pre></td></tr></table></figure><ul><li><strong><code>size()</code>方法</strong>：返回<code>valarray</code>中元素的个数。例如：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::valarray&lt;<span class="hljs-type">double</span>&gt; <span class="hljs-title">va1</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">3.14</span>)</span></span>;<br>std::cout &lt;&lt; va<span class="hljs-number">1.</span><span class="hljs-built_in">size</span>() &lt;&lt; std::endl;  <span class="hljs-comment">// 输出10</span><br></code></pre></td></tr></table></figure><ol><li>数学运算方法<ul><li>算术运算符重载<ul><li><strong>加法</strong>：可以将两个<code>valarray</code>相加，或者将一个<code>valarray</code>与一个标量相加。例如：</li></ul></li></ul></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::valarray&lt;<span class="hljs-type">int</span>&gt; va1 = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>std::valarray&lt;<span class="hljs-type">int</span>&gt; va2 = &#123;<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;;<br>std::valarray&lt;<span class="hljs-type">int</span>&gt; result1 = va1 + va2;  <span class="hljs-comment">// 对应元素相加，result1为&#123;5, 7, 9&#125;</span><br>std::valarray&lt;<span class="hljs-type">int</span>&gt; result2 = va1 + <span class="hljs-number">2</span>;    <span class="hljs-comment">// 每个元素加2，result2为&#123;3, 4, 5&#125;</span><br></code></pre></td></tr></table></figure><ul><li>减法、乘法、除法等运算与之类似<ul><li>减法：<code>std::valarray&lt;int&gt; result3 = va2 - va1;</code>（对应元素相减）</li><li>乘法：<code>std::valarray&lt;int&gt; result4 = va1 * 3;</code>（每个元素乘以 3）</li><li>除法：<code>std::valarray&lt;double&gt; va3 = {4.0, 8.0, 12.0};</code>，<code>std::valarray&lt;double&gt; result5 = va3 / 2.0;</code>（每个元素除以 2.0）</li></ul></li><li>数学函数应用<ul><li><strong><code>std::pow</code>函数</strong>：用于计算<code>valarray</code>中每个元素的幂。例如</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::valarray&lt;<span class="hljs-type">int</span>&gt; va = &#123;<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br>std::valarray&lt;<span class="hljs-type">int</span>&gt; result = std::<span class="hljs-built_in">pow</span>(va, <span class="hljs-number">2</span>);  <span class="hljs-comment">// 计算每个元素的平方，result为&#123;4, 9, 16&#125;</span><br></code></pre></td></tr></table></figure><ul><li><code>std::sin</code>、<code>std::cos</code>等三角函数也可以应用于<code>valarray</code>元素<ul><li>例如<code>std::valarray&lt;double&gt; va1 = {0.0, 3.14159 / 2.0, 3.14159};</code>，<code>std::valarray&lt;double&gt; sin_result = std::sin(va1);</code>，会分别计算<code>va1</code>中每个元素的正弦值。</li></ul></li></ul><ol><li>切片操作（<code>slice</code>）相关方法<ul><li><strong><code>valarray</code>支持切片操作</strong>：可以通过定义<code>slice</code>对象来提取<code>valarray</code>中的一部分元素。例如：</li></ul></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::valarray&lt;<span class="hljs-type">int</span>&gt; va = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>&#125;;<br><span class="hljs-function">std::slice <span class="hljs-title">s</span><span class="hljs-params">(<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>)</span></span>;  <span class="hljs-comment">// 从索引2开始，长度为4，步长为2的切片</span><br>std::valarray&lt;<span class="hljs-type">int</span>&gt; sliced_va = va[s];  <span class="hljs-comment">// sliced_va为&#123;3, 5, 7, 9&#125;</span><br></code></pre></td></tr></table></figure><ul><li><strong><code>cshift</code>方法（循环移位）</strong>：可以对<code>valarray</code>中的元素进行循环移位操作。例如：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::valarray&lt;<span class="hljs-type">int</span>&gt; va = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>std::valarray&lt;<span class="hljs-type">int</span>&gt; shifted_va = va.<span class="hljs-built_in">cshift</span>(<span class="hljs-number">2</span>);  <span class="hljs-comment">// 元素向右循环移2位，shifted_va为&#123;4, 5, 1, 2, 3&#125;</span><br></code></pre></td></tr></table></figure>
          </div>

<h3 id="如何操作has-a关系？"><a href="#如何操作has-a关系？" class="headerlink" title="如何操作has-a关系？"></a>如何操作<code>has-a</code>关系？</h3><p>公有继承比较适合的是<code>is-a-king-of</code>关系的建立，即构建一种<strong>种类上子集</strong>的关系。那如果是是一种<strong>has-a</strong>关系呢？举个简单的例子，我们现在又<strong>string</strong>类（姓名）和<strong>valarry</strong>类（分数）两个底层的基类，我想从这两个基类派生出我的<strong>student类</strong>（每个学生都有自己的姓名和分数）。</p>
<p>如果使用<strong>公有继承</strong>（在这里是多重公有继承），显然不合适。因为学生和姓名不属于同类事物。通常，我们使用<strong>包含（containment）</strong>的技术来构建一种<strong>has-a</strong>关系，即<strong>创建一个包含其他类对象的类</strong>。</p>
<p>下文给出<code>student</code>类的代码示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// studentc.h -- defining a Student class using containment</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> STUDENTC_H_</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> STUDENTC_H_</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span>   </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;valarray&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span><br>&#123;   <br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">typedef</span> std::valarray&lt;<span class="hljs-type">double</span>&gt; ArrayDb;<br>    std::string name;       <span class="hljs-comment">// contained object</span><br>    ArrayDb scores;         <span class="hljs-comment">// contained object</span><br>    <span class="hljs-comment">// private method for scores output</span><br>    <span class="hljs-function">std::ostream &amp; <span class="hljs-title">arr_out</span><span class="hljs-params">(std::ostream &amp; os)</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Student</span>() : <span class="hljs-built_in">name</span>(<span class="hljs-string">&quot;Null Student&quot;</span>), <span class="hljs-built_in">scores</span>() &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Student</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp; s)</span></span><br><span class="hljs-function">        : name(s), scores() &#123;</span>&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Student</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> : name(<span class="hljs-string">&quot;Nully&quot;</span>), scores(n) &#123;</span>&#125;<br>    <span class="hljs-built_in">Student</span>(<span class="hljs-type">const</span> std::string &amp; s, <span class="hljs-type">int</span> n)<br>        : <span class="hljs-built_in">name</span>(s), <span class="hljs-built_in">scores</span>(n) &#123;&#125;<br>    <span class="hljs-built_in">Student</span>(<span class="hljs-type">const</span> std::string &amp; s, <span class="hljs-type">const</span> ArrayDb &amp; a)<br>        : <span class="hljs-built_in">name</span>(s), <span class="hljs-built_in">scores</span>(a) &#123;&#125;<br>    <span class="hljs-built_in">Student</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> * str, <span class="hljs-type">const</span> <span class="hljs-type">double</span> * pd, <span class="hljs-type">int</span> n)<br>        : <span class="hljs-built_in">name</span>(str), <span class="hljs-built_in">scores</span>(pd, n) &#123;&#125;<br>    ~<span class="hljs-built_in">Student</span>() &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">Average</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">const</span> std::string &amp; <span class="hljs-title">Name</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-type">double</span> &amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> i);<br>    <span class="hljs-type">double</span> <span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> i) <span class="hljs-type">const</span>;<br><span class="hljs-comment">// friends</span><br>    <span class="hljs-comment">// input</span><br>    <span class="hljs-keyword">friend</span> std::istream &amp; <span class="hljs-keyword">operator</span>&gt;&gt;(std::istream &amp; is,<br>                                     Student &amp; stu);  <span class="hljs-comment">// 1 word</span><br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> std::istream &amp; <span class="hljs-title">getline</span><span class="hljs-params">(std::istream &amp; is,</span></span><br><span class="hljs-params"><span class="hljs-function">                                  Student &amp; stu)</span></span>;     <span class="hljs-comment">// 1 line</span><br>    <span class="hljs-comment">// output</span><br>    <span class="hljs-keyword">friend</span> std::ostream &amp; <span class="hljs-keyword">operator</span>&lt;&lt;(std::ostream &amp; os,<br>                                     <span class="hljs-type">const</span> Student &amp; stu);<br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br></code></pre></td></tr></table></figure>

<blockquote>
<p>复习一下：<code>explicit</code>关键词可以避免编译器进行隐式类型转换。</p>
<p>在这种情况下，Student类的成员函可以使用string类的共用接口来修改和访问name对象，但是在类的外部只能通过Student类的成员函数对私有数据进行访问。</p>
<p>换句话说，在has-a关系的继承中，<strong>类对象不能自动获得被包含对象的接口，而应该通过定义成员函数来实现。</strong>举个例子，在string类中重载了加法运算符用于字符串的拼接，但是student类继承这种方法是没有任何意义的（你不可以把两个学生拼在一起）。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// studentc.cpp -- Student class using containment</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;studentc.h&quot;</span></span><br><span class="hljs-keyword">using</span> std::ostream;<br><span class="hljs-keyword">using</span> std::endl;<br><span class="hljs-keyword">using</span> std::istream;<br><span class="hljs-keyword">using</span> std::string;<br><br><span class="hljs-comment">//public methods</span><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">Student::Average</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (scores.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> scores.<span class="hljs-built_in">sum</span>()/scores.<span class="hljs-built_in">size</span>();  <br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">const</span> string &amp; <span class="hljs-title">Student::Name</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> name;<br>&#125;<br><br><span class="hljs-type">double</span> &amp; Student::<span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> i)<br>&#123;<br>    <span class="hljs-keyword">return</span> scores[i];         <span class="hljs-comment">// use valarray&lt;double&gt;::operator[]()</span><br>&#125;<br><br><span class="hljs-type">double</span> Student::<span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> i) <span class="hljs-type">const</span><br>&#123;<br>    <span class="hljs-keyword">return</span> scores[i];<br>&#125;<br><br><span class="hljs-comment">// private method</span><br><span class="hljs-function">ostream &amp; <span class="hljs-title">Student::arr_out</span><span class="hljs-params">(ostream &amp; os)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-type">int</span> lim = scores.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">if</span> (lim &gt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; lim; i++)<br>        &#123;<br>            os &lt;&lt; scores[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>            <span class="hljs-keyword">if</span> (i % <span class="hljs-number">5</span> == <span class="hljs-number">4</span>)<br>                os &lt;&lt; endl;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (i % <span class="hljs-number">5</span> != <span class="hljs-number">0</span>)<br>            os &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>        os &lt;&lt; <span class="hljs-string">&quot; empty array &quot;</span>;<br>    <span class="hljs-keyword">return</span> os; <br>&#125;<br><br><span class="hljs-comment">// friends</span><br><br><span class="hljs-comment">// use string version of operator&gt;&gt;()</span><br>istream &amp; <span class="hljs-keyword">operator</span>&gt;&gt;(istream &amp; is, Student &amp; stu)<br>&#123;<br>    is &gt;&gt; stu.name;<br>    <span class="hljs-keyword">return</span> is; <br>&#125;<br><br><span class="hljs-comment">// use string friend getline(ostream &amp;, const string &amp;)</span><br><span class="hljs-function">istream &amp; <span class="hljs-title">getline</span><span class="hljs-params">(istream &amp; is, Student &amp; stu)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">getline</span>(is, stu.name);<br>    <span class="hljs-keyword">return</span> is;<br>&#125;<br><br><span class="hljs-comment">// use string version of operator&lt;&lt;()</span><br>ostream &amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp; os, <span class="hljs-type">const</span> Student &amp; stu)<br>&#123;<br>    os &lt;&lt; <span class="hljs-string">&quot;Scores for &quot;</span> &lt;&lt; stu.name &lt;&lt; <span class="hljs-string">&quot;:\n&quot;</span>;<br>    stu.<span class="hljs-built_in">arr_out</span>(os);  <span class="hljs-comment">// use private method for scores</span><br>    <span class="hljs-keyword">return</span> os;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h3 id="私有继承与保护继承（Additional）"><a href="#私有继承与保护继承（Additional）" class="headerlink" title="私有继承与保护继承（Additional）"></a>私有继承与保护继承（Additional）</h3><p>在C++中，<strong>私有继承</strong>也是实现<strong>has-a</strong>关系的重要实现方式之一，在这里不再展开涉及具体的细节（毕竟第一种方法已经够用了，不是吗），只给出头文件的语法规范示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// studenti.h -- defining a Student class using private inheritance</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> STUDENTC_H_</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> STUDENTC_H_</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;valarray&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span>   </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> : <span class="hljs-keyword">private</span> std::string, <span class="hljs-keyword">private</span> std::valarray&lt;<span class="hljs-type">double</span>&gt;<br>&#123;   <br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">typedef</span> std::valarray&lt;<span class="hljs-type">double</span>&gt; ArrayDb;<br>    <span class="hljs-comment">// private method for scores output</span><br>    <span class="hljs-function">std::ostream &amp; <span class="hljs-title">arr_out</span><span class="hljs-params">(std::ostream &amp; os)</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Student</span>() : std::<span class="hljs-built_in">string</span>(<span class="hljs-string">&quot;Null Student&quot;</span>), <span class="hljs-built_in">ArrayDb</span>() &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Student</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp; s)</span></span><br><span class="hljs-function">            : std::string(s), ArrayDb() &#123;</span>&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Student</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> : std::string(<span class="hljs-string">&quot;Nully&quot;</span>), ArrayDb(n) &#123;</span>&#125;<br>    <span class="hljs-built_in">Student</span>(<span class="hljs-type">const</span> std::string &amp; s, <span class="hljs-type">int</span> n)<br>            : std::<span class="hljs-built_in">string</span>(s), <span class="hljs-built_in">ArrayDb</span>(n) &#123;&#125;<br>    <span class="hljs-built_in">Student</span>(<span class="hljs-type">const</span> std::string &amp; s, <span class="hljs-type">const</span> ArrayDb &amp; a)<br>            : std::<span class="hljs-built_in">string</span>(s), <span class="hljs-built_in">ArrayDb</span>(a) &#123;&#125;<br>    <span class="hljs-built_in">Student</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> * str, <span class="hljs-type">const</span> <span class="hljs-type">double</span> * pd, <span class="hljs-type">int</span> n)<br>            : std::<span class="hljs-built_in">string</span>(str), <span class="hljs-built_in">ArrayDb</span>(pd, n) &#123;&#125;<br>    ~<span class="hljs-built_in">Student</span>() &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">Average</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-type">double</span> &amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> i);<br>    <span class="hljs-type">double</span> <span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> i) <span class="hljs-type">const</span>;<br>    <span class="hljs-function"><span class="hljs-type">const</span> std::string &amp; <span class="hljs-title">Name</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-comment">// friends</span><br>    <span class="hljs-comment">// input</span><br>    <span class="hljs-keyword">friend</span> std::istream &amp; <span class="hljs-keyword">operator</span>&gt;&gt;(std::istream &amp; is,<br>                                     Student &amp; stu);  <span class="hljs-comment">// 1 word</span><br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> std::istream &amp; <span class="hljs-title">getline</span><span class="hljs-params">(std::istream &amp; is,</span></span><br><span class="hljs-params"><span class="hljs-function">                                  Student &amp; stu)</span></span>;     <span class="hljs-comment">// 1 line</span><br>    <span class="hljs-comment">// output</span><br>    <span class="hljs-keyword">friend</span> std::ostream &amp; <span class="hljs-keyword">operator</span>&lt;&lt;(std::ostream &amp; os,<br>                                     <span class="hljs-type">const</span> Student &amp; stu);<br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br></code></pre></td></tr></table></figure>

<h2 id="Multiple-Inheritance"><a href="#Multiple-Inheritance" class="headerlink" title="Multiple Inheritance"></a>Multiple Inheritance</h2><p>从单继承，我们很容易的推理出多重继承（Multiple Inheritance），简称MI。</p>
<p><img src="/posts/Above-All/-in-OOP/MI.png" srcset="/img/loading.gif" lazyload alt="Multiple Inheritance"></p>
<div class="note note-danger">
            <p><strong>注意！！！多重继承在一定程度上大大提高了继承的复杂性！一定要慎用！（笔者建议能使用单继承就使用单继承）</strong></p>
          </div>

<div class="note note-info">
            <h3 id="小故事：钻石问题"><a href="#小故事：钻石问题" class="headerlink" title="小故事：钻石问题"></a>小故事：钻石问题</h3><p>钻石问题（Diamond Problem）是多重继承中的一个经典问题，特别是在面向对象编程语言中。这个问题发生在一个类继承自两个或更多有共同父类的类时，导致继承结构中产生二义性和不明确的继承路径。它的名字来源于继承关系图形的形状，通常呈现一个钻石形状。</p><p><strong>钻石问题的例子</strong>：</p><p>假设有一个类 <code>A</code>，它是两个类 <code>B</code> 和 <code>C</code> 的父类，而 <code>B</code> 和 <code>C</code> 又被一个类 <code>D</code> 继承。继承关系可以表示为一个钻石形状：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Css">  <span class="hljs-selector-tag">A</span><br> / \<br><span class="hljs-selector-tag">B</span>   C<br> \ /<br>  D<br></code></pre></td></tr></table></figure><p><strong>问题的具体情况</strong>：</p><p>在这个继承关系中，类 <code>B</code> 和类 <code>C</code> 都继承了类 <code>A</code>，并且类 <code>D</code> 同时继承了 <code>B</code> 和 <code>C</code>。假设类 <code>A</code> 中有一个成员函数 <code>foo()</code>，而类 <code>B</code> 和类 <code>C</code> 都没有覆盖（override）该函数。那么，类 <code>D</code> 在继承时会遇到以下问题：</p><ul><li><strong>二义性</strong>：类 <code>D</code> 继承了 <code>B</code> 和 <code>C</code>，它同时会继承来自 <code>A</code> 的 <code>foo()</code> 函数。但是，当你尝试调用 <code>foo()</code> 时，编译器无法确定应该调用 <code>B</code> 中的 <code>foo()</code>，还是 <code>C</code> 中的 <code>foo()</code>（假设 <code>B</code> 和 <code>C</code> 都没有覆盖这个函数）。如果 <code>B</code> 和 <code>C</code> 都没有 <code>foo()</code>，那么 <code>D</code> 也会得到二义性错误。</li><li><strong>重复继承</strong>：由于 <code>B</code> 和 <code>C</code> 都继承自 <code>A</code>，在类 <code>D</code> 中可能会包含 <code>A</code> 的多个副本，导致同一个基类成员被多次继承，这种冗余的继承可能会导致不必要的资源浪费和代码混乱。</li></ul><blockquote><p>实际上，C++ 引入了 <strong>虚拟继承（Virtual Inheritance）</strong> 来解决钻石问题。虚拟继承可以确保在多重继承时，<code>A</code> 类的子对象只会被继承一次。</p></blockquote>
          </div>

<h2 id="Class-Template"><a href="#Class-Template" class="headerlink" title="Class Template"></a>Class Template</h2><p>在函数章节，我们学习了模版函数，实现了一个模版在多个不同数据类型之间的通用，大大提高了代码重用的效率。在类的定义中同样也是如此，模板提供<strong>参数化（parameterized）类型</strong>，即能够将类型名作为参数传递给接收方来建立类或函数。例如，将类型名 <code>int</code> 传递给 <code>Queue</code> 模板，可以让编译器构造一个对 int 进行排队的 <code>Queue</code> 类。  </p>
<p>在接下来的内容中，我们将以非常重要的数据结构——<strong>栈（Stack）</strong>为示例，向读者演示模板类的强大之处。</p>
<h3 id="The-Implementation-of-Stack"><a href="#The-Implementation-of-Stack" class="headerlink" title="The Implementation of Stack"></a>The Implementation of Stack</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// stack.h -- class definition for the stack ADT</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> STACK_H_</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> STACK_H_</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> Item;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Stack</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">enum</span> &#123;MAX = <span class="hljs-number">10</span>&#125;;    <span class="hljs-comment">// constant specific to class</span><br>    Item items[MAX];    <span class="hljs-comment">// holds stack items</span><br>    <span class="hljs-type">int</span> top;            <span class="hljs-comment">// index for top stack item</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Stack</span>();<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isempty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isfull</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-comment">// push() returns false if stack already is full, true otherwise</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">const</span> Item &amp; item)</span></span>;   <span class="hljs-comment">// add item to stack</span><br>    <span class="hljs-comment">// pop() returns false if stack already is empty, true otherwise</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">pop</span><span class="hljs-params">(Item &amp; item)</span></span>;          <span class="hljs-comment">// pop top into item</span><br>&#125;;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><br><span class="hljs-comment">// stack.cpp -- Stack member functions</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stack.h&quot;</span></span><br>Stack::<span class="hljs-built_in">Stack</span>()    <span class="hljs-comment">// create an empty stack</span><br>&#123;<br>    top = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Stack::isempty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> top == <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Stack::isfull</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> top == MAX;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Stack::push</span><span class="hljs-params">(<span class="hljs-type">const</span> Item &amp; item)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (top &lt; MAX)<br>    &#123;<br>        items[top++] = item;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Stack::pop</span><span class="hljs-params">(Item &amp; item)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (top &gt; <span class="hljs-number">0</span>)<br>    &#123;<br>        item = items[--top];<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <br>&#125;<br><br></code></pre></td></tr></table></figure>

<blockquote>
<p>在第十章书中给出了针对<code>unsigned long</code>类型的栈数据结构示例，此处不再解释具体代码的含义。</p>
</blockquote>
<h3 id="The-Definition"><a href="#The-Definition" class="headerlink" title="The Definition"></a>The Definition</h3><p>我们先给出模板类的头文件声明，读者可以自行比较有哪边进行了修改：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Type</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Stack</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">enum</span> &#123;SIZE = <span class="hljs-number">10</span>&#125;;    <span class="hljs-comment">// default size</span><br>    <span class="hljs-type">int</span> stacksize;<br>    Type * items;       <span class="hljs-comment">// holds stack items</span><br>    <span class="hljs-comment">//在这里优化为了指针，更加的高效（相比使用数组存储）</span><br>    <span class="hljs-type">int</span> top;            <span class="hljs-comment">// index for top stack item</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Stack</span><span class="hljs-params">(<span class="hljs-type">int</span> ss = SIZE)</span></span>;<br>    <span class="hljs-built_in">Stack</span>(<span class="hljs-type">const</span> Stack &amp; st);<br>    ~<span class="hljs-built_in">Stack</span>() &#123; <span class="hljs-keyword">delete</span> [] items; &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isempty</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> top == <span class="hljs-number">0</span>; &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isfull</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> top == stacksize; &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">const</span> Type &amp; item)</span></span>;   <span class="hljs-comment">// add item to stack</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">pop</span><span class="hljs-params">(Type &amp; item)</span></span>;          <span class="hljs-comment">// pop top into item</span><br>    Stack &amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Stack &amp; st);<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>采用模板时，将使用模板定义替换 <code>Stack</code> 声明，使用模板成员函数替换 <code>Stack</code> 的成员函数。和模板函数一样，模板类以下面这样的代码开头 :<code>template &lt;class Type&gt;</code>。</p>
<p>剩下的操作基本上没什么区别了。（因为定义类在很大程度上就是定义成员函数和方法。那定义模版类就是定义模版函数的过程）</p>
<p>接下来我们来看类方法的定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Type</span>&gt;<br>    <span class="hljs-comment">//这一行必不可少（相当于定义模版函数的过程）</span><br>Stack&lt;Type&gt;::<span class="hljs-built_in">Stack</span>(<span class="hljs-type">int</span> ss) : <span class="hljs-built_in">stacksize</span>(ss), <span class="hljs-built_in">top</span>(<span class="hljs-number">0</span>)<br>&#123;<br>    items = <span class="hljs-keyword">new</span> Type [stacksize];<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Type</span>&gt;<br>Stack&lt;Type&gt;::<span class="hljs-built_in">Stack</span>(<span class="hljs-type">const</span> Stack &amp; st)<br>&#123;<br>    stacksize = st.stacksize;<br>    top = st.top;<br>    items = <span class="hljs-keyword">new</span> Type [stacksize];<br>    <span class="hljs-comment">//使用动态内存分配，注意指针的安全使用！</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; top; i++)<br>        items[i] = st.items[i];<br>&#125;<br><span class="hljs-comment">//这个显示复制构造函数也是为了指针栈的使用（后文会提到）</span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Type</span>&gt;<br><span class="hljs-type">bool</span> Stack&lt;Type&gt;::<span class="hljs-built_in">push</span>(<span class="hljs-type">const</span> Type &amp; item)<br>&#123;<br>    <span class="hljs-keyword">if</span> (top &lt; stacksize)<br>    &#123;<br>        items[top++] = item;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Type</span>&gt;<br><span class="hljs-type">bool</span> Stack&lt;Type&gt;::<span class="hljs-built_in">pop</span>(Type &amp; item)<br>&#123;<br>    <span class="hljs-keyword">if</span> (top &gt; <span class="hljs-number">0</span>)<br>    &#123;<br>        item = items[--top];<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Type</span>&gt;<br>Stack&lt;Type&gt; &amp; Stack&lt;Type&gt;::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Stack&lt;Type&gt; &amp; st)<br>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;st)<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    <span class="hljs-keyword">delete</span> [] items;<br>    stacksize = st.stacksize;<br>    top = st.top;<br>    items = <span class="hljs-keyword">new</span> Type [stacksize];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; top; i++)<br>        items[i] = st.items[i];<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>; <br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br></code></pre></td></tr></table></figure>

<h3 id="The-Use-of-Pointer-Stack"><a href="#The-Use-of-Pointer-Stack" class="headerlink" title="The Use of Pointer Stack"></a>The Use of Pointer Stack</h3><p>细心的读者可能会发现，在模版类的函数定义中，多出了这样一个函数（对赋值运算符的运算符重载）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++">Stack &amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Stack &amp; st);<br><span class="hljs-comment">//在public中的函数声明</span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Type</span>&gt;<br>Stack&lt;Type&gt; &amp; Stack&lt;Type&gt;::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Stack&lt;Type&gt; &amp; st)<br>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;st)<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    <span class="hljs-keyword">delete</span> [] items;<br>    stacksize = st.stacksize;<br>    top = st.top;<br>    items = <span class="hljs-keyword">new</span> Type [stacksize];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; top; i++)<br>        items[i] = st.items[i];<br>    <span class="hljs-comment">//考虑到如果数据类型为指针，直接整块赋值会产生非常严重的问题。</span><br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>; <br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>同时，对构造函数和析构函数的定义也做出了相关修改。</p>
</blockquote>
<p>为什么要做这样一个修改？<strong>模板类和模版函数非常重要的一点就是模版必须具有通用性</strong>（也可以使用<strong>显示具体化</strong>来为特殊类型打补丁，后文会讲到）。如果模板类型是<strong>指针</strong>（即<strong>指针栈</strong>），那么使用默认的赋值运算符会产生比较严重的问题。</p>
<blockquote>
<p>什么严重的问题？欢迎参考第十二章有关动态内存分配的知识，此处不再展开。</p>
<p><a href="https://xiyuanyang-code.github.io/posts/Dynamic-Memory-and-Classes/">我的博客链接</a></p>
</blockquote>
<h4 id="正确使用指针栈"><a href="#正确使用指针栈" class="headerlink" title="正确使用指针栈"></a>正确使用指针栈</h4><p>使用指针栈的方法之一是，让调用程序提供一个指针数组，其中每个指针都指向不同的字符串。把这些指针放在栈中是有意义的，因为每个指针都将指向不同的字符串。注意，创建不同指针是调用程序的职责，而不是栈的职责。<strong>栈的任务是管理指针，而不是创建指针</strong>。  </p>
<h3 id="Advanced-Usage"><a href="#Advanced-Usage" class="headerlink" title="Advanced Usage"></a>Advanced Usage</h3><h4 id="非类型参数"><a href="#非类型参数" class="headerlink" title="非类型参数"></a>非类型参数</h4><p>在使用模板类的时候，我们通过构造函数在堆上动态分配内存，这样的效率往往比较低。如果<strong>在确定具体类型之后再栈上开辟空间，将会变得更加的高效。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//arraytp.h  -- Array Template</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> ARRAYTP_H_</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ARRAYTP_H_</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>, <span class="hljs-type">int</span> n&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayTP</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>    T ar[n];<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">ArrayTP</span>() &#123;&#125;;<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">ArrayTP</span><span class="hljs-params">(<span class="hljs-type">const</span> T &amp; v)</span></span>;<br>    <span class="hljs-keyword">virtual</span> T &amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> i);<br>    <span class="hljs-keyword">virtual</span> T <span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> i) <span class="hljs-type">const</span>;<br>&#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>, <span class="hljs-type">int</span> n&gt;<br>ArrayTP&lt;T,n&gt;::<span class="hljs-built_in">ArrayTP</span>(<span class="hljs-type">const</span> T &amp; v)<br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        ar[i] = v;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>, <span class="hljs-type">int</span> n&gt;<br>T &amp; ArrayTP&lt;T,n&gt;::<span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> i)<br>&#123;<br>    <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || i &gt;= n)<br>    &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;Error in array limits: &quot;</span> &lt;&lt; i<br>            &lt;&lt; <span class="hljs-string">&quot; is out of range\n&quot;</span>;<br>        std::<span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ar[i];<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>, <span class="hljs-type">int</span> n&gt;<br>T ArrayTP&lt;T,n&gt;::<span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> i) <span class="hljs-type">const</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || i &gt;= n)<br>    &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;Error in array limits: &quot;</span> &lt;&lt; i<br>            &lt;&lt; <span class="hljs-string">&quot; is out of range\n&quot;</span>;<br>        std::<span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ar[i]; <br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure>

<p><code>template &lt;class T, int n&gt;</code> 是 C++ 中的一种模板声明方式，其中包含了两种不同类型的模板参数：</p>
<ul>
<li><strong><code>T</code><strong>：这是一个</strong>类型模板参数</strong>（Type Template Parameter），表示一个类型，通常用来代表类、结构体、函数等的类型。</li>
<li><strong><code>n</code><strong>：这是一个</strong>非类型模板参数</strong>（Non-type Template Parameter），表示一个常量值，通常是整数、指针、引用或其他常量值。</li>
</ul>
<p><img src="/posts/Above-All/-in-OOP/biaodashi.png" srcset="/img/loading.gif" lazyload alt="表达式参数"></p>
<p>缺点是，在<code>n</code>不相同的情况下，编译器会生成两种不同的模版（<strong>哪怕非类型模版参数是相同的</strong>）。非类型参数的使用本质是更改了内存的存储方式，在提升效率的同时牺牲了部分的通用性。（无法创建数组大小可变的类了）</p>
<h4 id="递归使用模板"><a href="#递归使用模板" class="headerlink" title="递归使用模板"></a>递归使用模板</h4><p><code>ArrayTP&lt; ArrayTP&lt;int,5&gt;, 10&gt; twodee;</code></p>
<h4 id="pair类"><a href="#pair类" class="headerlink" title="pair类"></a>pair类</h4><div class="note note-info">
            <p><code>std::pair</code> 是 C++ 标准库中的一个模板类，用于存储两个不同类型的元素。它可以将两个数据组合成一个对象，这两个数据可以是任意类型，因此 <code>std::pair</code> 是一种非常常见的<strong>通用容器</strong>，特别适用于需要将两个相关数据关联在一起的场景。</p><p><code>std::pair</code> 定义在 <code>&lt;utility&gt;</code> 头文件中，其模板定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span>&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">pair</span> &#123;<br>    T1 first;   <span class="hljs-comment">// 第一个元素</span><br>    T2 second;  <span class="hljs-comment">// 第二个元素</span><br><br>    <span class="hljs-comment">// 默认构造函数</span><br>    <span class="hljs-built_in">pair</span>();<br>    <br>    <span class="hljs-comment">// 带参数的构造函数</span><br>    <span class="hljs-built_in">pair</span>(<span class="hljs-type">const</span> T1&amp; a, <span class="hljs-type">const</span> T2&amp; b);<br>    <br>    <span class="hljs-comment">// 构造函数（使用移动语义）</span><br>    <span class="hljs-built_in">pair</span>(T1&amp;&amp; a, T2&amp;&amp; b);<br><br>    <span class="hljs-comment">// 比较运算符</span><br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> pair&amp; other) <span class="hljs-type">const</span>;<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-type">const</span> pair&amp; other) <span class="hljs-type">const</span>;<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> pair&amp; other) <span class="hljs-type">const</span>;<br>    <span class="hljs-type">bool</span> <span class="hljs-built_in">operator</span>&lt;=(<span class="hljs-type">const</span> pair&amp; other) <span class="hljs-type">const</span>;<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&gt;(<span class="hljs-type">const</span> pair&amp; other) <span class="hljs-type">const</span>;<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&gt;=(<span class="hljs-type">const</span> pair&amp; other) <span class="hljs-type">const</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p><code>std::pair</code> 存储两个值：<code>first</code> 和 <code>second</code>，它们可以是不同类型的数据。<code>T1</code> 是第一个元素的类型，<code>T2</code> 是第二个元素的类型。</p><ul><li><p><strong>默认构造函数</strong>：<code>pair</code> 的两个成员 <code>first</code> 和 <code>second</code> 都会被默认初始化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">double</span>&gt; p1;  <span class="hljs-comment">// p1.first 和 p1.second 都是默认初始化</span><br></code></pre></td></tr></table></figure></li><li><p><strong>带参构造函数</strong>：通过提供两个值初始化 <code>first</code> 和 <code>second</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">double</span>&gt; <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">3.14</span>)</span></span>;  <span class="hljs-comment">// p2.first = 1, p2.second = 3.14</span><br></code></pre></td></tr></table></figure></li><li><p><strong>拷贝构造函数</strong>：允许使用另一个 <code>pair</code> 来初始化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">double</span>&gt; p3 = p2;  <span class="hljs-comment">// p3.first = p2.first, p3.second = p2.second</span><br></code></pre></td></tr></table></figure></li><li><p><strong>移动构造函数</strong>：允许通过右值引用来初始化（C++11 引入的特性）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">double</span>&gt; p4 = std::<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20.5</span>);<br></code></pre></td></tr></table></figure></li></ul><p><strong>操作：</strong></p><ul><li><p><strong>访问成员</strong>：<code>pair</code> 提供了两个公共成员变量 <code>first</code> 和 <code>second</code>，可以直接访问。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">double</span>&gt; <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">3.14</span>)</span></span>;<br>std::cout &lt;&lt; p.first &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; p.second &lt;&lt; std::endl;  <span class="hljs-comment">// 输出: 1, 3.14</span><br></code></pre></td></tr></table></figure></li><li><p>**<code>std::make_pair</code>**：<code>make_pair</code> 是一个方便的函数模板，用于创建 <code>pair</code> 对象，避免手动指定类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> p = std::<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">1</span>, <span class="hljs-number">3.14</span>);  <span class="hljs-comment">// p 是 pair&lt;int, double&gt;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>比较操作符</strong>：<code>pair</code> 支持常见的比较操作符（<code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>）。比较时，<code>pair</code> 会首先比较 <code>first</code>，如果相等，则再比较 <code>second</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">double</span>&gt; <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">3.14</span>)</span>, <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2.718</span>)</span></span>;<br><span class="hljs-keyword">if</span> (p1 &lt; p2) &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;p1 &lt; p2&quot;</span> &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>交换元素</strong>：<code>std::pair</code> 提供了一个 <code>swap</code> 方法用于交换 <code>first</code> 和 <code>second</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">double</span>&gt; <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">3.14</span>)</span>, <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-number">2</span>, <span class="hljs-number">2.718</span>)</span></span>;<br>p<span class="hljs-number">1.</span><span class="hljs-built_in">swap</span>(p2);  <span class="hljs-comment">// 交换 p1 和 p2 的值</span><br></code></pre></td></tr></table></figure></li></ul><p><strong>使用场景</strong></p><p><code>std::pair</code> 经常用于以下场景：</p><ul><li><p><strong>返回多个值</strong>：有时我们需要返回多个相关的值（例如，函数返回两个值），<code>std::pair</code> 是一个非常方便的方式来做到这一点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">double</span>&gt; <span class="hljs-title">get_coordinates</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20.5</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>在容器中存储键值对</strong>：例如，<code>std::map</code> 和 <code>std::unordered_map</code> 等容器使用 <code>std::pair</code> 来存储键值对。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::map&lt;<span class="hljs-type">int</span>, std::string&gt; m;<br>m[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;apple&quot;</span>;<br>m[<span class="hljs-number">2</span>] = <span class="hljs-string">&quot;banana&quot;</span>;<br></code></pre></td></tr></table></figure></li><li><p><strong>配对数据</strong>：在某些算法或数据结构中，两个相关的数据项经常被配对在一起。<code>std::pair</code> 允许你简洁地存储和访问它们。</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span>  <span class="hljs-comment">// 引入 std::pair 和 std::make_pair</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 创建一个 pair</span><br>    <span class="hljs-function">std::pair&lt;<span class="hljs-type">int</span>, std::string&gt; <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;apple&quot;</span>)</span></span>;<br><br>    <span class="hljs-comment">// 访问 pair 的元素</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;First: &quot;</span> &lt;&lt; p<span class="hljs-number">1.f</span>irst &lt;&lt; <span class="hljs-string">&quot;, Second: &quot;</span> &lt;&lt; p<span class="hljs-number">1.</span>second &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 使用 std::make_pair 创建一个 pair</span><br>    <span class="hljs-keyword">auto</span> p2 = std::<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;banana&quot;</span>);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;First: &quot;</span> &lt;&lt; p<span class="hljs-number">2.f</span>irst &lt;&lt; <span class="hljs-string">&quot;, Second: &quot;</span> &lt;&lt; p<span class="hljs-number">2.</span>second &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 比较两个 pair</span><br>    <span class="hljs-keyword">if</span> (p1 &lt; p2) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;p1 is less than p2&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-comment">// 交换两个 pair</span><br>    p<span class="hljs-number">1.</span><span class="hljs-built_in">swap</span>(p2);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;After swap: &quot;</span> &lt;&lt; <span class="hljs-string">&quot;First: &quot;</span> &lt;&lt; p<span class="hljs-number">1.f</span>irst &lt;&lt; <span class="hljs-string">&quot;, Second: &quot;</span> &lt;&lt; p<span class="hljs-number">1.</span>second &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;After swap: &quot;</span> &lt;&lt; <span class="hljs-string">&quot;First: &quot;</span> &lt;&lt; p<span class="hljs-number">2.f</span>irst &lt;&lt; <span class="hljs-string">&quot;, Second: &quot;</span> &lt;&lt; p<span class="hljs-number">2.</span>second &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">First</span>: <span class="hljs-number">1</span>, <span class="hljs-keyword">Second</span>: apple<br><span class="hljs-keyword">First</span>: <span class="hljs-number">2</span>, <span class="hljs-keyword">Second</span>: banana<br>p1 <span class="hljs-keyword">is</span> less than p2<br>After swap: <span class="hljs-keyword">First</span>: <span class="hljs-number">2</span>, <span class="hljs-keyword">Second</span>: banana<br>After swap: <span class="hljs-keyword">First</span>: <span class="hljs-number">1</span>, <span class="hljs-keyword">Second</span>: apple<br></code></pre></td></tr></table></figure><h4 id="tuple和tie（补充知识）"><a href="#tuple和tie（补充知识）" class="headerlink" title="tuple和tie（补充知识）"></a>tuple和tie（补充知识）</h4><h5 id="打包函数：std-tie"><a href="#打包函数：std-tie" class="headerlink" title="打包函数：std::tie"></a>打包函数：<code>std::tie</code></h5><p><code>std::tie</code> 是 C++11 引入的一个非常强大且方便的工具，它可以将多个值打包成一个元组，并使得这些值能够像元组一样被进行比较、解构或传递。它在多个方面提供了便利，以下是其强大之处：</p><ol><li><strong>简化多重比较</strong></li></ol><p><code>std::tie</code> 可以将多个变量组合成一个元组，然后直接进行比较。这样，我们可以避免手动写出冗长的多重 <code>if</code> 语句来比较多个值。例如，比较结构体中的多个成员时，<code>std::tie</code> 可以将多个成员打包，按字典顺序（lexicographical order）进行比较。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span> &#123;<br>    <span class="hljs-type">int</span> x, y, z;<br>&#125;;<br><br><span class="hljs-comment">// 使用 std::tie 对 Point 进行比较</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-type">const</span> Point&amp; p1, <span class="hljs-type">const</span> Point&amp; p2)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">tie</span>(p<span class="hljs-number">1.</span>x, p<span class="hljs-number">1.</span>y, p<span class="hljs-number">1.</span>z) &lt; std::<span class="hljs-built_in">tie</span>(p<span class="hljs-number">2.</span>x, p<span class="hljs-number">2.</span>y, p<span class="hljs-number">2.</span>z);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的比较会首先比较 <code>x</code>，如果 <code>x</code> 相同，再比较 <code>y</code>，如果 <code>y</code> 也相同，则比较 <code>z</code>。<strong>这是一个典型的按字典顺序的比较</strong>。</p><ol start="2"><li><strong>简化排序操作</strong></li></ol><p>通过 <code>std::tie</code>，你可以在排序操作中直接比较多个字段，而无需手动指定每个字段的比较方式。比如在 <code>std::sort</code> 中进行排序时，使用 <code>std::tie</code> 让代码更加简洁且易于维护。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;Point&gt; points = &#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;, &#123;<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;&#125;;<br>std::<span class="hljs-built_in">sort</span>(points.<span class="hljs-built_in">begin</span>(), points.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">const</span> Point&amp; p1, <span class="hljs-type">const</span> Point&amp; p2) &#123;<br>    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">tie</span>(p<span class="hljs-number">1.</span>x, p<span class="hljs-number">1.</span>y, p<span class="hljs-number">1.</span>z) &lt; std::<span class="hljs-built_in">tie</span>(p<span class="hljs-number">2.</span>x, p<span class="hljs-number">2.</span>y, p<span class="hljs-number">2.</span>z);<br>&#125;);<br></code></pre></td></tr></table></figure><p>这样，排序时就不需要多个嵌套的 <code>if</code> 语句来分别比较 <code>x</code>, <code>y</code>, <code>z</code>。<code>std::tie</code> 会自动按字段顺序进行比较。</p><ol start="3"><li><strong>方便的结构体解构</strong></li></ol><p><code>std::tie</code> 不仅可以用于比较，还可以用于解构，特别是在函数中返回多个值时，或者从一个元组中提取值时。它让你可以直接将多个值赋给多个变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::tuple&lt;<span class="hljs-type">int</span>, <span class="hljs-type">double</span>, std::string&gt; <span class="hljs-title">getValues</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">make_tuple</span>(<span class="hljs-number">1</span>, <span class="hljs-number">3.14</span>, <span class="hljs-string">&quot;hello&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-type">double</span> d;<br>    std::string s;<br>    std::<span class="hljs-built_in">tie</span>(i, d, s) = <span class="hljs-built_in">getValues</span>();  <span class="hljs-comment">// 直接解构</span><br>    std::cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; d &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; s &lt;&lt; std::endl;  <span class="hljs-comment">// 输出: 1 3.14 hello</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这样，你就可以将一个元组中的元素直接解构到不同的变量中，而不需要手动访问每个元素。</p><ol start="4"><li><strong>元组和非元组类型的统一接口</strong></li></ol><p><code>std::tie</code> 的强大之处还在于它能够与普通类型（如 <code>int</code>，<code>double</code> 等）和标准库类型（如 <code>std::tuple</code>）无缝结合。这使得你在处理多个返回值时非常方便。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a = <span class="hljs-number">5</span>;<br><span class="hljs-type">double</span> b = <span class="hljs-number">3.14</span>;<br>std::<span class="hljs-built_in">tie</span>(a, b) = std::<span class="hljs-built_in">make_tuple</span>(<span class="hljs-number">10</span>, <span class="hljs-number">2.718</span>);  <span class="hljs-comment">// 可以直接解构元组</span><br></code></pre></td></tr></table></figure><ol start="5"><li><strong>更灵活的函数返回值</strong></li></ol><p>当你需要一个函数返回多个值时，<code>std::tie</code> 可以帮助你轻松解构并同时返回多个值，而不需要使用 <code>std::pair</code> 或 <code>std::tuple</code> 来包裹它们。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::tuple&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; <span class="hljs-title">divide</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">make_tuple</span>(a / b, a % b);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> quotient, remainder;<br>    std::<span class="hljs-built_in">tie</span>(quotient, remainder) = <span class="hljs-built_in">divide</span>(<span class="hljs-number">10</span>, <span class="hljs-number">3</span>);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Quotient: &quot;</span> &lt;&lt; quotient &lt;&lt; <span class="hljs-string">&quot;, Remainder: &quot;</span> &lt;&lt; remainder &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure>
          </div>

<div class="note note-info">
            <h5 id="std-tuple"><a href="#std-tuple" class="headerlink" title="std::tuple"></a><code>std::tuple</code></h5><p><code>std::tuple</code> 是 C++11 引入的一个标准库容器，它允许你存储多个不同类型的元素，类似于数组或结构体，但与这两者不同的是，<code>std::tuple</code> 的元素可以是不同类型的。换句话说，<code>tuple</code> 可以看作是一个异构的容器，即它可以存储多个不同类型的值，而不像数组那样只能存储相同类型的元素。</p><ul><li><strong>异构性</strong>：<code>std::tuple</code> 可以包含不同类型的元素（如 <code>int</code>、<code>double</code>、<code>std::string</code> 等），而不像 <code>std::vector</code> 或 <code>std::array</code> 这样的容器只能包含相同类型的元素。</li><li><strong>固定大小</strong>：<code>std::tuple</code> 的大小在编译时就确定了，无法动态改变大小。也就是说，它的大小（即元素的个数）是固定的。</li><li><strong>元素访问</strong>：可以通过索引或者 <code>std::get</code> 来访问 <code>tuple</code> 中的元素。</li></ul><p>你可以通过 <code>std::make_tuple</code> 或直接使用构造函数来创建 <code>tuple</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;tuple&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 创建一个 tuple，包含不同类型的元素</span><br>    <span class="hljs-function">std::tuple&lt;<span class="hljs-type">int</span>, <span class="hljs-type">double</span>, std::string&gt; <span class="hljs-title">t</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">3.14</span>, <span class="hljs-string">&quot;Hello&quot;</span>)</span></span>;<br><br>    <span class="hljs-comment">// 通过 std::get 访问 tuple 中的元素</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;First element: &quot;</span> &lt;&lt; std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">0</span>&gt;(t) &lt;&lt; std::endl;  <span class="hljs-comment">// 输出 10</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Second element: &quot;</span> &lt;&lt; std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">1</span>&gt;(t) &lt;&lt; std::endl; <span class="hljs-comment">// 输出 3.14</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Third element: &quot;</span> &lt;&lt; std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">2</span>&gt;(t) &lt;&lt; std::endl;  <span class="hljs-comment">// 输出 Hello</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>t</code> 是一个包含三个元素的 <code>tuple</code>，它的元素分别是 <code>int</code>、<code>double</code> 和 <code>std::string</code> 类型。</p><p><strong>获取 <code>tuple</code> 中的元素：</strong></p><p>使用 <code>std::get&lt;index&gt;(tuple)</code> 来访问特定位置的元素。索引是编译时确定的，因此使用时需要指定元素的类型或位置。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::tuple&lt;<span class="hljs-type">int</span>, <span class="hljs-type">double</span>, std::string&gt; <span class="hljs-title">t</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">3.14</span>, <span class="hljs-string">&quot;Hello&quot;</span>)</span></span>;<br><br><span class="hljs-comment">// 使用 std::get 获取元素</span><br><span class="hljs-type">int</span> i = std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">0</span>&gt;(t);           <span class="hljs-comment">// 获取第一个元素</span><br><span class="hljs-type">double</span> d = std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">1</span>&gt;(t);        <span class="hljs-comment">// 获取第二个元素</span><br>std::string s = std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">2</span>&gt;(t);   <span class="hljs-comment">// 获取第三个元素</span><br></code></pre></td></tr></table></figure><p><strong>获取 <code>tuple</code> 的大小：</strong></p><p>你可以使用 <code>std::tuple_size</code> 来获取 <code>tuple</code> 中元素的个数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::tuple&lt;<span class="hljs-type">int</span>, <span class="hljs-type">double</span>, std::string&gt; <span class="hljs-title">t</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">3.14</span>, <span class="hljs-string">&quot;Hello&quot;</span>)</span></span>;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;Tuple size: &quot;</span> &lt;&lt; std::tuple_size&lt;<span class="hljs-keyword">decltype</span>(t)&gt;::value &lt;&lt; std::endl;  <span class="hljs-comment">// 输出 3</span><br></code></pre></td></tr></table></figure><p><strong>解构 <code>tuple</code>：</strong></p><p>你可以使用 <code>std::tie</code> 来解构 <code>tuple</code> 中的值，或者直接通过 <code>std::get</code> 提取多个值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::tuple&lt;<span class="hljs-type">int</span>, <span class="hljs-type">double</span>, std::string&gt; <span class="hljs-title">t</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">3.14</span>, <span class="hljs-string">&quot;Hello&quot;</span>)</span></span>;<br><br><span class="hljs-comment">// 解构 tuple</span><br><span class="hljs-type">int</span> a;<br><span class="hljs-type">double</span> b;<br>std::string c;<br>std::<span class="hljs-built_in">tie</span>(a, b, c) = t;<br><br>std::cout &lt;&lt; <span class="hljs-string">&quot;a: &quot;</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot;, b: &quot;</span> &lt;&lt; b &lt;&lt; <span class="hljs-string">&quot;, c: &quot;</span> &lt;&lt; c &lt;&lt; std::endl;<br></code></pre></td></tr></table></figure><p><strong>scenario：</strong></p><ol><li><p><strong>函数返回多个值</strong>：使用 <code>tuple</code> 可以方便地在函数中返回多个不同类型的值，而无需创建自定义结构体。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::tuple&lt;<span class="hljs-type">int</span>, <span class="hljs-type">double</span>&gt; <span class="hljs-title">getValues</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">make_tuple</span>(<span class="hljs-number">10</span>, <span class="hljs-number">3.14</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> values = <span class="hljs-built_in">getValues</span>();<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;First value: &quot;</span> &lt;&lt; std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">0</span>&gt;(values) &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Second value: &quot;</span> &lt;&lt; std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">1</span>&gt;(values) &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>存储异构数据</strong>：当你需要存储异构数据（不同类型的元素）时，<code>tuple</code> 是一个非常方便的选择。例如，可以用它来存储一个人的年龄、名字和身高等不同类型的数据。</p></li><li><p><strong>元组解构和泛型编程</strong>：<code>std::tuple</code> 常用于模板编程中，特别是在处理多类型的返回值或元组解构时，能够提供强大的灵活性。</p></li></ol>
          </div>

<h4 id="模版的具体化"><a href="#模版的具体化" class="headerlink" title="模版的具体化"></a>模版的具体化</h4><ul>
<li>隐式实例化</li>
<li>显示实例化</li>
<li>显示具体化</li>
<li>部分具体化</li>
</ul>
<blockquote>
<p>自行查阅《C++ Primer Plus》</p>
</blockquote>
<h4 id="成员模版"><a href="#成员模版" class="headerlink" title="成员模版"></a>成员模版</h4><h4 id="将模板用作参数"><a href="#将模板用作参数" class="headerlink" title="将模板用作参数"></a>将模板用作参数</h4><h4 id="模板类和友元"><a href="#模板类和友元" class="headerlink" title="模板类和友元"></a>模板类和友元</h4><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2>
                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Code/" class="category-chain-item">Code</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/tutorial/" class="print-no-link">#tutorial</a>
      
        <a href="/tags/C-C/" class="print-no-link">#C/C++</a>
      
        <a href="/tags/OOP/" class="print-no-link">#OOP</a>
      
        <a href="/tags/C-Primer-Plus/" class="print-no-link">#C++ Primer Plus</a>
      
        <a href="/tags/Inheritance/" class="print-no-link">#Inheritance</a>
      
        <a href="/tags/Code-Reuse/" class="print-no-link">#Code Reuse</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Code-Reuse-in-OOP</div>
      <div>https://xiyuanyang-code.github.io/posts/Code-Reuse-in-OOP/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>Author</div>
          <div>Xiyuan Yang</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>Posted on</div>
          <div>December 12, 2024</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>Updated on</div>
          <div>December 13, 2024</div>
        </div>
      
      
        <div class="license-meta-item">
          <div>Licensed under</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - Attribution">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/posts/Exception-Handling-in-C-plus-plus/" title="Exception-Handling-in-C-plus-plus">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Exception-Handling-in-C-plus-plus</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/posts/Leetcode-Mistake-collection-31-40/" title="Leetcode-Mistake-collection-31-40">
                        <span class="hidden-mobile">Leetcode-Mistake-collection-31-40</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
    <div id="giscus" class="giscus"></div>
    <script type="text/javascript">
      Fluid.utils.loadComments('#giscus', function() {
        var options = {"repo":"xiyuanyang-code/xiyuanyang-code.github.io","repo-id":"R_kgDONRhvHQ","category":"Announcements","category-id":"DIC_kwDONRhvHc4ClBnp","theme-light":"light","theme-dark":"dark","mapping":"pathname","reactions-enabled":1,"emit-metadata":0,"input-position":"top","lang":"zh-CN"};
        var attributes = {};
        for (let option in options) {
          if (!option.startsWith('theme-')) {
            var key = option.startsWith('data-') ? option : 'data-' + option;
            attributes[key] = options[option];
          }
        }
        var light = 'light';
        var dark = 'dark';
        window.GiscusThemeLight = light;
        window.GiscusThemeDark = dark;
        attributes['data-theme'] = document.documentElement.getAttribute('data-user-color-scheme') === 'dark' ? dark : light;
        for (let attribute in attributes) {
          var value = attributes[attribute];
          if (value === undefined || value === null || value === '') {
            delete attributes[attribute];
          }
        }
        var s = document.createElement('script');
        s.setAttribute('src', 'https://giscus.app/client.js');
        s.setAttribute('crossorigin', 'anonymous');
        for (let attribute in attributes) {
          s.setAttribute(attribute, attributes[attribute]);
        }
        var ss = document.getElementsByTagName('script');
        var e = ss.length > 0 ? ss[ss.length - 1] : document.head || document.documentElement;
        e.parentNode.insertBefore(s, e.nextSibling);
      });
    </script>
    <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>Table of Contents</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">Keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://github.com/xiyuanyang-code" target="_blank" rel="nofollow noopener"><span>YXY</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/Siyan-Li" target="_blank" rel="nofollow noopener"><span>LSY</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script defer src="/js/leancloud.js" ></script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">Blog works best with JavaScript enabled</div>
  </noscript>
</body>
</html>
