

<!DOCTYPE html>
<html lang="en" >



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/YXY.png">
  <link rel="icon" href="/img/YXY.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#c30000">
  <meta name="author" content="Xiyuan Yang">
  <meta name="keywords" content="Code">
  
    <meta name="description" content="Leetcode-Mistake-Collection-Episode-4, focusing on advanced algorithm.">
<meta property="og:type" content="article">
<meta property="og:title" content="Leetcode-Mistake-Collection-31-40">
<meta property="og:url" content="https://xiyuanyang-code.github.io/posts/Leetcode-Mistake-collection-31-40/index.html">
<meta property="og:site_name" content="Xiyuan Yang&#39;s Blog">
<meta property="og:description" content="Leetcode-Mistake-Collection-Episode-4, focusing on advanced algorithm.">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://xiyuanyang-code.github.io/img/cover/Leetcode.png">
<meta property="article:published_time" content="2024-12-10T05:07:20.000Z">
<meta property="article:modified_time" content="2025-02-17T11:46:02.700Z">
<meta property="article:author" content="Xiyuan Yang">
<meta property="article:tag" content="Finished">
<meta property="article:tag" content="C&#x2F;C++">
<meta property="article:tag" content="Leetcode notes">
<meta property="article:tag" content="algorithm">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://xiyuanyang-code.github.io/img/cover/Leetcode.png">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>Leetcode-Mistake-Collection-31-40 - Xiyuan Yang&#39;s Blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"xiyuanyang-code.github.io","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":50,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":"❡"},"progressbar":{"enable":true,"height_px":3,"color":"red","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":2},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":"L7r0uGb0fafbzNvmBADCMH42-gzGzoHsz","app_key":"2Lr1fQ2rjhwRiUrDx0VOQyUm","server_url":null,"path":"window.location.pathname","ignore_local":true},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  

  

  

  
    
  



  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Xiyuan Yang&#39;s Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>Home</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/above/" target="_self">
                <i class="iconfont icon-bookmark-fill"></i>
                <span>Intro</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>Archive</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>Category</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>Tag</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>About</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/resume/" target="_self">
                <i class="iconfont icon-code"></i>
                <span>Resume</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/FAQ/" target="_self">
                <i class="iconfont icon-bug"></i>
                <span>FAQ</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/" target="_self">
                <i class="iconfont icon-link-fill"></i>
                <span>Links</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/pink.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Leetcode-Mistake-Collection-31-40"></span>
          
        </div>

        
          
  <div class="mt-3">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-author" aria-hidden="true"></i>
        Xiyuan Yang
      </span>
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-12-10 13:07" pubdate>
          December 10, 2024 pm
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          5.7k words
        
      </span>
    

    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> views
        </span>
        

      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar category-bar" style="margin-right: -1rem">
    





<div class="category-list">
  
  
    
    
    
    <div class="category row nomargin-x">
      <a class="category-item 
          list-group-item category-item-action col-10 col-md-11 col-xm-11" title="Algorithm"
        id="heading-4afa80e77a07f7488ce4d1bdd8c4977a" role="tab" data-toggle="collapse" href="#collapse-4afa80e77a07f7488ce4d1bdd8c4977a"
        aria-expanded="true"
      >
        Algorithm
        <span class="list-group-count">(15)</span>
        <i class="iconfont icon-arrowright"></i>
      </a>
      
      <div class="category-collapse collapse show" id="collapse-4afa80e77a07f7488ce4d1bdd8c4977a"
           role="tabpanel" aria-labelledby="heading-4afa80e77a07f7488ce4d1bdd8c4977a">
        
        
          
  <div class="category-post-list">
    
    
      
      
        <a href="/posts/Algorithm-Introduction/" title="Algorithm-Introduction"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">Algorithm-Introduction</span>
        </a>
      
    
      
      
        <a href="/posts/Linked-List-Implementation-Based-on-Structs/" title="Linked-List-Implementation-Based-on-Structs"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">Linked-List-Implementation-Based-on-Structs</span>
        </a>
      
    
      
      
        <a href="/posts/Leetcode-Mistake-collection/" title="Leetcode-Mistake-Collection"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">Leetcode-Mistake-Collection</span>
        </a>
      
    
      
      
        <a href="/posts/Leetcode-Mistake-collection-1-10/" title="Leetcode-Mistake-Collection-1-10"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">Leetcode-Mistake-Collection-1-10</span>
        </a>
      
    
      
      
        <a href="/posts/Leetcode-Mistake-collection-11-20/" title="Leetcode-Mistake-Collection-11-20"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">Leetcode-Mistake-Collection-11-20</span>
        </a>
      
    
      
      
        <a href="/posts/Leetcode-Mistake-collection-21-30/" title="Leetcode-Mistake-Collection-21-30"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">Leetcode-Mistake-Collection-21-30</span>
        </a>
      
    
      
      
        <a href="/posts/Leetcode-Mistake-collection-31-40/" title="Leetcode-Mistake-Collection-31-40"
           class="list-group-item list-group-item-action
           active">
          <span class="category-post">Leetcode-Mistake-Collection-31-40</span>
        </a>
      
    
      
      
        <a href="/posts/DataStructure-Tutorial/" title="DataStructure-Tutorial"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">DataStructure-Tutorial</span>
        </a>
      
    
      
      
        <a href="/posts/DataStructure-LinearList/" title="DataStructure-LinearList"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">DataStructure-LinearList</span>
        </a>
      
    
      
      
        <a href="/posts/DataStructure-Stack/" title="DataStructure-Stack"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">DataStructure-Stack</span>
        </a>
      
    
      
      
        <a href="/posts/DataStructure-Queue/" title="DataStructure-Queue"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">DataStructure-Queue</span>
        </a>
      
    
      
      
        <a href="/posts/DataStructure-String/" title="DataStructure-String"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">DataStructure-String</span>
        </a>
      
    
      
      
        <a href="/posts/DataStructure-Tree/" title="DataStructure-Tree"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">DataStructure-Tree</span>
        </a>
      
    
      
      
        <a href="/posts/DataStructure-Tree-Binary-Tree/" title="DataStructure-Tree-Binary-Tree"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">DataStructure-Tree-Binary-Tree</span>
        </a>
      
    
      
      
        <a href="/posts/Algorithm-Chunking/" title="Algorithm-Chunking"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">Algorithm-Chunking</span>
        </a>
      
    
  </div>

        
      </div>
    </div>
  
</div>


  </aside>


    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">Leetcode-Mistake-Collection-31-40</h1>
            
            
              <div class="markdown-body">
                
                <style>
  html, body, .markdown-body {
    font-family: Georgia, sans, serif;
  }
</style>

<h1 id="Leetcode-Mistake-collection-31-40"><a href="#Leetcode-Mistake-collection-31-40" class="headerlink" title="Leetcode-Mistake-collection-31-40"></a>Leetcode-Mistake-collection-31-40</h1><h1 id="程设错题-31-35-20241112"><a href="#程设错题-31-35-20241112" class="headerlink" title="程设错题 31-35 20241112"></a>程设错题 31-35 20241112</h1><h2 id="1-上机错题-寻找字符串的最大非重复子串问题"><a href="#1-上机错题-寻找字符串的最大非重复子串问题" class="headerlink" title="1 上机错题 寻找字符串的最大非重复子串问题"></a>1 上机错题 寻找字符串的最大非重复子串问题</h2><h4 id="解法1基本双循环枚举（略）"><a href="#解法1基本双循环枚举（略）" class="headerlink" title="解法1基本双循环枚举（略）"></a>解法1基本双循环枚举（略）</h4><h4 id="解法2-使用双指针"><a href="#解法2-使用双指针" class="headerlink" title="解法2 使用双指针"></a>解法2 使用双指针</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    string theinput;cin&gt;&gt;theinput;<br>    <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,j=<span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> maxoflength=<span class="hljs-number">0</span>;<br>    unordered_map&lt;<span class="hljs-type">char</span>,<span class="hljs-type">int</span>&gt; list;<br><br>    <span class="hljs-keyword">for</span>(;j&lt;theinput.<span class="hljs-built_in">length</span>();j++)&#123;<br>        <span class="hljs-keyword">if</span>(list.<span class="hljs-built_in">find</span>(theinput[j])!=list.<span class="hljs-built_in">end</span>())&#123;<br>            i=list[theinput[j]]<span class="hljs-number">+1</span>;<br>            <span class="hljs-keyword">if</span>(j-i<span class="hljs-number">+1</span>&gt;maxoflength)&#123;<br>                maxoflength=j-i<span class="hljs-number">+1</span>;<br>            &#125;<br>        &#125;<br>        list[theinput[j]]=j;<br>    &#125;<br>    cout&lt;&lt;maxoflength;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="2-Leetcode-888-公平糖果交换"><a href="#2-Leetcode-888-公平糖果交换" class="headerlink" title="2 Leetcode 888 公平糖果交换"></a>2 Leetcode 888 公平糖果交换</h2><p>爱丽丝和鲍勃拥有不同总数量的糖果。给你两个数组 <code>aliceSizes</code> 和 <code>bobSizes</code> ，<code>aliceSizes[i]</code> 是爱丽丝拥有的第 <code>i</code> 盒糖果中的糖果数量，<code>bobSizes[j]</code> 是鲍勃拥有的第 <code>j</code> 盒糖果中的糖果数量。</p>
<p>两人想要互相交换一盒糖果，这样在交换之后，他们就可以拥有相同总数量的糖果。一个人拥有的糖果总数量是他们每盒糖果数量的总和。</p>
<p>返回一个整数数组 <code>answer</code>，其中 <code>answer[0]</code> 是爱丽丝必须交换的糖果盒中的糖果的数目，<code>answer[1]</code> 是鲍勃必须交换的糖果盒中的糖果的数目。如果存在多个答案，你可以返回其中 <strong>任何一个</strong> 。题目测试用例保证存在与输入对应的答案。</p>
<h4 id="解法1-双循环枚举"><a href="#解法1-双循环枚举" class="headerlink" title="解法1 双循环枚举"></a>解法1 双循环枚举</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">fairCandySwap</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; aliceSizes, vector&lt;<span class="hljs-type">int</span>&gt;&amp; bobSizes)</span> </span>&#123;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> sum1=<span class="hljs-number">0</span>,sum2=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> alice:aliceSizes)&#123;<br>            sum1+=alice;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> bob:bobSizes)&#123;<br>            sum2+=bob;<br>        &#125;<br>        <span class="hljs-type">int</span> target=<span class="hljs-built_in">abs</span>(sum1-sum2)/<span class="hljs-number">2</span>;<br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> alice:aliceSizes)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> bob:bobSizes)&#123;<br>                <span class="hljs-keyword">if</span>(sum1&gt;sum2&amp;&amp;alice-bob==target)&#123;<br>                    ans.<span class="hljs-built_in">push_back</span>(alice);<br>                    ans.<span class="hljs-built_in">push_back</span>(bob);<br>                    <span class="hljs-keyword">return</span> ans;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(sum1&lt;sum2&amp;&amp;bob-alice==target)&#123;<br>                    ans.<span class="hljs-built_in">push_back</span>(alice);<br>                    ans.<span class="hljs-built_in">push_back</span>(bob);<br>                    <span class="hljs-keyword">return</span> ans;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> &#123;&#125;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="解法2-使用哈希表存储，优化查找方案"><a href="#解法2-使用哈希表存储，优化查找方案" class="headerlink" title="解法2 使用哈希表存储，优化查找方案"></a>解法2 使用哈希表存储，优化查找方案</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">fairCandySwap</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; aliceSizes, vector&lt;<span class="hljs-type">int</span>&gt;&amp; bobSizes)</span> </span>&#123;<br>        <span class="hljs-type">int</span> sumA = <span class="hljs-built_in">accumulate</span>(aliceSizes.<span class="hljs-built_in">begin</span>(), aliceSizes.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>);<br>        <span class="hljs-type">int</span> sumB = <span class="hljs-built_in">accumulate</span>(bobSizes.<span class="hljs-built_in">begin</span>(), bobSizes.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>);<br>        <span class="hljs-type">int</span> delta = (sumA - sumB) / <span class="hljs-number">2</span>;<br>        <span class="hljs-comment">//这里差值可以取负值，就不用分类讨论</span><br>        <span class="hljs-function">unordered_set&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">rec</span><span class="hljs-params">(aliceSizes.begin(), aliceSizes.end())</span></span>;<br>        <span class="hljs-comment">//对Alice的数组创建哈希表（自动删去重复元素）</span><br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; y : bobSizes) &#123;<br>            <span class="hljs-type">int</span> x = y + delta;<br>            <span class="hljs-keyword">if</span> (rec.<span class="hljs-built_in">count</span>(x)) &#123;<br>                <span class="hljs-comment">//如果找到了，就说明存在</span><br>                ans = vector&lt;<span class="hljs-type">int</span>&gt;&#123;x, y&#125;;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>

<h2 id="3-Leetcode-473-火柴拼正方形"><a href="#3-Leetcode-473-火柴拼正方形" class="headerlink" title="3 Leetcode 473 火柴拼正方形"></a>3 Leetcode 473 火柴拼正方形</h2><p>你将得到一个整数数组 <code>matchsticks</code> ，其中 <code>matchsticks[i]</code> 是第 <code>i</code> 个火柴棒的长度。你要用 <strong>所有的火柴棍</strong> 拼成一个正方形。你 <strong>不能折断</strong> 任何一根火柴棒，但你可以把它们连在一起，而且每根火柴棒必须 <strong>使用一次</strong> 。</p>
<p>如果你能使这个正方形，则返回 <code>true</code> ，否则返回 <code>false</code> 。</p>
<h3 id="补充：DFS（深度优先搜索）的C-代码实现"><a href="#补充：DFS（深度优先搜索）的C-代码实现" class="headerlink" title="补充：DFS（深度优先搜索）的C++代码实现"></a>补充：DFS（深度优先搜索）的C++代码实现</h3><p>DFS的关键：优先搜索点的未被访问的邻居节点</p>
<p>非递归的代码示例</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">const</span> vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; graph, vector&lt;<span class="hljs-type">bool</span>&gt;&amp; visited)</span> </span>&#123;<br>    <span class="hljs-comment">// 使用一个栈来模拟递归</span><br>    stack&lt;<span class="hljs-type">int</span>&gt; s;<br>    s.<span class="hljs-built_in">push</span>(start);<br>    <span class="hljs-comment">//将起始点start压入栈中</span><br><br>    <span class="hljs-keyword">while</span> (!s.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-comment">// 从栈顶取出一个节点</span><br>        <span class="hljs-type">int</span> node = s.<span class="hljs-built_in">top</span>();<br>        s.<span class="hljs-built_in">pop</span>();<br><br>        <span class="hljs-comment">// 如果节点未被访问过</span><br>        <span class="hljs-keyword">if</span> (!visited[node]) &#123;<br>            <span class="hljs-comment">// 标记为已访问</span><br>            visited[node] = <span class="hljs-literal">true</span>;<br>            <br>            <span class="hljs-comment">// 打印当前访问的节点</span><br>            cout &lt;&lt; <span class="hljs-string">&quot;Visiting node: &quot;</span> &lt;&lt; node &lt;&lt; endl;<br><br>            <span class="hljs-comment">// 将该节点的所有未访问的邻居节点压入栈中</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = graph[node].<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>                <span class="hljs-keyword">if</span> (!visited[graph[node][i]]) &#123;<br>                    s.<span class="hljs-built_in">push</span>(graph[node][i]);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 示例图的邻接表表示</span><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; graph = &#123;<br>        &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;,      <span class="hljs-comment">// 节点0的邻居节点是1和2</span><br>        &#123;<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;,   <span class="hljs-comment">// 节点1的邻居节点是0、3和4</span><br>        &#123;<span class="hljs-number">0</span>, <span class="hljs-number">5</span>&#125;,      <span class="hljs-comment">// 节点2的邻居节点是0和5</span><br>        &#123;<span class="hljs-number">1</span>, <span class="hljs-number">4</span>&#125;,      <span class="hljs-comment">// 节点3的邻居节点是1和4</span><br>        &#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>&#125;,      <span class="hljs-comment">// 节点4的邻居节点是1和3</span><br>        &#123;<span class="hljs-number">2</span>&#125;          <span class="hljs-comment">// 节点5的邻居节点是2</span><br>    &#125;;<br><br>    <span class="hljs-type">int</span> numNodes = graph.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">visited</span><span class="hljs-params">(numNodes, <span class="hljs-literal">false</span>)</span></span>;<br><br>    <span class="hljs-comment">// 从节点0开始DFS</span><br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>, graph, visited);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>优化为递归的版本：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> node, <span class="hljs-type">const</span> vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; graph, vector&lt;<span class="hljs-type">bool</span>&gt;&amp; visited)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (visited[node]) <span class="hljs-keyword">return</span>;<br>    visited[node] = <span class="hljs-literal">true</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Visiting node: &quot;</span> &lt;&lt; node &lt;&lt; endl;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> neighbor : graph[node]) &#123;<br>        <span class="hljs-keyword">if</span> (!visited[neighbor]) &#123;<br>            <span class="hljs-built_in">dfs</span>(neighbor, graph, visited);<br>            <span class="hljs-comment">//遍历每一个未被访问的邻居节点实现全局搜索</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="BFS-广度优先搜索"><a href="#BFS-广度优先搜索" class="headerlink" title="BFS 广度优先搜索"></a>BFS 广度优先搜索</h3><p>下面是使用C++实现的BFS的示例代码，该代码会遍历一个图，并打印每个节点的访问顺序：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">const</span> vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; graph, vector&lt;<span class="hljs-type">bool</span>&gt;&amp; visited)</span> </span>&#123;<br>    <span class="hljs-comment">// 使用队列来存储待访问的节点</span><br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    <br>    <span class="hljs-comment">// 将起始节点标记为已访问并入队</span><br>    visited[start] = <span class="hljs-literal">true</span>;<br>    q.<span class="hljs-built_in">push</span>(start);<br><br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-comment">// 从队列中取出一个节点</span><br>        <span class="hljs-type">int</span> node = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br><br>        <span class="hljs-comment">// 打印当前访问的节点</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;Visiting node: &quot;</span> &lt;&lt; node &lt;&lt; endl;<br><br>        <span class="hljs-comment">// 遍历当前节点的所有邻居节点</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> neighbor : graph[node]) &#123;<br>            <span class="hljs-comment">// 如果邻居节点未被访问过，标记为已访问并入队</span><br>            <span class="hljs-keyword">if</span> (!visited[neighbor]) &#123;<br>                visited[neighbor] = <span class="hljs-literal">true</span>;<br>                q.<span class="hljs-built_in">push</span>(neighbor);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 示例图的邻接表表示</span><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; graph = &#123;<br>        &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;,      <span class="hljs-comment">// 节点0的邻居节点是1和2</span><br>        &#123;<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;,   <span class="hljs-comment">// 节点1的邻居节点是0、3和4</span><br>        &#123;<span class="hljs-number">0</span>, <span class="hljs-number">5</span>&#125;,      <span class="hljs-comment">// 节点2的邻居节点是0和5</span><br>        &#123;<span class="hljs-number">1</span>, <span class="hljs-number">4</span>&#125;,      <span class="hljs-comment">// 节点3的邻居节点是1和4</span><br>        &#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>&#125;,      <span class="hljs-comment">// 节点4的邻居节点是1和3</span><br>        &#123;<span class="hljs-number">2</span>&#125;          <span class="hljs-comment">// 节点5的邻居节点是2</span><br>    &#125;;<br><br>    <span class="hljs-type">int</span> numNodes = graph.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">visited</span><span class="hljs-params">(numNodes, <span class="hljs-literal">false</span>)</span></span>;<br><br>    <span class="hljs-comment">// 从节点0开始BFS</span><br>    <span class="hljs-built_in">bfs</span>(<span class="hljs-number">0</span>, graph, visited);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<ol>
<li><p><strong>图的表示</strong>: 这里使用邻接表来表示图，每个节点的邻居节点存储在一个<code>vector</code>中。</p>
</li>
<li><p><strong>BFS函数</strong>：</p>
<ul>
<li><code>bfs</code>函数接受起始节点<code>start</code>，图<code>graph</code>，以及一个用于标记节点是否已访问的<code>visited</code>数组。</li>
<li>使用一个队列<code>queue</code>来模拟BFS的层级访问过程。</li>
<li>将起始节点标记为已访问并入队。</li>
<li>当队列不为空时，弹出队列的第一个节点（FIFO），打印该节点，然后将其所有未访问的邻居节点标记为已访问并入队。</li>
</ul>
</li>
<li><p><strong>主函数</strong>：</p>
<ul>
<li>定义了一个示例图。</li>
<li>创建一个<code>visited</code>数组来跟踪每个节点的访问状态。</li>
<li>从节点0开始调用BFS函数。</li>
</ul>
</li>
</ol>
<p>这个示例展示了如何使用队列来实现BFS。如果你更喜欢使用递归来实现BFS，可以使用一个辅助函数来模拟队列的功能，但通常非递归的实现更直观和高效，因为BFS本身就是一个层级遍历的过程。</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> index, vector&lt;<span class="hljs-type">int</span>&gt; &amp;matchsticks, vector&lt;<span class="hljs-type">int</span>&gt; &amp;edges, <span class="hljs-type">int</span> len)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (index == matchsticks.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; edges.<span class="hljs-built_in">size</span>()<span class="hljs-comment">/*4*/</span>; i++) &#123;<br>            edges[i] += matchsticks[index];<br>            <span class="hljs-keyword">if</span> (edges[i] &lt;= len &amp;&amp; <span class="hljs-built_in">dfs</span>(index + <span class="hljs-number">1</span>, matchsticks, edges, len)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            edges[i] -= matchsticks[index];<br>            <span class="hljs-comment">//算法的关键：判断条件：如果edges没有超过边界，那么尝试把第index+1根火柴添加到每一条边上</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">makesquare</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;matchsticks)</span> </span>&#123;<br>        <span class="hljs-type">int</span> totalLen = <span class="hljs-built_in">accumulate</span>(matchsticks.<span class="hljs-built_in">begin</span>(), matchsticks.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span> (totalLen % <span class="hljs-number">4</span> != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-built_in">sort</span>(matchsticks.<span class="hljs-built_in">begin</span>(), matchsticks.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">greater</span>&lt;<span class="hljs-type">int</span>&gt;()); <br>        <span class="hljs-comment">// 减少搜索量</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">edges</span><span class="hljs-params">(<span class="hljs-number">4</span>)</span></span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>, matchsticks, edges, totalLen / <span class="hljs-number">4</span>);<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>

<h2 id="4-Leetcode-921-栈（LIFO）的应用"><a href="#4-Leetcode-921-栈（LIFO）的应用" class="headerlink" title="4 Leetcode 921 栈（LIFO）的应用"></a>4 Leetcode 921 栈（LIFO）的应用</h2><p>栈的“先进后出”</p>
<p>只有满足下面几点之一，括号字符串才是有效的：</p>
<ul>
<li>它是一个空字符串，或者</li>
<li>它可以被写成 <code>AB</code> （<code>A</code> 与 <code>B</code> 连接）, 其中 <code>A</code> 和 <code>B</code> 都是有效字符串，或者</li>
<li>它可以被写作 <code>(A)</code>，其中 <code>A</code> 是有效字符串。</li>
</ul>
<p>给定一个括号字符串 <code>s</code> ，在每一次操作中，你都可以在字符串的任何位置插入一个括号</p>
<ul>
<li>例如，如果 <code>s = &quot;()))&quot;</code> ，你可以插入一个开始括号为 <code>&quot;(()))&quot;</code> 或结束括号为 <code>&quot;())))&quot;</code> 。</li>
</ul>
<p>返回 <em>为使结果字符串 <code>s</code> 有效而必须添加的最少括号数</em>。</p>
<h4 id="解法：使用栈！"><a href="#解法：使用栈！" class="headerlink" title="解法：使用栈！"></a>解法：使用栈！</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minAddToMakeValid</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        stack &lt;<span class="hljs-type">char</span>&gt; thekuohao;<br>        <span class="hljs-comment">//代表一个栈，之后不断压入内容</span><br>        <span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> ch:s)&#123;<br>            <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;(&#x27;</span>)&#123;<br>                thekuohao.<span class="hljs-built_in">push</span>(ch);<br>                <span class="hljs-comment">//左括号希望在后面找到他唯一匹配的右括号</span><br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;)&#x27;</span>)&#123;<br>                <span class="hljs-keyword">if</span>(!thekuohao.<span class="hljs-built_in">empty</span>()&amp;&amp;thekuohao.<span class="hljs-built_in">top</span>()==<span class="hljs-string">&#x27;(&#x27;</span>)&#123;<br>                    thekuohao.<span class="hljs-built_in">pop</span>();<br>                    <span class="hljs-comment">//找到了，弹出栈顶的左括号，同时不压入右括号</span><br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    count++;<br>                    <span class="hljs-comment">//说明此时的右括号无人访问，需要在另一个方向压入新的左括号</span><br>                    <span class="hljs-comment">//count统计到的时需要添加的左括号（即存在盈余的右括号）</span><br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count+thekuohao.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">//最后留在栈中的括号都是未被匹配到的左括号</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>如果降低空间复杂度O（1），则可以这样做：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minAddToMakeValid</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> leftCount = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;c : s) &#123;<br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                leftCount++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (leftCount &gt; <span class="hljs-number">0</span>) &#123;<br>                    leftCount--;<br>                    <span class="hljs-comment">//那么右括号一定可以找到被匹配的左括号</span><br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    ans++;<br>                    <span class="hljs-comment">//leftcount==0，说明此时应该在另一侧加入括号</span><br>                &#125;<br>            &#125;<br>        &#125;<br>        ans += leftCount;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>

<h2 id="5-Leetcode-937-自定义排序"><a href="#5-Leetcode-937-自定义排序" class="headerlink" title="5 Leetcode 937 自定义排序"></a>5 Leetcode 937 自定义排序</h2><p>给你一个日志数组 <code>logs</code>。每条日志都是以空格分隔的字串，其第一个字为字母与数字混合的 <strong>标识符</strong> 。</p>
<p>有两种不同类型的日志：</p>
<ul>
<li><strong>字母日志</strong>：除标识符之外，所有字均由小写字母组成</li>
<li><strong>数字日志</strong>：除标识符之外，所有字均由数字组成</li>
</ul>
<p>请按下述规则将日志重新排序：</p>
<ul>
<li>所有 <strong>字母日志</strong> 都排在 <strong>数字日志</strong> 之前。</li>
<li><strong>字母日志</strong> 在内容不同时，忽略标识符后，按内容字母顺序排序；在内容相同时，按标识符排序。</li>
<li><strong>数字日志</strong> 应该保留原来的相对顺序。</li>
</ul>
<p>返回日志的最终顺序。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：logs = [<span class="hljs-string">&quot;dig1 8 1 5 1&quot;</span>,<span class="hljs-string">&quot;let1 art can&quot;</span>,<span class="hljs-string">&quot;dig2 3 6&quot;</span>,<span class="hljs-string">&quot;let2 own kit dig&quot;</span>,<span class="hljs-string">&quot;let3 art zero&quot;</span>]<br>输出：[<span class="hljs-string">&quot;let1 art can&quot;</span>,<span class="hljs-string">&quot;let3 art zero&quot;</span>,<span class="hljs-string">&quot;let2 own kit dig&quot;</span>,<span class="hljs-string">&quot;dig1 8 1 5 1&quot;</span>,<span class="hljs-string">&quot;dig2 3 6&quot;</span>]<br>解释：<br>字母日志的内容都不同，所以顺序为 <span class="hljs-string">&quot;art can&quot;</span>, <span class="hljs-string">&quot;art zero&quot;</span>, <span class="hljs-string">&quot;own kit dig&quot;</span> 。<br>数字日志保留原来的相对顺序 <span class="hljs-string">&quot;dig1 8 1 5 1&quot;</span>, <span class="hljs-string">&quot;dig2 3 6&quot;</span> 。<br></code></pre></td></tr></table></figure>

<p><strong>对于较为复杂的排序问题，可以尝试使用自定义排序的方法实现排序规则的“自定义”。</strong></p>
<h4 id="最基本的例子：使用sort函数实现升序和降序数组排序"><a href="#最基本的例子：使用sort函数实现升序和降序数组排序" class="headerlink" title="最基本的例子：使用sort函数实现升序和降序数组排序"></a>最基本的例子：使用sort函数实现升序和降序数组排序</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-comment">// 自定义比较函数</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    <span class="hljs-comment">// 这里定义你的排序规则</span><br>    <span class="hljs-comment">// 返回true表示a应该在b之前（即a较小）</span><br>    <span class="hljs-keyword">return</span> a &lt; b;  <span class="hljs-comment">// 这是一个简单的升序比较</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; numbers = &#123;<span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">9</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;;<br><br>    <span class="hljs-comment">// 使用自定义比较函数进行升序排序</span><br>    std::<span class="hljs-built_in">sort</span>(numbers.<span class="hljs-built_in">begin</span>(), numbers.<span class="hljs-built_in">end</span>(), compare);<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;自定义升序排序后的结果: &quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; num : numbers) &#123;<br>        std::cout &lt;&lt; num &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    std::cout &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 现在定义一个不同的比较函数进行降序排序</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">descendingCompare</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> a &gt; b;  <span class="hljs-comment">// 返回true表示a应该在b之后（即b较小）</span><br>    &#125;<br><br>    <span class="hljs-comment">// 使用自定义比较函数进行降序排序</span><br>    std::<span class="hljs-built_in">sort</span>(numbers.<span class="hljs-built_in">begin</span>(), numbers.<span class="hljs-built_in">end</span>(), descendingCompare);<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;自定义降序排序后的结果: &quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; num : numbers) &#123;<br>        std::cout &lt;&lt; num &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    std::cout &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">reorderLogFiles</span><span class="hljs-params">(vector&lt;string&gt;&amp; logs)</span> </span>&#123;<br>        <span class="hljs-built_in">stable_sort</span>(logs.<span class="hljs-built_in">begin</span>(), logs.<span class="hljs-built_in">end</span>(), [&amp;](<span class="hljs-type">const</span> string &amp; log1, <span class="hljs-type">const</span> string &amp; log2) &#123;<br>            <span class="hljs-comment">//使用stable_sort保证相同元素排序的稳定性</span><br>            <span class="hljs-type">int</span> pos1 = log<span class="hljs-number">1.f</span>ind_first_of(<span class="hljs-string">&quot; &quot;</span>);<br>            <span class="hljs-type">int</span> pos2 = log<span class="hljs-number">2.f</span>ind_first_of(<span class="hljs-string">&quot; &quot;</span>);<br>            <span class="hljs-comment">//库函数find_first_of()可以实现定位到字符串的目标字符的第一个索引位置</span><br>            <br>            <span class="hljs-type">bool</span> isDigit1 = <span class="hljs-built_in">isdigit</span>(log1[pos1 + <span class="hljs-number">1</span>]);<br>            <span class="hljs-type">bool</span> isDigit2 = <span class="hljs-built_in">isdigit</span>(log2[pos2 + <span class="hljs-number">1</span>]);<br>            <span class="hljs-comment">//这两个bool值判断是否为数字，进而实现对两种不同的日志的分类</span><br>            <span class="hljs-keyword">if</span> (isDigit1 &amp;&amp; isDigit2) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                <span class="hljs-comment">//都是数字，保持位置</span><br>            &#125;<br>            <span class="hljs-keyword">if</span> (!isDigit1 &amp;&amp; !isDigit2) &#123;<br>                <span class="hljs-comment">//如果都不是数字</span><br>                string s1 = log<span class="hljs-number">1.</span><span class="hljs-built_in">substr</span>(pos1);<br>                <span class="hljs-comment">//复制子串的库函数 substr()</span><br>                string s2 = log<span class="hljs-number">2.</span><span class="hljs-built_in">substr</span>(pos2);<br>                <span class="hljs-keyword">if</span> (s1 != s2) &#123;<br>                    <span class="hljs-comment">//string类重载了对应运算符，可以直接实现字符串的比较(逐位比较)</span><br>                    <span class="hljs-keyword">return</span> s1 &lt; s2;<br>                &#125;<br>                <span class="hljs-keyword">return</span> log1 &lt; log2;<br>                <span class="hljs-comment">//如果内容相同，则比较日志头部log1和log2</span><br>            &#125;<br>            <span class="hljs-keyword">return</span> isDigit1 ? <span class="hljs-literal">false</span> : <span class="hljs-literal">true</span>;<br>            <span class="hljs-comment">//最后一种情况，一个为数字，一个为字符，则根据规则字符应该排在前面</span><br>        &#125;);<br>        <span class="hljs-comment">//以上内容都是Lambda表达式，实现对自定义排序函数compare的定义</span><br>        <span class="hljs-comment">//在compare中，如果匿名函数返回false，说明不用交换顺序</span><br>        <span class="hljs-keyword">return</span> logs;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>

<h3 id="补充知识点讲解：Lambda表达式"><a href="#补充知识点讲解：Lambda表达式" class="headerlink" title="补充知识点讲解：Lambda表达式"></a>补充知识点讲解：Lambda表达式</h3><p>在C++中，lambda表达式（Lambda Expressions）<strong>是一种简洁的方式来定义匿名函数对象</strong>（即没有名称的函数），它允许你直接在代码中定义小型的、一次性使用的函数。<strong>这些函数对象可以捕获外部作用域中的变量</strong>，并可以在需要时直接使用。Lambda表达式的引入使得C++编程更加灵活和方便，特别是在需要短小、临时函数时。以下是关于lambda表达式的一些关键点：</p>
<h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><p>Lambda表达式的基本形式如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">[捕获列表](参数列表)可变性规范 -&gt; 返回类型 &#123;<br>    <span class="hljs-comment">// 函数体</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>捕获列表</strong>：<code>[]</code> 用于指定哪些外部变量应该被lambda表达式捕获。可以是：<ul>
<li><code>[]</code> 什么都不捕获。</li>
<li><code>[=]</code> 按值捕获所有可见的外部变量。</li>
<li><code>[&amp;]</code> 按引用捕获所有可见的外部变量。</li>
<li><code>[x, &amp;y]</code> 按值捕获<code>x</code>，按引用捕获<code>y</code>。</li>
</ul>
</li>
<li><strong>参数列表</strong>：类似于普通函数的参数列表，可以为空。</li>
<li><strong>可变性规范</strong>：<code>mutable</code>关键字表示lambda表达式可以修改被值捕获的变量。</li>
<li><strong>返回类型</strong>：如果lambda表达式包含多个<code>return</code>语句或需要明确指定返回类型，可以使用<code>-&gt;</code>来指定。</li>
<li><strong>函数体</strong>：包含lambda表达式的实际代码。</li>
</ul>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; numbers = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>    <span class="hljs-type">int</span> factor = <span class="hljs-number">2</span>;<br><br>    <span class="hljs-comment">// 使用lambda表达式对向量中的每个元素乘以factor</span><br>    std::for_each(numbers.<span class="hljs-built_in">begin</span>(), numbers.<span class="hljs-built_in">end</span>(), [factor](<span class="hljs-type">int</span> &amp;n) &#123;<br>        n *= factor;<br>    &#125;);<br><br>    <span class="hljs-comment">// 打印结果</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; num : numbers) &#123;<br>        std::cout &lt;&lt; num &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    std::cout &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 另一个lambda表达式示例，返回一个函数</span><br>    <span class="hljs-keyword">auto</span> add = [](<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y) -&gt; <span class="hljs-type">int</span> &#123;<br>        <span class="hljs-keyword">return</span> x + y;<br>    &#125;;<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;1 + 2 = &quot;</span> &lt;&lt; <span class="hljs-built_in">add</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li><strong>匿名性</strong>：Lambda表达式是匿名的，不需要为其定义一个名称。</li>
<li><strong>捕获外部变量</strong>：可以捕获外部作用域的变量，允许这些变量在lambda表达式内使用。</li>
<li><strong>简洁性</strong>：相比于定义一个函数对象或函数指针，lambda表达式更加简洁。</li>
<li><strong>闭包</strong>：lambda表达式可以创建闭包，捕获的变量在lambda表达式执行时仍然有效。</li>
</ul>
<p>Lambda表达式在C++11及以后的标准中被引入，极大地方便了编写简短的函数式代码，常用于STL算法、事件处理、异步编程等场景。</p>
<h3 id="补充知识点讲解：深入了解sort函数"><a href="#补充知识点讲解：深入了解sort函数" class="headerlink" title="补充知识点讲解：深入了解sort函数"></a>补充知识点讲解：深入了解sort函数</h3><p><code>std::sort</code>在C++标准库中实现的是<strong>内省排序（Introsort）</strong>，这是一种混合排序算法，结合了快速排序（Quicksort）、堆排序（Heapsort）和插入排序（Insertion Sort）的优点。以下是<code>std::sort</code>的基本原理：</p>
<h4 id="1-快速排序（Quicksort）"><a href="#1-快速排序（Quicksort）" class="headerlink" title="1. 快速排序（Quicksort）"></a>1. <strong>快速排序（Quicksort）</strong></h4><ul>
<li><code>std::sort</code>首先尝试使用快速排序，因为快速排序在平均情况下有很好的性能，时间复杂度为O(n log n)。</li>
<li>快速排序通过选择一个枢轴元素（pivot）将数组分成两部分，比枢轴小的元素放在一侧，比枢轴大的元素放在另一侧，然后递归地对这两部分进行排序。</li>
</ul>
<h4 id="2-堆排序（Heapsort）"><a href="#2-堆排序（Heapsort）" class="headerlink" title="2. 堆排序（Heapsort）"></a>2. <strong>堆排序（Heapsort）</strong></h4><ul>
<li>当快速排序的递归深度超过一定阈值时（通常是log n），<code>std::sort</code>会切换到堆排序。</li>
<li>堆排序保证了最坏情况下的时间复杂度为O(n log n)，避免了快速排序在某些情况下可能退化到O(n^2)的性能。</li>
</ul>
<h4 id="3-插入排序（Insertion-Sort）"><a href="#3-插入排序（Insertion-Sort）" class="headerlink" title="3. 插入排序（Insertion Sort）"></a>3. <strong>插入排序（Insertion Sort）</strong></h4><ul>
<li>对于小规模的数据（通常是少于16个元素的子数组），<code>std::sort</code>会使用插入排序，因为在小数据集上，插入排序的性能通常优于其他排序算法。</li>
</ul>
<h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ul>
<li><strong>自适应性</strong>：<code>std::sort</code>根据数据的大小和递归深度自动选择最适合的排序策略，这使得它在各种情况下都表现良好。</li>
<li><strong>稳定性</strong>：<code>std::sort</code>不是稳定的排序算法，这意味着相同元素的相对顺序在排序后可能改变。如果需要稳定排序，可以使用<code>std::stable_sort</code>。</li>
<li><strong>内存使用</strong>：<code>std::sort</code>通常是原地排序算法，意味它不需要额外的内存空间（除了递归调用栈），这对大规模数据的排序是非常有利的。</li>
</ul>
<p>由于C++标准库的具体实现可能会因不同的编译器和标准库版本而有所不同，这里提供一个简化的、概念性的<code>std::sort</code>实现，展示内省排序的核心思想：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">namespace</span> std &#123;<br>    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">RandomIt</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">Compare</span> = std::less&lt;&gt;&gt;<br>    <span class="hljs-type">void</span> <span class="hljs-built_in">sort</span>(RandomIt first, RandomIt last, Compare comp = <span class="hljs-built_in">Compare</span>()) &#123;<br>        <span class="hljs-comment">// 内省排序的阈值，通常为log(n)</span><br>        <span class="hljs-type">const</span> <span class="hljs-type">int</span> introsort_threshold = <span class="hljs-number">2</span> * <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-built_in">log</span>(last - first) / <span class="hljs-built_in">log</span>(<span class="hljs-number">2</span>));<br><br>        <span class="hljs-comment">// 辅助函数，执行快速排序</span><br>        <span class="hljs-keyword">auto</span> quicksort = [&amp;](RandomIt low, RandomIt high, <span class="hljs-type">int</span> depth) &#123;<br>            <span class="hljs-keyword">if</span> (high - low &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 已经排序或只有一个元素</span><br><br>            <span class="hljs-keyword">if</span> (depth == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// 达到最大深度，使用堆排序</span><br>                std::<span class="hljs-built_in">make_heap</span>(low, high, comp);<br>                std::<span class="hljs-built_in">sort_heap</span>(low, high, comp);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br><br>            --depth;<br><br>            <span class="hljs-comment">// 选择枢轴并进行分区</span><br>            RandomIt pivot = std::<span class="hljs-built_in">partition</span>(low, high, <br>                [&amp;](<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; a) &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">comp</span>(a, *std::<span class="hljs-built_in">next</span>(high, <span class="hljs-number">-1</span>)); &#125;);<br><br>            <span class="hljs-comment">// 递归排序左右两部分</span><br>            <span class="hljs-built_in">quicksort</span>(low, pivot, depth);<br>            <span class="hljs-built_in">quicksort</span>(pivot, high, depth);<br>        &#125;;<br><br>        <span class="hljs-comment">// 开始内省排序</span><br>        <span class="hljs-built_in">quicksort</span>(first, last, introsort_threshold);<br><br>        <span class="hljs-comment">// 对小规模数据使用插入排序</span><br>        <span class="hljs-keyword">if</span> (last - first &lt;= <span class="hljs-number">16</span>) &#123;<br>            <span class="hljs-keyword">for</span> (RandomIt i = first + <span class="hljs-number">1</span>; i != last; ++i) &#123;<br>                <span class="hljs-keyword">auto</span> key = *i;<br>                RandomIt j = i - <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">while</span> (j &gt;= first &amp;&amp; <span class="hljs-built_in">comp</span>(key, *j)) &#123;<br>                    *(j + <span class="hljs-number">1</span>) = *j;<br>                    --j;<br>                &#125;<br>                *(j + <span class="hljs-number">1</span>) = key;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h4><ol>
<li><p><strong>内省排序阈值</strong>：<code>introsort_threshold</code>用于决定何时从快速排序切换到堆排序，通常设置为<code>2 * log(n)</code>。</p>
</li>
<li><p><strong>快速排序部分</strong>：</p>
<ul>
<li><code>quicksort</code>函数实现了快速排序的核心逻辑。</li>
<li>使用<code>std::partition</code>进行分区，基于比较函数<code>comp</code>。</li>
<li>当递归深度达到<code>introsort_threshold</code>时，切换到堆排序。</li>
</ul>
</li>
<li><p><strong>堆排序</strong>：</p>
<ul>
<li>当达到最大递归深度时，调用<code>std::make_heap</code>和<code>std::sort_heap</code>来完成排序。</li>
</ul>
</li>
<li><p><strong>插入排序</strong>：</p>
<ul>
<li>对于小规模数据（这里设定为16个元素或更少），使用插入排序来优化性能。</li>
</ul>
</li>
<li><p><strong>比较函数</strong>：</p>
<ul>
<li><code>comp</code>参数允许用户提供自定义的比较函数，实现自定义排序逻辑。</li>
</ul>
</li>
</ol>
<p>请注意，这是一个简化的实现，实际的标准库实现可能包含更多的优化：</p>
<ul>
<li>选择枢轴的策略可能更复杂，以避免最坏情况（如已经排序或逆序的数组）。</li>
<li>可能使用不同的阈值来决定何时切换到堆排序或插入排序。</li>
<li>内存管理和性能优化，如减少递归调用的栈空间使用。</li>
<li>可能使用其他技术来减少比较次数或提高缓存命中率。</li>
</ul>
<p>这种实现展示了内省排序的基本理念：结合快速排序的平均性能优势、堆排序的最坏情况保证，以及插入排序在小数据集上的效率。</p>
<h1 id="程序设计错题-36-40"><a href="#程序设计错题-36-40" class="headerlink" title="程序设计错题 36-40"></a>程序设计错题 36-40</h1><h2 id="1-Leetcode-334-经典算法题：递增三元子序列排序"><a href="#1-Leetcode-334-经典算法题：递增三元子序列排序" class="headerlink" title="1.Leetcode 334 经典算法题：递增三元子序列排序"></a>1.Leetcode 334 经典算法题：递增三元子序列排序</h2><p>给你一个整数数组 nums ，判断这个数组中是否存在长度为 3 的递增子序列。</p>
<p>如果存在这样的三元组下标 (i, j, k) 且满足 i &lt; j &lt; k ，使得 nums[i] &lt; nums[j] &lt; nums[k] ，返回 true ；否则，返回 false。</p>
<h4 id="解法1-O-n-3-暴力枚举"><a href="#解法1-O-n-3-暴力枚举" class="headerlink" title="解法1 O(n^3)暴力枚举"></a>解法1 O(n^3)暴力枚举</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">increasingTriplet</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>()&lt;<span class="hljs-number">3</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i<span class="hljs-number">+2</span>&lt;nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i<span class="hljs-number">+2</span>;j&lt;nums.<span class="hljs-built_in">size</span>();j++)&#123;<br>                <span class="hljs-keyword">if</span>(nums[j]&lt;=nums[i])&#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=i<span class="hljs-number">+1</span>;k&lt;j;k++)&#123;<br>                        <span class="hljs-keyword">if</span>(nums[j]&gt;nums[k]&amp;&amp;nums[k]&gt;nums[i])&#123;<br>                            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="解法2-动态规划（也会超时）"><a href="#解法2-动态规划（也会超时）" class="headerlink" title="解法2 动态规划（也会超时）"></a>解法2 动态规划（也会超时）</h4><p>维护一个dp[i]<strong>来记录每个位置的最长递增子序列的长度</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">increasingTriplet</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() &lt; <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(nums.size(), <span class="hljs-number">1</span>)</span></span>;<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; i; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (nums[i] &gt; nums[j]) &#123;<br>                    dp[i] = std::<span class="hljs-built_in">max</span>(dp[i], dp[j] + <span class="hljs-number">1</span>);<br>                    <span class="hljs-keyword">if</span> (dp[i] &gt;= <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>

<p>牺牲空间复杂度，换取时间复杂度：O(n^2)和O(n)</p>
<h4 id="优化1-使用双向遍历"><a href="#优化1-使用双向遍历" class="headerlink" title="优化1 使用双向遍历"></a>优化1 使用双向遍历</h4><p><img src="/posts/Leetcode-Mistake-collection-31-40/1.png" srcset="/img/loading.gif" lazyload alt="双向遍历"></p>
<p>维护数组的好处：提高了空间复杂度，但是不用在每一次遍历的时候重新找存在的元素了（相当于动态规划的思想）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">increasingTriplet</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n=nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(n&lt;<span class="hljs-number">3</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">leftnum</span><span class="hljs-params">(n,nums[<span class="hljs-number">0</span>])</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">rightnum</span><span class="hljs-params">(n,nums[n<span class="hljs-number">-1</span>])</span></span>;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;<br>            leftnum[i]=<span class="hljs-built_in">min</span>(leftnum[i<span class="hljs-number">-1</span>],nums[i]);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n<span class="hljs-number">-2</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>            rightnum[i]=<span class="hljs-built_in">max</span>(rightnum[i<span class="hljs-number">+1</span>],nums[i]);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n<span class="hljs-number">-1</span>;i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i]&gt;leftnum[i<span class="hljs-number">-1</span>]&amp;&amp;nums[i]&lt;rightnum[i<span class="hljs-number">+1</span>])&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>时间复杂度：O(n^2)</p>
<p>空间复杂度：O(n^2)</p>
<h4 id="优化2-贪婪算法"><a href="#优化2-贪婪算法" class="headerlink" title="优化2 贪婪算法"></a>优化2 贪婪算法</h4><p>first 和 second 代表这个数组中我们所找到的最小值和次小值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;climits&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">increasingTriplet</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> first = INT_MAX, second = INT_MAX;<br>        <span class="hljs-comment">//定义系统的最大最小值</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> n : nums) &#123;<br>            <span class="hljs-keyword">if</span> (n &lt;= first) &#123;<br>                first = n;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n &lt;= second) &#123;<br>                second = n;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//(n&gt;first &amp;&amp; n&gt;second)</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                <span class="hljs-comment">//理论分析：找到最小值和次小值为什么就可以判定true？</span><br>                <span class="hljs-comment">//找到了n&gt;first &amp;&amp; n&gt;second，则n作为三元组的最后一个数，而且根据遍历的规则，n的前面一个数一定是当前数组的second或者first！</span><br>                <span class="hljs-comment">//如果是second，那么说明first还在前面，找到了符合条件的三元组</span><br>                <span class="hljs-comment">//如果是first，因为这里n&gt;second，说明second的值已经被更新过，说明在n前面，first的值至少被更新过两次，second至少被更新过一次</span><br>                <span class="hljs-comment">//a1(数组第一个数，被更新为first)——a2(second)--a3(first)--n</span><br>                <span class="hljs-comment">//a1和a3之间还可以有很多次second和first值的更新，a3&lt;a1&lt;a2&lt;n;</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>

<p>时间复杂度O(n)，空间复杂度O(1)</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Algorithm/" class="category-chain-item">Algorithm</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Finished/" class="print-no-link">#Finished</a>
      
        <a href="/tags/C-C/" class="print-no-link">#C/C++</a>
      
        <a href="/tags/Leetcode-notes/" class="print-no-link">#Leetcode notes</a>
      
        <a href="/tags/algorithm/" class="print-no-link">#algorithm</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Leetcode-Mistake-Collection-31-40</div>
      <div>https://xiyuanyang-code.github.io/posts/Leetcode-Mistake-collection-31-40/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>Author</div>
          <div>Xiyuan Yang</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>Posted on</div>
          <div>December 10, 2024</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>Updated on</div>
          <div>February 17, 2025</div>
        </div>
      
      
        <div class="license-meta-item">
          <div>Licensed under</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - Attribution">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/posts/Code-Reuse-in-OOP/" title="Code-Reuse-in-OOP">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Code-Reuse-in-OOP</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/posts/Leetcode-Mistake-collection-21-30/" title="Leetcode-Mistake-Collection-21-30">
                        <span class="hidden-mobile">Leetcode-Mistake-Collection-21-30</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
    <div id="giscus" class="giscus"></div>
    <script type="text/javascript">
      Fluid.utils.loadComments('#giscus', function() {
        var options = {"repo":"xiyuanyang-code/xiyuanyang-code.github.io","repo-id":"R_kgDONRhvHQ","category":"Announcements","category-id":"DIC_kwDONRhvHc4ClBnp","theme-light":"light","theme-dark":"dark","mapping":"pathname","reactions-enabled":1,"emit-metadata":0,"input-position":"top","lang":"zh-CN"};
        var attributes = {};
        for (let option in options) {
          if (!option.startsWith('theme-')) {
            var key = option.startsWith('data-') ? option : 'data-' + option;
            attributes[key] = options[option];
          }
        }
        var light = 'light';
        var dark = 'dark';
        window.GiscusThemeLight = light;
        window.GiscusThemeDark = dark;
        attributes['data-theme'] = document.documentElement.getAttribute('data-user-color-scheme') === 'dark' ? dark : light;
        for (let attribute in attributes) {
          var value = attributes[attribute];
          if (value === undefined || value === null || value === '') {
            delete attributes[attribute];
          }
        }
        var s = document.createElement('script');
        s.setAttribute('src', 'https://giscus.app/client.js');
        s.setAttribute('crossorigin', 'anonymous');
        for (let attribute in attributes) {
          s.setAttribute(attribute, attributes[attribute]);
        }
        var ss = document.getElementsByTagName('script');
        var e = ss.length > 0 ? ss[ss.length - 1] : document.head || document.documentElement;
        e.parentNode.insertBefore(s, e.nextSibling);
      });
    </script>
    <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>Table of Contents</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">Keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://github.com/xiyuanyang-code" target="_blank" rel="nofollow noopener"><span>YXY</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/Siyan-Li" target="_blank" rel="nofollow noopener"><span>LSY</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script defer src="/js/leancloud.js" ></script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">Blog works best with JavaScript enabled</div>
  </noscript>
</body>
</html>
